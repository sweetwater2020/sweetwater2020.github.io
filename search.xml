<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mac安装和配置maven</title>
    <url>/2021/08/25/myblog/java/MAC%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEMaven/</url>
    <content><![CDATA[<h1 id="MAC安装和配置Maven"><a href="#MAC安装和配置Maven" class="headerlink" title="MAC安装和配置Maven"></a>MAC安装和配置Maven</h1><h2 id="1-Maven简介"><a href="#1-Maven简介" class="headerlink" title="1.Maven简介"></a>1.Maven简介</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">背景：开发A项目，A项目中的一些功能依赖于B项目中的某些类，那么如何维系这种依赖关系？需要用哪个项目中的哪些类，也就是用别人写好了的功能代码，导入jar包即可。所以这里也如此，可以将B项目打成jar包，然后在A项目的Library下导入B的jar文件，这样，A项目就可以调用B项目中的某些类了。如果在开发过程中，发现B中的bug，则必须将B项目修改好，并重新将B打包并对A项目进行重编译操作</span><br></pre></td></tr></table></figure>

<p>Maven是基于项目对象模型(POM project object model)，可以通过一小段描述信息（配置）来管理项目的构建，报告和文档的软件项目管理工具。</p>
<p>Maven的核心功能便是合理叙述项目间的依赖关系，通俗点讲，就是通过pom.xml文件的配置获取jar包，而不用手动去添加jar包。</p>
<p>由于Maven仓库中所有的JAR都有其自己的坐标，该坐标告诉Maven它的组ID，构件ID，版本，打包方式等等， 因此Maven项目可以方便的进行依赖版本管理。</p>
<h2 id="2-安装和配置Maven"><a href="#2-安装和配置Maven" class="headerlink" title="2.安装和配置Maven"></a>2.安装和配置Maven</h2><p>下载地址： <a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p>
<p>![image-20210824144100726](&#x2F;Users&#x2F;liuxuan14&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210824144100726.png)</p>
<p>我下载在了<code>/Library/ApacheMaven</code></p>
<p><code>vim ~/.bash_profile</code>  &#x2F;&#x2F;配置环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export M=&quot;/Library/ApacheMaven&quot;  //根据自己放在哪个目录</span><br><span class="line">export PATH=&quot;$M/bin:$PATH&quot;</span><br></pre></td></tr></table></figure>

<p><code>source ~/.bash_profile</code>     &#x2F;&#x2F;使配置生效</p>
<p><code>mvn -v</code>   &#x2F;&#x2F;查看版本</p>
<p>或者，可以直接<code>brew install maven</code></p>
<h3 id="下载远程仓库到本地"><a href="#下载远程仓库到本地" class="headerlink" title="下载远程仓库到本地"></a>下载远程仓库到本地</h3><p>maven 就像是一个大仓库，里面是很多的jar包，我们需要的时候就去里面拿，所以这就涉及到一个 ‘‘本地仓库’’（不能需要什么再去网上下载吧，速度有时候很慢的）,那么咱们就得先把这些jar包下载到咱们本地方便使用，<br>默认请况下，这个本地仓库会在&#x2F;user&#x2F;name&#x2F;.m2下面（name 是你的用户名）。为了方便，把本地仓库改在Maven安装目录下。</p>
<p>打开安装目录下的conf目录下的<code>settings.xml</code><br>加入<code>&lt;localRepository&gt;/Library/ApacheMaven/repository &lt;/localRepository&gt;</code></p>
<p>输入<code>mvn help:system</code></p>
<p>![image-20210824175620786](&#x2F;Users&#x2F;liuxuan14&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210824175620786.png)</p>
<p>多了一个repository文件夹，这就是咱们从远程仓库下载到本地仓库的文件。</p>
<h2 id="3-创建Maven项目"><a href="#3-创建Maven项目" class="headerlink" title="3.创建Maven项目"></a>3.创建Maven项目</h2><h3 id="a-使用命令行创建Maven项目"><a href="#a-使用命令行创建Maven项目" class="headerlink" title="a.使用命令行创建Maven项目"></a>a.使用命令行创建Maven项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=cn.xuanliu.helloword -DartifactId=helloworld -Dpackage=cn.cxuanliu.helloword -Dversion=1.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-quickstart</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mvn</code>:表示使用的是maven命令。</li>
<li><code>archetype:generate</code>:表示使用generate这个插件为我们的maven项目自动生成一个maven骨架，即我们项目的工程结构。后边跟的是该插件为我们创建工程结构所需要的一连串的参数。</li>
<li><code>-DgroupId</code>:标识项目的坐标元素之一，项目包名，可以是：域名的反写+项目名。</li>
<li><code>-DartifactId</code>:标识项目的坐标元素之一，它的值为我们的项目名。我这里指定我要生成的项目名为helloword。</li>
<li><code>-Dpackage</code>:标识项目的坐标元素之一,这里值就跟DgroupId的值保持一致即可。此属性在命令行中可选。</li>
<li><code>-Dversion</code>:指定版本号。此属性在命令行中可选</li>
<li><code>-DarchetypeArtifactId</code>:表示我们生成的工程结构为哪一种，这里的属性值为<code>maven-archetype-quickstart</code>表示生成工程目录结构为quickstart的结构。其值还可以为<code>maven-archetype-webapp</code>表示生成的工程目录结构为webapp的结构。</li>
</ul>
<p>![image-20210824155803431](&#x2F;Users&#x2F;liuxuan14&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210824155803431.png)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目录解读：在maven项目的开发中，所有的源代码放在文件夹 /src/main/java/下, 所有的单元测试代码放入 /src/test/java/。</span><br><span class="line">pom.xml 描述了整个项目的信息</span><br></pre></td></tr></table></figure>

<h3 id="b-使用IDEA创建Maven项目"><a href="#b-使用IDEA创建Maven项目" class="headerlink" title="b.使用IDEA创建Maven项目"></a>b.使用IDEA创建Maven项目</h3><p><code>Create New Project</code>，选择<code>Maven</code>，勾选<code>Create from archetype</code></p>
<p><img src="https://img2018.cnblogs.com/blog/1068501/201809/1068501-20180914191722384-1695467171.png" alt="img"></p>
<p>写<code>Maven</code>的坐标，“groupId”，“artifactId”，以及“version”，其中groupId是公司域名的反写，而artifactId是项目名或模块名，version就是该项目或模块所对应的版本号。</p>
<p>![image-20210824174243856](&#x2F;Users&#x2F;liuxuan14&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210824174243856.png)</p>
<p>![image-20210824180029943](&#x2F;Users&#x2F;liuxuan14&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210824180029943.png)</p>
<p>maven会自动下载maven依赖，当所有的都自动完成后，创建的maven项目结构如下所示： </p>
<p>![image-20210824180441439](&#x2F;Users&#x2F;liuxuan14&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210824180441439.png)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）在大多数情况下，把项目的主代码放到 src/main/java 目录下（遵循Maven约定），如果没有其他的配置，Maven在运行时将自动搜寻该目录下的主代码。</span><br><span class="line">（2）为了使项目的结构保持清晰，所以IDEA自动创建了 test 文件，将主代码和测试代码分别放到了独立的目录中。</span><br><span class="line">（3）pom.xml为Maven的核心配置文件，它的全称为（Project Object Model，项目对象模型），我们在使用Maven的时候也通常在这个pom .xml 中配置。</span><br></pre></td></tr></table></figure>

<h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml:"></a>pom.xml:</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>    <span class="comment">&lt;!-- xml头，指定xml文档的版本信息和编码方式 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;project&gt;为所有pom.xml的根元素，声明了一些POM相关的命名空间及xsd元素，</span></span><br><span class="line"><span class="comment">  这些元素不是pom.xml中必须添加的，但是使用这些属性可以使第三方工具，</span></span><br><span class="line"><span class="comment">  如IDE中的xml编辑器帮助开发者快速编辑POM。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;modeVersion&gt; 指定了当前POM模板的版本 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.liuxuan<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="comment">&lt;!-- &lt;groupId&gt; 定义了该项目属于哪个项目组 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ideamaven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   <span class="comment">&lt;!-- &lt;&lt;artifactId&gt;定义了当前Maven项目在项目组的唯一一个ID,项目名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="comment">&lt;!--&lt;version&gt;定义了Hello Maven项目当前的版本号 1.0-SNAPSHOT 为IDEA默认的初始版本号 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>在没有实际的java代码时，我们就可以完整的创建一个Maven项目的pom.xml，这说明了Maven可以使项目对象模型最大程度的与代码相独立，这充分体现了解耦的原则和理念！为开发者节省了时间，大大缩短了项目开发周期。在项目开发到稳定期时，升级版本时，开发者可以不需要修改实际的 java 代码，而是只修改pom.xml，这一特点使Maven被广泛的使用。</p>
<h2 id="4-编写主代码"><a href="#4-编写主代码" class="headerlink" title="4.编写主代码"></a>4.编写主代码</h2><p><strong>项目主代码和测试代码不同，主代码会被打包到最终的构件中，而测试代码只在运行测试时用到，不会被打包。</strong></p>
<p><strong>在src&#x2F;main&#x2F;java中创建文件com&#x2F;feiyu&#x2F;web&#x2F;helloworld&#x2F;helloWorld.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello liuxuan&#x27;s Maven!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">hello</span>().sayHello());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>右键运行。</p>
<p>目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---pom.xml　　　　核心配置，项目根下</span><br><span class="line">---src</span><br><span class="line">　　---main　　　　　　</span><br><span class="line">　　　   ---java　　　　java源码目录</span><br><span class="line">　　     ---resources　  java配置文件目录</span><br><span class="line">　　---test</span><br><span class="line">　　　　　---java　　　　测试源码目录</span><br><span class="line">　　　　　---resources　  测试配置目录</span><br><span class="line">---target    输出目录</span><br></pre></td></tr></table></figure>

<h2 id="5-Maven仓库"><a href="#5-Maven仓库" class="headerlink" title="5.Maven仓库"></a>5.Maven仓库</h2><p>Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。</p>
<p>Maven 仓库有三种类型：</p>
<ul>
<li>本地（local）</li>
<li>中央（central）</li>
<li>远程（remote）</li>
</ul>
<h3 id="a-本地仓库"><a href="#a-本地仓库" class="headerlink" title="a.本地仓库"></a>a.本地仓库</h3><p>第一次执行 maven 命令的时候才被创建。运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。</p>
<p>默认情况下，不管Linux还是 Windows，每个用户在自己的用户目录下都有一个路径名为 .m2&#x2F;respository&#x2F; 的仓库目录。</p>
<p>可以修改默认位置，改变settings.xml中的配置。<br><code>&lt;localRepository&gt;C:/MyLocalRepository&lt;/localRepository&gt;</code></p>
<h3 id="b-中央仓库"><a href="#b-中央仓库" class="headerlink" title="b.中央仓库"></a>b.中央仓库</h3><p>Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。</p>
<p>中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。</p>
<p>中央仓库的关键概念：</p>
<ul>
<li>这个仓库由 Maven 社区管理。</li>
<li>不需要配置。</li>
<li>需要通过网络才能访问。</li>
</ul>
<p>要浏览中央仓库的内容，maven 社区提供了一个 URL：<a href="http://search.maven.org/#browse%E3%80%82%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E4%BB%93%E5%BA%93%EF%BC%8C%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%8F%AF%E4%BB%A5%E6%90%9C%E7%B4%A2%E6%89%80%E6%9C%89%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96%E7%9A%84%E4%BB%A3%E7%A0%81%E5%BA%93%E3%80%82">http://search.maven.org/#browse。使用这个仓库，开发人员可以搜索所有可以获取的代码库。</a></p>
<h3 id="c-远程仓库"><a href="#c-远程仓库" class="headerlink" title="c.远程仓库"></a>c.远程仓库</h3><p>中央仓库是一些常用的库？远程仓库是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</p>
<h3 id="d-Maven依赖搜索顺序"><a href="#d-Maven依赖搜索顺序" class="headerlink" title="d.Maven依赖搜索顺序"></a>d.Maven依赖搜索顺序</h3><ul>
<li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li>
<li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。</li>
<li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li>
<li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li>
</ul>
<h3 id="e-更换Maven阿里云仓库"><a href="#e-更换Maven阿里云仓库" class="headerlink" title="e.更换Maven阿里云仓库"></a>e.更换Maven阿里云仓库</h3><p>Maven根目录下，conf文件夹下setting.xml文件，mirrors节点上修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mirrors&gt;</span><br><span class="line">  &lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">  &lt;/mirror&gt;</span><br><span class="line">&lt;/mirrors&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：pom.xml文件里添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;repositories&gt;  </span><br><span class="line">        &lt;repository&gt;  </span><br><span class="line">            &lt;id&gt;alimaven&lt;/id&gt;  </span><br><span class="line">            &lt;name&gt;aliyun maven&lt;/name&gt;  </span><br><span class="line">            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;  </span><br><span class="line">            &lt;releases&gt;  </span><br><span class="line">                &lt;enabled&gt;true&lt;/enabled&gt;  </span><br><span class="line">            &lt;/releases&gt;  </span><br><span class="line">            &lt;snapshots&gt;  </span><br><span class="line">                &lt;enabled&gt;false&lt;/enabled&gt;  </span><br><span class="line">            &lt;/snapshots&gt;  </span><br><span class="line">        &lt;/repository&gt;  </span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure>

<h2 id="6-Maven命令"><a href="#6-Maven命令" class="headerlink" title="6.Maven命令"></a>6.Maven命令</h2><p><code>maven -version   Maven版本及控制信息</code></p>
<p><code>mvn archetype:create  -DgroupId=   DartifactId=   构建java项目</code>   </p>
<p><code>mvn archetype:create  -DgroupId=   DartifactId=   -DarchetypeArtifactId=maven-archetype-webapp ls创建web项目</code></p>
<p><code>mvn compile     编译源代码</code>     </p>
<p><code>mvn test-compile    编译测试代码</code></p>
<p><code>mvn clean   打包前清理掉之前有过打包的文件夹target</code></p>
<p><code>mvn package  打包，package包括了编译、打包这两步</code>    </p>
<p>![image-20210825113016694](&#x2F;Users&#x2F;liuxuan14&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210825113016694.png)</p>
<p><code>mvn install   将打包好的jar包部署到本地，放到本地仓库</code> </p>
<h2 id="7-运行jar包"><a href="#7-运行jar包" class="headerlink" title="7.运行jar包"></a>7.运行jar包</h2><p><code>java -jar ideamaven-1.0-SNAPSHOT.jar</code></p>
<p>问题：<code>ideamaven-1.0-SNAPSHOT.jar中没有主清单属性</code></p>
<p>解决：找不到<code>main</code>方法，需要在<code>pom.xml</code>配置<code>main</code>方法的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--  添加main方法   --&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.2.1&lt;/version&gt;</span><br><span class="line">  &lt;executions&gt;</span><br><span class="line">    &lt;execution&gt;</span><br><span class="line">      &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">      &lt;goals&gt;</span><br><span class="line">        &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">      &lt;/goals&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;transformers&gt;</span><br><span class="line">          &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;</span><br><span class="line">            &lt;!-- 在这里指定入口类 --&gt;</span><br><span class="line">            &lt;mainClass&gt;com.liuxuan.hello&lt;/mainClass&gt;</span><br><span class="line">          &lt;/transformer&gt;</span><br><span class="line">        &lt;/transformers&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/execution&gt;</span><br><span class="line">  &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

<p>mvn打包和jar包运行问题未解决。</p>
<p>问题：<code>Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.8.0:compile (default-compile) on project ideamaven: Compilation failure</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://console.cloud.baidu-int.com/devops/icode/repos/baidu/netdisk/platform-idproducter/reviews/18480257/files/base...latest/service/create_service.go">https://console.cloud.baidu-int.com/devops/icode/repos/baidu/netdisk/platform-idproducter/reviews/18480257/files/base...latest/service/create_service.go</a></p>
<p><a href="https://blog.csdn.net/wfy2695766757/article/details/81189291">https://blog.csdn.net/wfy2695766757/article/details/81189291</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis入门</title>
    <url>/2022/03/12/myblog/java/Mybatis%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><strong>mybatis</strong></p>
<h3 id="⛽️第一课"><a href="#⛽️第一课" class="headerlink" title="⛽️第一课"></a>⛽️第一课</h3><p>✅开发步骤：</p>
<p>1.添加Mybatis的坐标、mysql的驱动（pom.xml中）</p>
<p>2.创建数据表、编写对应的实体类（操作实体从而间接操作表，查询表从而间接封装实体）</p>
<p>3.编写映射文件UserMapper.xml  主要描述sql文件（第一个点：namespace命名空间，第二个点：id和resultType，通过命名空间.id进行调用，resultType结果集，封装到指定的类型中）</p>
<p>4.编写核心文件sqlMapConfig.xml，配置mybatis核心内容的，配置数据源信息、加载映射文件（可能很多）。</p>
<p>5.编写测试类（1.获取核心配置文件 2.获得session工厂对象 3.获得session会话对象 4.执行操作 5.打印数据 6.释放资源）</p>
<p>mybatis映射文件： </p>
<p><img src="https://img-blog.csdnimg.cn/6779525e71d546109fea38a2120c0479.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="Pasted Graphic.tiff"></p>
<p>DTD约束头在写标签或者属性时能给提示。</p>
<p>✅什么是mybatis？</p>
<p>是apache的一个开源项目iBatis，2010年迁移到google code，改名为mybatis，2013年迁移到github。</p>
<p>Mybatis是一个实现了数据持久化的开源框架，简单理解就是对JDBC进行封装。</p>
<p>ORMapping：Object Relationship Mapping 对象关系映射</p>
<p>对象：面向对象</p>
<p>关系：关系型数据库</p>
<p>映射：java到mysql的映射，开发者以面向对象的思想来管理数据库。</p>
<p>✅mybatis优缺点</p>
<p>优点：</p>
<p>1⃣️与JDBC相比，减少50%代码量</p>
<p>2⃣️最简单的持久化框架，小巧简单</p>
<p>3⃣️灵活，不会对程序或数据库的现有设计强行加任何影响，sql写在xml中，从程序代码中彻底分离，解耦合，可重用。</p>
<p>4⃣️提供xml标签，支持编写动态sql语句。</p>
<p>5⃣️提供映射标签，支持对象的属性与数据库的ORM字段关系映射。</p>
<p>缺点：</p>
<p>1⃣️半自动的，sql语句编写工作量大</p>
<p>2⃣️依赖于数据库，数据库迁移性差。</p>
<p>✅Mybatis核心接口和类</p>
<p>java和Mybatis的连接者：sqlsession</p>
<p>SqlSessionFactoryBuilder接口 build()方法。得到SqlSessionFactory（工厂对象）。调用openSession()方法，获得SqlSession。</p>
<p>✅Mybatis的开发方式</p>
<p>1⃣️使用原生接口</p>
<p>2⃣️Mapper代理实现自定义接口</p>
<p>两种方法都是通过sqlsession的相关方法来完成的。</p>
<p>✅创建第一个mybatis项目</p>
<p>1⃣️新建一个maven项目</p>
<p>pom.xml文件：增加mybatis坐标org.mybatis. mysql驱动</p>
<p>❓pom.xml中加入依赖显红怎么办？</p>
<p>解决：首先删除.m文件夹下的repo文件夹，然后回到项目右键pom.xml，选maven，选reimport</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>2⃣️新建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database mybatis;</span><br><span class="line"><span class="keyword">create table</span> account(</span><br><span class="line"> id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment,</span><br><span class="line"> username <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line"> password <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line"> age <span class="type">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>3⃣️新建数据表对应的实体类</p>
<p>这里用Lombok库，用来自动生成构造方法.类级别的 @Data 注释是由 Lombok 提供的，它告诉 Lombok 生成所有缺少的方法，以及接受所有final属性作为参数的构造函数。</p>
<p>加lombok依赖时，有错误，因为版本号的原因。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>4⃣️创建mybatis配置文件 config.xml 文件名可自定义，建在resource文件夹中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">​    <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置Mybatis运行环境 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!-- 下面可以多个environment，但是上面选一个 --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">​      <span class="comment">&lt;!-- 配置jdbc事务管理 --&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">​      <span class="comment">&lt;!--POOLED配置JDBC数据源连接池 --&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xuan&quot;</span>/&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jade&quot;</span>/&gt;</span></span><br><span class="line">​      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>5⃣️使用原生接口的方式开发</p>
<p>（1）Mybatis框架需要开发者自定义sql语句，写在Mapper.xml文件中，实际开发中，会为每个实体类创建对应的Mapper.xml，定义管理该对象数据的SQL。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">​    <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- namespace是mybatis加载配置文件时要找的路径（包+文件名的形式）。</span></span><br><span class="line"><span class="comment">  id是一会儿调用sql语句时要用的名字，自定义的.</span></span><br><span class="line"><span class="comment">  parameterType是要传入的参数,下面语句是从对象中取值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.demo.mybatis.mapper.AccountMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;save&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line">​    insert into account(username, password, age) values(#&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）在全局配置文件config.xml中注册AccountMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册AccountMapper.xml，加载映射文件，这里带后缀，所以用路径/ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/demo/mybatis/mapper/AccountMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）调用mybatis的原生接口执行添加操作，写测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.demo.mybatis.entity.Account;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInsert</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//加载mybatis配置文件config.xml</span></span><br><span class="line">​    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> TestInsert.class.getClassLoader().getResourceAsStream(<span class="string">&quot;config.xml&quot;</span>); <span class="comment">//变成一个流</span></span><br><span class="line">​    <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">​    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(inputStream); <span class="comment">//传入流</span></span><br><span class="line">​    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//然后就可以进行java和mysql的关联，结合namespace和id获取位置</span></span><br><span class="line">​    <span class="comment">//因为配置文件已经加载到环境中，因此可以通过下面找到</span></span><br><span class="line">​    <span class="type">String</span> <span class="variable">statement</span> <span class="operator">=</span> <span class="string">&quot;com.demo.mybatis.mapper.AccountMapper.save&quot;</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//传参数需要对象，因此需要实例化一个对象</span></span><br><span class="line">​    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">1L</span>, <span class="string">&quot;liu&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">12</span>);</span><br><span class="line">​    sqlSession.insert(statement, account);</span><br><span class="line">​    <span class="comment">//commit方法提交事务</span></span><br><span class="line">​    sqlSession.commit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>❓出现问题，明明已经有lombok，可是在对象实例化的时候还是有问题。</p>
<p>解决：添加插件：设置里找到plugins，搜索lombok plugin，安装，重启。勾选配置：setting–&gt;build,excecution,deployment–&gt;compiler–&gt;annotation processors勾选上 enable annotation processing。即可生效。</p>
<p>⚠️maven工程中不能直接读取resource以外的xml文件，得在pom里加一个配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>❓java.lang.ClassNotFoundException: Cannot find class: com.mysql.cj.jdbc</p>
<p>解决：<property name="driver" value="com.mysql.cj.jdbc.Driver"/> 少写了Driver</p>
<p>🎉Success</p>
<h3 id="⛽️第二课"><a href="#⛽️第二课" class="headerlink" title="⛽️第二课"></a>⛽️第二课</h3><p>✅使用Mapper代理实现自定义接口</p>
<p>实际开发中推荐用这种。</p>
<p>Mapper是mybatis内部提供的组建，接口是开发者自己写，接口的实现类是由mybatis动态生成实现类，同时获取实现类的对象，可以直接用。</p>
<p>1⃣️自定义接口，定义相关的业务方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.mybatis.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.mybatis.entity.Account;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountRepository</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">  <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> Account <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2⃣️编写与接口相对应的Mapper.xml，定义接口方法对应的sql语句。</p>
<p>statement标签（如<code>&lt;insert&gt;</code>）可根据sql执行的业务选择insert、delete、update、select。</p>
<p>Mybatis会自动根据规则自动创建接口实现类的代理对象。</p>
<p>规则：</p>
<ol>
<li>Mapper.xml中namespace为接口的全类名。</li>
<li>Mapper.xml中statement的id为接口中对应的方法名。</li>
<li>Mapper.xml中statement的parameterType和接口中对应方法的参数类型一致。</li>
<li>Mapper.xml中statement的resultType和接口中对应的方法的返回值类型一致。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">​    <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.demo.mybatis.repository.AccountRepository&quot;</span>&gt;</span>  <span class="comment">&lt;!-- 映射 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;save&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!-- 添加 修改 删除 三个操作在数据库返回的结果一定是int， 所以这里没有resultType属性 --&gt;</span></span><br><span class="line">​    insert into account(username, password, age) values(#&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line">​    update account set username = #&#123;username&#125;, password = #&#123;password&#125;, age = #&#123;age&#125; where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span>&gt;</span></span><br><span class="line">​    delete from account where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!-- 不写集合类型，而写集合里的泛型类型 --&gt;</span></span><br><span class="line">​    select * from account</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line">​    select * from account where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>3⃣️在config.xml中注册AccountRepository.xml</p>
<p><code>&lt;mappers&gt;</code></p>
<p>  <code>&lt;mapper resource=&quot;com/demo/mybatis/mapper/AccountMapper.xml&quot;&gt;&lt;/mapper&gt;</code></p>
<p>  <code>&lt;!-- 注册第二课中的AccountRepository.xml --&gt;</code></p>
<p>  <code>&lt;mapper resource=&quot;com/demo/mybatis/repository/AccountRepository.xml&quot;&gt;&lt;/mapper&gt;</code></p>
<p><code>&lt;/mappers&gt;</code></p>
<p>4⃣️测试</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">​    <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置Mybatis运行环境 ,配置数据源信息--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!-- 下面可以多个environment，但是上面选一个 --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">​      <span class="comment">&lt;!-- 配置jdbc事务管理 --&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">​      <span class="comment">&lt;!--POOLED配置JDBC数据源连接池 --&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xuan&quot;</span>/&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jade&quot;</span>/&gt;</span></span><br><span class="line">​      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 注册AccountMapper.xml，加载映射文件，这里带后缀，所以用路径/ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/demo/mybatis/mapper/AccountMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!-- 注册第二课中的AccountRepository.xml --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/demo/mybatis/repository/AccountRepository.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>🤔我对动态代理的理解：</p>
<p>自己只需要写一个类，框架为我动态代理实现接口的实现类，并且还给我实现类的对象，可以直接用。</p>
<p>可以看到第一种方法，确实比较复杂，需要自己写statement，但是说的自己写接口实现类？没有吧</p>
<h3 id="⛽️第三课"><a href="#⛽️第三课" class="headerlink" title="⛽️第三课"></a>⛽️第三课</h3><p>Mapper.xml解读</p>
<ol>
<li><p>statement标签，select、update、delete、insert分别对应查询、修改、删除、添加</p>
</li>
<li><p>parameterType：参数数据类型</p>
<p>A. 基本数据类型，通过id查询Account,  “long”</p>
<p>b. String类型，通过name查询Account，”java.lang.String”</p>
<p>C. 包装类，通过id查询Account。“java.lang.long”</p>
</li>
</ol>
<p>​     {用包装类的好处：基本数据类型接受不了null，null传进来报异常，业务中可能会有null，需要判断}</p>
<p>   D.多个参数，通过username和age查询account</p>
<p>​     ⚠️：如果返回结果可能多个，就得List。好像多个操作commit一次就行吧。</p>
<p>   e.java bean</p>
<p>​    update操作传入的account对象</p>
<ol>
<li><p>resultType结果类型</p>
<p>A. 基本数据类型</p>
<p>B. 包装类 java.lang.Integer</p>
<p>C. string类型，比如通过id查询username</p>
</li>
</ol>
<p>  ⚠️看到id有中断，这是因为之前程序有错异常了，没commit提交，但是id已经涨了。</p>
<p>   D. Java bean</p>
<p>​    findAll返回的account对象</p>
<h3 id="⛽️第四课"><a href="#⛽️第四课" class="headerlink" title="⛽️第四课"></a>⛽️第四课</h3><p>✅及联查询</p>
<p>1⃣️一对多，一个班对应多个学生</p>
<p>要查询id&#x3D;1的学生的名字、班级</p>
<p>建表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> student(</span><br><span class="line"> id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment,</span><br><span class="line"> name <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line"> cid <span class="type">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> classes(</span><br><span class="line"> id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment,</span><br><span class="line"> name <span class="type">varchar</span>(<span class="number">11</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>查询语句： <code>select * from student s, classes c where s.id =1 and s.cid=c.id;</code></p>
<p>🤔首先建接口，再写xxxRepository.xml, 再把xml文件加载到config中。 测试代码中，用方法就好了。</p>
<p>🏁mybatis和java类怎么做到映射，mybatis不关注表和类的结构，关注的是结果集和类的映射。</p>
<p>从select查出来的结果集，到赋给resutl的结果的映射。从结果集里按顺序找result对的上的字段，赋给result。</p>
<p>应该给后面的取别名。这里关于班级的信息要赋给classes对象，需要建立映射，用resultMap。</p>
<p>注意映射的时候，是看这个查询结果集上面的字段。</p>
<p>这样就完成了，结果类 和 结果集的映射</p>
<p>2⃣️通过classes查students</p>
<p>通过班级id，查出整个classes类.</p>
<p>首先写接口，再写xml文件，xml文件中先写sql语句，完成映射，添加到config，测试。</p>
<p>⚠️注意结果集要用resultMap，要还是用resultType的话，相当于写的映射没有用到。</p>
<p>3⃣️多对多</p>
<p>比如说，客户和商品，这两个是多对多的关系。</p>
<p>customer表和goods表，中间需要建一个从表customer_goods，里面cid表示客户表的外键，gid表示商品表的外键。</p>
<p>customer类中，有一个goods集合</p>
<p>goods类中，有一个custimer集合</p>
<p>要做的是：根据customer的id，返回custimer类。</p>
<p><code>select c.id as cid, c.name as came, g.id as gid, g.name as gname from customer as c, goods as g， customer_goods as cg where c.id=1 and cg.cid = c.id and cg.gid = g.id;</code> </p>
<p>返回id&#x3D;1的客人买的商品。</p>
<p>⚠️知识点；笛卡尔积，需要找这两张表的关联关系：第三张表.</p>
<p>根据一对多来建立多对多的映射就好了，不同之处在去sql语句中两张表建立关系的方式是通过第三张表了。</p>
<p>但是xml文件中构建映射要看的是sql语句返回结果集和接口方法要返回的返回类对象。</p>
<h3 id="⛽️第五课"><a href="#⛽️第五课" class="headerlink" title="⛽️第五课"></a>⛽️第五课</h3><p>✅逆向工程</p>
<p>对传统开发反向的一个方式。</p>
<p>Mybatis框架需要：实体类、自定义的Mapper接口、Mapper.xml。</p>
<p>传统的开发中，上述的三个组件需要开发者手动创建，逆向工程可以帮助开发者自动创建这三个组件，减轻开发者的工作量，提高工作效率。</p>
<p>缺点：逆向工程只能执行一次，逆向工程根据数据表来建立实体类等，如果改了表结构，就需要重新执行一次逆向工程。</p>
<p>如果改了表结构，就需要删了已经存在的，重新执行。</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>如何使用：</p>
<p>Mybatis Generator，简称MBG，是一个专门为Mybatis框架开发者定制的代码生成器和自动生成Mybatis框架所需的实体类、Mapper接口、Mapper.xml，支持基本CRUD操作，但是一些相对复杂的sql需要开发者自己来完成。</p>
<p>1⃣️新建Maven工程，引入依赖</p>
<p>数据库建个表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t_user(</span><br><span class="line"> id int primary key auto_increment,</span><br><span class="line"> name varchar(11),</span><br><span class="line"> age int</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>2⃣️创建MBG配置文件generatorConfig.xml</p>
<p> \1. jdbcConnection 配置数据库连接信息</p>
<p> \2. javaModelGenerator 配置javaBean的生成策略，要把创建的实体类放在哪个包里</p>
<p> \3. sqlMapGenerator 配置sql映射文件生成策略</p>
<p> \4. javaClientGenerator 配置Mapper接口</p>
<p> \5. table 配置目标数据表（tableName：表名，dominObjectName：JavaBean类名）</p>
<p>3⃣️创建Generator执行类</p>
<p>启动类main，里面没有业务逻辑，没理解反正是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.MyBatisGenerator;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.xml.ConfigurationParser;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.exception.InvalidConfigurationException;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.exception.XMLParserException;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.internal.DefaultShellCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">​    List&lt;String&gt;warings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">​    <span class="type">boolean</span> <span class="variable">overwrite</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">​    <span class="type">String</span> <span class="variable">genCig</span> <span class="operator">=</span> <span class="string">&quot;/generatorConfig.xml&quot;</span>; <span class="comment">// /就表示resource文件夹</span></span><br><span class="line">​    <span class="type">File</span> <span class="variable">configFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(Main.class.getResource(genCig).getFile()); <span class="comment">//获取运行时类，getResource(路径)，获取配置文件</span></span><br><span class="line"></span><br><span class="line">​    <span class="type">ConfigurationParser</span> <span class="variable">configurationParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationParser</span>(warings);</span><br><span class="line">​    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span> &#123;</span><br><span class="line">​      configuration = configurationParser.parseConfiguration(configFile);</span><br><span class="line">​    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125; <span class="keyword">catch</span> (XMLParserException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="type">DefaultShellCallback</span> <span class="variable">callback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultShellCallback</span>(overwrite);</span><br><span class="line">​    <span class="type">MyBatisGenerator</span> <span class="variable">myBatisGenerator</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">​    <span class="keyword">try</span> &#123;</span><br><span class="line">​      myBatisGenerator = <span class="keyword">new</span> <span class="title class_">MyBatisGenerator</span>(configuration, callback, warings);</span><br><span class="line">​    &#125; <span class="keyword">catch</span> (InvalidConfigurationException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span> &#123;</span><br><span class="line">​      myBatisGenerator.generate(<span class="literal">null</span>);</span><br><span class="line">​    &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">​      throwables.printStackTrace();</span><br><span class="line">​    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>IDEA抛出异常快捷键：</strong></p>
<p><strong>Mac</strong></p>
<p><strong>方式一（光标移到该代码行，option+Enter），可以异常外抛出，也可以try-catch：</strong></p>
<p><strong>方式二（光标移到该代码行，或者选中该行代码，option+command+T）：[使用关键字或控制语句，比如if…else, try…catch, for, synchronized等]</strong></p>
<p>4⃣️<strong>然后运行main方法，文件夹下什么都有了，而且根据数据库的表建立了实体类。</strong></p>
<h3 id="⛽️第六课"><a href="#⛽️第六课" class="headerlink" title="⛽️第六课"></a>⛽️<strong>第六课</strong></h3><p>✅<strong>延迟加载</strong></p>
<p><strong>什么是延迟加载？也叫懒加载、惰性加载</strong></p>
<p><strong>使用延迟加载可以提高程序的运行效率，针对于数据的持久层的操作。在某些特定的情况下去访问特定的数据库，在其他情况下可以不访问某些表，从一定程度上减少了java应用与数据库的交互次数。</strong></p>
<p><strong>比如说上面及联查询时，查询学生和班级，学生和班级在两张不同的表，如果当前的需求只需要获取学生的信息，那么查询学生单表即可，如果需要通过学生获取对应的班级信息，则必须查询两张表。</strong></p>
<p><strong>不同的业务需求，需要查询不同的表，根据具体的业务需求来动态减少数据表查询的工作就是延迟加载。</strong></p>
<p><strong>举例：student和classes的例子里，两个接口里都增加一个方法，各自重写xml里面对应新增方法的sql语句，select语句不联表查询了，各查各的，测试时，首先得到student的名字，如果够了，就不用查classes表了，如果不够，再根据student的cid获得classes相关信息。</strong></p>
<p><strong>因此要在配置文件里完成一个连接的操作来自动识别是否还需要查另一张表，在</strong>association中。</p>
<p>实践效果：根据学生id，查到学生完成信息，包括里面的Classes类。</p>
<p>实际上进行了两次sql查询，本身student接口方法调用查询一次，student配置文件中select标签又查一次。</p>
<p>通过配置config文件中setting可以打印sql执行过程。</p>
<p>但是，只拿name的话，还是执行两次sql。因此需要在config中开启延迟加载。</p>
<p>奇怪了，我开启了延迟加载，只获得student的name，还是查两次。</p>
<p>⚠️出现问题，Cannot enable lazy loading because CGLIB is not available. Add CGLIB to your classpath.</p>
<p>应该增加CGLIB依赖。</p>
<p>❓依赖闲红的时候，必须要删除.m2文件夹下的所有依赖，然后reimport吗？</p>
<h3 id="⛽️第七课"><a href="#⛽️第七课" class="headerlink" title="⛽️第七课"></a>⛽️第七课</h3><p>✅MyBatis缓存</p>
<p>什么事mybatis缓存？使用缓存可以减少Java应用与数据库的交互次数，从而提高程序的运行效率。比如查询出id&#x3D;1的对象，第一次查询出之后会自动将该对象保存到缓存中，当下一次查询时，直接从缓存中取出对象即可，无需再次访问数据库。</p>
<p>Mybatis缓存分类：</p>
<ol>
<li><strong>一级缓存：SqlSession级别，默认开启，并且不能关闭。</strong></li>
</ol>
<p>  <strong>操作数据库时需要创建SqlSession对象，在对象中有一个HashMap用于存储缓存数据，不同的SqlSession之间缓存数据区域是互不影响的。</strong></p>
<p>  <strong>一级缓存的作用域是SqlSession范围的，当在同一个SqlSession中执行两次相同的SQL语句时，第一次执行完毕将结果保存到缓存中，第二次查询时直接从缓存中获取。</strong></p>
<p>  <strong>需要注意的是：如果SqlSession执行了DML操作（insert、update、delete），Mybatis必须将缓存清空，来保证数据的准确性。</strong></p>
<ol>
<li><strong>二级缓存：Mapper级别的，默认关闭，可以开启。</strong></li>
</ol>
<p>  <strong>使用二级缓存时，多个SqlSession使用同一个Mapper的sql语句操作数据库，得到的数据会存在二级缓存中，同样是使用HashMap进行数据存储，相比较一级缓存，二级缓存的范围更大，多个sqlsession可以共用二级缓存。二级缓存是跨sqlsession的。</strong></p>
<p>  <strong>二级缓存是多个sqlsession共享的，其作用域是mapper的同一个namespqce，不同的sqlsession两次执行相同的namespace下的sql语句，参数也相同，则第一次执行成功之后会将数据保存到二级缓存中，第二次可直接从二级缓存中取出数据。</strong></p>
<p>⚠️<strong>一级缓存是一个sqlsession一个缓存。二级缓存是一个mapper一个，多个sqlsession 可能是使用的同一mapper，也就是同一个namespace。二级缓存范围更大。</strong></p>
<p><strong>如何开启二级缓存：</strong></p>
<p><strong>config.xml中</strong></p>
<p><code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code></p>
<p><strong>然后再对应的mapper.xml中，添加配置二级缓存</strong></p>
<p><code>&lt;cache&gt;&lt;/cache&gt;</code></p>
<p><strong>然后实体类实现序列化接口</strong></p>
<p><code>public class Classes implements Serializable</code></p>
<ol>
<li><strong>第三方二级缓存。需要在pom.xml里添加相关依赖</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   &lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>然后添加配置文件ehcache.xml 不用自己写，定义了一些二级缓存的设置</strong></p>
<p><strong>然后在config.xml中开启二级缓存</strong></p>
<p><strong>然后在mapper.xml中配置二级缓存</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;</span><br><span class="line">  &lt;!-- 缓存创建之后，最后一次访问缓存的时间至缓存失效的时间间隔 --&gt;</span><br><span class="line">  &lt;property name=&quot;timeToIdleSeconds&quot; value=&quot;3600&quot;/&gt;</span><br><span class="line">  &lt;!-- 缓存自创建时间起至失效的时间间隔 --&gt;</span><br><span class="line">  &lt;property name=&quot;timeToLiveSeconds&quot; value=&quot;3600&quot;/&gt;</span><br><span class="line">  &lt;!-- 缓存的回收策略 ,LRU移除近期使用最少--&gt;</span><br><span class="line">  &lt;property name=&quot;memoryStoreEvictionPolicy&quot; value=&quot;LRU&quot;/&gt;</span><br><span class="line">&lt;/cache&gt;</span><br></pre></td></tr></table></figure>

<p><strong>这个缓存里实体类内不需要实现序列化接口</strong></p>
<h3 id="⛽️第八课-Mybatis动态sql"><a href="#⛽️第八课-Mybatis动态sql" class="headerlink" title="⛽️第八课 Mybatis动态sql"></a>⛽️<strong>第八课 Mybatis动态sql</strong></h3><p><strong>sql语句是动态创建的，只需要定一个大致的样式，它会根据具体的参数、具体的业务去动态生成不同的sql。</strong></p>
<p><strong>背景：业务比较复杂时，如果需要我们手动去拼接sql语句来完成操作，效率比较低而且容易出错。</strong></p>
<p>❓<strong>发现test类里，第一行的加载类一直是第一次用的，这合理吗？</strong></p>
<p><strong>用一个account对象查account对象，根据对象的四个参数对应放到sql语句中，如果传入的account的一个参数没设置，则传到sql语句那里，这个字段&#x3D;null。一般就没结果。</strong></p>
<p><strong>动态sql：只需要写一个模版，让程序自动根据属性是否有值，来动态决定是否加这个条件。</strong></p>
<p><strong>其实就是一个if else的流程，判断如果为null，就忽略掉，使得有结果。</strong></p>
<p><strong>使用动态sql的作用：可简化代码的开发，减少开发者的工作量，程序可以自动根据业务参数来决定sal的组成。</strong></p>
<ul>
<li><strong>if标签</strong></li>
</ul>
<p><strong>～～～～～</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByAccount1&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  select * from account where</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != 0&quot;</span>&gt;</span></span><br><span class="line">​    id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">​    and username = #&#123;username&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span></span><br><span class="line">​    and password = #&#123;password&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != 0&quot;</span>&gt;</span></span><br><span class="line">​    age = #&#123;age&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>但是，如果第一个参数不给，就会出错，因为直接and后面的，语法错误。</strong></p>
<p><strong>将if标签的语句，放在where标签里就可以了。</strong></p>
<p><strong>if标签可以自动根据表达式的结果来决定是否将对应的语句添加到sql中，如果条件不成立则不添加，如果条件成立则添加。</strong></p>
<p><strong>where标签可以自动判断是否要删除语句块中的and关键字，如果监测到where直接跟and拼接，则自动删除and，通常情况下 if 和 where结合使用。</strong></p>
<ul>
<li><strong>choose、when标签</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByAccount2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  select * from account</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span> = <span class="string">&quot;id !=0 &quot;</span>&gt;</span></span><br><span class="line">​        id = #&#123;id&#125;</span><br><span class="line">​      <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​      <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span> = <span class="string">&quot;username !=null &quot;</span>&gt;</span></span><br><span class="line">​        username = #&#123;username&#125;</span><br><span class="line">​      <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​      <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span> = <span class="string">&quot;password !=null &quot;</span>&gt;</span></span><br><span class="line">​        password = #&#123;password&#125;</span><br><span class="line">​      <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​      <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span> = <span class="string">&quot;age !=0 &quot;</span>&gt;</span></span><br><span class="line">​        age = #&#123;age&#125;</span><br><span class="line">​      <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>trim标签：trim标签中的prefix和suffix属性会被用于生成实际的sql语句，会和标签内部的语句进行拼接，如果语句前后出现了prefixOverrides或者suffixOverrides属性中指定的值，Mybatis框架会自动将其删除。</strong></p>
</li>
<li><p><strong>set标签：用于update操作，会自动根据参数来选择生成sql语句。</strong></p>
</li>
</ul>
<p><strong>update传入的对象，如果set属性只有一个，相当于其他属性不传值，变为了null或者0.</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update1&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  update account</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != 0&quot;</span>&gt;</span></span><br><span class="line">​      id = #&#123;id&#125;</span><br><span class="line">​    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">​      and username = #&#123;username&#125;</span><br><span class="line">​    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span></span><br><span class="line">​      and password = #&#123;password&#125;</span><br><span class="line">​    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != 0&quot;</span>&gt;</span></span><br><span class="line">​      age = #&#123;age&#125;</span><br><span class="line">​    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">   where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>这是sql拼接吗？</strong></p>
<ul>
<li><strong>foreach标签</strong></li>
</ul>
<p><strong>foreach标签可以迭代生成一系列值，这个标签主要用于sql的in语句。</strong></p>
<p><code>private List&lt;Long&gt; ids;</code></p>
<p><code>List&lt;Long&gt; ids = new ArrayList&lt;Long&gt;();</code></p>
<p><strong>还得在实体类里建一个List吗？感觉不太便利。</strong></p>
<p><code>&lt;select id=&quot;findByIds&quot; param&gt;</code></p>
<h3 id="⛽️第九课-mybatis-通用Mapper"><a href="#⛽️第九课-mybatis-通用Mapper" class="headerlink" title="⛽️第九课 mybatis 通用Mapper"></a>⛽️<strong>第九课 mybatis 通用Mapper</strong></h3><p><strong>虽然有逆向工程MBG，能够自动生成代码，但是entity改变会牵一发而动全身。</strong></p>
<p>1⃣️<strong>建表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> mapperdemo(</span><br><span class="line"> id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment,</span><br><span class="line"> username <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line"> password <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line"> age <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> mapperdemo (username, password, age) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;liuxuan&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="number">23</span>),</span><br><span class="line">(<span class="string">&#x27;jade&#x27;</span>, <span class="string">&#x27;kk&#x27;</span>, <span class="number">22</span>),</span><br><span class="line">(<span class="string">&#x27;aks&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure>



<p>2⃣️新建java实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.mybatis.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span> <span class="comment">//有参构造</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span>  <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mapperdemo</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>
考虑到基本数据类型在Java类型中都有默认值，会导致mybatis在执行相关操作时很难判断当前字段是否为null。因此在mybatis环境下使用基本数据类型对应的包装类型。(上面的作废)



✅mapper注解重来：

参考链接：https://blog.csdn.net/jintingbo/article/details/80517053



从mybatis3.4.0开始加入了@Mapper注解，目的就是为了不再写mapper映射文件

现在我们通过一个简易的maven项目去了解@Mapper注解的使用方式：



1⃣️建表：

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> <span class="keyword">user</span>(</span><br><span class="line"> name <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line"> pwd <span class="type">varchar</span>(<span class="number">11</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> <span class="keyword">user</span> (name, pwd) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;liuxuan&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;jade&#x27;</span>, <span class="string">&#x27;kk&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;aks&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>);</span><br></pre></td></tr></table></figure>



2⃣️实体类

操作之前，从github上clone下来的项目出现问题

1.文件左下角有个橙色的小时钟，出现橙色原因：没有添加到maven解决办法：找到项目的xml,如果最外层没有xml,找到模块里面对应的xml,右键选择Add as Maven project. 导入通过maven导入jar。就解决了了。

2.项目依赖是红的，去maven仓库[Maven Repository: Search/Browse/Explore](https://mvnrepository.com/)下下来，放在.m2文件夹下。

3.没弄sdk，弄成jdk1.8

4.奇了怪了，这个项目里实体类用Lombok，依赖显红，懵逼了。

5.p空间显红的解决办法：file--&gt;settings...--&gt;languages &amp; frameworks--&gt;schemas and DTDs --&gt; 添加url



3⃣️加载配置文件时找不到bean

不知道啥原因了，应该是mybatis结合spring，这一点还没掌握。



总之，使用方面，不需要在mapper.xml里写sql语句？

测试类里直接调用dao接口里的方法即可？

！！！项目里还是有sql语句的，接口里用@mapper @param注解，只是传递参数。和之前学的，只是在接口里多了这俩注解。
</code></pre>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Page分页</title>
    <url>/2022/11/05/myblog/java/Page%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<h2 id="spring整合mybatis"><a href="#spring整合mybatis" class="headerlink" title="spring整合mybatis"></a>spring整合mybatis</h2><p>新建一个子工程web-repository。</p>
<p>mybatis依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.35&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>项目结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--web-repository</span><br><span class="line"> --src</span><br><span class="line">  --main</span><br><span class="line">   --java</span><br><span class="line">     --config</span><br><span class="line">       --SpringConfig.java</span><br><span class="line">     --domain</span><br><span class="line">       --StudentDO.java</span><br><span class="line">     --StudentDao.java</span><br><span class="line">   --resource</span><br><span class="line">     --mapper</span><br><span class="line">  --test</span><br></pre></td></tr></table></figure>

<p>✅spring配置类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &#123;&quot;org.example&quot;&#125;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要引入spring依赖。</p>
<p>spring配置：<a href="https://www.cnblogs.com/fengyupinglan/p/14517267.html">https://www.cnblogs.com/fengyupinglan/p/14517267.html</a></p>
<p>✅spring整合mybatis</p>
<p>首先，spring配置文件可以是xml文件在resource文件夹下，也可以是注解方式的java文件。先写一个spring配置文件，自动装配搞上去。还有mybatis的一些bean要配置上去。</p>
<h3 id="xml方式"><a href="#xml方式" class="headerlink" title="xml方式"></a>xml方式</h3><p>xml文件方式，spring-mybatis.xml<br>开启自动扫描和配置bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描,扫描多个包用,隔开--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启Aspect生成代理对象 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--加载properties文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">ignore-unresolvable</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">location</span>=<span class="string">&#x27;classpath:dbconfig.properties&#x27;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1.配置阿里druid连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置数据库基本信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.maxActive&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.initialSize&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2.配置spring的数据源，声明事务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3.配置 mybatis，扫描mapper.xml文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 3.1 配置 mybatis config --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 3.2 配置扫描mybatis映射文件路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4.类似于 jdbcTemplate 帮助类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描了所有的*Mapper.xml对应的mapper接口文件，这样就不用一个一个手动配置Mapper的映射了，只要Mapper接口类和Mapper映射文件对应起来就可以了。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.example.mysql&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>druid需要依赖包：druid<br>SqlSessionFactoryBean 需要依赖包：spring-jdbc<br>还需要 ibatis-common</p>
<p>dbconfig.properties:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.url=jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">db.driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">db.password=jade</span><br><span class="line">db.username=liuxuan</span><br><span class="line">db.maxActive=5</span><br><span class="line">db.initialSize=1</span><br></pre></td></tr></table></figure>

<p>mybatis配置文件，mybatis-config.xml<br>一些configuration setting</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//ybatis.org//DTD SQL Map Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;REUSE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>xml方式spring整合mybatis，mybatis配置项的意义：<br><a href="https://blog.csdn.net/qq_45797116/article/details/117105095">https://blog.csdn.net/qq_45797116/article/details/117105095</a></p>
<p>xml文件中如果想引入其他xml文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;import resource=&quot;.../...xml&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><p>注解方式，SpringConfig.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.mysql.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.ImportResource;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &#123;&quot;org.example&quot;&#125;)</span><br><span class="line">@ImportResource(&quot;classpath:spring-mybatis.xml&quot;) //导入xml配置项</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，可以用@Import导入其他注解方式的配置文件，以及用@ImportResource导入xml方式的配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Import(CDPlayerConfig.class)  </span><br><span class="line">@ImportResource(&quot;classpath:cons-injec.xml&quot;) //导入xml配置项</span><br></pre></td></tr></table></figure>

<p>注解方式倒入配置文件：<br><a href="https://blog.csdn.net/weixin_42107384/article/details/116475637">https://blog.csdn.net/weixin_42107384/article/details/116475637</a></p>
<p>纯注解方式的整合spring和mybatis配置：<br><a href="https://blog.csdn.net/weixin_44226181/article/details/127343597">https://blog.csdn.net/weixin_44226181/article/details/127343597</a></p>
<p>还有一个一行代码的基于注解整合的：<br><a href="https://www.pudn.com/news/62f1dcb95425817ffc22c172.html">https://www.pudn.com/news/62f1dcb95425817ffc22c172.html</a></p>
<h3 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example;</span><br><span class="line"></span><br><span class="line">public class StudentDaoTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectById() &#123;</span><br><span class="line"></span><br><span class="line">        // xml：</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        UserMapper mapper = (UserMapper) context.getBean(&quot;userMapper&quot;);</span><br><span class="line"></span><br><span class="line">        // 注解：</span><br><span class="line">        ApplicationContext context =new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        StudentDao studentDao = (StudentDao) context.getBean(&quot;studentDao&quot;);</span><br><span class="line"></span><br><span class="line">        StudentDO studentDO = studentDao.selectById(1L);</span><br><span class="line">        System.out.println(studentDO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试验证及xml中配置SqlSessionFactory的bean和扫描的bean：<br><a href="https://blog.csdn.net/qq_28082757/article/details/103488364">https://blog.csdn.net/qq_28082757/article/details/103488364</a></p>
<p>配置数据库连接池有几种方法，上面用的是ali的druid连接池，关于Druid连接池：<br><a href="https://www.cnblogs.com/chy18883701161/p/12594889.html">https://www.cnblogs.com/chy18883701161/p/12594889.html</a></p>
<p>注解方式配置JdbcConfig中 PlatformTransactionManager 是事务管理，在spring-jdbc包下。<br><a href="https://www.jianshu.com/p/903c01cb2a77">https://www.jianshu.com/p/903c01cb2a77</a></p>
<p>@Mapper注解，难道是spring-boot才能用的？<br>mybatis支持的映射方式有基于xml的mapper.xml文件、基于java的使用Mapper接口class。<br>从mybatis3.4.0开始加入了@Mapper注解，目的就是为了不再写mapper映射文件。<br><a href="https://blog.csdn.net/weixin_46369022/article/details/122755858">https://blog.csdn.net/weixin_46369022/article/details/122755858</a><br>需要依赖包：mybatis-spring-boot-starter</p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>✅ @Value里的字段报红</p>
<p>原因：自动导入了lombok里的@Value，要用的是SpringFramework下的@Value。</p>
<p>✅ xml配置文件加载不到properties属性问题</p>
<p>原因：spring中没有成功加载相应的配置文件</p>
<p>解决：进入File-Project Struccture，进入Facets中进行配置，.在右边的spring目录下，找到对应的爆红问题所在配置文件，选择xml文件，点击修改符合（下图中的小铅笔），在跳出来的弹框中，选择添加（加号），然后选择Additioonal properties files。然后找到需要加载进spring中的配置文件，点击OK，添加成功。</p>
<p>来自：<a href="https://blog.csdn.net/zhaogot/article/details/103224088">https://blog.csdn.net/zhaogot/article/details/103224088</a></p>
<p>✅ xml配置文件中的问题：根元素 “beans” 必须匹配 DOCTYPE 根 “null”</p>
<p>在<code>&lt;beans&gt;</code>标签那里报出来。</p>
<p>原因：mybatis在扫描Mapper.xml文件时，扫描到非mapper文件。比如本次报错扫描到了自己。spring.xml的根元素是<code>&lt;beans&gt;&lt;/beans&gt;</code>当然不会有DOCTYPE了。<br>所以当Mybatis扫描到了Spring.xml这个非Mapper.xml文件时，自然找不到DOCTYPE，所以会有“DOCTYPE 根 “null””这个错误。</p>
<p>粗心：应该扫的是mybatis-config.xml文件，结构写成了自己。</p>
<p>来自：<a href="https://www.codeleading.com/article/7746743165/">https://www.codeleading.com/article/7746743165/</a></p>
<p>✅ org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)</p>
<p>原因：mapper接口和xml文件没匹配上，有可能是文件名方法名没匹配上，这里是在配置文件里没加扫描接口，加了就好了。</p>
<p><a href="https://blog.csdn.net/weixin_43570367/article/details/103147854">https://blog.csdn.net/weixin_43570367/article/details/103147854</a></p>
<p>✅ properties文件 java.lang.NumberFormatException</p>
<p>明明是数字类型，但是说我从String转为int发生异常。</p>
<p>需要在xml配置文件中加载properties配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载properties文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">ignore-unresolvable</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">location</span>=<span class="string">&#x27;classpath:dbconfig.properties&#x27;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>spring加载properties文件的几种方式：<br><a href="https://blog.csdn.net/chuige2013/article/details/121759088">https://blog.csdn.net/chuige2013/article/details/121759088</a></p>
<p>✅ java.sql.SQLException: com.mysql.cj.jdbc.Driver</p>
<p>mysql连接驱动依赖的版本不匹配问题，一般出现在使用低版本连接驱动连接高版本mysql情况下，解决方法是在maven中央仓库中下载高版本的mysql连接驱动.</p>
<p>mysql-connector-java 换8.0.21的包，自动引入没成功，手动下载装到.m2的。</p>
<p>✅ init datasource error, url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8</p>
<p>db.url换成：<code>jdbc:mysql://localhost:3306/mysql?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</code></p>
<p>✅ Table ‘mysql.student’ doesn’t exist</p>
<p>上面mysql换成库名。</p>
<p>😄终于成功了，不容易。</p>
<h2 id="com-github-pagehelper"><a href="#com-github-pagehelper" class="headerlink" title="com.github.pagehelper"></a>com.github.pagehelper</h2><p>背景：使用Pige时，从数据库中获取到list之后，removeIf筛选，但是分页得到的效果不对，条目总数total是从数据库得到的list size。</p>
<p>原因：Page与Mybatis强耦合，不是先从数据库获取再分页，而是先获取某页要获取的条目，耦合到sql中查询。</p>
<p>难道只能是spring-boot用的？ pagehelper-spring-boot-starter 依赖包中。</p>
<p>PageHelper分页：<a href="https://blog.csdn.net/weixin_43958747/article/details/103822761">https://blog.csdn.net/weixin_43958747/article/details/103822761</a></p>
<p>其中有个参数为CallBack接口。</p>
<p>⚠️使用中的一个case：<br>Pageed中的list的元素得和数据库dao返回的数据结构一样，得是DO。获取了Paged之后再转为vo，因为分页Page和mybatis是强耦合的。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mac安装和配置java环境</title>
    <url>/2021/08/25/myblog/java/MAC%E4%B8%8B%E5%AE%89%E8%A3%85java%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="MAC下java环境安装"><a href="#MAC下java环境安装" class="headerlink" title="MAC下java环境安装"></a>MAC下java环境安装</h1><h2 id="1-下载jdk8并且安装"><a href="#1-下载jdk8并且安装" class="headerlink" title="1.下载jdk8并且安装"></a>1.下载jdk8并且安装</h2><p><code>java -version</code>看一下有没有安装</p>
<p>若没有，<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<h2 id="2-配置java环境"><a href="#2-配置java环境" class="headerlink" title="2.配置java环境"></a>2.配置java环境</h2><p>我们如果要在terminal终端上使JAVA命令，还有让其实应用知道JDK1.8环境的存在，那我们还需要配置系统的环境变量。</p>
<p>访达中，打开资源库，打开java，下面有jdk目录。</p>
<p><code>/Library/Java/JavaVirtualMachines/jdk1.8.0_192.jdk/Contents/Home</code>  右键打开终端</p>
<p>终端运行：<code>sudo vim/etc/profile</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_192.jdk/Contents/Home&quot;</span><br><span class="line">export JAVA_HOME</span><br><span class="line">CLASS_PATH=&quot;$JAVA_HOME/lib&quot;</span><br><span class="line">PATH=&quot;.$PATH:$JAVA_HOME/bin&quot;</span><br></pre></td></tr></table></figure>

<p><code>source /etc/profile  //使配置生效</code></p>
<p><code>echo $JAVA_HOME //得到配置的路径，说明配置成功</code></p>
<h2 id="3-vim一个java程序"><a href="#3-vim一个java程序" class="headerlink" title="3.vim一个java程序"></a>3.vim一个java程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件名需要跟java文件中的类名一致！</span><br><span class="line">public class helloworld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">javac helloworld.java   //生成.class字节码文件</span><br><span class="line">java helloworld    //运行</span><br></pre></td></tr></table></figure>

<h3 id="4-java-IDE"><a href="#4-java-IDE" class="headerlink" title="4.java IDE"></a>4.java IDE</h3><p>官网下载：<a href="https://www.jetbrains.com/">https://www.jetbrains.com/</a></p>
<p>下载破解包，保存在百度云中了。</p>
<p>安装IDEA，在注册页面，选择 Evaluate for free，点击 Evaluate 试用软件</p>
<p>将下载的破解文件夹中的 jetbrains-agent.jar 文件拖动到软件内，然后点击 Restart 重启软件</p>
<p>重启完成之后，如果弹出了激活方式，选择 Activation code，没有弹出则不用管，复制破解文件中的 Activation code，然后选择激活，重启软件</p>
<p>重启软件，在 Get Help 中点击 About ，可以查看激活情况</p>
<p><strong>不得行</strong></p>
<p>更新：<a href="https://www.jianshu.com/p/bbc7cd207a85">https://www.jianshu.com/p/bbc7cd207a85</a></p>
<h3 id="5-用idea的第一个java程序"><a href="#5-用idea的第一个java程序" class="headerlink" title="5.用idea的第一个java程序"></a>5.用idea的第一个java程序</h3><p>![image-20210823173916506](&#x2F;Users&#x2F;liuxuan14&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210823173916506.png)</p>
<p>右键运行。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java的junit与mock测试</title>
    <url>/2022/04/14/myblog/java/java%20junit%E4%B8%8Emock%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>单元测试(Unit test)：<br>单元测试关注单一的类. 它们存在的目的是检查这个类中的代码是否按照期望正确运行.<br>特征：快速、独立、可重复、自检查（不加main不打日志）<br>核心价值：缩短反馈周期，降低缺陷修复成本，理解代码意图</p>
<p>集成测试(Integration test)<br>顾名思义, 集成测试是检查开发的模块和其他模块整合时是否正常工作.<br>虽然集成测试的代码影响范围比单元测试要广, 但是集成测试和单元测试一样, 也是针对于开发者而言的.<br>集成测试是对外部系统（数据库、消息队列等）有依赖的测试。</p>
<p>端到端测试(End-to-End test)<br>端到端测试是将整个系统作为一个整体, 然后从用户的角度进行测试的.<br>端到端测试的目的是测试系统在实际使用的是否正常的, 因此通常来说是不需要测试替身的(Test Double)</p>
<h2 id="1-Junit单元测试"><a href="#1-Junit单元测试" class="headerlink" title="1.Junit单元测试"></a>1.Junit单元测试</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>单元测试的目的: 测试当前所写的代码是否是正确的, 例如输入一组数据, 会输出期望的数据; 输入错误数据, 会产生错误异常等.</p>
<p>在单元测试中, 我们需要保证被测系统是独立的(SUT 没有任何的 DOC), 即当被测系统通过测试时, 那么它在任何环境下都是能够正常工作的. 编写单元测试时, 仅仅需要关注单个类就可以了. 而不需要关注例如数据库服务, Web 服务等组件.</p>
<p>【SUT】被测系统(System under test, SUT) 被测系统。根据测试类型的不同, SUT 指代的内容也不同, 例如 SUT 可以是一个类甚至是一整个系统.</p>
<p>【DOC】被测系统所依赖的组件, 例如进程 UserService 的单元测试时, UserService 会依赖 UserDao, 因此 UserDao 就是 DOC</p>
<p>【Test Double】测试替身<br>一个实际的系统会依赖多个外部对象, 但是在进行单元测试时, 我们会用一些功能较为简单的并且其行为和实际对象类似的假对象来作为 SUT 的依赖对象, 以此来降低单元测试的复杂性和可实现性. 在这里, 这些假对象就被称为 测试替身(Test Double).</p>
<p>测试替身有以下五种：</p>
<p>1.Test stub, 为 SUT 提供数据的假对象。stub 类有时候还会记录调用的一些信息。</p>
<p>2.Fake object，实现了简单功能的一个假对象. Fake object 和 Test stub 的主要区别就是 Test stub 侧重于用于提供数据的假对象, 而 Fake object 没有这层含义，使用 Fake object 的最主要的原因就是在测试时某些组件不可用或运行速度太慢, 因而使用 Fake object 来代替它们.<br>譬如说，它存在内存中而不是真正的数据库中。</p>
<p>3.Mock object<br>是指类或者接口的模拟实现，你可以自定义这个对象中某个方法的输出结果。<br>实际上, Mock object 是 Test stub 或 Fake object 一种, 但是 Mock object 有 Test stub&#x2F;Fake object 没有的特性, Mock object 可以很灵活地配置所调用的方法所产生的行为, 并且它可以追踪方法调用, 例如一个 Mock Object 方法调用时传递了哪些参数, 方法调用了几次等.</p>
<p>4.Dummy object: 在测试中并不使用的, 但是为了测试代码能够正常编译&#x2F;运行而添加的对象. 例如我们调用一个 Test Double 对象的一个方法, 这个方法需要传递几个参数, 但是其中某个参数无论是什么值都不会影响测试的结果, 那么这个参数就是一个 Dummy object.<br>Dummy object 可以是一个空引用, 一个空对象或者是一个常量等.<br>简单的说, Dummy object 就是那些没有使用到的, 仅仅是为了填充参数列表的对象.</p>
<p>5.Test Spy<br>可以包装一个真实的 Java 对象, 并返回一个包装后的新对象. 若没有特别配置的话, 对这个新对象的所有方法调用, 都会委派给实际的 Java 对象.</p>
<p>mock 和 spy 的区别是: mock 是无中生有地生出一个<strong>完全虚拟的对象</strong>, 它的所有方法都是虚拟的; 而 spy 是在现有类的基础上包装了一个对象, 即如果我们没有重写 spy 的方法, 那么这些方法的实现其实都是调用的被包装的对象的方法.</p>
<p>【test fixture】测试的先决条件，<br>@Before 在每个测试方法运行前都会被调用, @After 在每个测试方法运行后都会被调用.<br>因为 @Before 和 @After 会在每个测试方法前后都会被调用, 而有时我们仅仅需要在测试前进行一次初始化, 这样的情况下, 可以使用@BeforeClass 和@AfterClass 注解.</p>
<p>【test case】测试用例<br>在 JUnit 3中, 测试方法都必须以 test 为前缀, 且必须是 public void 的, JUnit 4之后, 就没有这个限制了, 只要在每个测试方法标注 @Test 注解, 方法签名可以是任意的.</p>
<p>【测试套件】通过 TestSuit 对象将多个测试用例组装成一个测试套件, 测试套件批量运行.<br>通过@RunWith 和@SuteClass 两个注解, 我们可以创建一个测试套件. 通过@RunWith 指定一个特殊的运行器, 并通过@SuiteClasses 注解, 将需要进行测试的类列表作为参数传入.</p>
<h3 id="Junit4注解"><a href="#Junit4注解" class="headerlink" title="Junit4注解"></a>Junit4注解</h3><p>@Test (expected &#x3D; Exception.class) 表示预期会抛出Exception.class 的异常</p>
<p>@Ignore 含义是“某些方法尚未完成，暂不参与此次测试”。这样的话测试结果就会提示你有几个测试被忽略，而不是失败。一旦你完成了相应函数，只需要把@Ignore注解删去，就可以进行正常的测试。</p>
<p>@Test(timeout&#x3D;100) 表示预期方法执行不会超过 100 毫秒，控制死循环</p>
<p>@Before 表示该方法在每一个测试方法之前运行，可以使用该方法进行初始化之类的操作</p>
<p>@After 表示该方法在每一个测试方法之后运行，可以使用该方法进行释放资源，回收内存之类的操</p>
<p>@BeforeClass 表示该方法只执行一次，并且在所有方法之前执行。一般可以使用该方法进行数据库连接操作，注意该注解运用在静态方法。</p>
<p>@AfterClass 表示该方法只执行一次，并且在所有方法之后执行。一般可以使用该方法进行数据库连接关闭操作，注意该注解运用在静态方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.junit.runner.RunWith;  </span><br><span class="line">import org.junit.runners.Suite;  </span><br><span class="line">import org.junit.runners.Suite.SuiteClasses;  </span><br><span class="line">  </span><br><span class="line">@RunWith( Suite.class )  </span><br><span class="line">@SuiteClasses( &#123; JUnitTest1.class, JUnitTest2.class &#125; )  </span><br><span class="line">public class AllTests &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有多个测试类, 可以合并成一个测试套件进行测试, 运行一个 Test Suite, 那么就会运行在这个 Test Suite 中的所用的测试.<br>在这个例子中, 我们定义了一个 Test Suite, 这个 Test Suite 包含了两个测试类: JUnitTest1 和 JUnitTest2, 因此运行 这个 Test Suite 时, 就会自动运行这两个测试类了.</p>
<p>*在类名上按下command+shift+t，就可以生成对应测试类。</p>
<p>来源：<a href="https://segmentfault.com/a/1190000006731125">https://segmentfault.com/a/1190000006731125</a></p>
<h2 id="2-Mockito中-Mock与-InjectMock"><a href="#2-Mockito中-Mock与-InjectMock" class="headerlink" title="2.Mockito中@Mock与@InjectMock"></a>2.Mockito中@Mock与@InjectMock</h2><p>Mockito 是一个流行 mock 框架，可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象。<br>Mockito是java单元测试中，最常用的mck工具之一，提供了诸多打桩方法和注解。其中有两个比较常用的注解，@Mock和@InjectMock，名字和在代码中使用 的位置都很像。但是是在功能上无任何可类比性的完全不同的东西。<br>程序员通常创造模拟对象来测试其他对象的行为，很类似汽车设计者使用碰撞测试假人来模拟车辆碰撞中人的动态行为。</p>
<p>为什么使用mock？<br>在单元测试中，模拟对象可以模拟复杂的、真实的（非模拟）对象的行为， 如果真实的对象无法放入单元测试中，使用模拟对象就很有帮助。</p>
<p>单元测试的思路是在不涉及依赖关系的情况下测试代码（隔离性），所以测试代码与其他类或者系统的关系应该尽量被消除。一个可行的消除方法是替换掉依赖类（测试替换），也就是说我们可以使用替身来替换掉真正的依赖对象。</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>@Mock：<br>在Mockito中用于创建mock对象，使用方法如下：<br><code>@Mock</code><br><code>private ClassName mockedObject；</code></p>
<p>上面代码创建了一个名为mockedObject，类型为ClassName的mock对象，该对象所有的方法被置空，根据测试代码逻辑的需要使用.</p>
<hr>
<p>@InjectMock：<br>创建一个实例，简单的说是这个Mock可以调用真实代码的方法，其余用@Mock（或@Spy）注解创建的mock将被注入到用该实例中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(MockitoJUnitRunner.class)  </span><br><span class="line">public class Test &#123;  </span><br><span class="line">  </span><br><span class="line">    @InjectMocks  </span><br><span class="line">    private SomeHandler someHandler;  </span><br><span class="line">  </span><br><span class="line">    @Mock  </span><br><span class="line">    private OneDependency oneDependency; // 此mock将被注入到someHandler  </span><br><span class="line"></span><br><span class="line">    // ...   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这段代码中，@InjectMock下面声明了一个待测试的对象，@Mock定义的mock对象将会被注入到这个待测试的对象中。</p>
<hr>
<p>🤔 @Mock创建创建mock对象之后，在对具体的方法打桩之前，mock对象的所有属性和方法全被置空（0或者null），所以，对应的方法是不运行的。<br>*mock对象创建之后，被测试类中的该对象的方法就都不执行了。</p>
<p>🤔 @Spy可以创建的对象的所有成员方法都会按照原方法的逻辑执行，直到被打桩返回某个具体的值。</p>
<p>来源：<a href="https://www.cnblogs.com/langren1992/p/9681600.html">https://www.cnblogs.com/langren1992/p/9681600.html</a></p>
<h3 id="mock使用"><a href="#mock使用" class="headerlink" title="mock使用"></a>mock使用</h3><p>maven注入依赖。</p>
<p>如果你使用注解，那么必须要实例化 mock 对象。Mockito 在遇到使用注解的字段的时候必须使用@RunWith(MockitoJUnitRunner.class) 或 MockitoAnnotations.initMocks(this)进行mocks的初始化和注入。<br>(可以写一个init函数，加@Before注解)</p>
<h4 id="配置mock"><a href="#配置mock" class="headerlink" title="配置mock"></a>配置mock</h4><p>when(…​.).thenReturn(…​.)可以被用来定义当条件满足时函数的返回值，当多次调用函数的时候，Mockito 会根据你定义的先后顺序来返回返回值（多次调用）。Mocks 还可以根据传入参数的不同来定义不同的返回值。譬如说你的函数可以将anyString 或者 anyInt作为输入参数，然后定义其特定的放回值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import static org.mockito.Mockito.*;</span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test1()  &#123;</span><br><span class="line">        //  创建 mock</span><br><span class="line">        MyClass test = Mockito.mock(MyClass.class);</span><br><span class="line"></span><br><span class="line">        // 自定义 getUniqueId() 的返回值</span><br><span class="line">        when(test.getUniqueId(Mockito.anyLong())).thenReturn(43);</span><br><span class="line"></span><br><span class="line">        // 在测试中使用mock对象</span><br><span class="line">        assertEquals(test.getUniqueId(), 43);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回多个值</span><br><span class="line">@Test</span><br><span class="line">public void testMoreThanOneReturnValue()  &#123;</span><br><span class="line">        Iterator i= mock(Iterator.class);</span><br><span class="line">        when(i.next()).thenReturn(&quot;Mockito&quot;).thenReturn(&quot;rocks&quot;);</span><br><span class="line">        String result=i.next()+&quot; &quot;+i.next();</span><br><span class="line">        // 断言</span><br><span class="line">        assertEquals(&quot;Mockito rocks&quot;, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如何根据输入来返回值</span><br><span class="line">@Test</span><br><span class="line">public void testReturnValueDependentOnMethodParameter()  &#123;</span><br><span class="line">        Comparable c= mock(Comparable.class);</span><br><span class="line">        when(c.compareTo(&quot;Mockito&quot;)).thenReturn(1);</span><br><span class="line">        when(c.compareTo(&quot;Eclipse&quot;)).thenReturn(2);</span><br><span class="line">        // 断言</span><br><span class="line">        assertEquals(1,c.compareTo(&quot;Mockito&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如何让返回值不依赖于输入</span><br><span class="line">@Test</span><br><span class="line">public void testReturnValueInDependentOnMethodParameter()  &#123;</span><br><span class="line">        Comparable c= mock(Comparable.class);</span><br><span class="line">        when(c.compareTo(anyInt())).thenReturn(-1);</span><br><span class="line">        // 断言</span><br><span class="line">        assertEquals(-1 ,c.compareTo(9));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据参数类型来返回值</span><br><span class="line">@Test</span><br><span class="line">public void testReturnValueInDependentOnMethodParameter()  &#123;</span><br><span class="line">        Comparable c= mock(Comparable.class);</span><br><span class="line">        when(c.compareTo(isA(Todo.class))).thenReturn(0);</span><br><span class="line">        // 断言</span><br><span class="line">        Todo todo = new Todo(5);</span><br><span class="line">        assertEquals(todo ,c.compareTo(new Todo(1)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="无返回值的方法"><a href="#无返回值的方法" class="headerlink" title="无返回值的方法"></a>无返回值的方法</h4><p>mokito中，对无返回的函数什么都不做<br>Mokito.doNothing().when(对象).函数();</p>
<p>对于无返回值的函数，我们可以使用doReturn(…​).when(…​).methodCall来获得类似的效果。例如我们想在调用某些无返回值函数的时候抛出异常，那么可以使用doThrow 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import static org.mockito.Mockito.*;</span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line">// 下面测试用例描述了如何使用doThrow()方法</span><br><span class="line"></span><br><span class="line">@Test(expected=IOException.class)</span><br><span class="line">public void testForIOException() &#123;</span><br><span class="line">        // 创建并配置 mock 对象</span><br><span class="line">        OutputStream mockStream = mock(OutputStream.class);</span><br><span class="line">        doThrow(new IOException()).when(mockStream).close();</span><br><span class="line"></span><br><span class="line">        // 使用 mock</span><br><span class="line">        OutputStreamWriter streamWriter= new OutputStreamWriter(mockStream);</span><br><span class="line">        streamWriter.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="验证是否调用"><a href="#验证是否调用" class="headerlink" title="验证是否调用"></a>验证是否调用</h4><p>验证 query 方法是否被 MyDatabase 的 mock 对象调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import static org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line">public class MockitoTest  &#123;</span><br><span class="line"></span><br><span class="line">        @Mock</span><br><span class="line">        MyDatabase databaseMock; (1)</span><br><span class="line"></span><br><span class="line">        @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); (2)</span><br><span class="line"></span><br><span class="line">        @Test</span><br><span class="line">        public void testQuery()  &#123;</span><br><span class="line">                ClassToTest t  = new ClassToTest(databaseMock); (3)</span><br><span class="line">                boolean check = t.query(&quot;* from t&quot;); (4)</span><br><span class="line">                assertTrue(check); (5)</span><br><span class="line">                verify(databaseMock).query(&quot;* from t&quot;); (6)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mockito 会跟踪 mock 对象里面所有的方法和变量。所以我们可以用来验证函数在传入特定参数的时候是否被调用。这种方式的测试称行为测试，行为测试并不会检查函数的返回值，而是检查在传入正确参数时候函数是否被调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import static org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testVerify()  &#123;</span><br><span class="line">        // 创建并配置 mock 对象</span><br><span class="line">        MyClass test = Mockito.mock(MyClass.class);</span><br><span class="line">        when(test.getUniqueId()).thenReturn(43);</span><br><span class="line"></span><br><span class="line">        // 调用mock对象里面的方法并传入参数为12</span><br><span class="line">        test.testing(12);</span><br><span class="line">        test.getUniqueId();</span><br><span class="line">        test.getUniqueId();</span><br><span class="line"></span><br><span class="line">        // 查看在传入参数为12的时候方法是否被调用</span><br><span class="line">        verify(test).testing(Matchers.eq(12));</span><br><span class="line"></span><br><span class="line">        // 方法是否被调用两次</span><br><span class="line">        verify(test, times(2)).getUniqueId();</span><br><span class="line"></span><br><span class="line">        // 其他用来验证函数是否被调用的方法</span><br><span class="line">        verify(mock, never()).someMethod(&quot;never called&quot;);</span><br><span class="line">        verify(mock, atLeastOnce()).someMethod(&quot;called at least once&quot;);</span><br><span class="line">        verify(mock, atLeast(2)).someMethod(&quot;called at least twice&quot;);</span><br><span class="line">        verify(mock, times(5)).someMethod(&quot;called five times&quot;);</span><br><span class="line">        verify(mock, atMost(3)).someMethod(&quot;called at most 3 times&quot;);</span><br><span class="line">&#125;</span><br><span class="line">前面都加个Mockito.</span><br></pre></td></tr></table></figure>

<h3 id="spy使用"><a href="#spy使用" class="headerlink" title="spy使用"></a>spy使用</h3><p>@Spy或者spy()方法可以被用来封装 java 对象。被封装后，除非特殊声明（打桩 stub），否则都会真正的调用对象里面的每一个方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import static org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line">// Lets mock a LinkedList</span><br><span class="line">List list = new LinkedList();</span><br><span class="line">List spy = spy(list);</span><br><span class="line"></span><br><span class="line">// 可用 doReturn() 来打桩</span><br><span class="line">doReturn(&quot;foo&quot;).when(spy).get(0);</span><br><span class="line"></span><br><span class="line">// 下面代码不生效</span><br><span class="line">// 真正的方法会被调用</span><br><span class="line">// 将会抛出 IndexOutOfBoundsException 的异常，因为 List 为空</span><br><span class="line">when(spy.get(0)).thenReturn(&quot;foo&quot;);</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.jianshu.com/p/f6e3ab9719b9">https://www.jianshu.com/p/f6e3ab9719b9</a><br><a href="https://www.jianshu.com/p/7b67806b74f6">https://www.jianshu.com/p/7b67806b74f6</a></p>
<h2 id="PowerMockRunner-和-MockitoJUnitRunner"><a href="#PowerMockRunner-和-MockitoJUnitRunner" class="headerlink" title="PowerMockRunner 和 MockitoJUnitRunner"></a>PowerMockRunner 和 MockitoJUnitRunner</h2><p>关于打桩：<br><a href="https://blog.csdn.net/moshowgame/article/details/100983711">https://blog.csdn.net/moshowgame/article/details/100983711</a></p>
<h2 id="when-thenReturn-和-doReturn-when-区别"><a href="#when-thenReturn-和-doReturn-when-区别" class="headerlink" title="when().thenReturn() 和 doReturn().when() 区别"></a>when().thenReturn() 和 doReturn().when() 区别</h2><p>使用@Mock时可以相互替换，但是@Spy时，它们的调用结果不同。<br>1.when().thenReturn() 会调用真实的方法，容易抛出异常<br>2.doReturn().when() 不会调用真实方法</p>
<h2 id="PowerMockito"><a href="#PowerMockito" class="headerlink" title="PowerMockito"></a>PowerMockito</h2><p>PowerMock扩展了EasyMock和Mockito框架，增加了对static和final方法mock支持等功能.<br>PowerMock有两个重要的注解：<br> @RunWith(PowerMockRunner.class)<br> @prepareForTest({MyObject.class})<br> @PrepareForTest注解和@RunWith注解是结合使用的，不要单独使用@PrepareForTest，否则不起作用。当使用PowerMock去mock静态，final或者私有方法时，需要加上这两个注解。<br>————————————————<br><a href="https://blog.csdn.net/KeeYang108/article/details/79891588">https://blog.csdn.net/KeeYang108/article/details/79891588</a></p>
<h2 id="Mock测试踩坑"><a href="#Mock测试踩坑" class="headerlink" title="Mock测试踩坑"></a>Mock测试踩坑</h2><p>今天写了一个control层的mock单元测试，因为要调service层（实现类）的方法，就把service接口做了一个mock，测试时候一直包空指针异常。<br>mock service实现类之后，正常。</p>
<p>更新：今天@Mock的接口也是可以的，奇怪了：<br>mock接口出现空指针异常的case：是service（.之前的）是实现类，@Autowired的也是实现类，所以mock接口没用？<br>而今天mock接口，被测试类中.之前的是接口，@Autowired的也是接口，所以没毛病。</p>
<p>加@RunWith(PowerMockRunner.class)<br>要测试的类加@InjectMocks</p>
<p>1.service实现类不加mock，到指定方法会报空指针异常，service对象为空<br>2.如果service方法无返回，可以不打桩，如果有返回，最好打个桩。<br>3.有返回的打了桩，可以根据不同的输入，返回不同的结果。有返回如果不打桩，相当于返回的是null，返回如果被后面用到，容易报空指针异常。</p>
<h2 id="Mock测试踩坑空指针异常"><a href="#Mock测试踩坑空指针异常" class="headerlink" title="Mock测试踩坑空指针异常"></a>Mock测试踩坑空指针异常</h2><p>mock测试的被测试类（@InjectMock）中的属性一般为null，所以什么都不加就在被测试类中调用属性对象的方法时，报空指针异常，因为属性对象是null。<br>将属性对象在Test中添加@Mock为mock对象，直接忽略属性对象方法，不进入执行。<br>将属性对象在Test中添加@Spy为spy对象，会进入该方法中，但是只限于一层，再进入就不行了，还是会报空指针异常。</p>
<hr>
<h2 id="单元测试框架和步骤"><a href="#单元测试框架和步骤" class="headerlink" title="单元测试框架和步骤"></a>单元测试框架和步骤</h2><p>Jnit：一个java语言的单元测试框架，编写和运行可重复的自动化测试。</p>
<p>Mockito：单元测试模拟框架，采用模拟技术，模拟应用中依赖的复杂对象，把测试对象和依赖对象隔离开。</p>
<p>PowerMock：在Mockito的基础上作出扩展。</p>
<p>单元测试步骤：定义对象 - 模拟方法 - 调用方法 - 验证方法 （第二步和第四步是有外部依赖时需要mock使用的）</p>
<p>1、定义测试对象（new&#x2F;Mockito.spy&#x2F;@Spy&#x2F;@InjectMocks）<br>2、模拟依赖对象（直接构建对象&#x2F;Json反序列化对象&#x2F;@Mock&#x2F;@Spy）<br>3、注入依赖对象（set&#x2F;Whitebox&#x2F;@Mock）<br>4、模拟依赖方法<br>5、调用被测方法（分为构造方法、普通方法、静态方法）（都分为有权限和无权限）（有权限直接调用，无权限用：<code>Whitebox.invokeMethod(userService, &quot;isUser&quot;, uid)</code>）<br>6、验证依赖方法（Mockito.verify(…)）（用ArgumentCaptor&#x2F;@Captor捕获参数）<br>7、验证数据对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//验证对象为空</span><br><span class="line">Assert.assertNull(&quot;必须为空！&quot;, uid);</span><br><span class="line">//验证对象非空</span><br><span class="line">Assert.assertNotNull(&quot;不能为空！&quot;, uid);</span><br><span class="line">//验证为真</span><br><span class="line">Assert.assertTrue(&quot;返回必须为真&quot;, isSuper);</span><br><span class="line">//验证为假</span><br><span class="line">Assert.assertFalse(&quot;返回必须为假&quot;, isSuper);</span><br><span class="line">//验证数据对象是否一致</span><br><span class="line">Assert.assertSame(&quot;用户必须一致&quot;, exceptId, uid);</span><br><span class="line">//验证数据对象是否一致</span><br><span class="line">Assert.assertNotSame(&quot;用户不能一致&quot;, exceptId, uid);</span><br><span class="line">//验证简单数据对象</span><br><span class="line">Assert.assertNotEquals(&quot;用户名称不一致&quot;, &quot;admin&quot;, user)</span><br><span class="line">//验证简单数组或集合对象</span><br><span class="line">Assert.assertArrayEquals</span><br><span class="line">//对于复杂数据，可以先序列化为json字符串，然后Assert.assertEquals</span><br></pre></td></tr></table></figure>
<p>验证跑出异常：可以用@Test(expected&#x3D;ExampleException.class)，但是一旦内部方法抛出异常，整个方法就返回，后面的验证没法执行。@Rule注解实现。推荐使用Assert</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExampleException e = Assert.assertThrows(&quot;异常类型不一致&quot;, ExampleException.class, ()-&gt;userService.getUser(uid));</span><br><span class="line">Assert.assertEquals(&quot;异常消息不一致&quot;, exceptString, e.getMessage());</span><br></pre></td></tr></table></figure>
<p>8、验证依赖对象（一般不用）<br><code>Mockito.verifyNotInteractions</code></p>
<p>✅Mockito的any相关的参数匹配方法不支持可空参数和空参数，应该用nullable方法。<br>✅采用Mockito的参数匹配方法时，其他参数不能直接用常量或变量，应该用Mockito的eq方法。</p>
<h2 id="Mock静态方法"><a href="#Mock静态方法" class="headerlink" title="Mock静态方法"></a>Mock静态方法</h2><p>通过PowerMockito.mockStatic() 对静态方法进行mock。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.powermock&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;powermock-api-mockito2&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.powermock&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import org.junit.jupiter.api.Assertions;</span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.powermock.api.mockito.PowerMockito;</span><br><span class="line">import org.powermock.core.classloader.annotations.PowerMockIgnore;</span><br><span class="line">import org.powermock.core.classloader.annotations.PrepareForTest;</span><br><span class="line">import org.powermock.modules.junit4.PowerMockRunner;</span><br><span class="line"> </span><br><span class="line">@RunWith(PowerMockRunner.class)</span><br><span class="line">@PrepareForTest(StringUtils.class)  //多个静态方法的话&#123;1,2&#125;</span><br><span class="line">//@PowerMockIgnore(&quot;javax.crypto.*&quot;)</span><br><span class="line">public class MyTest &#123;</span><br><span class="line"> </span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        //模拟依赖方法</span><br><span class="line">        PowerMockito.mockStatic(StringUtils.class);</span><br><span class="line">        PowerMockito.when(StringUtils.isEmpty(&quot;empty&quot;)).thenReturn(true);</span><br><span class="line">        Assertions.assertTrue(StringUtils.isEmpty(&quot;empty&quot;));</span><br><span class="line">        //验证依赖方法被调用</span><br><span class="line">        PowerMockito.verifyStatic(StringUtils.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/q2878948/article/details/124862699">https://blog.csdn.net/q2878948/article/details/124862699</a><br><a href="https://blog.csdn.net/qq_34497300/article/details/119774225">https://blog.csdn.net/qq_34497300/article/details/119774225</a></p>
<h2 id="Mock私有方法"><a href="#Mock私有方法" class="headerlink" title="Mock私有方法"></a>Mock私有方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先@RunWith(PowerMockRunner.class)</span><br><span class="line">把私有方法所在类放在@PrepareForTest()中</span><br><span class="line">//模拟私有依赖方法</span><br><span class="line">PowerMockito.doReturn(true).when(MyService.class, &quot;myFunc&quot;, myParam);</span><br><span class="line">PowerMockito.when(MyService.class, &quot;myFunc&quot;, myParam).thenReturn(true);</span><br><span class="line">//验证私有方法调用</span><br><span class="line">PowerMockito.verifyPrivate(myClass, times(1)).invoke(&quot;myfunc&quot;, any(List.class))</span><br></pre></td></tr></table></figure>

<p>⚠️想mock被验证类(@InjectMock)的私有方法是不行的。只能mock注入类的私有方法。</p>
<h2 id="Mock被测试类的其他public方法"><a href="#Mock被测试类的其他public方法" class="headerlink" title="Mock被测试类的其他public方法"></a>Mock被测试类的其他public方法</h2><p>直接用Mockito.when是不行，会报空指针。</p>
<p>还没搞出来。</p>
<p>Java中使用PowerMockito mock static方法&#x2F;new对象&#x2F;mock对象的public或private方法的简单示例：<br><a href="https://www.cnblogs.com/epic358/p/16559549.html">https://www.cnblogs.com/epic358/p/16559549.html</a></p>
<h2 id="Mock测试修改方法的入参"><a href="#Mock测试修改方法的入参" class="headerlink" title="Mock测试修改方法的入参"></a>Mock测试修改方法的入参</h2><p>如果方法有返回值，直接使用Mockito.when().thenReturn()的方式Mock即可，但是对于没有返回值的方法，但是在方法内部却对方法的入参做了一些逻辑的方法，就不能再用这种方式，应该用另外一个Mock方法，即doNothing。</p>
<p>Mock的时候，首先匹配参数，然后在ArgumentMatcher中修改参数即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// mock方式修改方法入参</span><br><span class="line">doNothing().when(userService).service(any(), argThat(new ArgumentMatcher&lt;UserResponse&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(UserResponse response) &#123;</span><br><span class="line">        ImportInfo importInfo = new ImportInfo();</span><br><span class="line">        importInfo.setStatus(&quot;APPROVING&quot;);</span><br><span class="line">        // 修改入参的属性</span><br><span class="line">        response.setImportInfo(importInfo);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br><span class="line">Request request = new Request();</span><br><span class="line">Response response = new Response();</span><br><span class="line">// 这个是我们要验证的主方法</span><br><span class="line">handler.handle(request, response);</span><br></pre></td></tr></table></figure>

<p><a href="https://www.wxxblog.com/article/5">https://www.wxxblog.com/article/5</a></p>
<h2 id="单元测试风格"><a href="#单元测试风格" class="headerlink" title="单元测试风格"></a>单元测试风格</h2><p>单元测试的意义在于验证业务代码，高覆盖率+可读性 &#x3D; 高价值。高覆盖率包括对代码的覆盖，也包括对测试用例的覆盖。</p>
<p>一个方法要测试多种测试场景的话，就写多个mock方法，一个单侧方法只针对一个行为。但是看，有些公共的mock打桩可以提取出来，写成一个公共的私有方法，或者写一个init方法，用@Before注解修饰，在运行测试方法时就提前打桩。</p>
<p>推荐的风格：<br>1.一个测试方法仅调用一次被测方法<br>2.至少一个正例的测试用例<br>3，提取公共的mock插桩<br>4.异常流的测试中，只引入一种异常的mock重写<br>5.加注释：测试什么场景，期望什么结果</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、Mockito.anyString 什么的，不能和实际的参数一起作为一个方法的输入。<br>会报错：InvalidUseOfMatchersException。</p>
<p>2、接口的单元测试类，一般是一个实现类就一个单元测试类。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java web相关</title>
    <url>/2022/09/11/myblog/java/java%20web%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="网页502"><a href="#网页502" class="headerlink" title="网页502"></a>网页502</h2><p>502 Bad Gateway是指错误网关，无效网关；在互联网中表示一种网络错误。表现在WEB浏览器中给出的页面反馈。</p>
<p>服务端代码下掉，重新部署的间隙，访问接口会502.</p>
<h2 id="504错误"><a href="#504错误" class="headerlink" title="504错误"></a>504错误</h2><p>504错误代表网关超时 （Gateway timeout），是指服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p>
<p>接口504超时，是服务端这边超时断开请求了，需要看一下nginx配置。如果是tomcat，看一下conf中配置的请求超时时间。</p>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><h3 id="✅nginx是什么？"><a href="#✅nginx是什么？" class="headerlink" title="✅nginx是什么？"></a>✅nginx是什么？</h3><blockquote>
<p>Nginx是十分轻量级的HTTP服务器。Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP&#x2F;POP3&#x2F;SMTP 代理服务器。</p>
<p>Ngnix 是互联网企业使用最为广泛的代理服务器。它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务。</p>
<p>Nginx是lgor Sysoev为俄罗斯访问量第二的rambler.ru站点设计开发的。从2004年发布至今，凭借开源的力量，已经接近成熟与完善。<br>Nginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。<br>Nginx的稳定性、功能集、示例配置文件和低系统资源的消耗让他后来居上，在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。</p>
</blockquote>
<p>nginx是服务器，代理服务器，负载均衡，反向代理，服务器架构。</p>
<p>Nginx凭借其稳定性、低资源消耗、简单配置和丰富的功能，从十多年前名不见经传的Web服务器软件，发展到如今能够跟Apache匹敌的地位。</p>
<p>1、作为Web服务器，Nginx处理静态文件、索引文件，自动索引的效率非常高</p>
<p>2、作为代理服务器，Nginx可以实现无缓存的反向代理加速，提高网站运行速度</p>
<p>3、作为负载均衡服务器，Nginx既可以在内部直接支持Rails和PHP，也可以支持HTTP代理服务器对外进行服务，同时还支持简单的容错和利用算法进行负载均衡</p>
<p>4、在性能方面，Nginx是专门为性能优化而开发的，实现上非常注重效率。它采用内核Poll模型，可以支持更多的并发连接，最大可以支持对5万个并发连接数的响应，而且只占用很低的内存资源</p>
<p>5、在稳定性方面，Nginx采取了分阶段资源分配技术，使得CPU与内存的占用率非常低。Nginx官方表示，Nginx保持1万个没有活动的连接，而这些连接只占用2.5MB内存，因此，类似DOS这样的攻击对Nginx来说基本上是没有任何作用的</p>
<p>6、在高可用性方面，Nginx支持热部署，启动速度特别迅速，因此可以在不间断服务的情况下，对软件版本或者配置进行升级，即使运行数月也无需重新启动，几乎可以做到7x24小时不间断地运行<br>————————————————<br>解读nginx：<br>原文链接：<a href="https://blog.csdn.net/weixin_60274825/article/details/122101640">https://blog.csdn.net/weixin_60274825/article/details/122101640</a></p>
<h3 id="✅什么是代理服务器？"><a href="#✅什么是代理服务器？" class="headerlink" title="✅什么是代理服务器？"></a>✅什么是代理服务器？</h3><p>代理服务器是介于客户端和Web服务器之间的另一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页，而是通过向代理服务器发送请求，信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。</p>
<p><img src="/images/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8.png"></p>
<p>代理位于Web客户端和Web服务器之间，扮演“中间人”的角色。<br>HTTP的代理服务器既是Web服务器又是Web客户端。</p>
<h3 id="✅什么是正反向代理"><a href="#✅什么是正反向代理" class="headerlink" title="✅什么是正反向代理"></a>✅什么是正反向代理</h3><p>正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取的内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端，客户端必须要进行一些特别的设置才能使用正向代理。</p>
<p>正向代理代理的对象是客户端，正向代理中，proxy和client同属一个LAN，对server透明 （客户端服务端多对一？）</p>
<p>反向代理服务器：在服务器端接收客户端的请求，然后把请求分发给具体的服务器进行处理，然后再将服务器的响应结果反馈给客户端。Nginx就是其中的一种反向代理服务器软件。</p>
<p>反向代理代理的对象是服务端，反向代理中，proxy和server同属一个LAN，对client透明  （客户端服务端多对多）</p>
<p>正向代理客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。<br>反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间中的内容发送普通请求，接着反向代理将判断向哪个原始服务器转交请求，并将获得的内容返回给客户端。<br>————————————————<br>解读nginx：<br>原文链接：<a href="https://blog.csdn.net/weixin_60274825/article/details/122101640">https://blog.csdn.net/weixin_60274825/article/details/122101640</a></p>
<h3 id="✅nginx与tomcat什么关系"><a href="#✅nginx与tomcat什么关系" class="headerlink" title="✅nginx与tomcat什么关系"></a>✅nginx与tomcat什么关系</h3><p>nginx是上面做web代理服务器的，而tomcat是上面做真正web服务器的。</p>
<p>nginx常用做静态内容服务和代理服务器，直面外来请求转发给后面的应用服务（tomcat，django什么的），tomcat更多用来做做一个应用容器，让java web app跑在里面的东西，对应同级别的有jboss,jetty等东西。</p>
<p>但是事无绝对，nginx也可以通过模块开发来提供应用功能，tomcat也可以直接提供http服务，通常用在内网和不需要流控等小型服务的场景。</p>
<p>严格的来说，Apache&#x2F;Nginx 应该叫做「HTTP Server」；而 Tomcat 则是一个「Application Server」，或者更准确的来说，是一个「Servlet&#x2F;JSP」应用的容器（Ruby&#x2F;Python 等其他语言开发的应用也无法直接运行在 Tomcat 上）。</p>
<p>一个 HTTP Server 关心的是 HTTP 协议层面的传输和访问控制，所以在 Apache&#x2F;Nginx 上你可以看到代理、负载均衡等功能。客户端通过 HTTP Server 访问服务器上存储的资源（HTML 文件、图片文件等等）。通过 CGI 技术，也可以将处理过的内容通过 HTTP Server 分发，但是一个 HTTP Server 始终只是把服务器上的文件如实的通过 HTTP 协议传输给客户端。</p>
<p>而应用服务器，则是一个应用执行的容器。它首先需要支持开发语言的 Runtime（对于 Tomcat 来说，就是 Java），保证应用能够在应用服务器上正常运行。其次，需要支持应用相关的规范，例如类库、安全方面的特性。对于 Tomcat 来说，就是需要提供 JSP&#x2F;Sevlet 运行需要的标准类库、Interface 等。为了方便，应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/weixin_44517990/article/details/100712182">https://blog.csdn.net/weixin_44517990/article/details/100712182</a></p>
<h3 id="✅-springboot内置tomcat-和-tomcat"><a href="#✅-springboot内置tomcat-和-tomcat" class="headerlink" title="✅ springboot内置tomcat 和 tomcat"></a>✅ springboot内置tomcat 和 tomcat</h3><p>1.内置的tomcat没有tomcat的主页页面<a href="http://localhost:9999/%EF%BC%8C%E8%80%8C%E6%88%91%E4%BB%AC%E5%B9%B3%E6%97%B6%E7%94%A8%E7%9A%84%E5%A4%96%E7%BD%AE%E7%9A%84tomcat%E6%98%AF%E6%9C%89%E7%9A%84">http://localhost:9999/，而我们平时用的外置的tomcat是有的</a></p>
<p>2.内置的tomcat可以用main跑项目，而如果要用外置的tomcat就需要把项目打成war包，然后拷贝到webapp下进行运行</p>
<p>Tomcat：<br>Tomcat是一个Web应用服务器，也是Servlet容器。它的作用是，解析客户端client发起的request，并组装出HttpRequest、创建HttpResponse，将二者交于内部的HttpServlet处理和填充</p>
<p>Tomcat映射处理请求的Servlet是通过web.xml做的。</p>
<p>SpringMVC使用一个DispatcherServlet来接收所有的请求，并把它们分发到不同的controller中来做进一步处理。</p>
<p>SpringMVC &#x3D; Spring + Web框架，Spring这部分主要是AOP&#x2F;IOC容器。</p>
<p>SpringBoot是Spring的扩展，简化了Spring的配置，通过starter的方式简化了常用组件依赖的引入，使其更加易用。</p>
<p>SpringBoot内置了tomcat。</p>
<h3 id="✅tomcat和spring-mvc"><a href="#✅tomcat和spring-mvc" class="headerlink" title="✅tomcat和spring mvc"></a>✅tomcat和spring mvc</h3><p>tomcat既是Http服务器（不用代理的话，其实是应用服务器），Http服务器与Servlet容器的功能界限是：可以把HTTP服务器想象成前台的接待，负责网络通信和解析请求，Servlet容器是业务部门，负责处理业务请求。</p>
<p>Tomcat和Servlet作为Web服务器和Servlet容器的结合，可以接受网络http请求解析为Servlet规范的请求对象和响应对象。比如，HttpServletRequest对象是Tomcat提供的，Servlet是规范，Tomcat是实现规范的Servlet容器。tomcat监听了端口，请求过来后，根据url等信息，确定要将请求交给哪个servlet去处理;然后调用那个servlet的service方法，service方法返回一个response对象;<br>tomcat再把这个response返回给客户端。</p>
<p>SpringMVC是处理Servlet请求的应用，其中DispatcherServlet实现了Servlet接口，Tomcat负责加载和调用DispatcherServlet。同时，DispatcherServlet有自己的容器（SpringMVC）容器，这个容器负责管理SpringMVC相关的bean，比如Controler和ViewResolver等。同时，Spring中还有其他的Bean比如Service和DAO等，这些由全局的Spring IOC容器管理，因此，Spring有两个IOC容器。</p>
<p>如果只是使用spring(不包含springmvc)，那么是tomcat容器解析xml文件，通过反射实例化对应的类，根据这些servlet规范实现类，触发对应的代码处理逻辑，这个时候tomcat负责http报文的解析和servlet调度的工作。</p>
<p>如果使用spring mvc，那么tomcat只是解析http报文，然后将其转发给dispatchsetvlet，然后由springmvc根据其配置，实例对应的类，执行对应的逻辑，然后返回结果给dispatchservlet，最后由它转发给tomcat,由tomcat负责构建http报文数据。</p>
<p>DispatcherServlet：是Spring MVC中的一个类，实现了Servlet接口。所以部署在Tomcat中的Spring项目，对Tomcat来说，都是一个servlet。</p>
<p>————————————————<br>spring mvc还需要tomcat吗？<br>版权声明：本文为CSDN博主「黄泥川水猴子」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_40277163/article/details/124730530">https://blog.csdn.net/qq_40277163/article/details/124730530</a></p>
<h3 id="✅nginx与域名解析DNS什么关系"><a href="#✅nginx与域名解析DNS什么关系" class="headerlink" title="✅nginx与域名解析DNS什么关系"></a>✅nginx与域名解析DNS什么关系</h3><p>首先，nginx是web服务器和反向代理服务器。 dns是域名解析服务器。nginx不带dns。</p>
<p>作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。访问域名，dns帮忙解析到ip，然后访问这个地址的资源呈现给你。hosts和nginx在后面用到。</p>
<p>hosts文件：<br>hosts文件是个本地域名解析文件，不管你是windwos还是linux，那都是有的，他里面的有效内容，就是一个个的ip和域名映射关系。<br>windows一般在：C:&#x2F;Windows&#x2F;System32&#x2F;drivers&#x2F;etc&#x2F;hosts<br>Linux的hosts文件路径一般：&#x2F;etc&#x2F;hosts<br>比如：127.0.0.1 localhost<br>这个文件其实也是配置了ip和域名之间的映射关系的数据库，本地要是有这个文件，就优先用这个文件中的配置去解析，如果没有，那就通过dns解析。<br>注意：hosts文件只能配置ip和域名的映射关系，但是不能配置端口号，默认访问80端口</p>
<p>因为要解决端口问题，这里就得使用反向代理软件nginx，nginx中的每个server就是一个反向代理配置，可以有多个server。</p>
<p>理解：<em><strong>客户端请求 - dns解析域名 - 解析到nginx服务器的ip - nginx代理到tomcat服务器+端口 - tomcat将请求给servlet - servlet的service处理请求。</strong></em></p>
<h3 id="✅nginx与CDN内容分发网络什么关系"><a href="#✅nginx与CDN内容分发网络什么关系" class="headerlink" title="✅nginx与CDN内容分发网络什么关系"></a>✅nginx与CDN内容分发网络什么关系</h3><p>cdn是网络，nginx是服务器也是负载均衡。</p>
<p>cdn：<br>1、CDN的全称是Content Delivery Network，即内容分发网络。<br>2、其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。<br>3、通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。<br>4、其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度**。<br>5、内容分发网络是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。</p>
<p>cdn的工作原理：<br>CDN这个技术其实说起来并不复杂，最初的核心理念，就是将内容缓存在终端用户附近。</p>
<p>内容源不是远么？那么，我们就在靠近用户的地方，建一个缓存服务器，把远端的内容，复制一份，放在这里，不就OK了？</p>
<p>具体来说，CDN就是采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。（有点像电商的本地仓吧？）</p>
<p>大家可能觉得，这个不就是“镜像服务器”嘛？其实不一样。镜像服务器是源内容服务器的完整复制。而CDN，是部分内容的缓存，智能程度更高。</p>
<p><img src="/images/CDN.png"></p>
<p>借用阿里云官网的例子，来简单介绍CDN的工作原理。</p>
<p>假设通过CDN加速的域名为 <a href="http://www.a.com，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：">www.a.com，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：</a></p>
<p>1、当终端用户（北京）向<a href="http://www.a.com下的指定资源发起请求时,首先向ldns(本地dns)发起域名解析请求./">www.a.com下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。</a></p>
<p>2、LDNS检查缓存中是否有<a href="http://www.a.com的ip地址记录.如果有,则直接返回给终端用户;如果没有,则向授权dns查询./">www.a.com的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。</a></p>
<p>3、当授权DNS解析<a href="http://www.a.com时,返回域名cname/">www.a.com时，返回域名CNAME</a> <a href="http://www.a.tbcdn.com对应ip地址./">www.a.tbcdn.com对应IP地址。</a></p>
<p>4、域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。</p>
<p>5、LDNS获取DNS返回的解析IP地址。</p>
<p>6、用户获取解析IP地址。</p>
<p>7、用户向获取的IP地址发起对该资源的访问请求。</p>
<p>8、如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤7和8，请求结束。</p>
<p>9、如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。</p>
<p>所以：<br>（1）CDN的加速资源是跟域名绑定的。<br>（2）通过域名访问资源，首先是通过DNS分查找离用户最近的CDN节点（边缘服务器）的IP<br>（3）通过IP访问实际资源时，如果CDN上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上，这样，用户下一次访问时，该CDN节点就会有对应资源的缓存了。</p>
<hr>
<p>nginx负载均衡：负载均衡实际上就是将大量请求进行分布式处理的策略</p>
<p>Nginx 作为一个基于 C 实现的高性能 Web 服务器，可以通过系列算法解决上述的负载均衡问题。并且由于它具有高并发、高可靠性、高扩展性、开源等特点，成为开发人员常用的反向代理工具</p>
<p>1、正向代理</p>
<p>正向代理（Forward Proxy）最大的特点是，客户端非常明确要访问的服务器地址，它代理客户端，替客户端发出请求。比如：科学上网。</p>
<p>假设客户端想要访问 Google，它明确知道待访问的服务器地址是 <a href="https://www.google.com/%EF%BC%8C%E4%BD%86%E7%94%B1%E4%BA%8E%E6%9D%A1%E4%BB%B6%E9%99%90%E5%88%B6%EF%BC%8C%E5%AE%83%E6%89%BE%E6%9D%A5%E4%BA%86%E4%B8%80%E4%B8%AA%E8%83%BD%E5%A4%9F%E8%AE%BF%E9%97%AE%E5%88%B0">https://www.google.com/，但由于条件限制，它找来了一个能够访问到</a> Google 的”朋友”：代理服务器。客户端把请求发给代理服务器，由代理服务器代替它请求 Google，最终再将响应返回给客户端。这便是一次正向代理的过程，该过程中服务器并不知道真正发出请求的是谁。<br>（客户端 - 正向代理 - 服务器）</p>
<p>2、反向代理</p>
<p>随着请求量的爆发式增长，服务器觉得自己一个人始终是应付不过来，需要兄弟服务器们帮忙，于是它喊来了自己的兄弟以及代理服务器朋友。此时，来自不同客户端的所有请求实际上都发到了代理服务器处，再由代理服务器按照一定的规则将请求分发给各个服务器。这就是反向代理（Reverse Proxy），反向代理隐藏了服务器的信息，它代理的是服务器端，代其接收请求。换句话说，反向代理的过程中，客户端并不知道具体是哪台服务器处理了自己的请求。如此一来，既提高了访问速度，又为安全性提供了保证<br>（一堆客户端 - 反向代理 - 一堆服务器）</p>
<p>在这之中，反向代理需要考虑的问题是，如何进行均衡分工，控制流量，避免出现局部节点负载过大的问题。通俗的讲，就是如何为每台服务器合理的分配请求，使其整体具有更高的工作效率和资源利用率。</p>
<p>3、负载均衡常用算法</p>
<p>轮询 （round-robin）<br>轮询为负载均衡中较为基础也较为简单的算法，它不需要配置额外参数。假设配置文件中共有 台服务器，该算法遍历服务器节点列表，并按节点次序每轮选择一台服务器处理请求。当所有节点均被调用过一次后，该算法将从第一个节点开始重新一轮遍历。特点：由于该算法中每个请求按时间顺序逐一分配到不同的服务器处理，因此适用于服务器性能相近的集群情况，其中每个服务器承载相同的负载。但对于服务器性能不同的集群而言，该算法容易引发资源分配不合理等问题。</p>
<p>加权轮询<br>为了避免普通轮询带来的弊端，加权轮询应运而生。在加权轮询中，每个服务器会有各自的 weight。一般情况下，weight 的值越大意味着该服务器的性能越好，可以承载更多的请求。该算法中，客户端的请求按权值比例分配，当一个请求到达时，优先为其分配权值最大的服务器。特点：加权轮询可以应用于服务器性能不等的集群中，使资源分配更加合理化。</p>
<p>IP 哈希（IP hash）<br>ip_hash 依据发出请求的客户端 IP 的 hash 值来分配服务器，该算法可以保证同 IP 发出的请求映射到同一服务器，或者具有相同 hash 值的不同 IP 映射到同一服务器。特点：该算法在一定程度上解决了集群部署环境下 Session 不共享的问题。</p>
<p>所以：<br>Nginx 作为一款优秀的反向代理服务器，可以通过不同的负载均衡算法来解决请求量过大情况下的服务器资源分配问题。较为常见的负载均衡算法有轮询、加权轮询、IP 哈希等等，可分别应对不同的请求场景。</p>
<p>————————————————<br>好文章：从对CDN的理解到Nginx负载均衡<br>原文链接：<a href="https://blog.csdn.net/qq_40409143/article/details/118330238">https://blog.csdn.net/qq_40409143/article/details/118330238</a></p>
<h3 id="✅nginx与RPC远程过程调用什么关系？"><a href="#✅nginx与RPC远程过程调用什么关系？" class="headerlink" title="✅nginx与RPC远程过程调用什么关系？"></a>✅nginx与RPC远程过程调用什么关系？</h3><p>RPC是远程过程调用，是一种计算机通信思想。</p>
<p>nginx是代理服务器。它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务。</p>
<p>Nginx 和后端服务之间的交互在本质上也可以理解为 RPC 数据交互。也许你会争辩说 Nginx 和后端服务之间使用的是 HTTP 协议，走的是短连接，严格上不能算是 RPC 调用。 Nginx 和后端服务之间还可以走其它的协议，比如 uwsgi 协议、fastcgi 协议等，这两个协议都是采用了比 HTTP 协议更加节省流量的二进制协议。</p>
<p>讲RPC、RPC与nginx、RPC与HTTP间的关系的好文章：<br><a href="https://www.kancloud.cn/machh03/server/2096716">https://www.kancloud.cn/machh03/server/2096716</a></p>
<h3 id="✅与gateway有什么关系？"><a href="#✅与gateway有什么关系？" class="headerlink" title="✅与gateway有什么关系？"></a>✅与gateway有什么关系？</h3><p>网关(Gateway)就是一个网络连接到另一个网络的“关口”。</p>
<p><img src="/images/gateway.png"></p>
<p>1、nginx也可以做网关，是用户访问的总入口，也就是前端页面的容器，流量网关。</p>
<p>流量网关是定义全局性的、跟具体的后端业务应用和服务完全无关的策略网关。<br>流量网关通常只专注于全局的Api管理策略，比如全局流量监控、日志记录、全局限流、黑白名单控制、接入请求到业务系统的负载均衡等，有点类似防火墙。</p>
<p>2、gateway的定义是针对每一个业务微服务来得，属于业务网关。是介于nignx以及业务应用之间的中间层，主要负责将请求路由到不同的微服务中以及对请求的合法性进行校验。</p>
<p>业务网关针对具体的业务需要提供特定的流控策略、缓存策略、鉴权认证策略等等。<br>业务网关一般部署在流量网关之后、业务系统之前，比流量网关更靠近业务系统。通常API网指的是业务网关。 有时候我们也会模糊流量网关和业务网关，让一个网关承担所有的工作,所以这两者之间并没有严格的界线。</p>
<hr>
<p>网关可以看做系统与外界联通的入口，我们可以在网关进行处理一些非业务逻辑的逻辑，比如权限验证，监控，缓存，请求路由等等。</p>
<p>1、nginx是用户到 前端工程 的网关，对外网关<br>nginx是用C语言写的<br>nginx做网关，更多的是做总流量入口，反向代理，负载均衡等，还可以用来做web服务器。<br>Nginx在其中扮演的角色是什么？<br>反向代理<br>负载均衡</p>
<p>2、gateway 是前端工程 到 后台服务器之间的一个 对内网关<br>gateway是java语言的一个框架，可以在框架上进行代码的扩展与控制，例如：安全控制，统一异常处理，XXS,SQL注入等；权限控制，黑白名单，性能监控，日志打印等<br>gateway的主要功能有，路由，断言，过滤器，利用它的这些特性，可以做流控。<br>SpringGateway在其中扮演的角色是什么？<br>统一鉴权</p>
<p>nginx与gateway：<a href="https://blog.csdn.net/yangbindxj/article/details/125040773">https://blog.csdn.net/yangbindxj/article/details/125040773</a></p>
<hr>
<p>网关服务的端口号默认是80或者443.<br>相同点：都是可以实现对api接口的拦截，负载均衡、反向代理、请求过滤等，可以实现和网关一样的效果。<br>Nginx实现负载均衡的原理属于服务器端负载均衡器。<br>Gateway实现负载均衡原理采用本地负载均衡器的形式。</p>
<h3 id="✅nginx与统一接入有什么关系？"><a href="#✅nginx与统一接入有什么关系？" class="headerlink" title="✅nginx与统一接入有什么关系？"></a>✅nginx与统一接入有什么关系？</h3><p>统一接入层是：指的是设置专属一层，统一接入所有流量，包括 PC 流量、无线流量、IoT 流量。在应用层之上的一层。</p>
<p>如果没有统一接入层，之前的业务方，例如购物车、商品等都要自己维护一个网关，这就涉及到维护成本和机器成本。例如卸载 HTTPS，如果所有业务方都要申请证书，那造成的应用成本是非常高的。可如果将所有功能全放在这一层进行，好处非常明显：一方面是机器集中管理节省成本；另外一方面，如果遇到新的瓶颈可以在统一接入层集中优化，如请求响应 Body 统一在这一层进行压缩减少带宽消耗，压缩会消耗 CPU，可以在这一层通过硬件加速的方式集中优化等。</p>
<p>阿里统一接入层：<a href="https://zhuanlan.zhihu.com/p/96510277?hmsr=toutiao.io">https://zhuanlan.zhihu.com/p/96510277?hmsr=toutiao.io</a></p>
<p>统一接入层方案：<a href="https://www.cnblogs.com/Leo_wl/archive/2012/10/17/2728541.html">https://www.cnblogs.com/Leo_wl/archive/2012/10/17/2728541.html</a></p>
<p>统一接入层是网关中最前端的服务，统一接入到集群中。<br>所以，统一接入层应该是在web代理服务器nginx前的。</p>
<h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><h3 id="nginx配置文件结构"><a href="#nginx配置文件结构" class="headerlink" title="nginx配置文件结构"></a>nginx配置文件结构</h3><p>Main 位于 nginx.conf 配置文件的最高层；<br>Main 层下可以有 Event、HTTP 层；<br>Http 层下面允许有多个 Server 层，用于对不同的网站做不同的配置；<br>Server 层下面允许有多个 Location，用于对不同的路径进行不同模块的配置。</p>
<p>1、main（最上面）<br>全局配置部分用来配置对整个 server 都有效的参数。主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等<br>全局Main配置<br>user nginx;<br>worker_processes 1; #设置值和CPU核心数一致</p>
<p>error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn; #日志位置和日志级别<br>pid       &#x2F;var&#x2F;run&#x2F;nginx.pid;</p>
<p>2.event<br>events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 worker process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 worker process 可以同时支持的最大连接数等。<br>Event配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、http<br>http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。<br>http配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  include       /etc/nginx/mime.types;</span><br><span class="line">  default_type application/octet-stream;</span><br><span class="line">  log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                    &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                    &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">  access_log /var/log/nginx/access.log main;</span><br><span class="line">  sendfile       on;</span><br><span class="line">  #tcp_nopush     on;</span><br><span class="line">  keepalive_timeout 65;</span><br><span class="line">  #gzip on;</span><br><span class="line">  include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、server<br>Server 块也被叫做“虚拟主机”部分，它描述的是一组根据不同 server_name 指令逻辑分割的资源，这些虚拟服务器响应 HTTP 请求，因此都包含在 http 部分。最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。一个 server 块可以配置多个 location 块。<br>server配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  location / &#123;</span><br><span class="line">      root   /usr/share/nginx/html;</span><br><span class="line">      index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">  error_page   500 502 503 504 /50x.html;</span><br><span class="line">  location = /50x.html &#123;</span><br><span class="line">      root   /usr/share/nginx/html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nginx配置结构：<a href="https://baijiahao.baidu.com/s?id=1729793004418584302&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1729793004418584302&amp;wfr=spider&amp;for=pc</a></p>
<p>菜鸟nginx配置：<a href="https://www.runoob.com/w3cnote/nginx-setup-intro.html">https://www.runoob.com/w3cnote/nginx-setup-intro.html</a></p>
<p>nginx配置详细介绍：<a href="https://blog.51cto.com/u_12218973/2457715">https://blog.51cto.com/u_12218973/2457715</a></p>
<h3 id="nginx超时配置"><a href="#nginx超时配置" class="headerlink" title="nginx超时配置"></a>nginx超时配置</h3><p>Nginx主要有四类超时设置：客户端超时设置、DNS解析超时设置、代理超时设置，如果使用ngx_lua，则还有lua相关的超时设置。</p>
<p>1、客户端超时</p>
<p>客户端超时主要设置有读取请求头超时时间、读取请求体超时时间、发送响应超时时间、长连接超时时间。通过客户端超时设置避免客户端恶意或者网络状况不佳造成连接长期占用，影响服务端的可处理的能力。</p>
<p><strong>client_header_timeout time</strong>：设置读取客户端请求头超时时间，默认为60s，如果在此超时时间内客户端没有发送完请求头，则响应408（RequestTime-out）状态码给客户端。</p>
<p><strong>client_body_timeout time</strong>：设置读取客户端内容体超时时间，默认为60s，此超时时间指的是两次成功读操作间隔时间，而不是发送整个请求体的超时时间，如果在此超时时间内客户端没有发送任何请求体，则响应408（RequestTime-out）状态码给客户端。</p>
<p><strong>send_timeout time</strong>：设置发送响应到客户端的超时时间，默认为60s，此超时时间指的也是两次成功写操作间隔时间，而不是发送整个响应的超时时间。如果在此超时时间内客户端没有接收任何响应，则Nginx关闭此连接。</p>
<p><strong>keepalive_timeout timeout [header_timeout]</strong>：设置HTTP长连接超时时间，其中，第一个参数timeout是告诉Nginx长连接超时时间是多少，默认为75s。第二个参数header_timeout是用于设置响应头“Keep-Alive: timeout&#x3D;time”，即告知客户端长连接超时时间。如果timeout设置为0，则表示禁用长连接。</p>
<p>2、DNS解析超时</p>
<p><strong>resolver_timeout 30s</strong>：设置DNS解析超时时间，默认为30s</p>
<p>3、代理超时</p>
<p>主要有三组配置：网络连接&#x2F;读&#x2F;写超时设置、失败重试机制设置、upstream存活超时设置</p>
<p><strong>proxy_connect_timeout time</strong>：与后端&#x2F;上游服务器建立连接的超时时间，默认为60s，此时间不超过75s。</p>
<p><strong>proxy_read_timeout time</strong>：设置从后端&#x2F;上游服务器读取响应的超时时间，默认为60s，此超时时间指的是两次成功读操作间隔时间，而不是读取整个响应体的超时时间，如果在此超时时间内上游服务器没有发送任何响应，则Nginx关闭此连接。</p>
<p><strong>proxy_send_timeout time</strong>：设置往后端&#x2F;上游服务器发送请求的超时时间，默认为60s，此超时时间指的是两次成功写操作间隔时间，而不是发送整个请求的超时时间，如果在此超时时间内上游服务器没有接收任何响应，则Nginx关闭此连接。</p>
<p><strong>proxy_next_upstream_tries number</strong>：设置重试次数，默认0表示不限制，注意此重试次数指的是所有请求次数（包括第一次和之后的重试次数之和）。</p>
<p><strong>proxy_next_upstream_timeout time</strong>：设置重试最大超时时间，默认0表示不限制。</p>
<p>Nginx超时配置：<a href="https://blog.csdn.net/xiao__jia__jia/article/details/124075274">https://blog.csdn.net/xiao__jia__jia/article/details/124075274</a></p>
<h2 id="PoolingHttpClientConnectionManager"><a href="#PoolingHttpClientConnectionManager" class="headerlink" title="PoolingHttpClientConnectionManager"></a>PoolingHttpClientConnectionManager</h2><p>HttpClien高并发请求连接池 - PoolingHttpClientConnectionManager</p>
<p>连接池：<br>连接池技术作为创建和管理连接的缓冲池技术，目前已广泛用于诸如数据库连接等长连接的维护和管理中，能够有效减少系统的响应时间，节省服务器资源开销。其优势主要有两个：其一是减少创建连接的资源开销，其二是资源的访问控制。连接池管理的对象是长连接。</p>
<p>PoolingHttpClientConnectionManager是通过租用连接和收回链接的方式来实现的。解决了http请求的多线程问题。</p>
<p>依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>实现http连接池：<a href="https://blog.csdn.net/qq_34484062/article/details/109470135">https://blog.csdn.net/qq_34484062/article/details/109470135</a></p>
<h2 id="rpc"><a href="#rpc" class="headerlink" title="rpc"></a>rpc</h2><p>远程过程调用（Remote Procedure Call，缩写为 RPC）允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。 如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用，比如 Java RMI。</p>
<p>远程过程调用是一个分布式计算的客户端-服务器（Client&#x2F;Server）的例子，它简单而又广受欢迎。 远程过程调用总是由客户端对服务器发出一个执行若干过程请求，并用客户端提供的参数。执行结果将返回给客户端。 由于存在各式各样的变体和细节差异，对应地派生了各式远程过程调用协议，而且它们并不互相兼容。</p>
<p>为了允许不同的客户端均能访问服务器，许多标准化的 RPC 系统应运而生了。其中大部分采用接口描述语言（Interface Description Language，IDL），方便跨平台的远程过程调用。<br>有些实现扩展了远程调用的模型，实现了双向的服务调用，但是不管怎样，调用过程还是由一个客户端发起，服务器端提供响应，基本模型没有变化。</p>
<p>服务的调用过程为：<br>1、client调用client stub，这是一次本地过程调用<br>2、client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做 marshalling<br>3、client所在的系统将消息发送给server<br>4、server的的系统将收到的包传给server stub<br>5、server stub解包得到参数。 解包也被称作 unmarshalling<br>6、最后server stub调用服务过程. 返回结果按照相反的步骤传给client</p>
<hr>
<p>RPC (Remote Procedure Call)即远程过程调用，是分布式系统常见的一种通信方法，已经有 40 多年历史。当两个物理分离的子系统需要建立逻辑上的关联时，RPC 是牵线搭桥的常见技术手段之一。除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存。</p>
<p>其中 RPC 和 HTTP 调用是没有经过中间件的，它们是端到端系统的直接数据交互。<strong>HTTP 调用其实也可以看成是一种特殊的 RPC，只不过传统意义上的 RPC 是指长连接数据交互，而 HTTP 一般是指即用即走的短链接。</strong></p>
<p>RPC 在我们熟知的各种中间件中都有它的身影。Nginx&#x2F;Redis&#x2F;MySQL&#x2F;Dubbo&#x2F;Hadoop&#x2F;Spark&#x2F;Tensorflow 等重量级开源产品都是在 RPC 技术的基础上构建出来的，我们<strong>这里说的 RPC 指的是广义的 RPC，也就是分布式系统的通信技术</strong>。RPC 在技术中的地位好比我们身边的空气，它无处不在，但是又有很多人根本不知道它的存在。</p>
<p>例如数据库：<br>子系统和数据库之间的交互也是通过 RPC 进行的，只不过这里是三个子系统之间复杂的组合消息交互罢了。如果再深入进去，你会发现，这里的数据库不是那种单机数据库，而是具备主从复制功能的数据库，比如 MySQL。在互联网企业里一般都会使用这种主从读写分离的数据库。一个业务子系统将数据写往主库，主库再将数据同步到从库，然后另一个业务子系统又从从库里将数据取出来。这时又可以进一步将它们看成是四个子系统之间进行的更加复杂的 RPC 数据交互。</p>
<hr>
<p>一些分布式场景中RPC的使用：（广义上的RPC）</p>
<p>✅nginx<br>Ngnix 是互联网企业使用最为广泛的代理服务器。它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务。Nginx 和后端服务之间的交互在本质上也可以理解为 RPC 数据交互。也许你会争辩说 Nginx 和后端服务之间使用的是 HTTP 协议，走的是短连接，严格上不能算是 RPC 调用。不过 Nginx 和后端服务之间还可以走其它的协议，比如 uwsgi 协议、fastcgi 协议等，这两个协议都是采用了比 HTTP 协议更加节省流量的二进制协议。</p>
<p>✅Hadoop<br>在大数据技术领域，RPC 也占据了非常重要的地位。大数据领域广泛应用了非常多的分布式技术，分布式意味着节点的物理隔离，隔离意味着需要通信，通信意味着 RPC 的存在。大数据需要通信的量比业务系统更加庞大，所以在数据通信优化上做的更深。比如最常见的 Hadoop 文件系统 hdfs，一般包括一个 NameNode 和多个 DataNode，NameNode 和 DataNode 之间就是通过一种称为 Hadoop RPC 的二进制协议进行通讯。</p>
<p>✅TensorFlow<br>在人工智能领域，RPC 也很重要，著名的 TensorFlow 框架如果需要处理上亿的数据，就需要依靠分布式计算力，需要集群化，当多个分布式节点需要集体智慧时，就必须引入 RPC 技术进行通讯。Tensorflow Cluster 的 RPC 通讯框架使用了 Google 内部自研的 gRPC 框架。</p>
<p>转自：<a href="https://www.kancloud.cn/machh03/server/2096716">https://www.kancloud.cn/machh03/server/2096716</a><br>里面还有实现rpc</p>
<h2 id="理解http和rpc"><a href="#理解http和rpc" class="headerlink" title="理解http和rpc"></a>理解http和rpc</h2><p>HTTP1.0 协议时，HTTP 调用还只能是短链接调用，一个请求来回之后连接就会关闭。HTTP1.1 在 HTTP1.0 协议的基础上进行了改进，引入了 KeepAlive 特性可以保持 HTTP 连接长时间不断开，以便在同一个连接之上进行多次连续的请求，进一步拉近了 HTTP 和 RPC 之间的距离。</p>
<p>当 HTTP 协议进化到 2.0 之后，Google 开源了一个建立在 HTTP2.0 协议之上的通信框架直接取名为 gRPC，也就是 Google RPC，这时 HTTP 和 RPC 之间已经没有非常明显的界限了。</p>
<p>HTTP 与 RPC 的关系就好比普通话与方言的关系。要进行跨企业服务调用时，往往都是通过 HTTP API，也就是普通话，虽然效率不高，但是通用，没有太多沟通的学习成本。但是在企业内部还是 RPC 更加高效，同一个企业公用一套方言进行高效率的交流，要比通用的 HTTP 协议来交流更加节省资源。整个中国有非常多的方言，正如有很多的企业内部服务各有自己的一套交互协议一样。好比开源 RPC 协议中 Protobuf 和 Thrift 一样，它们两应该是 RPC 协议中使用最为广泛的两个。</p>
<p>rpc基于什么实现网络传输？<br>1.rpc可以基于tcp直接开发自己的协议，这个是可以保持长连接的，tcp的传输效率高，并且可以一直维持链接</p>
<p>2.自定义协议可以优化数据的传输，例如更大的压缩比。分布式系统中非常有用。</p>
<p>3.http协议1.x一般情况下一个来回就关闭连接，虽然提供了keep-alive可以保持长连接，但是依然不方便，所以就出现了http2.0， http2.0基本上可以当做tcp协议使用了。所以grpc就会使用http2.0开发。</p>
<h2 id="rest和restful"><a href="#rest和restful" class="headerlink" title="rest和restful"></a>rest和restful</h2><p>REST，英文全称Representational State Transfer（表述性状态转移），是一组架构约束条件和原则（注意，REST是设计风格而不是标准）。满足这些约束条件和原则的应用程序或设计就是RESTful。可以降低开发的复杂性，提高系统的可伸缩性。体现在Web开发中就是通过HTTP方法中的POST、DELETE、PUT、GET来对资源进行操作。</p>
<p>一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p>在 REST 样式的 Web 服务中，每个资源都有一个地址。资源本身都是方法调用的目标，方法列表对所有资源都是一样的。这些方法都是标准方法，包括 HTTP GET、POST、PUT、DELETE，还可能包括 HEADER 和 OPTIONS。</p>
<p>Representation（表现层）<br>资源的信息载体形式。它可以是文本、XML、JSON或者是一个二进制文件。它的表现形式应该在HTTP请求的头信息中用Accept和Content-Type字段指定描述。</p>
<p>State Transfer（状态转移）<br>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转移”。</p>
<p>在 HTTP 中，我们一般通过四种 HTTP 动词来对应资源的变化：<br>POST（新建资源，也可用于更新资源）<br>DELETE（删除资源）<br>PUT（更新资源）<br>GET（获取资源）</p>
<p>REST架构原则：<br>对网络上所有资源都有一个资源标识符<br>对资源的操作不会改变标识符<br>同一资源有多种表现形式，如XML、JSON…<br>所有操作都是无状态的（Stateless）</p>
<p>RESTful，是一种网络应用程序的设计风格和开发方式。RESTful可以通过一套统一的接口为Web，iOS和Android提供服务。比如微博开放平台，微信开放平台等，它们不需要有显式的前端，只需要一套提供服务的接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在使用RESTful风格之前，我们通常是这样操作用户数据:</span><br><span class="line">//创建用户信息</span><br><span class="line">http://localhost:8080/user/createUser</span><br><span class="line">//删除id为1的用户信息</span><br><span class="line">http://localhost:8080/user/deleteUser/1</span><br><span class="line">//修改id为2的用户信息</span><br><span class="line">http://localhost:8080/user/updateUser/2</span><br><span class="line">//获取所有用户信息</span><br><span class="line">http://localhost:8080/user/getUsers</span><br><span class="line"></span><br><span class="line">使用RESTful风格之后:</span><br><span class="line">//创建用户信息</span><br><span class="line">POST http://localhost:8080/user</span><br><span class="line">//删除id为1的用户信息</span><br><span class="line">DELETE http://localhost:8080/user/1</span><br><span class="line">//修改id为2的用户信息</span><br><span class="line">PUT http://localhost:8080/user/2</span><br><span class="line">//获取所有用户信息</span><br><span class="line">GET http://localhost:8080/user获取所有用户信息</span><br><span class="line">通过约定不同的HTTP方法来实现不同的业务，有一个更加直观的了解。</span><br><span class="line">1、看URL就知道要操作什么</span><br><span class="line">2、看HTTP方法就知道要如何操作</span><br><span class="line">3、看HTTP状态码就知道返回结果如何</span><br></pre></td></tr></table></figure>

<p>参考：<br>rest与restful：<br><a href="https://blog.csdn.net/weixin_44316527/article/details/106276655">https://blog.csdn.net/weixin_44316527/article/details/106276655</a></p>
<hr>
<p>rpc与restful：</p>
<p>RPC（Remote Procedure Call Protocol）就是远程调用。最简单的想法，应该就是把HTTP协议当做RPC来用。比如我们把网址作为一个借口，传入的参数作为函数参数，response的数据作为返回信息。这其实就是一个调用。</p>
<p>RESTful和RPC最大的区别应该就是面向对象了。<br>从设计上来看，RPC，所谓的远程过程调用 ，是面向方法的 ；<br>REST：所谓的 Representational state transfer ，是面向资源的；<br>除此之外，还有一种叫做 SOA，所谓的面向服务的架构，它是面向消息的。<br>很多人只知道GET和POST，因为现在最常用的就是GET和POST了。虽说这应该是违背了HTTP设计的初衷。</p>
<p>序列化协议的区别：<br>接口调用通常包含两个部分，序列化和通信协议。<br>通信协议，上面已经提及了，REST 是 基于 HTTP 协议，而 RPC 可以基于 TCP&#x2F;UDP，也可以基于 HTTP 协议进行传输的。<br>常见的序列化协议，有：json、xml、hession、protobuf、thrift、text、bytes等，REST 通常使用的是 JSON或者XML，而 RPC 使用的是 JSON-RPC，或者 XML-RPC。</p>
<p>什么时候用？<br>REST 接口更加规范，通用适配性要求高，建议对外的接口都统一成 REST。而组件内部的各个模块，可以选择 RPC，一个是不用耗费太多精力去开发和维护多套的HTTP接口，一个RPC的调用性能更高。从性能角度看，由于HTTP本身提供了丰富的状态功能与扩展功能，但也正由于HTTP提供的功能过多，导致在网络传输时，需要携带的信息更多，从性能角度上讲，较为低效。而RPC服务网络传输上仅传输与业务内容相关的数据，传输数据更小，性能更高。</p>
<p>转自：<br><a href="https://developer.aliyun.com/article/53677">https://developer.aliyun.com/article/53677</a></p>
<hr>
<p>restful和http：</p>
<p>REST 是一种软件架构风格。这种风格的典型应用，就是HTTP。其因为简单、扩展性强的特点而广受开发者的青睐。</p>
<p>某种意义下，我们说 REST 可以其实就是指代 HTTP 协议。</p>
<hr>
<p>总结：rpc、http、rest</p>
<p>rpc是一种协议还是，还是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想？更是后者<br>rpc包含：服务发现、负载、容器、网络传输、序列化等组件。<br>rpc指明了程序如何进行网络传输和序列化。</p>
<p>关于rpc和http的比较：<br>rpc的网络传输是如何实现的，rpc是连接，http是短连接。<br>http是一种rpc（广义上），还是rpc可以基于http实现？<br>RPC可以基于TCP协议也可以基于HTTP协议。<br>HTTP需要携带的信息更多，低效，RPC仅传输与业务相关的数据，传输数据更小，性能更高</p>
<p>关于rpc和restful的比较：<br>rpc面向方法，restful面向资源。<br>日常写的接口，更多基于rpc面向方法的，虽然有的是rpc接口，有的是http接口。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java之fastjson及XStream</title>
    <url>/2022/04/30/myblog/java/java%E4%B9%8Bfastjson%E5%8F%8AXStream/</url>
    <content><![CDATA[<p>fastjson是阿里出品的处理JSON字符串的Java类库，可以对JSON字符串、JSON对象、Java对象进行互相转换。需要导入fastjson包。</p>
<h3 id="String、JSONObject、Object转换"><a href="#String、JSONObject、Object转换" class="headerlink" title="String、JSONObject、Object转换"></a>String、JSONObject、Object转换</h3><p>一、字符串转成JSON对象&#x2F;数组<br>字符串转成JSON对象<br>JSON.parseObject(String text)<br>JSON.parse(String text)</p>
<p>字符串转成JSON数组<br>JSON.parseArray(String text)<br>JSON.parse(String text)</p>
<p>二、字符串转成Java对象&#x2F;列表<br>字符串转成Java对象<br>JSON.parseObject(String text, Class<T> clazz)</p>
<p>字符串转成Java对象列表<br>JSON.parseArray(String text, Class<T> clazz)</p>
<p>三、Java对象&#x2F;列表转成JSON对象&#x2F;数组<br>Java对象转成JSON对象<br>JSONObject.toJSON(Object javaObject)<br>JSON.toJSON(Object javaObject)</p>
<p>Java对象列表转成JSON数组<br>JSONArray.toJSON(Object javaObject)<br>JSON.toJSON(Object javaObject)</p>
<p>四、JSON对象&#x2F;数组转成Java对象&#x2F;列表<br>JSON对象转成Java对象<br>JSON.toJavaObject(JSON json, Class<T> clazz)<br>jsonObject.toJavaObject(JSON json) (非静态方法)</p>
<p>JSON数组转成Java对象列表<br>jsonArray.toJavaList(Class<T> clazz) (非静态方法)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONArray;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class FastJSONLearning &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    String jsonObjectStr = &quot;&#123;\&quot;prop\&quot;:\&quot;code\&quot;,\&quot;label\&quot;:\&quot;代码\&quot;,\&quot;required\&quot;:true,\&quot;key\&quot;:true&#125;&quot;;</span><br><span class="line">    String jsonArrayStr = &quot;[&#123;\&quot;prop\&quot;:\&quot;code\&quot;,\&quot;label\&quot;:\&quot;代码\&quot;,\&quot;required\&quot;:true,\&quot;key\&quot;:true&#125;,&#123;\&quot;prop\&quot;:\&quot;explain\&quot;,\&quot;label\&quot;:\&quot;中文释义\&quot;,\&quot;required\&quot;:true&#125;]&quot;;</span><br><span class="line"> </span><br><span class="line">    // 字符串转成JSON对象/数组</span><br><span class="line">    // 字符串转成JSON对象</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONObject jsonObject1 = JSON.parseObject(jsonObjectStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON对象: &quot; + jsonObject1);</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONObject jsonObject2 = (JSONObject) JSON.parse(jsonObjectStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON对象: &quot; + jsonObject2);</span><br><span class="line"> </span><br><span class="line">    // 字符串转成JSON数组</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONArray jsonArray1 = JSON.parseArray(jsonArrayStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON数组: &quot; + jsonArray1);</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONArray jsonArray2 = (JSONArray) JSON.parse(jsonArrayStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON数组: &quot; + jsonArray2);</span><br><span class="line"> </span><br><span class="line">    // 字符串转成Java对象/列表</span><br><span class="line">    // 字符串转成Java对象</span><br><span class="line">    Dict dict = JSON.parseObject(jsonObjectStr, Dict.class);</span><br><span class="line">    System.out.println(&quot;字符串转成Java对象: &quot; + dict.toString());</span><br><span class="line"> </span><br><span class="line">    // 字符串转成Java对象列表</span><br><span class="line">    List&lt;Dict&gt; dictList = JSON.parseArray(jsonArrayStr, Dict.class);</span><br><span class="line">    System.out.println(&quot;字符串转成Java对象列表: &quot; + dictList.toString());</span><br><span class="line"> </span><br><span class="line">    // Java对象/列表转成JSON对象/数组</span><br><span class="line">    // Java对象转成JSON对象</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONObject jsonObject3 = (JSONObject) JSONObject.toJSON(dict);</span><br><span class="line">    System.out.println(&quot;Java对象转成JSON对象: &quot; + jsonObject3.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONObject jsonObject4 = (JSONObject) JSON.toJSON(dict);</span><br><span class="line">    System.out.println(&quot;Java对象转成JSON对象: &quot; + jsonObject4.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // Java对象列表转成JSON数组</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONArray jsonArray3 = (JSONArray) JSONArray.toJSON(dictList);</span><br><span class="line">    System.out.println(&quot;Java对象列表转成JSON数组: &quot; + jsonArray3.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONArray jsonArray4 = (JSONArray) JSON.toJSON(dictList);</span><br><span class="line">    System.out.println(&quot;Java对象列表转成JSON数组: &quot; + jsonArray4.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // JSON对象/数组转成Java对象/列表</span><br><span class="line">    // JSON对象转成Java对象</span><br><span class="line">    // 方法1</span><br><span class="line">    Dict dict1 = JSON.toJavaObject(jsonObject1, Dict.class);</span><br><span class="line">    System.out.println(&quot;JSON对象转成Java对象: &quot; + dict1);</span><br><span class="line"> </span><br><span class="line">    // JSON对象转成Java对象</span><br><span class="line">    // 方法2</span><br><span class="line">    Dict dict2 = jsonObject1.toJavaObject(Dict.class);</span><br><span class="line">    System.out.println(&quot;JSON对象转成Java对象: &quot; + dict2);</span><br><span class="line"> </span><br><span class="line">    // JSON数组转成Java对象列表</span><br><span class="line">    List&lt;Dict&gt; dictList1 = jsonArray1.toJavaList(Dict.class);</span><br><span class="line">    System.out.println(&quot;JSON数组转成Java对象列表: &quot; + dictList1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://www.cnblogs.com/lasdaybg/p/15144350.html">https://www.cnblogs.com/lasdaybg/p/15144350.html</a></p>
<h3 id="json文件中获取"><a href="#json文件中获取" class="headerlink" title="json文件中获取"></a>json文件中获取</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class JsonTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void TestJ()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            File jsonFile = ResourceUtils.getFile(&quot;classpath:hello.json&quot;);</span><br><span class="line">            String s = FileUtils.readFileToString(jsonFile);</span><br><span class="line">            System.out.println(&quot;s:&quot;+s);</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;error:&quot;+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileUtils 需要导包：commons-io。<br>classpath表示项目中的resource文件夹。</p>
<h3 id="JSONObject、JSONArray"><a href="#JSONObject、JSONArray" class="headerlink" title="JSONObject、JSONArray"></a>JSONObject、JSONArray</h3><p>也是fastjson下的</p>
<p>JSON是互联网开发过程中应用最广泛的一种数据类型，不管是后端API接口中，还是在前端都能得到广泛应用。JSON 就是一种轻量级的数据交换格式，被广泛应用于 WEB 应用程序开发</p>
<p>在线解析：<a href="https://c.runoob.com/front-end/53/">https://c.runoob.com/front-end/53/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;area&quot;: &quot;山东菏泽&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;马马马马马百万&quot;,</span><br><span class="line">  &quot;age&quot;: [1,2,3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON、JSON对象、JSON数组区别<br>JSON 呢只是一种宏观上的叫法，可以理解为是一种数据结构，就像 xml 结构一样，是一种规约性内容；而 JSON 对象则是对 JSON 的具体体现；JSON 数组则是将多个 JSON 对象进行存储的一个集合，可以想象成 Java 中的 List 和 Object 的关系</p>
<h4 id="JSONObject"><a href="#JSONObject" class="headerlink" title="JSONObject"></a>JSONObject</h4><p>JSONObject 是根据 JSON 形式在 Java 中存在的对象映射<br>各大 JSON 类库的 JSONObject 内部实现也是不太一样的。<br>例如fastjson：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class JSONObject extends JSON implements Map&lt;String, Object&gt;, Cloneable, Serializable, InvocationHandler &#123;</span><br><span class="line">&#125;</span><br><span class="line">对 HashMap 的一层封装，并提供了一些个性化方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSONObject json = new JSONObject();</span><br><span class="line">json.put(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">json.put(&quot;key1&quot;,&quot;11&quot;);</span><br><span class="line">System.out.println(json.getInteger(&quot;key1&quot;));</span><br><span class="line">System.out.println(json.getString(&quot;key&quot;));</span><br></pre></td></tr></table></figure>

<h4 id="JSONArray"><a href="#JSONArray" class="headerlink" title="JSONArray"></a>JSONArray</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class JSONArray extends JSON implements List&lt;Object&gt;, Cloneable, RandomAccess, Serializable &#123;</span><br><span class="line">&#125;</span><br><span class="line">一个 List 中 套了个 Map 类结构</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSONObject person = new JSONObject();</span><br><span class="line">person.put(&quot;name&quot;, &quot;马马马马马百万&quot;);</span><br><span class="line">JSONObject drug = new JSONObject();</span><br><span class="line">drug.put(&quot;drugName&quot;, &quot;盐酸丁卡因注射液&quot;);</span><br><span class="line">JSONArray array = new JSONArray();</span><br><span class="line">array.add(person);</span><br><span class="line">array.add(drug);</span><br></pre></td></tr></table></figure>

<h4 id="各种转换"><a href="#各种转换" class="headerlink" title="各种转换"></a>各种转换</h4><p>普通对象、json字符串、jsonObject</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将对象转换为json字符串</span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">String jsonStr = JSON.toJSONString(person);</span><br><span class="line">将json字符串转换为JSONObject对象</span><br><span class="line">JSONObject jsonObject = JSON.parseObject(jsonStr);</span><br><span class="line">将JSONObject 转换为对象</span><br><span class="line">JSONObject person = new JSONObject();</span><br><span class="line">person.put(&quot;name&quot;, &quot;马马马马马百万&quot;);</span><br><span class="line">person.put(&quot;age&quot;, 25);</span><br><span class="line">Student stuObj = JSON.toJavaObject(person, Student.class);</span><br></pre></td></tr></table></figure>

<h3 id="一个对象转换为另一个对象"><a href="#一个对象转换为另一个对象" class="headerlink" title="一个对象转换为另一个对象"></a>一个对象转换为另一个对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B = JSON.parseObject(JSON.toString(a), b.class)</span><br></pre></td></tr></table></figure>


<h3 id="getJSONObject、getJSONArray"><a href="#getJSONObject、getJSONArray" class="headerlink" title="getJSONObject、getJSONArray"></a>getJSONObject、getJSONArray</h3><p>Fastjson中getJSONObject()与getJSONArray()，用于获取JSONObject里的JSONObject、JSONArray()。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;    &quot;package&quot;: &#123;</span><br><span class="line">        &quot;List1&quot;: &#123;</span><br><span class="line">            &quot;errorCode&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;errorMsg&quot;: &quot;Success&quot;,</span><br><span class="line">            &quot;receiverTradeNum&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;List2&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;medicalNum&quot;: &quot;15XXXXXX&quot;,</span><br><span class="line">                &quot;queryDate&quot;: &quot;YYYYMMDD&quot;,</span><br><span class="line">                &quot;name&quot;: &quot;XXX&quot;,</span><br><span class="line">                &quot;authorizationNum&quot;: &quot;xxxxx&quot;,</span><br><span class="line">                &quot;pageNum&quot;: &quot;1&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JSONObject jsonObj = JSON.parseObject(jsonStr);</span><br><span class="line">JSONObject package = jsonObj.getJSONObject(&quot;package&quot;);     // 定位到package json对象</span><br><span class="line">JSONArray list = package.getJSONArray(&quot;List2&quot;);   //采用getJSONArray方法， 定位到json集合</span><br></pre></td></tr></table></figure>


<h3 id="XStream"><a href="#XStream" class="headerlink" title="XStream"></a>XStream</h3><p>XStream是Java类库，用来将对象序列化成XML（JSON）或反序列化为对象。<br>也就是说，使用XStream，我们可以把Java对象转换成XML，也可以将XML转换为Java对象。</p>
<p>依赖：<br>XStream的必导JAR包：<br>核心JAR包：xstream-1.4.7.jar；<br>必须依赖包：xpp3_min-1.1.4c.jar（XML Pull Parser，一款速度很快的XML解析器）。</p>
<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XStream xStream = new XStream();</span><br><span class="line">xStream.alias(&quot;china&quot;, List.class);   //标签类换成指定字符</span><br><span class="line">xStream.alias(&quot;province&quot;, Province.class);</span><br><span class="line">xStream.alias(&quot;city&quot;, City.class);</span><br><span class="line"></span><br><span class="line">xStream.useAttributeFor(Province.class, &quot;name&quot;); //子元素编程熟悉</span><br><span class="line">xStream.addImplicitCollection(Province.class, &quot;cities&quot;);  //去掉cities标签</span><br><span class="line"></span><br><span class="line">String string = xStream.toXML(proList);</span><br><span class="line">System.out.println(string);</span><br></pre></td></tr></table></figure>

<p>更多：<a href="https://blog.csdn.net/u014565127/article/details/104419528">https://blog.csdn.net/u014565127/article/details/104419528</a></p>
<p><strong>高并发情况下的性能问题</strong></p>
<p>项目中使用了XStream进行XML序列化、反序列化的方案，完成服务之间的接口报文Object与Xmlg格式之间的转化。</p>
<p>当线上业务量并不大的情况下，一切正常；但是发现当业务量突然加大的情况下，突然发现，线上服务器出现CPU居高不下，服务接口调用速度越来越慢，研究JVM日志分析，发现出现很多的RUNNABLE问题。</p>
<p>问题原因：XStream在new的时候会创建CompositeClassLoader（初始类加载器），并且不断new会不断创建，导致ygc需要扫描的内容越来越多，最终导致接口调用性能下降。</p>
<p>XStream是线程安全的，不需要重复初始化xstream对象，每一种类型实例化一个对象即可，而正是由于开发人员错误地在每次处理时都实例化一个新的xstream对象，才导致了该问题。</p>
<p>解决：单列模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原来：</span><br><span class="line">XStream xstream = XStreamInitializer.getInstance();</span><br><span class="line">xstream.processAnnotations(this.getClass());</span><br><span class="line">xstream.aliasSystemAttribute(null, &quot;class&quot;);</span><br><span class="line">return xstream.toXML(this);</span><br><span class="line"></span><br><span class="line">现在：</span><br><span class="line">实现单列：</span><br><span class="line">public class XmlHandler&#123;</span><br><span class="line"></span><br><span class="line">    private static final ConcurrentHashMap xStream = new ConcurrentHashMap&lt;String, XStream&gt;();</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 初始化</span><br><span class="line">     * @param objName</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static XStream getXStream(Class&lt;?&gt; objName) &#123;</span><br><span class="line">        String key = objName.getName();</span><br><span class="line">        if (xStream.get(key) == null)</span><br><span class="line">            xStream.put(key, new XStream());</span><br><span class="line">        return (XStream) xStream.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">序列化：</span><br><span class="line">XStream xstream = XmlHandler.getXStream(Dog.class);</span><br><span class="line">xstream.processAnnotations(Dog.class);</span><br><span class="line">String xml = xstream.toXML(dog);</span><br><span class="line"></span><br><span class="line">反序列化：</span><br><span class="line">XStream xStream = XmlHandler.getXStream(Dog.class);</span><br><span class="line">xStream.processAnnotations(Dog.class);</span><br><span class="line">Dog dog = (Dog) xStream.fromXML(xml);</span><br></pre></td></tr></table></figure>

<p>原文：<a href="https://blog.csdn.net/weixin_43767602/article/details/114824028">https://blog.csdn.net/weixin_43767602/article/details/114824028</a></p>
<h3 id="JSON与XML转化"><a href="#JSON与XML转化" class="headerlink" title="JSON与XML转化"></a>JSON与XML转化</h3><p>详见：<a href="https://blog.csdn.net/CDWLX/article/details/119038509">https://blog.csdn.net/CDWLX/article/details/119038509</a><br><a href="https://blog.csdn.net/baidu_37366055/article/details/110468129">https://blog.csdn.net/baidu_37366055/article/details/110468129</a></p>
<p>xml转json：用 org.jdom，用 dom 提取节点 转成map<br>json转xml： com.alibaba.fastjson.JSONObject</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.jdom&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jdom&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;dom4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.6.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.16.graal&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.StringReader;</span><br><span class="line">import java.io.StringWriter;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">import org.dom4j.io.OutputFormat;</span><br><span class="line">import org.dom4j.io.SAXReader;</span><br><span class="line">import org.dom4j.io.XMLWriter;</span><br><span class="line">import org.jdom.Document;</span><br><span class="line">import org.jdom.Element;</span><br><span class="line">import org.jdom.JDOMException;</span><br><span class="line">import org.jdom.input.SAXBuilder;</span><br><span class="line">import org.xml.sax.InputSource;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONArray;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line">public class JsonXML &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //请注意使用正常的xml</span><br><span class="line">        //xml-&gt;json</span><br><span class="line">//      String jsonStr = xmlToJson(&quot;D:\\NewFile.xml&quot;, null);</span><br><span class="line">//      System.out.println(jsonStr);</span><br><span class="line"></span><br><span class="line">        //json-&gt;xml</span><br><span class="line">        String xmlstr = jsonToXml(&quot;&#123;\&quot;b_content\&quot;:&#123;\&quot;sdata\&quot;:\&quot;Ps/DPJnZZPN6QQJQodY3+hK6PWCF3/2oi3DJPnFEXgKDrXX5rHT7q/I0nQPAruuBbQRfErnenQNvPpbf/lXl690qtye0/ZEuDs0ByFdFAGffQalB+Ij3lLUMDPz=\&quot;,\&quot;userobj\&quot;:&#123;\&quot;uid\&quot;:\&quot;ma000\&quot;,\&quot;realtype\&quot;:\&quot;DC\&quot;,\&quot;cn\&quot;:\&quot;法人用户2\&quot;,\&quot;tokenid\&quot;:\&quot;\&quot;,\&quot;usertype\&quot;:\&quot;2\&quot;,\&quot;link_person_name\&quot;:\&quot;联系人2\&quot;,\&quot;isreal\&quot;:\&quot;true\&quot;,\&quot;telephonenumber\&quot;:\&quot;13*******21\&quot;,\&quot;mail\&quot;:\&quot;ceshi@123.com\&quot;,\&quot;idcardtype\&quot;:\&quot;10\&quot;,\&quot;createtime\&quot;:\&quot;20150618191221\&quot;,\&quot;extproperties\&quot;:[\&quot;address=广东省广州市天河区天河北路XXX号\&quot;,\&quot;legal_code=440***********033\&quot;,\&quot;ent_type=-1\&quot;,\&quot;link_person_code=350************14\&quot;,\&quot;origin=gdbs\&quot;,\&quot;card_type_two_num=-1\&quot;,\&quot;cert_ca=-1\&quot;,\&quot;accout_type=2\&quot;,\&quot;account_uid=2\&quot;,\&quot;comm_code=-1\&quot;,\&quot;unit_type=-1\&quot;,\&quot;legal_id_type=10\&quot;,\&quot;landline=-1\&quot;,\&quot;tax_code=-1\&quot;,\&quot;cert_notafter=-1\&quot;,\&quot;card_type_one_num=-1\&quot;,\&quot;local_user=-1\&quot;,\&quot;legal_person=郑**\&quot;,\&quot;link_person_type=10\&quot;,\&quot;card_type_three=-1\&quot;,\&quot;card_type_two=-1\&quot;,\&quot;card_type_three_num=-1\&quot;,\&quot;cert_data=-1\&quot;,\&quot;area=guangzhou\&quot;,\&quot;uversion=3.0\&quot;,\&quot;cert_notbefore=-1\&quot;,\&quot;card_type_one=-1\&quot;,\&quot;user_typeext=2\&quot;],\&quot;idcardnumber\&quot;:\&quot;11***************23\&quot;,\&quot;useridcode\&quot;:\&quot;38c97fa1ee2e43d4a664cffc4554cde4\&quot;,\&quot;creditable_level_of_account_way\&quot;:\&quot;L2@YSS@2088******653||L0@IDV@44088******75||L3@GW@44088******75\&quot;,\&quot;creditable_level_of_account\&quot;:\&quot;L3\&quot;&#125;,\&quot;pareobj\&quot;:&#123;\&quot;uid\&quot;:\&quot;mayintao\&quot;,\&quot;realtype\&quot;:\&quot;DC\&quot;,\&quot;cn\&quot;:\&quot;单位用户2\&quot;,\&quot;tokenid\&quot;:\&quot;\&quot;,\&quot;usertype\&quot;:\&quot;2\&quot;,\&quot;link_person_name\&quot;:\&quot;联系人2\&quot;,\&quot;isreal\&quot;:\&quot;true\&quot;,\&quot;telephonenumber\&quot;:\&quot;13*******21\&quot;,\&quot;mail\&quot;:\&quot;ceshi@123.com\&quot;,\&quot;idcardtype\&quot;:\&quot;50\&quot;,\&quot;createtime\&quot;:\&quot;20150618191221\&quot;,\&quot;extproperties\&quot;:[\&quot;address=广东省广州市东山区\&quot;,\&quot;legal_id_type=-1\&quot;,\&quot;link_person_type=-1\&quot;,\&quot;legal_code=-1\&quot;,\&quot;origin=gdbs\&quot;,\&quot;tax_code=-1\&quot;,\&quot;legal_person=-1\&quot;,\&quot;area=shenzhen\&quot;,\&quot;link_person_code=-1\&quot;,\&quot;user_typeext=2\&quot;,\&quot;uversion=1.0\&quot;],\&quot;idcardnumber\&quot;:\&quot;456787654\&quot;,\&quot;useridcode\&quot;:\&quot;75c91fagrr2e67d4a169cfmc8735ctrf\&quot;,\&quot;creditable_level_of_account_way\&quot;:\&quot;L2@YSS@2088******653||L0@IDV@44088******75||L3@GW@44088******75\&quot;,\&quot;creditable_level_of_account\&quot;:\&quot;L3\&quot;&#125;,\&quot;user_creditable_level\&quot;:&#123;\&quot;creditable_level_of_account_way\&quot;:\&quot;L2@YSS@2088******653||L0@IDV@44088******75||L3@GW@44088******75\&quot;,\&quot;creditable_level_of_account_way_list\&quot;:[&#123;\&quot;auth_time\&quot;:\&quot;2018-02-28 16:45:26\&quot;,\&quot;uniqueid\&quot;:\&quot;***86f93fb61***\&quot;,\&quot;user_name\&quot;:\&quot;郭**\&quot;,\&quot;auth_identification\&quot;:\&quot;2088******653\&quot;,\&quot;identity_level\&quot;:\&quot;L2\&quot;,\&quot;credential_no\&quot;:\&quot;44088******75\&quot;,\&quot;way_code\&quot;:\&quot;YSS\&quot;&#125;,&#123;\&quot;auth_time\&quot;:null,\&quot;uniqueid\&quot;:\&quot;***764486f93fb61212***\&quot;,\&quot;user_name\&quot;:\&quot;郭**\&quot;,\&quot;auth_identification\&quot;:\&quot;44088******75\&quot;,\&quot;identity_level\&quot;:\&quot;L0\&quot;,\&quot;credential_no\&quot;:\&quot;44088******75\&quot;,\&quot;way_code\&quot;:\&quot;IDV\&quot;&#125;,&#123;\&quot;auth_time\&quot;:\&quot;2018-02-13 17:12:31\&quot;,\&quot;uniqueid\&quot;:\&quot;*****764486f93fb612122*****\&quot;,\&quot;user_name\&quot;:\&quot;郭**\&quot;,\&quot;auth_identification\&quot;:\&quot;44088******75\&quot;,\&quot;identity_level\&quot;:\&quot;L3\&quot;,\&quot;credential_no\&quot;:\&quot;44088******75\&quot;,\&quot;way_code\&quot;:\&quot;GW\&quot;&#125;],\&quot;creditable_level_of_account\&quot;:\&quot;L3\&quot;&#125;&#125;,\&quot;time_stamp\&quot;:\&quot;20200821\&quot;,\&quot;version \&quot;:\&quot;v1\&quot;,\&quot;sign\&quot;:\&quot;rxf0MFT7eQqYgYKWtgzNBi6mhS2tbqkPgI \&quot;&#125;&quot;);</span><br><span class="line">        System.out.println(xmlstr);</span><br><span class="line">        createXMLFile(formatXML(xmlstr), &quot;测试&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * xml转json字符串 注意:路径和字符串二传一另外一个传null&lt;br&gt;</span><br><span class="line">     * 方 法 名：xmlToJson &lt;br&gt;</span><br><span class="line">     * @param xmlPath xml路径(和字符串二传一,两样都传优先使用路径)</span><br><span class="line">     * @param xmlStr xml字符串(和路径二传一,两样都传优先使用路径)</span><br><span class="line">     * @return String</span><br><span class="line">     * @throws IOException</span><br><span class="line">     * @throws JDOMException</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static String xmlToJson(String xmlPath,String xmlStr)&#123;</span><br><span class="line">        SAXBuilder sbder = new SAXBuilder();</span><br><span class="line">        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">        Document document;</span><br><span class="line">        try &#123;</span><br><span class="line">            if(xmlPath!=null)&#123;</span><br><span class="line">                //路径</span><br><span class="line">                document = sbder.build(new File(xmlPath));</span><br><span class="line">            &#125;else if(xmlStr!=null)&#123;</span><br><span class="line">                //xml字符</span><br><span class="line">                StringReader reader = new StringReader(xmlStr);</span><br><span class="line">                InputSource ins = new InputSource(reader);</span><br><span class="line">                document = sbder.build(ins);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return &quot;&#123;&#125;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            //获取根节点</span><br><span class="line">            Element el =  document.getRootElement();</span><br><span class="line">            List&lt;Element&gt; eList =  el.getChildren();</span><br><span class="line">            Map&lt;String, Object&gt; rootMap = new HashMap&lt;String, Object&gt;();</span><br><span class="line">            //得到递归组装的map</span><br><span class="line">            rootMap = xmlToMap(eList,rootMap);</span><br><span class="line">            map.put(el.getName(), rootMap);</span><br><span class="line">            //将map转换为json 返回</span><br><span class="line">            return JSON.toJSONString(map);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return &quot;&#123;&#125;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * json转xml&lt;br&gt;</span><br><span class="line">     * 方 法 名：jsonToXml &lt;br&gt;</span><br><span class="line">     * @param json</span><br><span class="line">     * @return String</span><br><span class="line">     */</span><br><span class="line">    public static String jsonToXml(String json)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            StringBuffer buffer = new StringBuffer();</span><br><span class="line">            buffer.append(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&quot;);</span><br><span class="line">            buffer.append(&quot;&lt;base&gt;&quot;);</span><br><span class="line">            JSONObject jObj = JSON.parseObject(json);</span><br><span class="line">            jsonToXmlstr(jObj,buffer);</span><br><span class="line">            buffer.append(&quot;&lt;/base&gt;&quot;);</span><br><span class="line">            return buffer.toString();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * json转str&lt;br&gt;</span><br><span class="line">     * 方 法 名：jsonToXmlstr &lt;br&gt;</span><br><span class="line">     * @param jObj</span><br><span class="line">     * @param buffer</span><br><span class="line">     * @return String</span><br><span class="line">     */</span><br><span class="line">    public static String jsonToXmlstr(JSONObject jObj,StringBuffer buffer )&#123;</span><br><span class="line">        Set&lt;Entry&lt;String, Object&gt;&gt;  se = jObj.entrySet();</span><br><span class="line">        for( Iterator&lt;Entry&lt;String, Object&gt;&gt;   it = se.iterator();  it.hasNext(); )</span><br><span class="line">        &#123;</span><br><span class="line">            Entry&lt;String, Object&gt; en = it.next();</span><br><span class="line">            if(en.getValue() != null &amp;&amp; en.getValue().getClass().getName().equals(&quot;com.alibaba.fastjson.JSONObject&quot;))&#123;</span><br><span class="line">                buffer.append(&quot;&lt;&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">                JSONObject jo = jObj.getJSONObject(en.getKey());</span><br><span class="line">                jsonToXmlstr(jo,buffer);</span><br><span class="line">                buffer.append(&quot;&lt;/&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">            &#125;else if(en.getValue() != null &amp;&amp; en.getValue().getClass().getName().equals(&quot;com.alibaba.fastjson.JSONArray&quot;))&#123;</span><br><span class="line">                if (en.getKey().equals(&quot;extproperties&quot;)) &#123;</span><br><span class="line">                    JSONArray ja = jObj.getJSONArray(en.getKey());</span><br><span class="line">                    Iterator&lt;Object&gt; it1 = ja.iterator();</span><br><span class="line">                    List&lt;String&gt; list=new ArrayList&lt;String&gt;();</span><br><span class="line">                    while (it1.hasNext()) &#123;</span><br><span class="line">                        String ob = (String) it1.next();</span><br><span class="line">                        System.out.println(ob);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    JSONArray jarray = jObj.getJSONArray(en.getKey());</span><br><span class="line">                    for (int i = 0; i &lt; jarray.size(); i++) &#123;</span><br><span class="line">                        buffer.append(&quot;&lt;&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">                        JSONObject jsonobject =  jarray.getJSONObject(i);</span><br><span class="line">                        jsonToXmlstr(jsonobject,buffer);</span><br><span class="line">                        buffer.append(&quot;&lt;/&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;else if(en.getValue() != null &amp;&amp; en.getValue().getClass().getName().equals(&quot;java.lang.String&quot;))&#123;</span><br><span class="line">                buffer.append(&quot;&lt;&quot;+en.getKey()+&quot;&gt;&quot;+en.getValue());</span><br><span class="line">                buffer.append(&quot;&lt;/&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                buffer.append(&quot;&lt;&quot;+en.getKey()+&quot;&gt;&quot;+&quot;&quot;);</span><br><span class="line">                buffer.append(&quot;&lt;/&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 节点转map&lt;br&gt;</span><br><span class="line">     * 方 法 名：xmlToMap &lt;br&gt;</span><br><span class="line">     * @param eList</span><br><span class="line">     * @param map</span><br><span class="line">     * @return Map&lt;String,Object&gt;</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static Map&lt;String, Object&gt; xmlToMap(List&lt;Element&gt; eList,Map&lt;String, Object&gt; map)&#123;</span><br><span class="line">        for (Element e : eList) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; eMap = new HashMap&lt;String, Object&gt;();</span><br><span class="line">            List&lt;Element&gt; elementList = e.getChildren();</span><br><span class="line">            if(elementList!=null&amp;&amp;elementList.size()&gt;0)&#123;</span><br><span class="line">                eMap = xmlToMap(elementList,eMap);</span><br><span class="line">                Object obj = map.get(e.getName());</span><br><span class="line">                if(obj!=null)&#123;</span><br><span class="line">                    List&lt;Object&gt; olist = new ArrayList&lt;Object&gt;();</span><br><span class="line">                    if(obj.getClass().getName().equals(&quot;java.util.HashMap&quot;))&#123;</span><br><span class="line">                        olist.add(obj);</span><br><span class="line">                        olist.add(eMap);</span><br><span class="line"></span><br><span class="line">                    &#125;else if(obj.getClass().getName().equals(&quot;java.util.ArrayList&quot;))&#123;</span><br><span class="line">                        olist = (List&lt;Object&gt;)obj;</span><br><span class="line">                        olist.add(eMap);</span><br><span class="line">                    &#125;</span><br><span class="line">                    map.put(e.getName(), olist);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    map.put(e.getName(), eMap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                map.put(e.getName(), e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将已经格式化的xml字符串写入xml文件</span><br><span class="line">     * @param xmlStr</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean createXMLFile(String xmlStr,String xmlName)&#123;</span><br><span class="line">        boolean flag = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            XMLWriter output = null;</span><br><span class="line">            //OutputFormat   format   =   OutputFormat.createPrettyPrint();</span><br><span class="line">            //format.setSuppressDeclaration(true);</span><br><span class="line">            // format.setEncoding(&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">            //如果上面设置的xml编码类型为GBK，则应当用FileWriter来构建xml文件，否则会出现中文连码问题</span><br><span class="line">                /*outpt = new XMLWriter(</span><br><span class="line">                        new FileWriter(</span><br><span class="line">                                new File(&quot;D:/myeclipse/Workspaces/fusionChartsDemoTest/WebRoot/xml/&quot;+xmlName+&quot;.xml&quot;)) ,</span><br><span class="line">                                    format);</span><br><span class="line">                  */</span><br><span class="line"></span><br><span class="line">            //如果上面设置的xml编码类型为utf-8，则应当用FileOutputStream来构建xml文件，否则还是会出现问题</span><br><span class="line">            output = new XMLWriter(</span><br><span class="line">                    new FileOutputStream(</span><br><span class="line">                            new File(&quot;D:/&quot;+xmlName+&quot;.xml&quot;)));</span><br><span class="line">            output.setEscapeText(false);</span><br><span class="line">            output.write( xmlStr );</span><br><span class="line">            output.close();</span><br><span class="line">            return flag = true;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  String formatXML(String str) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        SAXReader reader=new SAXReader();</span><br><span class="line"></span><br><span class="line">        //创建一个串的字符输入流</span><br><span class="line">        StringReader in=new StringReader(str);</span><br><span class="line">        org.dom4j.Document doc=reader.read(in);</span><br><span class="line">        // 创建输出格式</span><br><span class="line">        OutputFormat formater=OutputFormat.createPrettyPrint();</span><br><span class="line">        //去掉xml文件的版本信息</span><br><span class="line">        //formater.setSuppressDeclaration(true);</span><br><span class="line">        //设置xml的输出编码</span><br><span class="line">        formater.setEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        //创建输出(目标)</span><br><span class="line">        StringWriter out=new StringWriter();</span><br><span class="line">        //创建输出流</span><br><span class="line">        XMLWriter writer=new XMLWriter(out,formater);</span><br><span class="line">        //输出格式化的串到目标中，执行后。格式化后的串保存在out中。</span><br><span class="line">        writer.write(doc);</span><br><span class="line"></span><br><span class="line">        writer.close();</span><br><span class="line"></span><br><span class="line">        // System.out.println(out.toString());</span><br><span class="line"></span><br><span class="line">        //返回我们格式化后的结果</span><br><span class="line">        return out.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程</title>
    <url>/2022/05/21/myblog/java/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="线程池Executor、ExecutorService、Executors三者关系"><a href="#线程池Executor、ExecutorService、Executors三者关系" class="headerlink" title="线程池Executor、ExecutorService、Executors三者关系"></a>线程池Executor、ExecutorService、Executors三者关系</h3><p><img src="/images/Executor%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p>
<p>层次关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ExecutorService extends Executor &#123;&#125;</span><br><span class="line">public abstract class AbstractExecutorService implements ExecutorService &#123;&#125;</span><br><span class="line">public interface ScheduledExecutorService extends ExecutorService &#123;&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolExecutor extends AbstractExecutorService &#123;&#125;</span><br><span class="line">public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>区别：<br>1.ExecutorService 接口继承了Executor 接口，是Executor 的子接口。</p>
<p>2.Executor接口中定义了execute()方法，用来接收一个Runnable接口的对象，而ExecutorService接口中定义的submit()方法可以接收Runnable和Callable接口对象。</p>
<p>3.Executor接口中execute()方法不返回任何结果，而ExecutorService接口中submit()方法可以通过一个 Future 对象返回运算结果。</p>
<p>4.Executor和ExecutorService除了允许客户端提交一个任务，ExecutorService 还提供用来控制线程池的方法。<br>比如：调用 shutDown() 方法终止线程池。</p>
<p>5.Executors 是一个工具类，类似于 Collections。Executors 类提供工厂方法用来创建不同类型的线程池。比如:<br>　　 Executors.newSingleThreadExecutor() 创建一个只有一个线程的线程池，<br>　　 Executors.newFixedThreadPool(int numOfThreads)来创建固定线程数的线程池，<br>　　 Executors.newCachedThreadPool()创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>　　 Executors.newScheduledThreadPool(int corePoolSize) 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p>
<p>转自：<a href="https://www.cnblogs.com/whx20100101/p/9862392.html">https://www.cnblogs.com/whx20100101/p/9862392.html</a></p>
<p>使用Executors还是ExecutorService？<br>当线程池中的线程均处于工作状态，并且线程数已达线程池允许的最大线程数时，就会采取指定的饱和策略来处理新提交的任务。总共有四种策略：<br>AbortPolicy: 直接抛异常<br>CallerRunsPolicy: 用调用者的线程来运行任务<br>DiscardOldestPolicy: 丢弃线程队列里最近的一个任务，执行新提交的任务<br>DiscardPolicy 直接将新任务丢弃</p>
<p>如果使用 Executors 的工厂方法创建的线程池，那么饱和策略都是采用默认的 AbortPolicy，所以如果我们想当线程池已满的情况，使用调用者的线程来运行任务，就要自己创建线程池，指定想要的饱和策略，而不是使用 Executors 了。</p>
<p>所以我们可以根据需要创建 ThreadPoolExecutor(ExecutorService接口的实现类) 对象，自定义一些参数，而不是调用 Executors 的工厂方法创建。</p>
<p>参考：<a href="https://blog.csdn.net/weixin_43921491/article/details/115717604">https://blog.csdn.net/weixin_43921491/article/details/115717604</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutorService executor = new ThreadPoolExecutor(...);</span><br><span class="line">executor.submit(()-&gt;单条语句);</span><br><span class="line"></span><br><span class="line">executor.submit(new Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        dosomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="线程池java-util-concurrent-ThreadPoolExecutor"><a href="#线程池java-util-concurrent-ThreadPoolExecutor" class="headerlink" title="线程池java.util.concurrent.ThreadPoolExecutor"></a>线程池java.util.concurrent.ThreadPoolExecutor</h3><p>构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor(int corePoolSize, </span><br><span class="line">int maximumPoolSize, </span><br><span class="line">long keepAliveTime, </span><br><span class="line">TimeUnit unit, </span><br><span class="line">BlockingQueue workQueue,  </span><br><span class="line">RejectedExecutionHandler handler) </span><br><span class="line"></span><br><span class="line">corePoolSize： 线程池维护线程的最少数量 </span><br><span class="line">maximumPoolSize：线程池维护线程的最大数量 </span><br><span class="line">keepAliveTime： 线程池维护线程所允许的空闲时间 </span><br><span class="line">unit： 线程池维护线程所允许的空闲时间的单位 </span><br><span class="line">workQueue： 线程池所使用的缓冲队列 </span><br><span class="line">handler： 线程池对拒绝任务的处理策略 </span><br><span class="line"></span><br><span class="line">unit可选的参数为java.util.concurrent.TimeUnit中的几个静态属性： </span><br><span class="line">NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS。 </span><br><span class="line"></span><br><span class="line">workQueue可用的队列类是：java.util.concurrent.ArrayBlockingQueue </span><br><span class="line"></span><br><span class="line">handler有四个选择： </span><br><span class="line">（1）ThreadPoolExecutor.AbortPolicy()   抛出java.util.concurrent.RejectedExecutionException异常 </span><br><span class="line">（2）ThreadPoolExecutor.CallerRunsPolicy()  重试添加当前的任务，他会自动重复调用execute()方法 </span><br><span class="line">（3）ThreadPoolExecutor.DiscardOldestPolicy() 抛弃旧的任务 （等待队列里面最早进入的）</span><br><span class="line">（4）ThreadPoolExecutor.DiscardPolicy()     抛弃当前的任务 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当一个任务（ Runnable类型的对象）通过execute(Runnable)方法欲添加到线程池时：<br>1、如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。<br>2、如果此时线程池中的线程数量等于 corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。<br>3、如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的线程数量小于maximumPoolSize，建新的线程来处理被添加的任务。<br>4、如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的线程数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。 </p>
<p>也就是：处理任务的优先级为：<br>核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。 </p>
<p>当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。 </p>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() throws InterruptedException &#123;</span><br><span class="line">    ExecutorService threadPool = new ThreadPoolExecutor(2, 4, 3, TimeUnit.SECONDS,</span><br><span class="line">            new ArrayBlockingQueue&lt;Runnable&gt;(3), new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    class ThreadPoolTask implements Runnable, Serializable &#123;</span><br><span class="line">        private static final long serialVersionUID = 0;</span><br><span class="line">        // 保存任务所需要的数据</span><br><span class="line">        private Object threadPoolTaskData;</span><br><span class="line"></span><br><span class="line">        ThreadPoolTask(Object tasks) &#123;</span><br><span class="line">            this.threadPoolTaskData = tasks;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;start ..&quot; + getTask());</span><br><span class="line">            try &#123;</span><br><span class="line">                // //便于观察，等待一段时间</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            threadPoolTaskData = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Object getTask() &#123;</span><br><span class="line">            return this.threadPoolTaskData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= 8; i++) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 产生一个任务，并将其加入到线程池</span><br><span class="line">            String task = &quot;task@ &quot; + i;</span><br><span class="line">            System.out.println(&quot;put &quot; + task);</span><br><span class="line">            threadPool.submit(new ThreadPoolTask(task));</span><br><span class="line">            // 便于观察，等待一段时间</span><br><span class="line">            Thread.sleep(2);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">    // 也可以直接用lambda表达式往线程池里加线程</span><br><span class="line">    threadPool.submit(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;start ..&quot; + &quot;lambda&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">put task@ 1</span><br><span class="line">pool-1-thread-1start ..task@ 1</span><br><span class="line">put task@ 2</span><br><span class="line">pool-1-thread-2start ..task@ 2</span><br><span class="line">put task@ 3</span><br><span class="line">put task@ 4</span><br><span class="line">put task@ 5</span><br><span class="line">put task@ 6</span><br><span class="line">pool-1-thread-3start ..task@ 6</span><br><span class="line">put task@ 7</span><br><span class="line">pool-1-thread-4start ..task@ 7</span><br><span class="line">put task@ 8</span><br><span class="line">java.util.concurrent.RejectedExecutionException: Task java.util....</span><br><span class="line">pool-1-thread-1start ..task@ 3</span><br><span class="line">pool-1-thread-2start ..task@ 4</span><br><span class="line">pool-1-thread-3start ..task@ 5</span><br><span class="line"></span><br><span class="line">因为线程加入线程池很快，线程都还没处理完，所以最开始先2个线程，</span><br><span class="line">然后3个加入队列，然后再来2个，扩大线程池，再一个就抛出异常了，</span><br><span class="line">慢慢队列中的三个会被执行。</span><br><span class="line"></span><br><span class="line">如果是DiscardOldestPolicy策略，就把最早进入队列的怼出去。</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/abcwywht/article/details/54744152">https://blog.csdn.net/abcwywht/article/details/54744152</a></p>
<p>✅规范创建线程池<br>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式。目的是规避资源耗尽的风险。FixedThreadPool和SingleThreadPool允许请求队列长度Integer.MAX_VALUE，可能堆积大量请求，OOM。CachedThreadPool允许创建线程数量Integer.MAX_VALUE，可能创建大量线程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ThreadPoolDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService threadPool = new ThreadPoolExecutor(2, 4, 0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                new LinkedBlockingDeque&lt;Runnable&gt;(6),</span><br><span class="line">                new ThreadFactory() &#123;</span><br><span class="line">                    AtomicInteger id = new AtomicInteger(0);</span><br><span class="line">                    @Override</span><br><span class="line">                    public Thread newThread(Runnable r) &#123;</span><br><span class="line">                        return new Thread(r, &quot;thread-poolName-&quot; + id.incrementAndGet());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        threadPool.submit(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //可以直接用lambda表达式：</span><br><span class="line">        threadPool.submit(() -&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">        threadPool.execute(() -&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面没加线程池到最大和队列满了该怎么办的参数，可以加。</p>
<h3 id="ThreadPoolExecutor的execute方法和submit方法"><a href="#ThreadPoolExecutor的execute方法和submit方法" class="headerlink" title="ThreadPoolExecutor的execute方法和submit方法"></a>ThreadPoolExecutor的execute方法和submit方法</h3><p>1、execute是Executor接口的方法，而submit是ExecutorService的方法，并且ExecutorService接口继承了Executor接口。</p>
<p>2、execute只接受Runnable参数，没有返回值；而submit可以接受Runnable参数和Callable参数，并且返回了Future对象，可以进行任务取消、获取任务结果、判断任务是否执行完毕&#x2F;取消等操作。</p>
<p>3、submit会对Runnable或Callable入参封装成RunnableFuture对象（同时继承了Runnable接口和Future接口），调用execute方法并返回。FutureTask是实现了RunnableFuture接口</p>
<p>4、通过execute方法提交的任务如果出现异常则直接抛出原异常，是在线程池中的线程中；而submit方法是捕获了异常的，只有当调用Future的get方法时，才会抛出ExecutionException异常，且是在调用get方法的线程。（FutureTask则是将catch到的异常存下来，在get的时候再去判断任务执行状态，如果任务状态是异常，则再抛出ExecutionException异常。）</p>
<p>参考：<a href="https://blog.csdn.net/happyyear1/article/details/122378013">https://blog.csdn.net/happyyear1/article/details/122378013</a><br><a href="https://blog.csdn.net/Mr_Zhang____/article/details/121866974">https://blog.csdn.net/Mr_Zhang____/article/details/121866974</a></p>
<h3 id="ThreadPoolExecutor的submit返回值Future"><a href="#ThreadPoolExecutor的submit返回值Future" class="headerlink" title="ThreadPoolExecutor的submit返回值Future"></a>ThreadPoolExecutor的submit返回值Future</h3><p>✅Executor接口中的execute方法：<br>这个方法是没有返回值的，而且只接受Runnable。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Executor &#123;</span><br><span class="line">    void execute(Runnable command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅ExecutorService接口中的submit方法：<br>这个方法接收两种参数，Callable和Runnable。返回值是Future。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p>✅Callable接口和Runnable接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">  V call() throws Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Runnable &#123;</span><br><span class="line">  public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区别：<br>1、Callable能接受一个泛型，然后在call方法中返回一个这个类型的值。而Runnable的run方法没有返回值<br>2、Callable的call方法可以抛出异常，而Runnable的run方法不会抛出异常。</p>
<p>✅Future接口<br>通过他可以获得任务执行的返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancel(boolean var1);</span><br><span class="line"> </span><br><span class="line">    boolean isCancelled();</span><br><span class="line"> </span><br><span class="line">    boolean isDone();</span><br><span class="line"> </span><br><span class="line">    V get() throws InterruptedException, ExecutionException;  //获取返回值</span><br><span class="line"> </span><br><span class="line">    V get(long var1, TimeUnit var3) throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅submit(Callable task)实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(2);</span><br><span class="line">        //创建一个Callable，3秒后返回String类型</span><br><span class="line">        Callable myCallable = new Callable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String call() throws Exception &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">                System.out.println(&quot;calld方法执行了&quot;);</span><br><span class="line">                return &quot;call方法返回值&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(&quot;提交任务之前 &quot;+getStringDate());</span><br><span class="line">        Future future = executor.submit(myCallable);</span><br><span class="line">        System.out.println(&quot;提交任务之后，获取结果之前 &quot;+getStringDate());</span><br><span class="line">        System.out.println(&quot;获取返回值: &quot;+future.get());</span><br><span class="line">        System.out.println(&quot;获取到结果之后 &quot;+getStringDate());</span><br><span class="line">    &#125;</span><br><span class="line">    public static String getStringDate() &#123;</span><br><span class="line">        Date currentTime = new Date();</span><br><span class="line">        SimpleDateFormat formatter = new SimpleDateFormat(&quot;HH:mm:ss&quot;);</span><br><span class="line">        String dateString = formatter.format(currentTime);</span><br><span class="line">        return dateString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">提交任务之前 09:09:28</span><br><span class="line">提交任务之后，获取结果之前 09:09:29</span><br><span class="line">calld方法执行了</span><br><span class="line">获取返回值: call方法返回值</span><br><span class="line">获取到结果之后 09:09:32</span><br></pre></td></tr></table></figure>

<p>✅get()方法的阻塞性</p>
<p>通过上面的输出可以看到，在调用submit提交任务之后，主线程本来是继续运行了。但是运行到future.get()的时候就阻塞住了，一直等到任务执行完毕，拿到了返回的返回值，主线程才会继续运行。</p>
<p>这里注意一下，他的阻塞性是因为调用get()方法时，任务还没有执行完，所以会一直等到任务完成，形成了阻塞。</p>
<p>任务是在调用submit方法时就开始执行了，如果在调用get()方法时，任务已经执行完毕，那么就不会造成阻塞。</p>
<p>submit多个任务时，总阻塞时间是最长的那个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Callable myCallable = new Callable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">        System.out.println(&quot;calld方法执行了&quot;);</span><br><span class="line">        return &quot;call方法返回值&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Callable myCallable2 = new Callable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        System.out.println(&quot;calld2方法执行了&quot;);</span><br><span class="line">        return &quot;call2方法返回值&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(&quot;提交任务之前 &quot;+getStringDate());</span><br><span class="line">Future future = executor.submit(myCallable);</span><br><span class="line">Future future2 = executor.submit(myCallable2);</span><br><span class="line">System.out.println(&quot;提交任务之后 &quot;+getStringDate());</span><br><span class="line">System.out.println(&quot;开始获取第一个返回值 &quot;+getStringDate());</span><br><span class="line">System.out.println(&quot;获取返回值: &quot;+future.get());</span><br><span class="line">System.out.println(&quot;获取第一个返回值结束，开始获取第二个返回值 &quot;+getStringDate());</span><br><span class="line">System.out.println(&quot;获取返回值2: &quot;+future2.get());</span><br><span class="line">System.out.println(&quot;获取第二个返回值结束 &quot;+getStringDate());</span><br><span class="line"></span><br><span class="line">提交任务之前 14:14:47</span><br><span class="line">提交任务之后 14:14:48</span><br><span class="line">开始获取第一个返回值 14:14:48</span><br><span class="line">calld2方法执行了</span><br><span class="line">calld方法执行了</span><br><span class="line">获取返回值: call方法返回值</span><br><span class="line">获取第一个返回值结束，开始获取第二个返回值 14:14:53</span><br><span class="line">获取返回值2: call2方法返回值</span><br><span class="line">获取第二个返回值结束 14:14:53</span><br></pre></td></tr></table></figure>

<p>✅submit(Runnable task, T result)实现</p>
<p>虽然submit传入Runnable不能直接返回内容，但是可以通过submit(Runnable task, T result)传入一个载体，通过这个载体获取返回值。这个其实不能算返回值了，是交给线程处理一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(2); //不推荐这样创建</span><br><span class="line">    Result res = new Result();</span><br><span class="line">    Future&lt;Result&gt; future = executor.submit(new MyThread(res), res);</span><br><span class="line">    System.out.println(&quot;返回的结果  name: &quot; + future.get().getName()); //新名字</span><br><span class="line">    System.out.println(&quot;原来的Data  name: &quot; + res.getName()); //原来的也变成了新名字</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class MyThread implements Runnable &#123;</span><br><span class="line">    private Result result;</span><br><span class="line">    public MyThread(Result result) &#123;</span><br><span class="line">        this.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">            System.out.println(&quot;线程  执行:&quot;);</span><br><span class="line">            result.setName(&quot;新名字&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public static class Result &#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️T是Runnable里面的属性，创建时传入，线程中赋值，get方法拿到，之前传入的变量也跟着变化。</p>
<p>✅get(long var1, TimeUnit var3)<br>前面都是用的get()方法获取返回值，那么因为这个方法是阻塞的，有时需要等很久。所以有时候需要设置超时时间。</p>
<p>get(long var1, TimeUnit var3)这个方法就是设置等待时间的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Future future1 = executor.submit(myCallable);</span><br><span class="line">System.out.println(&quot;开始拿结果 &quot;+getStringDate());</span><br><span class="line">try &#123;</span><br><span class="line">    System.out.println(&quot;返回的结果是： &quot;+future1.get(3, TimeUnit.SECONDS)+ &quot; &quot;+getStringDate());</span><br><span class="line">&#125; catch (TimeoutException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    System.out.println(&quot;超时了 &quot;+getStringDate());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;结束拿结果 &quot;+getStringDate());</span><br><span class="line"></span><br><span class="line">过了三秒就抛出超时异常了，主线程继续运行，不会再继续阻塞。</span><br></pre></td></tr></table></figure>


<p>✅execute与submit的异常处理</p>
<p>使用submit方法还有一个特点就是，他的异常可以在主线程中catch到。<br>而使用execute方法执行任务是捕捉不到异常的。<br>用下面这个Runnable来说,这个 里面一定会抛出一个异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runnable myRunnable = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        executor.execute(null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用execute：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">            executor.execute(myRunnable);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;抓到异常 &quot;+e.getMessage());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>不会输出抓到异常那行日志，输出是在线程pool-1-thread-1中，并不是在主线程中。说明主线程的catch不能捕捉到这个异常。异常在线程中直接抛出。</p>
<p>使用submit：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">           Future future1= executor.submit(myCallable);</span><br><span class="line">            future1.get();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;抓到异常 &quot;+e.getMessage());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以抓到异常。得有get方法。</p>
<p>转自：<a href="https://blog.csdn.net/zdx1515888659/article/details/109537577">https://blog.csdn.net/zdx1515888659/article/details/109537577</a></p>
<p>✅项目中的线程池中异常捕获<br>项目中想将线程池中线程的异常在外面捕获到，传递给前端。<br>所以用submit方法，返回Future&lt;?&gt;，在submit方法后直接get，future.get()，有两个异常需要处理：ExecutionException、InterruptException，直接方法上throws出去。调用这个方法的方法要不也throws（给前端透出异常），要不就try..catch..打log（这样无法给前端透出异常）。<br>⚠️注意：用get方法相当于是阻塞了，本来起线程，把要执行的动作交给线程池里的线程(submit)，然后不需要管线程执行完就直接退出干别的了，加了get的话，就要等线程执行完了。如果是大量任务一次交给线程池(线程池里的队列)，需要考虑get带来的阻塞性是否能接受。本来想异步，加了get捕获异常之后，变成同步的了。</p>
<p>🤔线程池中的线程出现异常，get方法这里会报异常，如果是throws，异常抛出到外面，线程池里的其他线程不受影响。外面的方法如果没有catch会中断。</p>
<p>🤔那么问题来了，get超时了的话，线程池中的线程还在继续做吗？<br>首先，countDownLatch超时了是继续做的。<br>future.get(2,TimeUnit.SECOND);<br>如果超时了，线程中断，会报异常TimeOutExcepTion，看是不是要捕获了。<br>即使捕获了，线程也不会继续执行了。</p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>场景：做多线程并行优化，多线程写入一个文件，首先输入流是可以共享的，只是需要重新定义一个做传递（不管是普通变量还是引用变量），但是for循环里面线程submit完，直接走到主线程上传文件的部分，这时线程池内线程还没往文件里写东西，上传了一个空文件。</p>
<p>想要：做一个同步，知道线程都执行完了，才进行下一步，起到阻塞的作用。</p>
<p>CountDownLatch可以做到，当做一个计数器，计算多少个线程执行完了：</p>
<p>让一些线程阻塞直到另外一些完成后才被唤醒。<br>CountDownLatch主要有两个方法：<br>（1）当一个或多个线程调用await方法时,线程会被阻塞，直到满足条件.<br>（2）其他线程调用countDown方法计数器减1(调用countDown方法时线程不会阻塞),当计数器的值变为0,因调用await方法被阻塞的线程会被唤醒,继续执行。<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/li1325169021/article/details/122353217">https://blog.csdn.net/li1325169021/article/details/122353217</a></p>
<p>实例：模拟公司所有员工都下班后，值班人员锁门离开公司。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">public class CountDownLatchDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        closeDoor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void closeDoor() throws InterruptedException &#123;</span><br><span class="line">        //创建CountDownLatch,初始容量为10，模拟10名员工</span><br><span class="line">        CountDownLatch countDownLatch=new CountDownLatch(10);</span><br><span class="line">        for (int i=1;i&lt;=10;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + &quot;忙完工作，下班。&quot;);</span><br><span class="line">                //计数器减1</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;,&quot;员工编号：&quot;+String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        //当计数器的值变为0,因调用await方法被阻塞的线程会被唤醒,继续执行</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t值班人员锁门离开公司&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分三步：</p>
<p>1、线程池外定义初始计数：<br>CountDownLatch countDownLatch&#x3D;new CountDownLatch(10);<br>2、线程池内executorService.submit()的线程new Runnable(){@Overide public void run() {}} run方法内，线程执行完毕后：<br>countDownLatch.countDown();<br>3、最后要进行操作前：<br>countDownLatch.await();</p>
<p>✅countDownLatch超时终止：<br><code>latch.await(10, TimeUnit.SECONDS);  //等待10秒后，如果线程没有执行完，则不再等待，进入后续</code></p>
<p>超时后，线程依然会执行，不会中断。</p>
<h3 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h3><p>1、public interface ScheduledExecutorService extends ExecutorService 延迟或定期执行任务。 </p>
<p>2、schedule 方法使用各种延迟创建任务，并返回一个可用于取消或检查执行的任务对象</p>
<p>3、scheduleAtFixedRate 和 scheduleWithFixedDelay 方法创建并执行某些在取消前一直定期运行的任务</p>
<p>4、所有的 schedule 方法都接受相对延迟和周期作为参数，而不是绝对的时间或日期</p>
<p>5、SheduleExecutorService 是JDK 1.5出来的，比以前的 Timer 性能好</p>
<p>Timer用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() throws InterruptedException &#123;</span><br><span class="line">    TimerTask task = new TimerTask() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;Task performed on: &quot; + new Date() + &quot;n&quot; +</span><br><span class="line">                    &quot;Thread&#x27;s name: &quot; + Thread.currentThread().getName());</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;later: &quot; + new Date() + &quot;n&quot; +</span><br><span class="line">                    &quot;Thread&#x27;s name: &quot; + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Timer timer = new Timer(&quot;Timer&quot;);</span><br><span class="line"></span><br><span class="line">    long delay = 100L;</span><br><span class="line">    // 第一个参数是TimeTask对象，第二个参数是延迟（只有第二个参数时执行一次），第三个参数是周期执行的周期</span><br><span class="line">    timer.schedule(task, delay, 4000);</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Timer中，如果任务执行时间&gt;周期，则会等待上一个任务执行完，立马执行第二个。</p>
<p>✅用ScheduledExecutorService.scheduleAtFixedRate：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test5() throws InterruptedException &#123;</span><br><span class="line">    ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">    executorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125;catch (Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot; run : &quot;+ System.currentTimeMillis());</span><br><span class="line">    &#125;, 0, 1000, TimeUnit.MILLISECONDS);</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，如果任务执行时间&gt;周期，则会等上一个执行完立马执行下一个。</p>
<p>✅用ScheduledExecutorService.scheduleAtFixedRate：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test6() throws InterruptedException &#123;</span><br><span class="line">    ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">    executorService.scheduleWithFixedDelay(()-&gt;&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125;catch (Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot; go : &quot;+ System.currentTimeMillis());</span><br><span class="line">    &#125;, 0, 1000, TimeUnit.MILLISECONDS);</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与scheduleAtFixedRate：不同的是：这个是等上一个执行完，delay多长时间后，再执行下一个。</p>
<p>✅ScheduledExecutorService对象的创建方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、Executors工具类来创建</span><br><span class="line">ScheduledExecutorService executorService1 = Executors.newScheduledThreadPool(3);</span><br><span class="line">创建一个线程池，它可安排在给定延迟后运行任务或者定期地执行任务。</span><br><span class="line">corePoolSize - 池中所保存的线程数，即使线程是空闲的也包括在内。</span><br><span class="line">运行发现有多个线程执行，但是效果一样。</span><br><span class="line"></span><br><span class="line">可以传参ThreadFactory，用来命名和设置守护线程</span><br><span class="line">ScheduledExecutorService executorService2 = Executors.newSingleThreadScheduledExecutor(r -&gt; &#123;</span><br><span class="line">    Thread t = new Thread(r, &quot;myThread&quot;);</span><br><span class="line">    t.setDaemon(true); //设置为守护线程</span><br><span class="line">    return t;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">2、Executors工具类来创建</span><br><span class="line">ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行任务。</span><br><span class="line">可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。 </span><br><span class="line">同样这是一个无界的任务队列，即虽然线程只有一个，但是新增的任务会在队列中排队等待执行</span><br><span class="line"></span><br><span class="line">3、用ScheduledExecutorService 的实现类 ScheduledThreadPoolExecutor（推荐）</span><br><span class="line">ScheduledExecutorService executorService1 = new ScheduledThreadPoolExecutor(1);</span><br></pre></td></tr></table></figure>

<p>✅规范创建：<br>要使用带有ThreadFactory参数的ScheduledThreadPoolExecutor构造方法创建，这样可以方便设置线程名字。方便出措时回溯。并且提供自定义的ThreadFactory实现或三方实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService executorService3 = new ScheduledThreadPoolExecutor(1, new ThreadFactory() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Thread newThread(Runnable r) &#123;</span><br><span class="line">        return new Thread(r, &quot;myThread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ScheduledExecutorService executorService4 = new ScheduledThreadPoolExecutor(1,</span><br><span class="line">    new BasicThreadFactory.Builder().namingPattern(&quot;myThread&quot;).daemon(true).build());</span><br></pre></td></tr></table></figure>


<h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><p>用来创建线程的，其中也只是有一个newthread方法。</p>
<p>作用：<br>给线程命名，查看创建线程数<br>给线程设置是否是后台运行<br>设置线程优先级</p>
<p>自定义ThreadFactory：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.demo.factory;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ThreadFactory;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class MyThreadFactory implements ThreadFactory&#123;</span><br><span class="line"></span><br><span class="line">    private AtomicInteger atomicInteger = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    private boolean isDaemon;</span><br><span class="line"></span><br><span class="line">    public MyThreadFactory(boolean isDaemon)&#123;</span><br><span class="line">        this.isDaemon = isDaemon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Thread newThread(Runnable r) &#123;</span><br><span class="line">        atomicInteger.incrementAndGet();</span><br><span class="line">        Thread thread =  new MyWorkThread(atomicInteger,r);</span><br><span class="line">        thread.setDaemon(isDaemon);</span><br><span class="line">        return thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool(new MyThreadFactory(false));</span><br><span class="line">        for (int i=0;i&lt;1000;i++)&#123;</span><br><span class="line">            executorService.execute(new TestRunnable(String.valueOf(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class TestRunnable implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        private String msg;</span><br><span class="line"></span><br><span class="line">        public TestRunnable(String msg)&#123;</span><br><span class="line">            this.msg = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;runnable:&quot;+msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅三种创建 ThreadFactory 的方式</p>
<p>第一种 CustomizableThreadFactory<br>Spring 框架提供的 CustomizableThreadFactory。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ThreadFactory springThreadFactory = new CustomizableThreadFactory(&quot;springThread-pool-&quot;);</span><br></pre></td></tr></table></figure>

<p>第二种 ThreadFactoryBuilder<br>Google guava 工具类 提供的 ThreadFactoryBuilder ,使用链式方法创建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ThreadFactory guavaThreadFactory = new ThreadFactoryBuilder().setNameFormat(&quot;retryClient-pool-&quot;).build();</span><br><span class="line">//-pool-后面加%d ？</span><br></pre></td></tr></table></figure>

<p>第三种 BasicThreadFactory<br>Apache commons-lang3 提供的 BasicThreadFactory.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ThreadFactory basicThreadFactory = new BasicThreadFactory.Builder().namingPattern(&quot;basicThreadFactory-&quot;).build();</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/u010648555/article/details/106137206/">https://blog.csdn.net/u010648555/article/details/106137206/</a></p>
<h3 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h3><p>进程：操作系统结构的基础、操作系统进行资源分配和调度的独立单元<br>线程：进程中独立运行的子任务，程序执行的单元。<br>例如：启动jvm相当于起了一个进程，jvm内：main方法、垃圾回收等相当于多个线程。<br>cpu是运算和控制的中心，在cpu的运行过程中，同一时刻只能执行一个进程。<br>多线程下，cpu在不同的线程之间进行切换，多线程不一定比单线程快。<br>多线程执行时，执行顺序是随机的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread.sleep(1000);  //休息1s，以毫秒为单位。</span><br><span class="line"></span><br><span class="line">新建Thread线程：</span><br><span class="line">Thread thread = new Thread(new Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        dosomething();</span><br><span class="line">    &#125;, &quot;name&quot;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<h4 id="start、run、join方法"><a href="#start、run、join方法" class="headerlink" title="start、run、join方法"></a>start、run、join方法</h4><p>start： 用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。 </p>
<p>run： run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</p>
<p>总结：调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用 run()方法，这是由jvm的内存机制规定的。并且run()方法必须是public访问权限，返回值类型为void。</p>
<p>join方法在线程外使用，表示等待thread线程执行完毕，再继续执行当前join方法所在的线程。在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p>
<p>✅多线程累加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 线程安全的累加</span><br><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line">/**</span><br><span class="line">    * 创建线程</span><br><span class="line">    */</span><br><span class="line">class CreateThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private int num = 1;</span><br><span class="line">    private final Object lock = new Object(); //使用一个Java对象作为一个锁</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                if (num &lt;= 100) &#123;</span><br><span class="line">                    System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot;  num: &quot; + num );</span><br><span class="line">                    num++;</span><br><span class="line">                    lock.notifyAll(); //不加也一样</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 必须共用一个Runnable</span><br><span class="line">CreateThread myThread1 = new CreateThread();</span><br><span class="line">Thread thread1 = new Thread(myThread1, &quot;thread1&quot;);</span><br><span class="line">Thread thread2 = new Thread(myThread1, &quot;thread2&quot;);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅线程休眠等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() throws InterruptedException &#123;</span><br><span class="line">    // 线程类还必须放前面</span><br><span class="line">    class CreateThread1 implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;线程执行&quot;);</span><br><span class="line">            Thread.yield(); //线程让步</span><br><span class="line">            System.out.println(&quot;继续执行&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread thread1 = new Thread(new CreateThread1(), &quot;thread1&quot;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.join();  //插队执行</span><br><span class="line">    System.out.println(&quot;main线程&quot;);</span><br><span class="line">    Thread.sleep(1000 * 10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>单测方法有一个问题，当单测方法结束的时候，里面的线程也要结束，不管是不是执行完成。单测方法结束的时候会把里面的资源释放掉，导致里面的线程提前结束。<br>结论：尽量不要在test中开启线程，开启的话，sleep一下，等线程执行完。</p>
<p>但是在main方法中，main方法执行完以后子线程并不会退出，因为子线程是非守护线程。</p>
<p>首先，JVM程序在什么情况下能够正常退出<br>The Java Virtual Machine exits when the only threads running are all daemon threads.<br>当JVM中不存在任何一个正在运行的非守护线程时，则JVM进程即会退出。<br>main线程是一个非守护线程。只剩下守护线程，就会退出。</p>
<p>什么是守护线程？<br>在Java中有两类线程：</p>
<ul>
<li>User Thread(用户线程)</li>
<li>Daemon Thread(守护线程)</li>
</ul>
<p>JVM中的垃圾回收就是典型的守护线程，当JVM要退出时，如果垃圾回收线程还在运行，导致程序无法退出。这就很尴尬了。守护线程主要是为了给其他的线程提供服务，比如说计时器，清空高速缓存等等操作。当被守护线程死亡，守护线程往往也会死亡，当虚拟机中只剩下守护线程时，虚拟机就会退出，因为此时也没有运行程序的必要了</p>
<p>守护线程经常被用来执行一些后台任务，如果你希望JVM退出时，线程能够正常退出，守护线程是你的首选。<br>守护线程应该永远不去访问固有资源，比如说文件或者数据库，因为它会在任何时候甚至一个操作的中间发生中断。</p>
<h3 id="Synchronized同步锁"><a href="#Synchronized同步锁" class="headerlink" title="Synchronized同步锁"></a>Synchronized同步锁</h3><p>synchronized的作用是保证在同一时刻， 被修饰的代码块或方法只会有一个线程执行，以达到保证并发安全的效果。</p>
<p>synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。</p>
<p>在JDK1.5之前synchronized是一个重量级锁，相对于j.u.c.Lock，它会显得那么笨重，随着Javs SE 1.6对synchronized进行的各种优化后，synchronized并不会显得那么重了。</p>
<p>synchronized的作用主要有三个：</p>
<p>原子性：确保线程互斥地访问同步代码；<br>可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的“对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值” 来保证的；<br>有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”；<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/m0_53474063/article/details/112389756">https://blog.csdn.net/m0_53474063/article/details/112389756</a></p>
<p>✅wait方法、notify方法、notifyAll方法</p>
<p>等待池：<br>假设线程 A 调用了锁对象的 wait() 方法，则 A线程就会释放该对象的锁(因为 wait() 方法必须出现在 synchronized 中，所以在执行 wait() 方法之前 A线程就已经拥有了该对象的锁)，同时线程 A进入到了该对象的等待池中。如果有其它线程调用了相同对象的 notifyAll() 方法，那么处于该对象的等待池中的线程就会全部进入该对象的锁池中，重新争夺锁的拥有权。如果另外的一个线程调用了相同对象的 notify() 方法，那么仅仅有一个处于该对象的等待池中的线程(随机)会进入该对象的锁池。</p>
<p>锁池：<br>假设线程 A已经拥有了锁，而其它的线程想要调用该对象的 synchronized 方法(或者 synchronized 块)，其他未获得锁的线程在进入对象的 synchronized 方法之前都需要先获得该对象的锁的拥有权，但是该对象的锁目前正被 A线程拥有，所以这些线程就进入了该对象的锁池中。</p>
<h3 id="leeco-按序打印"><a href="#leeco-按序打印" class="headerlink" title="leeco 按序打印"></a>leeco 按序打印</h3><p>三个不同的线程 A、B、C，调用同一个类的三个不同的方法，想要异步调用三个线程，但是实现线程调用类中方法的同步输出。实现异步转同步的操作。<br>线程内run方法里面负责打印。<br>比如先调用second，再调用first，输出的是first-second。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line"></span><br><span class="line">    public Foo() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object lock = new Object(); //得定义，不然是null</span><br><span class="line">    private Integer index = 1;</span><br><span class="line"></span><br><span class="line">    public void first(Runnable printFirst) throws InterruptedException &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">            while(index != 1) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            printFirst.run();</span><br><span class="line">            index++;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void second(Runnable printSecond) throws InterruptedException &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">            while(index != 2) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            printSecond.run();</span><br><span class="line">            index++;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void third(Runnable printThird) throws InterruptedException &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">            while(index != 3) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            printThird.run();</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leeco-交替打印FooBar"><a href="#leeco-交替打印FooBar" class="headerlink" title="leeco 交替打印FooBar"></a>leeco 交替打印FooBar</h3><p>两个不同的线程将会共用一个 FooBar实例，分别调用两个打印方法，保证线程是交替打印的。<br>需要加循环，循环里面再抢锁。如果不加循环，wait之后进入等待池，其他线程notifyAll，只是告诉其他线程可以抢锁，并不是唤醒其他线程让他们开始抢锁。抢锁这个动作还是需要自己触发的。<br>如果把循环加在synchronized里面就不对了，没有主动触发抢锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class FooBar &#123;</span><br><span class="line">    private int n;</span><br><span class="line"></span><br><span class="line">    public FooBar(int n) &#123;</span><br><span class="line">        this.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object lock = new Object();</span><br><span class="line">    private Integer index = 1;</span><br><span class="line"></span><br><span class="line">    public void foo(Runnable printFoo) throws InterruptedException &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            synchronized(lock) &#123;</span><br><span class="line">                if(index != 1) &#123; //不需要while，if就行</span><br><span class="line">                //表示的是拿错锁了，释放掉</span><br><span class="line">                    lock.wait();</span><br><span class="line">                    //wait进入锁池，再进来就是重新获锁进来了</span><br><span class="line">                &#125;</span><br><span class="line">                //锁拿对了，就进行处理</span><br><span class="line">                printFoo.run();</span><br><span class="line">                index =2;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void bar(Runnable printBar) throws InterruptedException &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            synchronized(lock) &#123;</span><br><span class="line">                if(index != 2) &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printBar.run();</span><br><span class="line">                index =1;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="synchronized的对象锁和类锁"><a href="#synchronized的对象锁和类锁" class="headerlink" title="synchronized的对象锁和类锁"></a>synchronized的对象锁和类锁</h3><p>上面的两个leeco例子中，因为是创建一个对象进行调用，多线程共享那个lock，所以lock不需要static，只需要对象锁。但是如果创建多个对象调用，就需要类锁了。（比如接口的方法要控制多个请求同步）</p>
<p>synchronized关键字可以用在方法和代码块上。这些方法或者代码块可以使静态的也可以是非静态的。</p>
<p>对象锁-一个对象一把锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DemoClass &#123;</span><br><span class="line">    public synchronized void demoMethod()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DemoClass &#123;</span><br><span class="line">    public void demoMethod()&#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DemoClass &#123;</span><br><span class="line">    private final Object lock = new Object();</span><br><span class="line">    public void demoMethod()&#123;</span><br><span class="line">        synchronized (lock)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>类锁-一个类一把锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DemoClass &#123;</span><br><span class="line">    public synchronized static void demoMethod()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DemoClass&#123;</span><br><span class="line">    public void demoMethod()&#123;</span><br><span class="line">        synchronized (DemoClass.class)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DemoClass &#123;</span><br><span class="line">    private final static Object lock = new Object();</span><br><span class="line">    public void demoMethod()&#123;</span><br><span class="line">        synchronized (lock)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>类锁：static synchronized 是要控制类的所有实例的并发访问，static synchronized是限制多线程中该类的所有实例同时访问jvm中该类所对应的代码块。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-22 23:44</span><br><span class="line"> **/</span><br><span class="line">public class SynchroObject extends Thread &#123;</span><br><span class="line">    private static volatile int n = 0;</span><br><span class="line">    private Object lock = new Object();</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            add();</span><br><span class="line">            try &#123;</span><br><span class="line">                sleep(5);</span><br><span class="line">                //测试多线程的private变量，发现多个线程对象的private变量是不同的</span><br><span class="line">                System.out.println(&quot;lock hashcode:&quot; + lock.hashCode());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果同步方法是static的，则多线程正确同步</span><br><span class="line">    //如果同步方法不是static的，则不是正确同步</span><br><span class="line">    private static synchronized void add() &#123;</span><br><span class="line">        n++;</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread threads[] = new Thread[100];</span><br><span class="line">        for (int i = 0; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = new SynchroObject();</span><br><span class="line">        &#125;</span><br><span class="line">        for (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        for (Thread thread : threads) &#123;</span><br><span class="line">            thread.join(); //等待该线程终止</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot; n= &quot; + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：<br>1、synchronized(this){&#x2F;<em>区块</em>&#x2F;} 作用域是当前对象。被synchronized修饰符修饰的实例方法，跟整个方法体被一个synchronized(this) { … } 包围住，意思完全一样。</p>
<p>2、synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法。</p>
<p>3、根据java语言的规定，你不能在构造方法上使用synchronized关键字，这是非法的并且会导致编译错误。</p>
<p>转自：synchronized的对象锁和类锁：<a href="https://www.cnblogs.com/ZenoLiang/p/14713160.html">https://www.cnblogs.com/ZenoLiang/p/14713160.html</a></p>
<p>✅多线程synchronized变量的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-06-27 09:15</span><br><span class="line"> **/</span><br><span class="line">public class ThreadDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建并开启4个线程，模拟四个售票窗口</span><br><span class="line">        SaleThread saleThread = new SaleThread();</span><br><span class="line">        new Thread(new SaleThread(), &quot;窗口1&quot;).start();</span><br><span class="line">        new Thread(new SaleThread(), &quot;窗口2&quot;).start();</span><br><span class="line">        new Thread(new SaleThread(), &quot;窗口3&quot;).start();</span><br><span class="line">        new Thread(new SaleThread(), &quot;窗口4&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SaleThread implements Runnable&#123;</span><br><span class="line">    //大前提：票得是static的，除非创建线程共用一个SaleThread对象</span><br><span class="line">    //不共用Runnable对象的话，且票不是static的，则每个线程各自卖</span><br><span class="line">    private static Integer tickets = 100;  //多线程共享的变量</span><br><span class="line">    //定义任意一个对象，用作同步代码块的锁</span><br><span class="line">    //如果不是static变量，达不到同步效果</span><br><span class="line">    //如果是static变量，多线程对象共享该变量。正确同步。</span><br><span class="line">    //如果上面创建线程用的是同一个SaleThread对象，则不管是不是static的，都是正确同步的。</span><br><span class="line">    private static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                if(tickets&gt;0)&#123;</span><br><span class="line">                    int i = tickets;</span><br><span class="line">                    try&#123;</span><br><span class="line">                        Thread.sleep(1);  //模拟售票耗时过程</span><br><span class="line">                    &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果lock是static，则hashcode一样。tickets的hashcode一直在变</span><br><span class="line">                    System.out.println(lock.hashCode() + &quot;  &quot; + tickets.hashCode());</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            +&quot;正在发售第&quot;+tickets--+&quot;张票&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程共享变量问题"><a href="#多线程共享变量问题" class="headerlink" title="多线程共享变量问题"></a>多线程共享变量问题</h3><p>在并发编程的艺术中探讨了静态变量和成员变量的区别。<br>由static修饰的变量称为静态变量，其实质上就是一个全局变量。<br>本质是说静态变量是类所有对象共享，成员变量是对象专有。</p>
<p>这里探讨一下全局变量和局部变量的区别：</p>
<p>首先各种变量的分类：<br>变量分为全局变量（成员变量）和局部变量，全局变量又分为静态变量和实例变量。<br>所以上边对静态变量和成员变量的区分，应该是静态变量</p>
<p>✅什么是静态变量：<br>1：为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关。<br>2：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。<br>3：被static修饰后的值可以直接类名.值进行引用，而无需new一个对象进行调用<br>4：在JVM中，静态变量的加载顺序在对象之前，因此静态变量不依附于对象存在，可以在不实例化类的情况下直接使用静态变量</p>
<p>✅局部变量和全局变量（成员变量）：<br>在方法体中声明的变量叫做：局部变量。<br>在方法体外声明的变量叫做：成员变量。成员变量又可以分为：实例变量和静态变量。</p>
<p>全局变量和局部变量的区别:<br>1，作用域不同：全局变量的作用域为整个程序，而局部变量的作用域为当前函数或循环等<br>2，内存存储方式不同：全局变量存储在全局数据区中，局部变量存储在栈区<br>3，生命期不同：全局变量的生命期和主程序一样，随程序的销毁而销毁，局部变量在函数内部或循环内部，随函数的退出或循环退出就不存在了<br>4，使用方式不同：全局变量在声明后程序的各个部分都可以用到，但是局部变量只能在局部使用。函数内部会优先使用局部变量再使用全局变量。</p>
<p>✅多线程访问全局变量(成员变量)和局部变量：</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HelloThreadTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        HelloThread r = new HelloThread();</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(r);</span><br><span class="line">        Thread t2 = new Thread(r);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HelloThread implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        //int i = 0;</span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Hello number: &quot; + i++);</span><br><span class="line"></span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep((long) Math.random() * 1000);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (50 == i)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，i是成员变量，则HelloThread的对象r只包含这一个i，两个Thread对象因为由r构造，所以共享了同一个i。</p>
<p>如果i改为在run方法中定义，那么就是局部变量，由于局部变量对于每一个线程来说都有自己的拷贝，所以各个线程之间不再共享同一个变量。</p>
<p>总结：<br>如果一个变量是成员变量，那么多个线程对同一个对象的成员变量进行操作时，它们对该成员变量是彼此影响的，也就是说一个线程对成员变量的改变会影响到另一个线程。</p>
<p>如果一个变量是局部变量，那么每个线程都会有一个该局部变量的拷贝（即便是同一个对象中的方法的局部变量，也会对每一个线程有一个拷贝），一个线程对该局部变量的改变不会影响到其他线程。</p>
<p>转自：<a href="http://t.zoukankan.com/xiaowenwu-p-5077639.html">http://t.zoukankan.com/xiaowenwu-p-5077639.html</a></p>
<p>⚠️这里所说的全局变量和局部变量，说的是线程对象内的，不是传入线程的是局部变量还是全局变量。猜测：不分传入的是全局变量还是局部变量，都是有拷贝的，因为传入的变量对线程来说是成员变量。</p>
<p>实验：一个ArrayList，对代码块儿来说是局部变量，传入线程中，只读list的hashcode，传入线程前和线程中的hashcode一样。</p>
<p>实验：ArrayList增加一个元素，hashCode会变，改变一个对象的某个属性，hashCode不变。</p>
<h3 id="ThreadLocal变量"><a href="#ThreadLocal变量" class="headerlink" title="ThreadLocal变量"></a>ThreadLocal变量</h3><p>成员变量：从上面的例子，如果使用一个Runnable对象创建多个线程，多个线程共享成员变量，多个线程对该变量进行操作是彼此影响的，是线程不安全的。也就是上面加了锁，达到了线程安全。</p>
<p>局部变量：每个线程都会有局部变量的拷贝，一个线程对局部变量的操作不会影响其他线程。（上面的i）</p>
<p>多线程之间就是因为数据共享在多个线程才导致了线程不安全，这就要求线程间的数据需要隔离，从根本上解决了线程安全问题。</p>
<p>因此ThreadLocal：提供线程局部变量；一个线程局部变量在多个线程中，分别有独立的值(副本)。</p>
<p>✅例子：多个线程共用一个Runnable对象，内部ThreadLocal变量和普通成员变量区别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-23 23:28</span><br><span class="line"> **/</span><br><span class="line">public class ThreadLocalExample &#123;</span><br><span class="line"></span><br><span class="line">    public static class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;();</span><br><span class="line">        int local = 1;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            threadLocal.set((int) (Math.random() * 100D));</span><br><span class="line">            local = (int) (Math.random() * 100D);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;threadLocal:&quot; +threadLocal.get());</span><br><span class="line">            System.out.println(&quot;local:&quot; +local);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MyRunnable sharedRunnableInstance = new MyRunnable();</span><br><span class="line">        Thread thread1 = new Thread(sharedRunnableInstance);</span><br><span class="line">        Thread thread2 = new Thread(sharedRunnableInstance);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">threadLocal:40</span><br><span class="line">threadLocal:32</span><br><span class="line">local:95</span><br><span class="line">local:95</span><br></pre></td></tr></table></figure>

<p>每个线程拥有自己的ThreadLocal变量，但是共享local变量。</p>
<p>✅例子：多个线程共同对一个对象进行操作，对象内部ThreadLocal变量和普通成员变量区别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-23 23:55</span><br><span class="line"> **/</span><br><span class="line">public class ThreadLocalExample2 &#123;</span><br><span class="line">    private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;();</span><br><span class="line">    int local = 1;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadLocalExample2 demo = new ThreadLocalExample2();</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">                demo.threadLocal.set((int) (Math.random() * 100D));</span><br><span class="line">                demo.local = (int) (Math.random() * 100D);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;threadLocal:&quot; +demo.threadLocal.get());</span><br><span class="line">                System.out.println(&quot;local:&quot; +demo.local);</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(&quot;线程&quot; + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一样的效果。</p>
<p>多线程变量共享和隔离，ThreadLocal讲解：<a href="https://blog.csdn.net/JokerLJG/article/details/121284966">https://blog.csdn.net/JokerLJG/article/details/121284966</a></p>
<p>线程私有变量的另一个方法：多个对象构造方法传入不同的值：<a href="https://blog.csdn.net/qq_43209615/article/details/124993090">https://blog.csdn.net/qq_43209615/article/details/124993090</a></p>
<p>SimpleDateFormat不是线程安全的解决：<a href="https://blog.csdn.net/sinat_38816924/article/details/122642680">https://blog.csdn.net/sinat_38816924/article/details/122642680</a></p>
<h3 id="Runnable和Thread的区别"><a href="#Runnable和Thread的区别" class="headerlink" title="Runnable和Thread的区别"></a>Runnable和Thread的区别</h3><p>Runnable是接口。Thread是实现了Runnable接口的类，并进行了扩展，而Thread和Runnable的实质是实现的关系，不是同类东西，所以Runnable或Thread本身没有可比性。</p>
<p>Runnable更容易可以实现多个线程间的资源共享，提交给Thread同一个Runnable对象，共享其中的private对象。（只是共享，线程安全要加同步）。<br>而Thread也是可以的，只不过是多个thread对象共享static变量，或者提交同一个Thread对象，并且static只是可见，还需要加同步才是线程安全的。</p>
<blockquote>
<p>这里只探讨共享变量的问题，想实现线程安全，要么加同步，要么volatile+原子性变量。</p>
</blockquote>
<p>还是卖票：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test3  extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        private int ticket = 10;</span><br><span class="line"></span><br><span class="line">        public void run()&#123;</span><br><span class="line">            for(int i =0;i&lt;10;i++)&#123;</span><br><span class="line">                synchronized (this)&#123;</span><br><span class="line">                    if(this.ticket&gt;0)&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Thread.sleep(100);</span><br><span class="line">                            System.out.println(Thread.currentThread().getName()+&quot;卖票----&gt;&quot;+(this.ticket--));</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void main(String[] arg)&#123;</span><br><span class="line">            Test3 t1 = new Test3();</span><br><span class="line">            new Thread(t1,&quot;线程1&quot;).start();</span><br><span class="line">            new Thread(t1,&quot;线程2&quot;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/zhaojianting/article/details/97664370">https://blog.csdn.net/zhaojianting/article/details/97664370</a></p>
<h3 id="获取线程池中的线程？"><a href="#获取线程池中的线程？" class="headerlink" title="获取线程池中的线程？"></a>获取线程池中的线程？</h3><p>貌似无法获取线程。<br>但是可以获取线程池中活动的线程数：<br>ThreadPoolExecutor的getActiveCount方法。<br><code>public class ThreadPoolExecutor extends AbstractExecutorService &#123;</code><br><code>public abstract class AbstractExecutorService implements ExecutorService &#123;</code><br><code>public interface ExecutorService extends Executor &#123;</code></p>
<p>ExecutorService先转型一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(10);</span><br><span class="line">System.out.println(((ThreadPoolExecutor)executorService).getActiveCount());  //0</span><br></pre></td></tr></table></figure>

<h3 id="ThreadPoolTaskExecutor"><a href="#ThreadPoolTaskExecutor" class="headerlink" title="ThreadPoolTaskExecutor"></a>ThreadPoolTaskExecutor</h3><p>ThreadPoolTaskExecutor是一个spring的线程池技术。ThreadPoolTaskExecutor是spring core包中的，而ThreadPoolExecutor是JDK中的JUC。ThreadPoolTaskExecutor是对ThreadPoolExecutor进行了封装处理。</p>
<p>Spring自带的线程池ThreadPoolTaskExecutor：<br><a href="https://zhuanlan.zhihu.com/p/346086161">https://zhuanlan.zhihu.com/p/346086161</a></p>
<h3 id="Scheduled"><a href="#Scheduled" class="headerlink" title="@Scheduled"></a>@Scheduled</h3><p>Spring内置定时任务调度，主要用于控制任务在某个指定时间执行,或者每隔一段时间执行.注意须要配合@EnableScheduling使用,配置@Scheduled主要有三种配置执行时间的方式,cron,fixedRate,fixedDelay。</p>
<p>Spring内置定时任务调度@Scheduled使用详解：<br><a href="https://www.jb51.net/article/201373.htm">https://www.jb51.net/article/201373.htm</a></p>
<p>@Scheduled注解：<br><a href="http://www.javashuo.com/article/p-otgzzukq-hc.html">http://www.javashuo.com/article/p-otgzzukq-hc.html</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java实现自定义注解</title>
    <url>/2022/03/19/myblog/java/java%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="关于注解"><a href="#关于注解" class="headerlink" title="关于注解"></a>关于注解</h3><p>Annotation，注解是Java SE 5.0版本开始引入的概念，它是对java源代码的说明，是一种元数据（描述数据的数据）。</p>
<ul>
<li>注释<br>   注释是对代码的说明，给代码的读者看，便于帮读者梳理业务逻辑；</li>
<li>注解<br>  注解也是对代码的说明，需要配合工具（解析它的代码）使用，参与代码的编译，给应用程序看的。</li>
</ul>
<p>注解的渊源：</p>
<p>在频繁使用注解之前，是用xml 来作为元数据使用，在最开始使用ssm(Spring,SpringMVC,Mybatis)框架时，bean与bean之间的依赖关系是通过xml文件来配置，这个xml文件和源代码分散，当微服务、分布式注解流行，系统越来越大，需要越来越多的xml文件来配置管理，文件配置冗长，而且类型不安全（运行期才会发现错误）,此时就需要一种比较简单直观而且类型安全的配置方式，注解就应运而生了，按照Springboot“约定大于配置”的方式，通过注解来约定其含义，更是减少了xml配置文件的数量。<br>     对于一些经常变动或者配置复杂的配置，使用xml文件来说是比较合适的，所以现在经常是注解和xml方式共存。<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/zt15732625878/article/details/99671586">https://blog.csdn.net/zt15732625878/article/details/99671586</a></p>
<p>————————————————</p>
<h3 id="注解分类"><a href="#注解分类" class="headerlink" title="注解分类"></a>注解分类</h3><p>按照来源划分，可以分为 JDK的注解，第三方的注解，自定义注解。</p>
<p>JDK注解</p>
<p>Java 内置三大注解<br>@Override （标记重写方法）<br>@Deprecated （标记过时）<br>@SuppressWarnings （忽略警告）</p>
<p>元注解 (注解的注解)<br>@Target （注解的作用目标）<br>@Retention （注解的生命周期）<br>@Document （注解是否被包含在JavaDoc中）<br>@Inherited （是否允许子类集成该注解）</p>
<p>第三方注解（主要来源于各种框架）<br>Spring注解<br>@RequestMapping,@RestController,@Configuration,@Value,@Controller,@Service,@Repository,@Component等<br>SpringBoot注解<br>@SpringBootApplication,@EnableAutoConfiguration等<br>JPA注解<br>@Table,@Entity,@Column,@Id等<br>……</p>
<p>自定义注解<br>使用元注解自己定义的注解</p>
<h3 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h3><p>1&gt;.每一个方法实际上是声明了一个配置参数,<br>2&gt;.方法的名称就是参数的名称,<br>3&gt;.返回值类型就是参数的类型,(返回值类型只能是基本类型、Class、String、enum)<br>4&gt;.可以通过default来声明参数的默认值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="meta">@interface</span> 注解名 &#123;</span><br><span class="line">    注解元素的声明<span class="number">1</span> </span><br><span class="line">    注解元素的声明<span class="number">2</span></span><br><span class="line">    type <span class="title function_">elementName</span><span class="params">()</span>;</span><br><span class="line">    type <span class="title function_">elementName</span><span class="params">()</span> <span class="keyword">default</span> value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Service的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ElementType.TYPE 代表在类上使用</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="comment">// RetentionPolicy.RUNTIME 代表运行时使用，可以通过反射获取到</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">//包含在JavaDoc中</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">//允许通过包扫描的方式自动检测</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">	 * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line">	String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Annotation：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所有注解</strong>，<strong>默认是一个实现了Annotation接口的接口。</strong></p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>注解是一种能被添加到java源代码中的元数据，可以看作是一种特殊的标记，可以用在方法、类、参数和包上，程序在编译或者运行时可以检测到这些标记而进行一些特殊的处理。</p>
<p>注解的基本元素：</p>
<ul>
<li>修饰符<br> 访问修饰符必须为public,不写默认为pubic；</li>
<li>关键字<br> 关键字为@interface；</li>
<li>注解名称<br> 注解名称为自定义注解的名称，使用时还会用到；</li>
<li>注解类型元素<br> 注解类型元素是注解中内容，可以理解成自定义接口的实现部分；</li>
</ul>
<p>使用元注解修饰注解：</p>
<p>@Target，@Retention,@Document,@Inherited用来修饰注解。</p>
<p><strong>@Target</strong><br> 表明该注解可以应用的java元素类型。<br>ElementType.TYPE	应用于类、接口（包括注解类型）、枚举<br>ElementType.FIELD	应用于属性（包括枚举中的常量）<br>ElementType.METHOD	应用于方法<br>ElementType.PARAMETER	应用于方法的形参<br>ElementType.CONSTRUCTOR	应用于构造函数<br>ElementType.LOCAL_VARIABLE	应用于局部变量<br>ElementType.ANNOTATION_TYPE	应用于注解类型<br>ElementType.PACKAGE	应用于包<br>ElementType.TYPE_PARAMETER	1.8版本新增，应用于类型变量<br>ElementType.TYPE_USE	1.8版本新增，应用于任何使用类型的语句中（例如声明语句、泛型和强制转换语句中的类型）</p>
<p>@Retention<br>  表明该注解的生命周期<br>RetentionPolicy.SOURCE	编译时被丢弃，不包含在类文件中<br>RetentionPolicy.CLASS	JVM加载时被丢弃，包含在类文件中，默认值<br>RetentionPolicy.RUNTIME	由JVM 加载，包含在类文件中，在运行时可以被获取到</p>
<p>@Document<br>  表明该注解标记的元素可以被Javadoc 或类似的工具文档化</p>
<p>@Inherited<br>  表明使用了@Inherited注解的注解，所标记的类的子类也会拥有这个注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Info &#123;</span><br><span class="line">      String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;tracy&quot;</span>;</span><br><span class="line">      <span class="type">boolean</span> <span class="title function_">isDelete</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用自定义注解"><a href="#使用自定义注解" class="headerlink" title="使用自定义注解"></a>使用自定义注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="comment">// 为Person类配置了刚刚定义的注解@Info</span></span><br><span class="line"><span class="meta">@Info(isDelete = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用反射解析注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取Person的Class对象(类)</span></span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> Person.builder().build();</span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> person.getClass();</span><br><span class="line">            <span class="comment">//判断类上是否有Info注解</span></span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(Info.class)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Person类上配置了Info注解！&quot;</span>);</span><br><span class="line">                <span class="comment">//获取该对象上Info类型的注解</span></span><br><span class="line">                <span class="type">Info</span> <span class="variable">infoAnno</span> <span class="operator">=</span> (Info) clazz.getAnnotation(Info.class);</span><br><span class="line">                System.out.println(<span class="string">&quot;infoAnno.value :&quot;</span> + infoAnno.value() + <span class="string">&quot;,infoAnno.isDelete:&quot;</span> + infoAnno.isDelete());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Person类上没有配置Info注解！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个类或者接口来说，Class类(java.lang包下)中提供了一些方法用于反射注解，当然对于字段、方法来说反射注解的方式很类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回指定的注解</span></span><br><span class="line">getAnnotation</span><br><span class="line"><span class="comment">//判断当前元素是否被指定注解修饰</span></span><br><span class="line">isAnnotationPresent</span><br><span class="line"><span class="comment">//返回所有的注解</span></span><br><span class="line">getAnnotations</span><br></pre></td></tr></table></figure>

<p>————————————————</p>
<p>参考链接：<a href="https://blog.csdn.net/zt15732625878/article/details/100061528">https://blog.csdn.net/zt15732625878/article/details/100061528</a></p>
<p>————————————————</p>
<h3 id="使用自定义注解例子2"><a href="#使用自定义注解例子2" class="headerlink" title="使用自定义注解例子2"></a>使用自定义注解例子2</h3><p>&lt;1&gt;.作用在属性上注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FiledAnnotation &#123;</span><br><span class="line">	 String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;GetFiledAnnotation&quot;</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;2&gt;.作用在方法上注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MethodAnnotation &#123;</span><br><span class="line">	String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;MethodAnnotation&quot;</span>;   </span><br><span class="line">    String <span class="title function_">url</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;https://www.cnblogs.com&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;3&gt;.作用在类上注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TypeAnnotation &#123;</span><br><span class="line">	String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;Is-TypeAnnotation&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;4&gt;.使用自定义注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TypeAnnotation(value = &quot;doWork&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line"><span class="meta">@FiledAnnotation(value = &quot;CSDN博客&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">myfield</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@MethodAnnotation()</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getDefaultInfo</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;do the getDefaultInfo method&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@MethodAnnotation(name = &quot;百度&quot;, url = &quot;www.baidu.com&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getDefineInfo</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;do the getDefineInfo method&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt;5&gt;.测试自定义注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMain</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.zbz.annotation.pattern3.Worker&quot;</span>);</span><br><span class="line">    Method[] method = cls.getMethods();</span><br><span class="line">    <span class="comment">/**判断Worker类上是否有TypeAnnotation注解*/</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> cls.isAnnotationPresent(TypeAnnotation.class);</span><br><span class="line">    <span class="comment">/**获取Worker类上是TypeAnnotation注解值*/</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    	<span class="type">TypeAnnotation</span> <span class="variable">typeAnno</span> <span class="operator">=</span> (TypeAnnotation) cls.getAnnotation(TypeAnnotation.class);</span><br><span class="line">    	System.out.println(<span class="string">&quot;@TypeAnnotation值:&quot;</span> + typeAnno.value());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**方法上注解*/</span></span><br><span class="line">    List&lt;Method&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Method&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; method.length; i++) &#123;</span><br><span class="line">        list.add(method[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Method m : list) &#123;</span><br><span class="line">    	<span class="type">MethodAnnotation</span> <span class="variable">methodAnno</span> <span class="operator">=</span> m.getAnnotation(MethodAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span> (methodAnno == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        System.out.println( <span class="string">&quot;方法名称:&quot;</span> + m.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;方法上注解name = &quot;</span> + methodAnno.name());</span><br><span class="line">        System.out.println(<span class="string">&quot;方法上注解url = &quot;</span> + methodAnno.url());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**属性上注解*/</span></span><br><span class="line">    List&lt;Field&gt; fieldList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Field&gt;();  <span class="comment">//Field表示属性</span></span><br><span class="line">    <span class="keyword">for</span> (Field f : cls.getDeclaredFields()) &#123;<span class="comment">// 访问所有字段</span></span><br><span class="line">    	<span class="type">FiledAnnotation</span> <span class="variable">filedAno</span> <span class="operator">=</span> f.getAnnotation(FiledAnnotation.class);</span><br><span class="line">    	System.out.println( <span class="string">&quot;属性名称:&quot;</span> + f.getName());</span><br><span class="line">    	System.out.println(<span class="string">&quot;属性注解值FiledAnnotation = &quot;</span> + filedAno.value());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>————————————————<br>原文链接：<a href="https://blog.csdn.net/zhangbeizhen18/article/details/87885441/">https://blog.csdn.net/zhangbeizhen18/article/details/87885441/</a></p>
<p>————————————————</p>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>自定义注解像是为类或者什么的新增加了属性，可以有默认值，通过类可以获得类上的自定义注解，然后通过注解获得注解中的值。注解不是属于对象的。定义在属性上的，可以用属性注解来区别这些属性，相当于属性名的别名。</p>
<h3 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h3><p>自定义注解+AOP：<a href="https://zhuanlan.zhihu.com/p/283936459">https://zhuanlan.zhihu.com/p/283936459</a></p>
<p>使用方法上的注解，实现通过注解来唤醒一个类里方法的效果：</p>
<p><a href="https://www.jianshu.com/p/b5b79434d3b5">https://www.jianshu.com/p/b5b79434d3b5</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java常规注解</title>
    <url>/2022/04/29/myblog/java/java%E5%B8%B8%E8%A7%84%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>从JDK5开始,Java增加对元数据的支持，也就是注解，注解与注释是有一定区别的，可以把注解理解为代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过注解开发人员可以在不改变原有代码和逻辑的情况下在源代码中嵌入补充信息。</p>
<p>所有的注解本质上都是继承自 Annotation 接口。但是，手动定义一个接口继承 Annotation 接口无效的，需要通过 @interface 声明注解，Annotation 接口本身也不定义注解类型，只是一个普通的接口。</p>
<h3 id="Pattern"><a href="#Pattern" class="headerlink" title="@Pattern"></a>@Pattern</h3><p>用来限定string格式，用正则表达式来限定。<br>需要导入validation-api包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">    @Setter</span><br><span class="line">    public static class StudentVO&#123;</span><br><span class="line">        @Pattern(regexp = &quot;^[A-Za-z]+$&quot;, message = &quot;只能字母&quot;)</span><br><span class="line">        private String name;</span><br><span class="line">        private Long age;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>常用的正则表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 匹配首尾空格的正则表达式：(^\s*)|(\s*$)</span><br><span class="line">  2 整数或者小数：^[0-9]+\.&#123;0,1&#125;[0-9]&#123;0,2&#125;$</span><br><span class="line">  3 只能输入数字：&quot;^[0-9]*$&quot;。</span><br><span class="line">  4 只能输入n位的数字：&quot;^\d&#123;n&#125;$&quot;。</span><br><span class="line">  5 只能输入至少n位的数字：&quot;^\d&#123;n,&#125;$&quot;。</span><br><span class="line">  6 只能输入m~n位的数字：。&quot;^\d&#123;m,n&#125;$&quot;</span><br><span class="line">  7 只能输入零和非零开头的数字：&quot;^(0|[1-9][0-9]*)$&quot;。</span><br><span class="line">  8 只能输入有两位小数的正实数：&quot;^[0-9]+(.[0-9]&#123;2&#125;)?$&quot;。</span><br><span class="line">  9 只能输入有1~3位小数的正实数：&quot;^[0-9]+(.[0-9]&#123;1,3&#125;)?$&quot;。</span><br><span class="line"> 10 只能输入非零的正整数：&quot;^\+?[1-9][0-9]*$&quot;。</span><br><span class="line"> 11 只能输入非零的负整数：&quot;^\-[1-9][]0-9&quot;*$。</span><br><span class="line"> 12 只能输入长度为3的字符：&quot;^.&#123;3&#125;$&quot;。</span><br><span class="line"> 13 只能输入由26个英文字母组成的字符串：&quot;^[A-Za-z]+$&quot;。</span><br><span class="line"> 14 只能输入由26个大写英文字母组成的字符串：&quot;^[A-Z]+$&quot;。</span><br><span class="line"> 15 只能输入由26个小写英文字母组成的字符串：&quot;^[a-z]+$&quot;。</span><br><span class="line"> 16 只能输入由数字和26个英文字母组成的字符串：&quot;^[A-Za-z0-9]+$&quot;。</span><br><span class="line"> 17 只能输入由数字、26个英文字母或者下划线组成的字符串：&quot;^\w+$&quot;。</span><br><span class="line"> 18 验证用户密码：&quot;^[a-zA-Z]\w&#123;5,17&#125;$&quot;正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。</span><br><span class="line"> 19 验证是否含有^%&amp;&#x27;,;=?$\&quot;等字符：&quot;[^%&amp;&#x27;,;=?$\x22]+&quot;。</span><br><span class="line"> 20 只能输入汉字：&quot;^[\u4e00-\u9fa5]&#123;0,&#125;$&quot;</span><br><span class="line"> 21 验证Email地址：&quot;^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$&quot;。</span><br><span class="line"> 22 验证InternetURL：&quot;^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$&quot;。</span><br><span class="line"> 23 验证电话号码：&quot;^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$&quot;正确格式为：&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX&quot;。</span><br><span class="line"> 24 验证身份证号（15位或18位数字）：&quot;^\d&#123;15&#125;|\d&#123;18&#125;$&quot;。</span><br><span class="line"> 25 验证一年的12个月：&quot;^(0?[1-9]|1[0-2])$&quot;正确格式为：&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;12&quot;。</span><br><span class="line"> 26 验证一个月的31天：&quot;^((0?[1-9])|((1|2)[0-9])|30|31)$&quot;正确格式为；&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;31&quot;。</span><br><span class="line"> 27 匹配中文字符的正则表达式： [\u4e00-\u9fa5]</span><br><span class="line"> 28 匹配双字节字符(包括汉字在内)：[^\x00-\xff]</span><br><span class="line"> 29 应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）</span><br><span class="line"> 30 String.prototype.len=function()&#123;return this.replace(/[^\x00-\xff]/g,&quot;aa&quot;).length;&#125;</span><br><span class="line"> 31 匹配空行的正则表达式：\n[\s| ]*\r</span><br><span class="line"> 32 匹配html标签的正则表达式：&lt;(.*)&gt;(.*)&lt;\/(.*)&gt;|&lt;(.*)\/&gt;</span><br><span class="line">————————————————</span><br><span class="line">原文链接：https://blog.csdn.net/qq_36927265/article/details/87864026</span><br></pre></td></tr></table></figure>

<p>在control层，前端调用来进行数据校验。</p>
<p>一、VO对象内用@Pattern限定，control方法中用@Valid检查。<br><a href="http://www.wpf123.com/post/97.html">http://www.wpf123.com/post/97.html</a></p>
<p>二、control类用@Validated注解，方法内String参数用@Pattern</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Validated</span><br><span class="line">class Controller &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping</span><br><span class="line">public ResponseEntity&lt;List&lt;Permission&gt;&gt; query(</span><br><span class="line">    @RequestHeader(&quot;iv-user&quot;) String userId,</span><br><span class="line">        @Pattern(regexp = &quot;^accessor$&quot;, message = &quot;请求参数不合法&quot;)</span><br><span class="line">        @RequestParam(&quot;findBy&quot;) String accessor,</span><br><span class="line">        @RequestParam(&quot;accessorId&quot;) long accessorId)&#123;</span><br><span class="line">        //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="JSONField"><a href="#JSONField" class="headerlink" title="@JSONField"></a>@JSONField</h3><p>来自fastjson，fastjson是阿里巴巴出品的快速解析json的一个工具,</p>
<p>一、name属性：用来指定JSON串中key的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@JSONField(name = &quot;AGE&quot;)</span><br><span class="line">private String age;</span><br></pre></td></tr></table></figure>
<p>也可以作用在setter、getter方法上。</p>
<p>二、format规定日期格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@JSONField(format=&quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br><span class="line">private Date date;</span><br></pre></td></tr></table></figure>

<p>三、ordinal：规定字段的顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@JSONField(ordinal = 3)</span><br><span class="line">private int f0;</span><br><span class="line"></span><br><span class="line">@JSONField(ordinal = 2)</span><br><span class="line">private int f1;</span><br><span class="line"></span><br><span class="line">@JSONField(ordinal = 1)</span><br><span class="line">private int f2;</span><br></pre></td></tr></table></figure>

<p>四、serialize&#x2F;deserialize指定字段不序列化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@JSONField(serialize=false)</span><br><span class="line">public Date date;</span><br></pre></td></tr></table></figure>

<p>五、<code>@JSONField(serializeUsing=xxx.class, deserializeUsing=xxx.class)</code><br>指定序列化和反序列化字段使用的序列化器和反序列化器。<br>需要实现<code>ObjectSerializer</code>接口。</p>
<h3 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h3><p>LomBok中的注解，用来简化代码。</p>
<p>1.默认情况下，将打印所有非静态字段。<br>2.如果要跳过某些字段，可以用注释这些字段@ToString.Exclude。<br>3.可以使用精确指定要被toString方法包含的字段，先设置@ToString(onlyExplicitlyIncluded &#x3D; true)，然后使用@ToString.Include标记每个要包含的字段。<br>4.可以更改用于标识成员的名称@ToString.Include(name &#x3D; “some other name”)，name相当于给字段起别名。<br>5.可以通过更改成员的打印顺序@ToString.Include(rank &#x3D; 1)。rank 表示该字段的优先级，值越大排在越前面，默认为 0，等级相同的成员以它们在源文件中出现的顺序打印。</p>
<h3 id="CrossOrigin"><a href="#CrossOrigin" class="headerlink" title="@CrossOrigin"></a>@CrossOrigin</h3><p>出于安全原因，浏览器禁止Ajax调用驻留在当前原点之外的资源。</p>
<p>跨源资源共享（CORS）是由大多数浏览器实现的W3C规范，允许您灵活地指定什么样的跨域请求被授权，而不是使用一些不太安全和不太强大的策略，如IFRAME或JSONP。</p>
<p>参数：<br>origins： 允许可访问的域列表<br>maxAge:准备响应前的缓存持续的最大时间（以秒为单位）。</p>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@CrossOrigin(origins = &#123;&quot;http://domain2.com&quot;,&quot;。。。&quot;&#125;, maxAge = 3600)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Account retrieve(@PathVariable Long id) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多：<a href="https://cloud.tencent.com/developer/article/188106">https://cloud.tencent.com/developer/article/188106</a></p>
<h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><p>开发restful API时，会用到，@RestController 是@controller和@ResponseBody 的结合。</p>
<p>@Controller 将当前修饰的类注入Spring IOC容器，使得从该类所在的项目跑起来的过程中，这个类就被实例化。</p>
<p>@ResponseBody 它的作用是指该类中所有的API接口返回的数据，甭管你对应的方法返回Map或是其他Object，它会以Json字符串的形式返回给客户端。</p>
<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>@RequestMapping 是 Spring Web 应用程序中最常被用到的注解之一。在Spring MVC 中使用 @RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController  </span><br><span class="line">@RequestMapping(&quot;/home&quot;)  </span><br><span class="line">public class IndexController &#123;  </span><br><span class="line">    @RequestMapping(&quot;/&quot;)  </span><br><span class="line">    String get() &#123;  </span><br><span class="line">        //mapped to hostname:port/home/  </span><br><span class="line">        return &quot;go to home&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    @RequestMapping(&quot;/index&quot;)  </span><br><span class="line">    String index() &#123;  </span><br><span class="line">        //mapped to hostname:port/home/index/  </span><br><span class="line">        return &quot;go to index&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>参考：<br><a href="https://www.jianshu.com/p/6f5aec232c97">https://www.jianshu.com/p/6f5aec232c97</a></p>
<p>✅RequestMapping参数</p>
<p>1，value，method<br>value：指定请求的实际地址，指定的地址可以是URI Template模式。<br>method：指定请求的method类型，GET、POST、PUT、DELETE等。</p>
<p>2，consumes，produces<br>consumes：指定处理请求的提交内容类型（content-type），例如application&#x2F;json，text&#x2F;html。<br>produces：指定返回的内容类型，仅当request请求头中的（Accept）类型中包含该指定类型才返回。不但可以设置返回值类型还可以设定返回值的字符编码。</p>
<p>3，params，headers<br>params：指定request中必须包含某些参数值时，才让该方法处理。<br>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>
<p>前后端数据json数据类型</p>
<p>1，json对象类型，即前端定义的Content type为application&#x2F;x-www-form-urlencoded等，后端应使用@RequestParam注解接收此类型的json参数。</p>
<p>2，json字符串类型，即前端定义的Content type为application&#x2F;json，后端应使用@RequestBody注解接收json参数。</p>
<p>转自：<a href="https://www.cnblogs.com/FlyGoldfish/articles/15649305.html">https://www.cnblogs.com/FlyGoldfish/articles/15649305.html</a></p>
<p>在Spring MVC 中使用 @RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求，相当于Servlet中在web.xml中配置</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/web&quot;)</span><br><span class="line">piblic class TestController &#123;</span><br><span class="line">    // 方法仅处理请求方式是GET和request Content-Type为“application/json”类型的请求</span><br><span class="line">    //普通参数用@RequestParam</span><br><span class="line">    @RequestMapping(value = &quot;/test1&quot;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;, consumes = &quot;application/json&quot;)</span><br><span class="line">    public String test2(@RequestParam(&quot;id&quot;) String id)&#123;</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //对象类型用@RequestBody</span><br><span class="line">    @RequestMapping(value = &quot;/test2&quot;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;, consumes = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">    public String test2(@RequestBody VO vo)&#123;</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //指定返回值类型为json</span><br><span class="line">    @RequestMapping(value = &quot;/list&quot; , method = RequestMethod.POST,produces=&quot;application/json&quot;)</span><br><span class="line">public JSONObject list(@PathVariable String communityId) &#123;</span><br><span class="line">   JSONObject object = new JSONObject();</span><br><span class="line">   object.put(&quot;communityId&quot;,communityId);</span><br><span class="line">   return object;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    //@responseBody就是返回值是json数据，使用@responseBody，就可以省略produces属性</span><br><span class="line">    @RequestMapping(value = &quot;/list&quot; , method = RequestMethod.POST)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public JSONObject list(@PathVariable String communityId) &#123;</span><br><span class="line">    JSONObject object = new JSONObject();</span><br><span class="line">    object.put(&quot;communityId&quot;,communityId);</span><br><span class="line">    return object;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //返回值是json数据，字符编码为utf-8</span><br><span class="line">    @RequestMapping(value = &quot;/list&quot; , method = RequestMethod.POST,produces=&quot;application/json;charset=utf-8&quot;)</span><br><span class="line">    public JSONObject list(@PathVariable String communityId) &#123;</span><br><span class="line">    JSONObject object = new JSONObject();</span><br><span class="line">    object.put(&quot;communityId&quot;,communityId);</span><br><span class="line">    return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多用法：<a href="https://blog.csdn.net/weixin_46058921/article/details/122141863">https://blog.csdn.net/weixin_46058921/article/details/122141863</a></p>
<p>✅MediaType<br>consumes参数中可以用的。</p>
<p>MediaType媒体类型：决定浏览器将以什么形式、什么编码对资源进行解析Content-Type：也属于MediaType媒体类型，主要用于在请求头中指定资源的MediaType</p>
<p><a href="https://javajgs.com/archives/75280">https://javajgs.com/archives/75280</a></p>
<p>✅RequestMapping、GetMapping、PostMapping的区别</p>
<p>@RequestMapping是一个无方法的注解。@GetMapping和@PostMapping是组合注解，分别是@RequestMapping(method &#x3D; RequestMethod.GET)和@RequestMapping(method &#x3D; RequestMethod.POST)的缩写。<br>GET、POST是方法的映射，表示为<br>@RequestMapping(method &#x3D; RequestMethod.${方法})</p>
<p>在一开始的映射是使用@RequestMapping(method &#x3D; RequestMethod.${方法})来表示。后来Spring4.3中引进了@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping注解来帮助简化常用的HTTP方法的映射。</p>
<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>@RequestParam：将请求参数绑定到你控制器的方法参数上（是springmvc中接收普通参数的注解）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：f(@RequestParam(value=”参数名”,required=”true/false”,defaultValue=””) String s</span><br><span class="line">       , 其他入参）</span><br><span class="line"> </span><br><span class="line">value：参数名</span><br><span class="line"> </span><br><span class="line">required：是否包含该参数，默认为true，表示该请求路径中必须包含该参数，如果不包含就报错。</span><br><span class="line"> </span><br><span class="line">defaultValue：默认参数值，如果设置了该值，required=true将失效，自动为false,如果没有传该参数，就使用默认值</span><br></pre></td></tr></table></figure>

<p>✅@RequestParam如何接收List参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value = &quot;hello&quot;, method = &#123;RequestMethod.POST&#125;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public boolean hello(@RequestParam(value = &quot;userIds&quot;) List&lt;Long&gt; userIds) &#123;</span><br><span class="line">   </span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postman传参：直接在Params中加：1,2,3</p>
<p>⚠️：@RequestBody传的vo，并且指明传入json格式（contentType），放在body-row中。<br>用的是@RequestParam传参，放在Params中，放在body-row中用json格式不行。放在Params中，相当于是加在url后面。</p>
<p>✅@RequestParam如何接收Date参数</p>
<p>首先引入joda-time包。maven的dependency：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;joda-time&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;joda-time&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在Controller代码里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String testMethod(@RequestParam @DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;) Date testdate)&#123;</span><br><span class="line">    System.out.println(testDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postman传参：直接2022-09-24 00:00:00</p>
<h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)，因此@RequestBody只能用于接收POST请求的参数<br>@RequestParam接收的是key-value里面的参数(URL中的参数)，通常用于接收GET请求的参数（POST也能接收只接收URL里的，请求体的接收不到）</p>
<p>即：<br>如果参数是放在请求体VO中，传入后台的话，那么后台要用@RequestBody才能接收到；<br>如果不是放在请求体中的话，那么后台接收前台传过来的参数时，要用@RequestParam来接收。</p>
<p>总结：<br>@RequestParam和@RequestBody都能接收Post方式请求传来的数据，但是@RequestParam不能接收json字符串，而@RequestBody能，@RequestBody不能接收form-data类型的内容，@RequestParam能。<br>一个请求，只有一个RequestBody；一个请求，可以有多个RequestParam。<br>@ReuestBody接受单个参数的时候只能先使用Map&lt;String,Object&gt; params接收,然后再使用params.get(“name”)获取参数的值。</p>
<p>更多：<a href="https://blog.csdn.net/justry_deng/article/details/80972817">https://blog.csdn.net/justry_deng/article/details/80972817</a></p>
<h3 id="postman上如何请求"><a href="#postman上如何请求" class="headerlink" title="postman上如何请求"></a>postman上如何请求</h3><p>✅post请求，传参是list的话，用@RequestParam的话只能放在url后面，长度是有限制的。用@RequestBody是放在body里。</p>
<p>✅关于@RequestParam传参和@RequestBody传参，在postman中如何加：<br>1、@RequestParam的参数可以放在postman的param中（跟在url后面），也可以放在body里的form-data里（放在body里的），但是不能放在body的raw里。能放在哪里需要看consume参数的MedisType，想放在form-data里需要设置MedisType为multipart&#x2F;form-data，或者不要限定为json。<br>2、@RequestBody的参数放在body里的raw里格式为json。一般传对象vo。</p>
<p>✅RequestBody传map型参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@PostMapping(&quot;/test&quot;)</span><br><span class="line">public String testMethod(@RequestBody Map&lt;String,String&gt; map)&#123;</span><br><span class="line">    System.out.println(testDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postman如何请求：<br>1.设置请求方式为Post<br>2.在Headers中添加Content-Type，值为application&#x2F;json<br>3.在body中选择row，选择json数据格式，最后在下面以json的数据格式填写参数</p>
<p>✅@RequestParam传参什么时候放在form-data里，什么时候放在params里</p>
<p>长的话放在form-data里，不是跟在url后的。如果放在params里就是跟在url后面的。</p>
<h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>@ResponseBody 注解的作用是将Controller的方法返回的对象，通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。</p>
<p>@ResponseBody的作用其实是将java对象转为json格式的数据，然后直接写入HTTP response 的body中；一般在异步获取数据时使用</p>
<p>@ResponseBody 是作用在方法上的</p>
<p>更多：<a href="https://blog.csdn.net/weixin_47609799/article/details/124843709">https://blog.csdn.net/weixin_47609799/article/details/124843709</a></p>
<h3 id="Builder"><a href="#Builder" class="headerlink" title="@Builder"></a>@Builder</h3><p>lombok中的注解。<br>Builder 使用创建者模式又叫建造者模式。简单来说，就是一步步创建一个对象，它对用户屏蔽了里面构建的细节，但却可以精细地控制对象的构造过程。</p>
<p>@Builder注解的作用主要是用来生成对象，并且可以为对象链式赋值。放在实体类上。<br>​@Builder​​注释为你的类生成相对略微复杂的构建器API。</p>
<p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student student = Student.builder()</span><br><span class="line">        .name( &quot;admin&quot; )</span><br><span class="line">        .age( 18 )</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>与@Singular结合使用<br>使用@Singular注释注释一个集合字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Singular</span><br><span class="line">private List&lt;String&gt; hobbies;</span><br><span class="line"></span><br><span class="line">.hobbies( &quot;110&quot; ).hobbies( &quot;112&quot; )</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/g56467467464/article/details/105407741">https://blog.csdn.net/g56467467464/article/details/105407741</a></p>
<h3 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h3><p>baomidou.mybatisplus的注解<br>@TableName是mybatis-plus中的注解，主要是实现实体类型和数据库中的表实现映射。<br>放在实体类DO上。</p>
<p>虽然功能相同，但是，@TableName是mybatis-plus中的注解，@Table是Hibernate中的注解。</p>
<h3 id="Param"><a href="#Param" class="headerlink" title="@Param"></a>@Param</h3><p>1 、@Param注解的作用是给参数命名,参数命名后就能根据名字得到参数值,正确的将参数传入sql语句中（一般通过#{}的方式，${}会有sql注入的问题）。<br>2、一般写在mappe接口（DAO接口）的入参，对应xml中#{}中的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用方法：</span><br><span class="line">Mapper接口方法：</span><br><span class="line">public int findById(@Param(&quot;userId&quot;) int userId);</span><br><span class="line">对应的xml文件：</span><br><span class="line"> &lt;select id=&quot;findById&quot; resultMap=&quot;baseMap&quot;&gt;</span><br><span class="line">    select &lt;include redif=&quot;all_column_list&quot;&gt; from table_name</span><br><span class="line">    where user_id = #&#123;userId&#125;</span><br><span class="line"> &lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>不使用@Param注解时，参数只能有一个，并且是Javabean。</p>
<p>使用了@Param后，可以不用parameterType？ 存疑</p>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="@Mapper"></a>@Mapper</h3><p>在使用Mybatis持久层框架来操作数据库时，我们可以使用@Mapper注解和@MapperScan注解来将Mapper接口类交给Sprinig进行管理。</p>
<p>目的就是为了不再写mapper映射文件（xml文件）。</p>
<p>Spring Boot的核心理念是：不建议使用xml文件配置。但是，这对MyBatis来说进退两难，因为MyBatis离不开xml，需要xml来配置sql语句。为了迎合Spring Boot的发展理念，MyBatis官方开发了mybatis-spring-boot-starter，我们要想更少的依赖xml，需要深入的研究mybatis-spring-boot-starter中的用法，尤其是@MapperScan和@Mapper的用法。</p>
<p>一、注解@Mapper，这种方式要求每一个Mapper类都需要添加此注解<br>在接口类上添加了@Mapper，在编译之后会生成相应的接口实现类</p>
<p>二、@MapperScan注解，可以让我们不用为每个Mapper类都添加@Mapper注解。指定要变成实现类的接口所在的包<br>添加位置：是在Springboot启动类上面添加，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication  </span><br><span class="line">@MapperScan(&#123;&quot;cn.mybatis.mappers.class&quot;,&quot;cn.mybatis.mappers.student&quot;&#125;)  </span><br><span class="line">public class SpringbootMybatisDemoApplication&#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">       SpringApplication.run(SpringbootMybatisDemoApplication.class, args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>最终实现：直接在Mapper类中采用注解的形式操作数据库，通过@MapperScan扫描制定的映射器存放路径，最终不需要加任何注解，也不需要对应的xml文件来配置sql语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//不需要加任何注解，也不需要对应的xml文件</span><br><span class="line">public interface UserMapper&#123;</span><br><span class="line">     @Select(&quot;select * from user&quot;)</span><br><span class="line">     List&lt;User&gt; getUserList(String userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="http://www.mybatis.cn/archives/862.html">http://www.mybatis.cn/archives/862.html</a></p>
<h3 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h3><p>@PostContruct是Java自带的注解，在方法上加该注解会在项目启动的时候执行该方法，也可以理解为在spring容器初始化的时候执行该方法。可作为一些数据的常规化加载，比如数据字典之类的。</p>
<p>从Java EE5规范开始，Servlet中增加了两个影响Servlet生命周期的注解，@PostConstruct和@PreDestroy，这两个注解被用来修饰一个非静态的void（）方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostConstruct</span><br><span class="line">public void someMethod()&#123;&#125;</span><br><span class="line"></span><br><span class="line">public @PostConstruct void someMethod()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>执行时机：在依赖注入完成后被自动调用。在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。<br>Constructor &gt;&gt; @Autowired &gt;&gt; @PostConstruct &gt;&gt; init &gt;&gt; service &gt;&gt; destroy &gt;&gt; PreDestroy</p>
<p>该注解与BeanPostProcessor接口有关，它有个实现类CommonAnnotationBeanPostProcessor，就是专门处理@PostConstruct  @PreDestroy注解。</p>
<hr>
<p>InitialzingBean接口的afterPropertiesSet和配置bean时的init-method，也有类似功能。</p>
<p>initMethod和InitializingBean是spring提供的两种对类的属性进行装配的方式。initMethod和InitializingBean指定方法的执行顺序在普通属性装配之后，initMethod指定的方法又在InitializingBean指定的方法之后执行。</p>
<p>三者执行顺序：Construction &gt; 对象属性set() 方法-&gt; @PostConstruct -&gt; InitializingBean -&gt; initMethod</p>
<p>总结：可不可以理解为@PostConstruct在初始化自己bean时，依赖注入其他属性bean后执行，而InitialzingBean接口又是在它后面。</p>
<p>参考：<a href="https://blog.csdn.net/chinawangfei/article/details/122825129">https://blog.csdn.net/chinawangfei/article/details/122825129</a></p>
<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><p>@Deprecated是java内置注解，此注解可以用在方法，属性，类上，表示已废弃，不维护，可能会删除。<br>表示不推荐程序员使用，但是还可以使用。</p>
<h3 id="Valid"><a href="#Valid" class="headerlink" title="@Valid"></a>@Valid</h3><p>用于对象属性字段的规则检测，为了避免使用冗余的代码进行if判断，使用@Valid注解实现。</p>
<p>是Spring中的注解，需要引入依赖，如果是 springboot 项目，那么可以不用引入了，已经引入了，就存在于最核心的 web 开发包 spring-boot-starter-web 里面。</p>
<p>如果不是，需要引入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.validation&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;validation-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.0.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.4.1.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>使用方法：在被检验的实体类中，使用注解加一些限制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@NotBlank(message = &quot;请输入名称&quot;)</span><br><span class="line">@Length(message = &quot;名称不能超过个 &#123;max&#125; 字符&quot;, max = 10)</span><br><span class="line">public String name;</span><br><span class="line"> </span><br><span class="line">@NotNull(message = &quot;请输入年龄&quot;)</span><br><span class="line">@Range(message = &quot;年龄范围为 &#123;min&#125; 到 &#123;max&#125; 之间&quot;, min = 1, max = 100)</span><br><span class="line">public Integer age;</span><br><span class="line"></span><br><span class="line">@Email(message = &quot;邮箱不正确&quot;)</span><br><span class="line">@Min(value = 1000000)</span><br><span class="line"></span><br><span class="line">@NotEmpty(message=&quot;不能为空&quot;)</span><br><span class="line">@Size(message=&quot;最多5个&quot;, max=5)</span><br><span class="line">private List&lt;Intefer&gt; list;</span><br></pre></td></tr></table></figure>

<p>在Controller的对应方法中，对传入参数加@Valid注解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/action/register&quot;)</span><br><span class="line">public Result registerByForm(@Valid @RequestBody RegisterUser registerUser)&#123;</span><br><span class="line">    return userService.register(registerUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/weixin_43587472/article/details/110388778">https://blog.csdn.net/weixin_43587472/article/details/110388778</a></p>
<h3 id="Transactional注解"><a href="#Transactional注解" class="headerlink" title="@Transactional注解"></a>@Transactional注解</h3><p>springframework中的注解。<br>声明式事务管理，是建立在AOP之上，本质上是对方法前后进行拦截，然后再目标方法开始之前创建或加入一个一个事务，在执行完目标方法之后，根据执行情况提交或者回滚事务。</p>
<p>简而言之：@Transactional注解在代码执行出错时进行事务的回滚。</p>
<p>java异常模型：<br>Throwable是最顶层的父类，有Error和Exception两个子类。<br>Error表示严重的错误（如OOM等）；<br>Exception可以分为运行时异常（RuntimeException及其子类）和非运行时异常（Exception的子类中，除了RuntimeException及其子类之外的类）。</p>
<p>非运行时异常是检查异常（checked exceptions），一定要try catch，因为这类异常是可预料的，编译阶段就检查的出来；<br>Error和运行时异常是非检查异常（unchecked exceptions），不需要try catch，因为这类异常是不可预料的，编辑阶段不会检查，没必要检查，也检查不出来。</p>
<p>spring的@Transactional注解可以很方便的开启事务，但是默认只在遇到运行时异常和Error时才会回滚，非运行时异常不回滚，即Exception的子类中，除了RuntimeException及其子类，其他的类默认不回滚。</p>
<p>而rollbackFor属性可以解决这个问题，rollbackFor &#x3D; Exception.class表示Exception及其子类的异常都会触发回滚，同时不影响Error的回滚。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 运行时异常，正常回滚</span><br><span class="line">@Transactional</span><br><span class="line">public void save()&#123;</span><br><span class="line">    StudentDO studentDO = new StudentDO();</span><br><span class="line">    studentDO.setName(&quot;ltm&quot;);</span><br><span class="line">    studentDO.setAge(22);</span><br><span class="line">    studentMapper.insert(studentDO);</span><br><span class="line">    throw new RuntimeException(&quot;我是异常&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 非运行时异常，加rollbackFor属性，抛出异常，并回滚</span><br><span class="line">@Transactional(rollbackFor = Exception.class)</span><br><span class="line">public void save() throws IOException&#123;</span><br><span class="line">    StudentDO studentDO = new StudentDO();</span><br><span class="line">    studentDO.setName(&quot;ltm&quot;);</span><br><span class="line">    studentDO.setAge(22);</span><br><span class="line">    studentMapper.insert(studentDO);</span><br><span class="line">    throw new IOException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/c5988db897fc">https://www.jianshu.com/p/c5988db897fc</a></p>
<p>使用方法：<br>1.需要在启动类上添加@EnableTransactionManagement注解。<br>2.当作用在类上，该类所以public方法都具有该类型的事务属性。也可以加在public方法上。</p>
<p><a href="https://blog.51cto.com/u_9177933/2978291">https://blog.51cto.com/u_9177933/2978291</a></p>
<h3 id="SneakyThrows"><a href="#SneakyThrows" class="headerlink" title="@SneakyThrows"></a>@SneakyThrows</h3><p>✅java的异常体系</p>
<p><img src="/images/java%E5%BC%82%E5%B8%B8.png"></p>
<p>Error是编译时错误和系统错误，系统错误在除特殊情况下，都不需要你来关心，基本不会出现。而编译时错误，如果你使用了编译器，那么编译器会提示。</p>
<p>Exception则是可以被抛出的基本类型，我们需要主要关心的也是这个类。<br>Exception又分为RunTimeException和其他Exception。</p>
<p>RunTimeException：运行时异常，又称不受检查异常，不受检查，因为不受检查，所以在代码中可能会有RunTimeException时Java编译检查时不会告诉你有这个异常，但是在实际运行代码时则会暴露出来，比如经典的1&#x2F;0，空指针等。如果不处理也会被Java自己处理。</p>
<p>其他Exception，受检查异常。可以理解为错误，必须要开发者解决以后才能编译通过，解决的方法有两种，<br>1：throw到上层，<br>2，try-catch处理。</p>
<p>✅@SneakyThrows的作用：<br>普通Exception类,也就是我们常说的受检异常或者Checked Exception会强制要求抛出它的方法声明throws，调用者必须显示的去处理这个异常。设计的目的是为了提醒开发者处理一些场景中必然可能存在的异常情况。比如网络异常造成IOException。</p>
<p>但是现实大部分情况下的异常，我们都是一路往外抛了事。所以渐渐的java程序员处理Exception的常见手段就是外面包一层RuntimeException，接着往上丢.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而Lombok的@SneakyThrows就是为了消除这样的模板代码。<br>使用注解后不需要担心Exception的处理.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> import lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line">public class SneakyThrowsExample implements Runnable &#123;</span><br><span class="line">  @SneakyThrows(UnsupportedEncodingException.class)</span><br><span class="line">  public String utf8ToString(byte[] bytes) &#123;</span><br><span class="line">    return new String(bytes, &quot;UTF-8&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @SneakyThrows</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    throw new Throwable();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：最重要的是throw (T)t, 使用泛型,将传入的Throwable强转为RuntimeException异常.<br>虽然, 我们抛出的异常不是RuntimeException,但是可以骗过javac编译器,泛型最后存储为字节码文件时并没有泛型信息.</p>
<p>————————————————<br>原文链接：<a href="https://blog.csdn.net/qq_22162093/article/details/115486647">https://blog.csdn.net/qq_22162093/article/details/115486647</a></p>
<h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h3><p>@Data注解是lombok.jar包下的注解，该注解通常用在实体bean上，不需要写出set和get方法，但是具备实体bean所具备的方法，简化编程提高变成速度。</p>
<p>@Data相当于@Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode这5个注解的合集。</p>
<p>@Data ：注在类上，提供类的get、set、equals、hashCode、toString等方法<br>@AllArgsConstructor ：注在类上，提供类的全参构造<br>@NoArgsConstructor ：注在类上，提供类的无参构造<br>@Setter ：注在属性上，提供 set 方法<br>@Getter ：注在属性上，提供 get 方法<br>@EqualsAndHashCode ：注在类上，提供对应的 equals 和 hashCode 方法<br>@Log4j&#x2F;@Slf4j ：注在类上，提供对应的 Logger 对象，变量名为 log</p>
<h3 id="RequiredArgsConstructor"><a href="#RequiredArgsConstructor" class="headerlink" title="@RequiredArgsConstructor"></a>@RequiredArgsConstructor</h3><p>lombok中的注解。可用于生成有参构造函数，也可以方便在写controller或者Service层的时候，需要注入很多的mapper接口或者另外的service接口的时候就避免会写很多的@Autowired注解。</p>
<p>实体类有参构造函数：<br>必须声明的变量为final</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ToString</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">static class Person &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@RequiredArgsConstructor(onConstructor &#x3D;@_(@Autowired))<br>写在类上可以代替@Autowired注解，需要注意的是在注入时需要用final定义，或者使用@notnull注解.<br>当我们需要注入Bean的时候可以直接在类名称上使用。代替了Autowrited注解.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/v1/demo&quot;)</span><br><span class="line">@RequiredArgsConstructor(onConstructor = @__(@Autowired))</span><br><span class="line">public class DemoController &#123;</span><br><span class="line">    private final DemoService demoService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><p>作用：抑制编译器警告，有时候可以看到idea中有警告的颜色标注，当我们不希望看到这些警告的时候，可以使用 SuppressWarnings注解来抑制警告信息。<br>在<code>&#123;&quot; &quot;&#125; </code>中，可以写入你希望抑制(不显示)警告信息。</p>
<p>例如：<br><code>@SuppressWarnings&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;, &quot;unused&quot;&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all，抑制所有警告</span><br><span class="line">boxing，抑制与封装/拆装作业相关的警告</span><br><span class="line">cast，抑制与强制转型作业相关的警告</span><br><span class="line">dep-ann，抑制与淘汰注释相关的警告</span><br><span class="line">deprecation，抑制与淘汰的相关警告</span><br><span class="line">fallthrough，抑制与switch陈述式中遗漏break相关的警告</span><br><span class="line">finally，抑制与未传回finally区块相关的警告</span><br><span class="line">hiding，抑制与隐藏变数的区域变数相关的警告</span><br><span class="line">incomplete-switch，抑制与switch陈述式(enum case)中遗漏项目相关的警告</span><br><span class="line">javadoc，抑制与javadoc相关的警告</span><br><span class="line">nls，抑制与非nls字串文字相关的警告</span><br><span class="line">null，抑制与空值分析相关的警告</span><br><span class="line">rawtypes，抑制与使用raw类型相关的警告</span><br><span class="line">resource，抑制与使用Closeable类型的资源相关的警告</span><br><span class="line">restriction，抑制与使用不建议或禁止参照相关的警告</span><br><span class="line">serial，抑制与可序列化的类别遗漏serialVersionUID栏位相关的警告</span><br><span class="line">static-access，抑制与静态存取不正确相关的警告</span><br><span class="line">static-method，抑制与可能宣告为static的方法相关的警告</span><br><span class="line">super，抑制与置换方法相关但不含super呼叫的警告</span><br><span class="line">synthetic-access，抑制与内部类别的存取未最佳化相关的警告</span><br><span class="line">sync-override，抑制因为置换同步方法而遗漏同步化的警告</span><br><span class="line">unchecked，抑制与未检查的作业相关的警告</span><br><span class="line">unqualified-field-access，抑制与栏位存取不合格相关的警告</span><br><span class="line">unused，抑制与未用的程式码及停用的程式码相关的警告</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://blog.csdn.net/qq_41684621/article/details/123807986">https://blog.csdn.net/qq_41684621/article/details/123807986</a></p>
<p>✅<code>Raw use of parameterized class</code> 参数化类型的原始使用</p>
<p>指出省略了类型的参数化类的使用。这种对参数化类型的原始使用在Java中是有效的，但是会破坏使用类型参数的目的，并可能掩盖错误。此检查反映了编译阶段对原始类型的警告。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List list = new ArrayList(); //不指定范型，默认为Object类型</span><br><span class="line">list.add(&quot;123&quot;);</span><br><span class="line">list.add(1L);</span><br><span class="line">list.add(0.11d);</span><br><span class="line">// 可以这样构造list，但是下面转类型会出错，不能吧String类型转为double。</span><br><span class="line">//java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Double</span><br><span class="line">for (Object o : list) &#123;</span><br><span class="line">    double a = (double) o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码就是直接使用原生态类型的实现，在编译时期不会有任何问题，但是一旦运行就会报错：Exception in thread “main” java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Double，代码设计应该使错误尽早被发现，而这就是不安全的表现了，而且可读性而言，缺少了形式类型参数，我们很难明白List存储的类型是什么，表述性变差。</p>
<p>如果确定使用是安全的，不会在运行时候导致错误，则可通过 <code>@SuppressWarnings(&quot;rawtypes&quot;)</code>消除使用原生态类型警告。</p>
<p>参考：<a href="https://cloud.tencent.com/developer/article/1677759">https://cloud.tencent.com/developer/article/1677759</a></p>
<p>✅<code>Unchecked call to ... </code> 调用未经检查</p>
<p>比如上面add的时候就会提示，表示未检查add的参数的类型，因为定义list的时候没指定类型，如果指定类型就不报了。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java常规</title>
    <url>/2022/04/30/myblog/java/java%E5%B8%B8%E8%A7%84/</url>
    <content><![CDATA[<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>1、sql（dao层）返回的，尽量不要用VO，而使用DO。除非联表查询？dao层查出来的do需要加其他表的一两个字段，可以在原表do的基础上继承封装一下，如果要传入，可以直接输入子类，dao层处理时会自动解析为父类。</p>
<p>2、service里面不要调不想干的dao层方法，而是调dao所在service的方法。</p>
<p>3、继承自同一抽象类的类方法，需要对同一返回处理，并且是串行的，可以输入中用context。</p>
<p>4、main方法是静态方法，同一个类内的方法得加static，不然就是成员方法，成员方法无法在静态方法中调用。</p>
<p>5、运行时异常比如NPE，在方法里throw，不需要在方法上throw了，并且里面方法抛出的异常，可以在外面方法可以catch到。</p>
<p>6、写service什么时候写成类，什么时候写成接口？ 如果对外的话就写接口，如果内部代码用，就service类就行。</p>
<p>7、null不能用来做比较，会报NPE，例如：1 &#x3D;&#x3D; null，不行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer s1 = null;</span><br><span class="line">if(s1 == 1) System.out.println(&quot;不对&quot;);  //报NPE</span><br><span class="line">Integer s1 = 3;</span><br><span class="line">if(null == s1) System.out.println(&quot;对&quot;); //对的</span><br><span class="line">String s1 = null;</span><br><span class="line">if(s1 == &quot;a&quot;) System.out.println(&quot;对&quot;); //String不会NPE</span><br></pre></td></tr></table></figure>

<p>8、如果类报红，没有引用到，尝试更新下仓库：点idea右边maven，点左上角更新圈，更新一下。如果还不行，看一下maven的setting文件对不对。</p>
<p>9、if、while、for关键词的后面和括号之间要有空格，HashMap&lt;Integer, Integer&gt;和变量名之间要有空格。<br>方法名后面到入参的括号不需要空格。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public voif func(Integer i) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10、不要在代码中，特别是主线程中随便Thread.sleep，这样会阻塞住线程。</p>
<p>11、方法返回如果是包装类型Double等，如果用double接，是接不住null的，会报空指针异常。</p>
<p>12、boolean这种类型，如果是一个对象的参数，初始化对象时，会给一个默认值false，但是单独初始化boolean类型，需要给值，不能boolean b;</p>
<p>13、配置可以写在一个接口里 XXXInstance，可以这么取名，直接加类型就行，不用public static。调用的时候就 XXXInstance.SSS。</p>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>private：仅限类本身可见<br>default：类内部、包访问权限<br>protected：类内部、同一个包、子类中访问<br>public：类内部、同一个包、子类、任意位置都能访问</p>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>✅java: Compilation failed:</p>
<p>报错原因：<br>项目中Java版本不一致，可以查看项目中的jdk配置.<br>1、查看项目的jdk<br>File -&gt;Project Structure-&gt;Project Settings -&gt;Project </p>
<p>2、查看工程的jdk<br>File -&gt;Project Structure-&gt;Project Settings -&gt; Modules -&gt; （需要修改的工程名称） -&gt; Sources -&gt;</p>
<p>3、查看idea中Java配置<br>compile 的 java compile中。</p>
<p>✅空指针NPE</p>
<p>空指针(Null Pointer Exception，NPE)<br>空指针异常属于运行时的异常。当Java尝试去调用真实对象上的任何方法时，如果在运行时中，该对象调用的是空引用(Null Reference)，那么就会抛出异常。<br>由于种种原因，开发人员时常会忘记初始化对象和验证对象。这往往是导致空指针异常的根源。<br>例如：对一个为null的对象调用get&#x2F;set方法，就会NPE。</p>
<p>🤔Optional避免空指针<br>java.util.Optional 是java8中引进的一个新的类，它可以对可能缺失的值进行建模，而不是直接将null赋值给变量。</p>
<p>java引入空指针的危害：<br>1、它是很多问题的错误之源，它是目前开发中最典型的异常。<br>2、它会使代码膨胀，它会使我们的代码充满了深度嵌套的null检查，代码的可读性下降。<br>3、它自身是毫无意义的，null自身没有任何的语义，它表示以一种错误的方式对缺失变量的值建模。<br>4、它破坏了java的哲学，java一直避免引入指针的存在，而唯一的例外就是null指针。<br>5、它破坏了java的类型，null不属于任何类型，这也意味着它可以被赋值给任意引用类型的变量，我们将无法获取这个null值最初的类型是什么。<br>而Optional的出现可以让我们最大程度上规避上述问题。</p>
<p>Optional的使用：<a href="https://blog.csdn.net/aaaPostcard/article/details/123596787">https://blog.csdn.net/aaaPostcard/article/details/123596787</a><br>（感觉只能避免对自己定义的domain产生空指针异常，无法避免从数据库中获取到null，然后操作造成NPE。）</p>
<p>✅ IllegalStateException:Failed to load ApplicationContext</p>
<p>加载类出问题，往下看是哪个类没加载，获取bean出现问题，看是不是当作对象调用了，但是没加@Service。</p>
<p>✅ for循环内通过new来修改引用变量导致的问题</p>
<p>for循环中声明的变量是局部变量，List中存着对象的引用变量，也就是对象在堆中的地址。for循环中通过set方法来改变堆中的变量，没问题，引用变量并不会改变。</p>
<p>但是，for循环中通过new一个新对象来赋值给局部变量，新对象是在堆中创建了，对象地址赋给局部变量，但是List中的值并没有改变。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test10() &#123;</span><br><span class="line">    A a = new A(&quot;lll&quot;);</span><br><span class="line">    List&lt;A&gt; list1 = Lists.newArrayList(a);</span><br><span class="line">    List&lt;A&gt; list2 = Lists.newArrayList();</span><br><span class="line">    list2.addAll(list1);</span><br><span class="line">    System.out.println(list2); //[A(name=lll)]</span><br><span class="line">    a.setName(&quot;www&quot;);</span><br><span class="line">    System.out.println(list1); //[A(name=www)]</span><br><span class="line">    System.out.println(list2); //[A(name=www)]</span><br><span class="line"></span><br><span class="line">    for (A u : list2) &#123;</span><br><span class="line">        u.setName(&quot;bbb&quot;);</span><br><span class="line">        System.out.println(u.hashCode()); //1642360923</span><br><span class="line">        A u1 = new A(&quot;aaa&quot;);</span><br><span class="line">        u = u1;</span><br><span class="line">        u.setName(&quot;aaa&quot;);</span><br><span class="line">        System.out.println(u.hashCode()); //1343441044</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list2); //[A(name=bbb)]</span><br><span class="line">    System.out.println(list2.get(0).hashCode()); //1642360923</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ToString</span><br><span class="line">class A &#123;</span><br><span class="line">    A(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Void-与-void-与-null"><a href="#Void-与-void-与-null" class="headerlink" title="Void 与 void 与 null"></a>Void 与 void 与 null</h3><p>void 是一种基本数据类型。而 Void 是 void 封装类型。<br>Void 之于 void 类似于 Integer 之于 int。但并非如此，Void 比较特别：<br>它不可实例化<br>它没有内置的类型实例，也没有可用的字面值。</p>
<p>声明一个 Void 变量通常是没有什么意义的，因为没有可为其赋值的实例。Void 变量唯一能持有的是 null。Void 一个可用的地方是反射判断方法的返回值时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(m.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">	// 处理返回值为 void 的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但也不是必需使用Void.TYPE，也可以用void.class。<br>总结来说，几乎很少会用到 Void 。</p>
<p>null是所有引用类型的默认值，但是要澄清一些误解，null既不是对象也不是一种类型，它仅是一种特殊的值，你可以将其赋予任何引用类型，你也可以将null转化成任何类型。</p>
<p>访问一个类里的方法，如果用null赋予的对象访问普通方法，会NullPointerException，而访问static方法，没事，因为访问静态方法不需要实例对象。因此，静态方法的访问，不建议用实例调用，用类调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Main m = (Main) null;</span><br><span class="line">System.out.println(m instanceof Main); //返回false</span><br><span class="line">System.out.println(m.getClass()); //空指针</span><br></pre></td></tr></table></figure>

<p>void不是函数，是方法的修饰符，void的意思是该方法没有返回值，意思就是方法只会运行方法中的语句，但是不返回任何东西。 java.lang.Void是一种类型。例如给Void引用赋值null。通过Void类的源代码可以看到，Void类型不可以继承与实例化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class Main &#123;</span><br><span class="line"></span><br><span class="line">    public void do1() &#123;</span><br><span class="line">        return; //返回void，return可写可不写</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Void do2() &#123;</span><br><span class="line">        return null; //此处必须返回null 返回其余类型都不好使</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Void.class); //class java.lang.Void</span><br><span class="line">        System.out.println(void.class); //void</span><br><span class="line">        //类似于下面的</span><br><span class="line">        System.out.println(Integer.class); //class java.lang.Integer</span><br><span class="line">        System.out.println(int.class); //int</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Void我们到底有什么用呢？其实在泛型出现之前，Void一般用于反射之中。判断方法返回是否为void。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">  public void print(String v) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  public static void main(String args[])&#123;</span><br><span class="line">    for(Method method : Test.class.getMethods()) &#123;</span><br><span class="line">      //判断返回值类型 用到了Void类</span><br><span class="line">      if(method.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">        System.out.println(method.getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有有的时候，并不需要返回值的抽像性设计，比如下面设计的分布式锁：RedisLock.</p>
<p>更多用法：<a href="https://blog.csdn.net/f641385712/article/details/80409211?utm_source=blogxgwz0">https://blog.csdn.net/f641385712/article/details/80409211?utm_source=blogxgwz0</a></p>
<h3 id="Java中包装类型和基本类型的使用场景"><a href="#Java中包装类型和基本类型的使用场景" class="headerlink" title="Java中包装类型和基本类型的使用场景"></a>Java中包装类型和基本类型的使用场景</h3><p>最简单的理解，基本类型有默认值，而包装类型初始为null。然后再根据这两个特性进行分业务使用，在阿里巴巴的规范里所有的POJO类必须使用包装类型，而在本地变量推荐使用基本类型。定义方法的输入输出参数用包装类型。List里用包装类型(,因为List中的泛型必须是引用类型。)，for循环里用包装类型。</p>
<p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。<br>1、整数：包括int、short、byte、long初始值为0。<br>2、浮点型：float、double初始值为0.0<br>3、字符：char初始值为空格，即’’ “，如果输出，在Console上是看不到效果的。<br>4、布尔：boolean初始值为false </p>
<p>基本类型的包装类<br>Integer 、Long、Short、Byte、Character、Double、Float、Boolean、BigInteger、BigDecimal<br>其中BigInteger、BigDecimal没有相对应的基本类型，主要应用于高精度的运算，BigInteger 支持任意精度的整数，<br>BigDecimal支持任意精度带小数点的运算。</p>
<p>基本类型与包装类型的异同：<br>1、在Java中，一切皆对象，但八大基本类型却不是对象。<br>2、声明方式的不同，基本类型无需通过new关键字来创建，而封装类型则需new关键字。<br>3、存储方式及位置的不同，基本类型是直接存储变量的值，保存在堆栈中能高效的存取；封装类型需要通过引用指向实例，具体的实例保存在堆中；<br>4、初始值的不同，封装类型的初始值为null，基本类型的的初始值视具体的类型而定，比如int类型的初始值为0，boolean类型为false；<br>5、使用方式的不同，比如与集合类合作使用时只能使用包装类型。<br>6、什么时候该用包装类，什么时候该用基本类型，看基本的业务来定：这个字段允不允许null值，如果允许，则必然要用封装类；否则，基本类型就可以了。如果用到比如泛型和反射调用函数，就需要用包装类！ </p>
<p>转自 <a href="http://t.zoukankan.com/east7-p-9887722.html">http://t.zoukankan.com/east7-p-9887722.html</a></p>
<h4 id="parseDouble-和valueOf-方法，类型转换"><a href="#parseDouble-和valueOf-方法，类型转换" class="headerlink" title="parseDouble()和valueOf()方法，类型转换"></a>parseDouble()和valueOf()方法，类型转换</h4><p>✅Double类parseDouble()和valueOf()方法的区别（String转Double）</p>
<p>1、Double.parseDouble(java.lang.String)的参数只能是String。Double.valueOf()的参数类型可以是浮点型或者是字符串均可。</p>
<p>2、Double.parseDouble(java.lang.String)把数字类型的字符串转换成double类型，返回是double类型。入参是String。<br>Double.valueOf()方把数字类型的字符串转换成Double类型，返回是Double类型。入参是String或double。</p>
<p>这两个方法里面都不能是Object类型，得先o.toString转为String，再变Double。注意空指针。</p>
<p>✅Double转String</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = Double.toString(1.1);  //里面可以是double也可以是Double,为null会NPE</span><br><span class="line"></span><br><span class="line">Double d = 1.1;</span><br><span class="line">String s1 = d.toString();  //Object的toString方法double类型不能用,d为null会NPE</span><br><span class="line"></span><br><span class="line">double d1 = 1.2;</span><br><span class="line">String s1 = String.valueOf(d);  //里面可以是double也可以是Double,可以是null，nul的话输出“null”</span><br></pre></td></tr></table></figure>

<p>✅强制类型转换<br>首先，每个包装类型都有一个valueOf方法，用来把其他类型转换为自己类型。例如：Double d &#x3D; Double.valueOf(“1”);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line">    System.out.println((double) 1 / 1000); //输出0.001</span><br><span class="line">    System.out.println((double) (1 / 1000)); //输出0.0</span><br><span class="line">    Integer integer = 1;</span><br><span class="line">    System.out.println((double) integer / 1000); //输出0.001</span><br><span class="line"></span><br><span class="line">    //向上取整</span><br><span class="line">    double d = Math.ceil(2.3);</span><br><span class="line">    Integer i = (int) d;</span><br><span class="line">    System.out.println(i); //输出3</span><br><span class="line"></span><br><span class="line">    int x = 1, y = 2;</span><br><span class="line">    double z = x / y; //waring:&#x27;x / y&#x27;: integer division in floating-point context （意思是说这是浮点数的除法）</span><br><span class="line">    System.out.println(z);  //0.0</span><br><span class="line">    double w = 1.0 * x / y;</span><br><span class="line">    System.out.println(w);  //0.5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="String-valueOf-1L-和-l-toString"><a href="#String-valueOf-1L-和-l-toString" class="headerlink" title="String.valueOf(1L)和 l.toString"></a>String.valueOf(1L)和 l.toString</h4><p>String.valueOf 入参是Object。<br>String.valueOf 如果传入null，返回是“null”字符串，而不是空null。<br>null.toString() 会报空指针。<br>不是包装类型的int，.toString()也不行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Long l = new Long(1L);</span><br><span class="line">String s1 = String.valueOf(l);</span><br><span class="line">System.out.println(s1);</span><br><span class="line">String s2 = l.toString();</span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line">l = null;</span><br><span class="line">String s3 = String.valueOf(l);</span><br><span class="line">System.out.println(s3);  //null</span><br><span class="line">String s4 = l.toString(); //NullPointerException</span><br><span class="line">System.out.println(s4);</span><br></pre></td></tr></table></figure>

<h4 id="判断小数精确度"><a href="#判断小数精确度" class="headerlink" title="判断小数精确度"></a>判断小数精确度</h4><p>实现思路：用String的split方法，得到小数点后的String，再看大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (&quot;1231312.12&quot;.split(&quot;\\.&quot;)[1].length()==2) &#123;</span><br><span class="line">    System.out.println(&quot;是两位小数&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="比较两个double的大小"><a href="#比较两个double的大小" class="headerlink" title="比较两个double的大小"></a>比较两个double的大小</h4><p>1.用bigdecimal，传入string类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigDecimal bdL = new BigDecimal(&quot;1.22&quot;);</span><br><span class="line">BigDecimal bdR = new BigDecimal(&quot;1.22&quot;);</span><br><span class="line">if (bdL.compareTo(bdR) &lt; 0)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else if (bdL.compareTo(bdR) == 0)</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br></pre></td></tr></table></figure>

<p>2.使用Double</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Double dL = 1.33;</span><br><span class="line">Double dR = 1.33;</span><br><span class="line">if (dL.compareTo(dR) &lt; 0)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else if (dL.compareTo(dR) == 0)</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br></pre></td></tr></table></figure>

<p>3.在误差范围内允许相等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 两实数的差在允许的范围内认为相等既可认为是相等的</span><br><span class="line">Double num1 = 1.222;</span><br><span class="line">Double num2 = 1.222;</span><br><span class="line">if (num1 - num2 &gt; 0.000001)</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br><span class="line">else if (num1 - num2 &lt; -0.0000001)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br></pre></td></tr></table></figure>

<p>4.转换成字符串</p>
<p>可以将double数据转换成string然后借助string的compareTo方法来间接实现比较两个double数据是否相等。注意这种方法只适用于比较精度相同的数据，并且是只能用于比较正数的大小，负数比较结果异常，不过可以用于比较两数是否相等，此时正负数对结果没有影响。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String strL = String.valueOf(num1);</span><br><span class="line">String strR = String.valueOf(num2);</span><br><span class="line">if (strL.compareTo(strR) &lt; 0)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else if (strL.compareTo(strR) == 0)</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br></pre></td></tr></table></figure>

<p>5.使用doubleToLongBits()方法</p>
<p>使用sun提供的Double.doubleToLongBits()方法，该方法可以将double转换成long型数据，从而可以使double按照long的方法（&lt;, &gt;, &#x3D;&#x3D;）判断是否大小和是否相等，但是，这种办法还是只能用于比较正数，负数结果异常，比较两数相等与否是没有问题的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用使用sun提供的Double.doubleToLongBits()方法</span><br><span class="line">long lL = Double.doubleToRawLongBits(num1);</span><br><span class="line">long lR = Double.doubleToRawLongBits(num2);</span><br><span class="line">System.out.println(lL + &quot;:&quot; + lR);</span><br><span class="line">if (lL &lt; lR)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else if (lL == lR)</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://blog.csdn.net/qq_49217297/article/details/124969742">https://blog.csdn.net/qq_49217297/article/details/124969742</a></p>
<h4 id="保留两位小数"><a href="#保留两位小数" class="headerlink" title="保留两位小数"></a>保留两位小数</h4><p>1、使用java.math.BigDecimal，四舍五入的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Double value = 1.2355;</span><br><span class="line">BigDecimal bd = new BigDecimal(value);</span><br><span class="line">bd = bd.setScale(2, RoundingMode.HALF_UP);</span><br><span class="line">System.out.println(bd.toString());</span><br><span class="line">System.out.println(bd.doubleValue());</span><br></pre></td></tr></table></figure>

<p>2、使用DecimalFormat,保留小数点后两位，四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DecimalFormat df = new DecimalFormat(&quot;0.00&quot;);</span><br><span class="line">df.setRoundingMode(RoundingMode.HALF_UP);</span><br><span class="line">System.out.println(df.format(value));</span><br></pre></td></tr></table></figure>

<p>3、使用NumberFormat,保留小数点后两位，四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NumberFormat nf = NumberFormat.getNumberInstance();</span><br><span class="line">//如果不这么做，那么当value的值是100.00的时候返回100</span><br><span class="line">nf.setMaximumFractionDigits(2);</span><br><span class="line">nf.setMinimumFractionDigits(2);</span><br><span class="line">nf.setRoundingMode(RoundingMode.HALF_UP);</span><br><span class="line">//如果想输出的格式用逗号隔开，可以设置成true</span><br><span class="line">nf.setGroupingUsed(false);</span><br><span class="line">System.out.println(nf.format(value));</span><br></pre></td></tr></table></figure>

<p>4、使用java.util.Formatter,保留小数点后两位，四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = new Formatter().format(&quot;%.2f&quot;, value).toString();</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>5、使用String.format来实现，四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(String.format(&quot;%.2f&quot;, value));</span><br></pre></td></tr></table></figure>

<p>六、通过运算，不是四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long l =(long)(value*100) ;</span><br><span class="line">double d = l/100D;</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure>

<p>Java保留两位小数的几种写法总结：<br><a href="https://cloud.tencent.com/developer/article/2155412">https://cloud.tencent.com/developer/article/2155412</a></p>
<h4 id="int的最大最小值"><a href="#int的最大最小值" class="headerlink" title="int的最大最小值"></a>int的最大最小值</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(Integer.MIN_VALUE); //-2147483648</span><br><span class="line">System.out.println(Integer.MAX_VALUE); //2147483647</span><br><span class="line">System.out.println(-Integer.MIN_VALUE); //-2147483648  Numeric overflow in expression</span><br></pre></td></tr></table></figure>

<p>32 位的有符号整数的范围 [−2^31,  2^31 − 1]</p>
<p>问题：为什么-Integer.MIN_VALUE的结果会是-2147483648<br>因为出现了溢出的问题，整数用二进制补码表示，最高位是符号为，0正数，1负数。<br>MIN_VALUE的二进制表示：100000….<br>负数的二进制表示进行取反再加1，就得到绝对值。<br>从绝对值到负数二进制：绝对值二进制，取反，再加1得到。</p>
<p>二进制补码的出现是为了方便负数的加减运算。减法可以通过加上对应正数的补码来实现。</p>
<p>Integer.MIN_VALUE取负的过程：<br>1.MIN_VALUE的二进制表示：100000….每一位取反，得到01111…<br>2.然后将上述结果+1，的到100000… 还是自己</p>
<p>正数的补码等于它的原码；负数的补码等于反码+1。</p>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>使用场景：比较精确的数字的加减法、小数的四舍五入</p>
<p>首先，浮点数为什么不准确？<br>码农在程序里写的10进制小数，计算机内部无法用二进制的小数来精确的表达。<br>对于二进制小数，小数点右边能表达的值是 1&#x2F;2, 1&#x2F;4, 1&#x2F;8, 1&#x2F;16, 1&#x2F;32, 1&#x2F;64, 1&#x2F;128 … 1&#x2F;(2^n）</p>
<p>试一试如何表达十进制的 0.2 吧。</p>
<p>0.01 &#x3D; 1&#x2F;4 &#x3D; 0.25 ,太大</p>
<p>0.001 &#x3D;1&#x2F;8 &#x3D; 0.125 , 又太小</p>
<p>0.0011 &#x3D; 1&#x2F;8 + 1&#x2F;16 &#x3D; 0.1875 , 逼近0.2了</p>
<p>0.00111 &#x3D; 1&#x2F;8 + 1&#x2F;16 + 1&#x2F;32 &#x3D; 0.21875 , 又大了</p>
<p>0.001101 &#x3D; 1&#x2F;8+ 1&#x2F;16 + 1&#x2F;64 &#x3D; 0.203125 还是大</p>
<p>0.0011001 &#x3D; 1&#x2F;8 + 1&#x2F;16 + 1&#x2F;128 &#x3D; 0.1953125 这结果不错</p>
<p>0.00110011 &#x3D; 1&#x2F;8+1&#x2F;16+1&#x2F;128+1&#x2F;256 &#x3D; 0.19921875<br>已经很逼近了， 就这样吧。</p>
<p>这就是用二进制小数没法精确表达10进制小数的含义。<br>根本原因是:十进制值通常没有完全相同的二进制表示形式;十进制数的二进制表示形式可能不精确。只能无限接近于那个值</p>
<p>《Effective Java》在第48条推荐“使用BigDecimal来做精确运算”。</p>
<hr>
<p>float和double类型的主要设计目标是为了科学计算和工程计算。他们执行二进制浮点运算，这是为了在广域数值范围上提供较为精确的快速近似计算而精心设计的。然而，它们没有提供完全精确的结果，所以不应该被用于要求精确结果的场合。但是，商业计算往往要求结果精确，这时候BigDecimal就派上大用场啦。</p>
<p>Java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，在商业计算中要用java.math.BigDecimal。BigDecimal所创建的是对象，我们不能使用传统的+、-、*、&#x2F;等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。</p>
<hr>
<h4 id="✅BigDecimal构造方法："><a href="#✅BigDecimal构造方法：" class="headerlink" title="✅BigDecimal构造方法："></a>✅BigDecimal构造方法：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public BigDecimal(double val)    将double表示形式转换为BigDecimal *不建议使用</span><br><span class="line">public BigDecimal(int val)　　将int表示形式转换成BigDecimal</span><br><span class="line">public BigDecimal(long)    创建一个具有参数所指定长整数值的对象。 </span><br><span class="line">public BigDecimal(String val)　　将String表示形式转换成BigDecimal *推荐使用</span><br></pre></td></tr></table></figure>
<p>⚠️BigDecimal 不像Double一样可以直接&#x3D;1.1。 BigDecimal需要new个对象，或者：BigDecimal.ZERO 表示0.0。</p>
<p>为什么不推荐使用Double入参？<br>BigDecimal bDouble &#x3D; new BigDecimal(2.3);<br>最终输出的数是：2.29999999….</p>
<p>为什么会出现这种情况呢？</p>
<p>JDK的描述：<br>1、参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。</p>
<p>2、另一方面，String 构造方法是完全可预知的：写入 newBigDecimal(“0.1”) 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法。</p>
<p>当double必须用作BigDecimal的源时，请使用Double.toString(double)转成String，然后使用String构造方法，或使用BigDecimal的静态方法valueOf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigDecimal bDouble1 = BigDecimal.valueOf(2.3); //方法不能传null</span><br><span class="line">BigDecimal bDouble2 = new BigDecimal(Double.toString(2.3));</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="✅BigDecimal用法："><a href="#✅BigDecimal用法：" class="headerlink" title="✅BigDecimal用法："></a>✅BigDecimal用法：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal a = new BigDecimal(&quot;4.5&quot;);</span><br><span class="line">        BigDecimal b = new BigDecimal(&quot;1.5&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;a + b =&quot; + a.add(b));</span><br><span class="line">        System.out.println(&quot;a - b =&quot; + a.subtract(b));</span><br><span class="line">        System.out.println(&quot;a * b =&quot; + a.multiply(b));</span><br><span class="line">        System.out.println(&quot;a / b =&quot; + a.divide(b));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>👋BigDecimal除法可能出现不能整除的情况，比如 4.5&#x2F;1.3，这时会报错java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.</p>
<p>其实divide方法有可以传三个参数</p>
<p><code>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) </code><br>第一参数表示除数， 第二个参数表示小数点后保留位数，<br>第三个参数表示舍入模式，只有在作除法运算或四舍五入时才用到舍入模式，有下面这几种:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROUND_CEILING    //向正无穷方向舍入</span><br><span class="line">ROUND_DOWN    //向零方向舍入</span><br><span class="line">ROUND_FLOOR    //向负无穷方向舍入</span><br><span class="line">ROUND_HALF_DOWN    //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向下舍入, 例如1.55 保留一位小数结果为1.5</span><br><span class="line">ROUND_HALF_EVEN    //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，如果保留位数是奇数，使用ROUND_HALF_UP，如果是偶数，使用ROUND_HALF_DOWN</span><br><span class="line">ROUND_HALF_UP    //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向上舍入, 1.55保留一位小数结果为1.6</span><br><span class="line">ROUND_UNNECESSARY    //计算结果是精确的，不需要舍入模式</span><br><span class="line">ROUND_UP    //向远离0的方向舍入</span><br><span class="line"></span><br><span class="line">四舍五入采用 ROUND_HALF_UP</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigDecimal b1 = new BigDecimal(&quot;1000&quot;);  </span><br><span class="line">BigDecimal b2 = new BigDecimal(&quot;100&quot;);  </span><br><span class="line">System.out.println(b1.divide(b2, 2, BigDecimal.ROUND_HALF_UP).toString());</span><br><span class="line">输出：</span><br><span class="line">10.00,结果返回一个BigDecimal</span><br></pre></td></tr></table></figure>


<p>对BigDecimal进行截断和四舍五入可用setScale方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal a = new BigDecimal(&quot;4.5635&quot;);</span><br><span class="line"></span><br><span class="line">        a = a.setScale(3, RoundingMode.HALF_UP);    //保留3位小数，且四舍五入</span><br><span class="line">        a = a.setScale(3, BigDecimal.ROUND_HALF_UP);    //这个也行</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        Double d = a.doubleValue();  //转为double/Double类型</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>BigDecimal都是不主动变的（immutable）的，在进行每一步运算时，都会产生一个新的对象，所以在做加减乘除运算时千万要保存操作后的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal a = new BigDecimal(&quot;4.5&quot;);</span><br><span class="line">        BigDecimal b = new BigDecimal(&quot;1.5&quot;);</span><br><span class="line">        a.add(b);</span><br><span class="line"></span><br><span class="line">        System.out.println(a);  //输出4.5. 加减乘除方法会返回一个新的BigDecimal对象，原来的a不变</span><br><span class="line">        a = a.add(b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://www.cnblogs.com/YangJavaer/p/6056394.html">https://www.cnblogs.com/YangJavaer/p/6056394.html</a></p>
<hr>
<h4 id="✅BigDecimal比较"><a href="#✅BigDecimal比较" class="headerlink" title="✅BigDecimal比较"></a>✅BigDecimal比较</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int flag = bigdemical.compareTo(bigdemical1)。</span><br><span class="line"></span><br><span class="line">flag = -1，表示bigdemical小于bigdemical1。</span><br><span class="line"></span><br><span class="line">flag =0，表示bigdemical等于bigdemical1。</span><br><span class="line"></span><br><span class="line">flag =1，表示bigdemical大于bigdemical1。</span><br><span class="line"></span><br><span class="line">实际中直接跟0比较就可以了，别跟-1或者1比较。</span><br></pre></td></tr></table></figure>

<p>BigDecimal的equals方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigDecimal a=BigDecimal.valueOf(1.0);</span><br><span class="line">BigDecimal b=BigDecimal.valueOf(1.000);</span><br><span class="line">System.out.println(a.equals(b));  //true</span><br><span class="line"></span><br><span class="line">BigDecimal c = new BigDecimal(&quot;10.00&quot;);</span><br><span class="line">BigDecimal d = new BigDecimal(&quot;10&quot;);</span><br><span class="line">BigDecimal e = new BigDecimal(10.00);</span><br><span class="line">System.out.println(c.equals(d));  //false</span><br><span class="line">System.out.println(c.equals(e));  //false</span><br><span class="line">// equals是比较内容，“1.0”和“1.000”不一样.</span><br><span class="line"></span><br><span class="line">//toPlainString再equals</span><br><span class="line">System.out.println(c.toPlainString().equals(d.toPlainString())); //false</span><br><span class="line">System.out.println(c.toPlainString().equals(e.toPlainString())); //false</span><br><span class="line"></span><br><span class="line">//longValue方式</span><br><span class="line">System.out.println(c.longValue() == d.longValue()); //true</span><br><span class="line">System.out.println(c.longValue() == e.longValue()); //true</span><br><span class="line"></span><br><span class="line">//compareTo</span><br><span class="line">System.out.println(c.compareTo(d) == 0); //true</span><br><span class="line">System.out.println(c.compareTo(e) == 0); //true</span><br><span class="line"></span><br><span class="line">BigDecimal f = new BigDecimal(&quot;10.100001&quot;);</span><br><span class="line">BigDecimal g = new BigDecimal(10.100001);</span><br><span class="line">System.out.println(f.compareTo(g) == 0); //false</span><br><span class="line">// 这是因为本身Double传参的构造就不准，看上面</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://www.iteye.com/blog/bijian1013-2366549">https://www.iteye.com/blog/bijian1013-2366549</a></p>
<hr>
<h4 id="✅mysql的decimal"><a href="#✅mysql的decimal" class="headerlink" title="✅mysql的decimal"></a>✅mysql的decimal</h4><p>decimal:数字型，不存在精度损失，常用于银行帐目计算</p>
<p><code>distance decimal(10,1) not null default 0.0 comment &#39;距离&#39;</code></p>
<p>decimal(P,m)<br>P的取值范围是1–65，表示整数位数<br>M的取值是0–30.表示小数位<br>精度M最大为30，表示有30位小数。<br>decimal整数和小数位均不写 默认为decimal(10,0)<br>若小数位不写默认的小数位为0。</p>
<p>decimal(22,6）表示整数位16个小数位6个。</p>
<p>decimal 还可以存储超过bigint的整数位，最大存储65位的整数类型。<br>还可以存储对应位数的负数</p>
<p>例：decimal(2,1)，此时，插入数据“12.3”、“12”等会出现“数据溢出错误”的异常；插入“1.23”或“1.2345…”会自动四舍五入成“1.2”；插入“2”会自动补成“2.0”，以确保2位的有效长度，其中包含1位小数。<br>当用 int类型会有溢出时，可以用 decimal 类型进行处理，把结果可以用 convert 或是 cast 进行转换。<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/chenpp666/article/details/124372731">https://blog.csdn.net/chenpp666/article/details/124372731</a></p>
<h3 id="java位运算"><a href="#java位运算" class="headerlink" title="java位运算"></a>java位运算</h3><p>1、左移( &lt;&lt; )  向左移动，低位补0<br>2、右移( &gt;&gt; )  向右移动，高位补0<br>3、无符号右移( &gt;&gt;&gt; )   正数右移，高位补0，负数右移，高位补1，当负数使用无符号右移时，用0进行补位(自然而然的，就由负数变成了正数了)<br>4、与( &amp; )  都为1，结果为1，否则为0<br>5、或( | )  一个是1，结果为1，否则为0<br>6、异或( ^ )  两个相反，结果为1，否则为0<br>7、非( ~ ) 一元操作符   取相反。</p>
<h3 id="Autowired接口还是现实类？"><a href="#Autowired接口还是现实类？" class="headerlink" title="Autowired接口还是现实类？"></a>Autowired接口还是现实类？</h3><p>答案：接口好</p>
<p>当实现类唯一时，表面上注入接口，其实注入实现类<br>当实现类多个时，通过@Service(“menuService1”)指定实现类</p>
<p>解析：<br>这个其实是创建了实现类的对象但引用了接口类型，<br>即 “InjectionDao injectionDao &#x3D; new InjectionDaoImpl ()”, 是 Java 多态性（向上转型）的一种应用。<br>在实现类处加 @Repository 注解，意思就是 new InjectionDaoImpl (),</p>
<p>而在 InjectionServiceImpl 中定义属性 InjectionDAO injectionDAO 就是将 new 出来的这个 InjectionDaoImpl 对象向上转型为 InjectionDao 类型。</p>
<p>注意：<br>若一个接口被多个实现类，实现的时候，@Autowired，Spring 会按 byType 的方式寻找接口的实现类，将其注入。存在多个实现类，应该指定名字，可以通过 byName 注入的方式。可以使用 @Resource 或 @Qualifier 注解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//实现类1</span><br><span class="line">@Service(&quot;menuService1&quot;)</span><br><span class="line">public class MenuServiceImpl implements IMenuService</span><br><span class="line"> </span><br><span class="line">//实现类2</span><br><span class="line">@Service(&quot;menuService2&quot;)</span><br><span class="line">public class MenuServiceImpl implements IMenuService</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//注入接口，相当于new一个实现类，指定名称menuService1实现类</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;menuService1&quot;)</span><br><span class="line">private IMenuService menuService;</span><br><span class="line"></span><br><span class="line">//注入接口，相当于new一个实现类，指定名称menuService2实现类  </span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;menuService2&quot;)</span><br><span class="line">private IMenuService menuService;</span><br></pre></td></tr></table></figure>

<p>链接：<a href="https://blog.csdn.net/huangkechen/article/details/122475824">https://blog.csdn.net/huangkechen/article/details/122475824</a></p>
<p>总结：就是Java 多态性（向上转型）的一种应用，但是这样做的好处并没有说。<br>规矩：注入实现类时用@Resource（@Autowired应该也可以），接口单个实现类用@Autowired（@Resource应该也可以），接口多个实现类用@Autowired + @Qualifier(value&#x3D;””) 或 @Resource(name&#x3D;””)。</p>
<h3 id="Collection、Collections、CollectionUtils"><a href="#Collection、Collections、CollectionUtils" class="headerlink" title="Collection、Collections、CollectionUtils"></a>Collection、Collections、CollectionUtils</h3><p>Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collection（单例集合  ） </span><br><span class="line">├-List（有序，可重复 ）  </span><br><span class="line">│  ├-LinkedList（查询速度慢，增删快）   </span><br><span class="line">│  ├-ArrayList（查询速度快，增删慢）  </span><br><span class="line">│  └-Vector（线程安全的，操作效率低 ）  </span><br><span class="line">│　    └-Stack   </span><br><span class="line">└-Set（无序，不可重复） </span><br><span class="line">      ├-HashSet（使用了哈希表存取）</span><br><span class="line">      │    └-LinkedHashSet</span><br><span class="line">      └-SortedSet</span><br><span class="line">               └-TreeSet（有序）</span><br><span class="line">Map（键值对）  </span><br><span class="line">├-Hashtable   </span><br><span class="line">├-HashMap   </span><br><span class="line">└-WeakHashMap</span><br></pre></td></tr></table></figure>
<p>set是在HashMap的基础上实现的，HashSet的存储方式是把HashMap中的Key作为Set的对应存储项。HashMap是非同步的，线程不安全的，Hashtable虽然是同步线程安全的，但是已经过期了。 现在使用ConcurrentHashMap，这个是线程安全同步的。</p>
<p>Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p>
<p>例如：排序(Sort)、倒序(reverse)、最大(max)、最小(min)、替换(fill)</p>
<p>使用sort方法可以根据元素的自然顺序对指定列表按升序进行排列。列表中所有元素都必须实现Comparable接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collections.sort(list);//排序</span><br><span class="line">System.out.println(list);</span><br><span class="line">Collections.reverse(list);//倒序</span><br><span class="line">System.out.println(list);</span><br><span class="line">int max = Collections.max(list);//最大</span><br><span class="line">System.out.println(max);</span><br><span class="line">int min = Collections.min(list);//最小</span><br><span class="line"></span><br><span class="line">Collections.emptyList()  //空list</span><br></pre></td></tr></table></figure>

<p>CollectionUtils是对Collection集合操作的类方法，这个类不是java自带的类方法，需要另外导入一个commons-collections.jar包才可以使用这个类中方法。</p>
<p>例如：CollectionUtils.isEmpty(list)<br>它可以处理null，但是list.isEmpty里面为null，会NPE。</p>
<p>更多用法：<a href="https://blog.csdn.net/chaoge321/article/details/83788667">https://blog.csdn.net/chaoge321/article/details/83788667</a></p>
<h3 id="list的一些操作"><a href="#list的一些操作" class="headerlink" title="list的一些操作"></a>list的一些操作</h3><h4 id="一、Lists-newArrayList-和-new-ArrayList-："><a href="#一、Lists-newArrayList-和-new-ArrayList-：" class="headerlink" title="一、Lists.newArrayList() 和 new ArrayList() ："></a>一、Lists.newArrayList() 和 new ArrayList() ：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">List&lt;Integer&gt; list = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">Lists和Maps是谷歌的两个工具类,</span><br><span class="line"></span><br><span class="line">Lists.newArrayList()其实和new ArrayList()几乎一模一样,</span><br><span class="line"></span><br><span class="line">唯一它帮你做的(其实是javac帮你做的),就是自动推导尖括号里的数据类型.</span><br><span class="line"></span><br><span class="line">在 Java 7 之后，都允许类型推断 - 在运行时没有区别。</span><br><span class="line"></span><br><span class="line">java8 的new ArrayList&lt;&gt;()的&lt;&gt;里面可以不写类型，java回帮你自动推导类型</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>同样，还有Sets：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; sets = Sets.newHashSet(&quot;ww&quot;); //可直接定义</span><br><span class="line">Set&lt;String&gt; sets = new HashSet&lt;&gt;(Lists.newArrayList(&quot;11&quot;,&quot;22&quot;));</span><br><span class="line">//还得用list转换</span><br><span class="line"></span><br><span class="line">set没有get(i)方法，遍历得用迭代器。要么先转换成list。</span><br><span class="line">set转换为list：</span><br><span class="line">ArrayList&lt;Long&gt; list = new ArrayList(set);</span><br></pre></td></tr></table></figure>

<p>新建List：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//List&lt;String&gt; list1 = new ArrayList&lt;String&gt;(&quot;1&quot;, &quot;2&quot;); 不行</span><br><span class="line">List&lt;String&gt; list2 = Lists.newArrayList(&quot;1&quot;, &quot;2&quot;);</span><br><span class="line">list2.add(&quot;3&quot;);  //咩问题</span><br><span class="line">System.out.println(list2);</span><br><span class="line">List&lt;String&gt; list3 = Arrays.asList(&quot;1&quot;, &quot;2&quot;);</span><br><span class="line">list3.set(1, &quot;3&quot;); //设置除了0、1会报错</span><br><span class="line">System.out.println(list3);</span><br><span class="line">list3.add(&quot;3&quot;);  //报错：java.lang.UnsupportedOperationException</span><br><span class="line">System.out.println(list3);</span><br><span class="line">List&lt;String&gt; list4 = Collections.singletonList(&quot;1&quot;);</span><br><span class="line">list4.add(&quot;2&quot;); //报错：java.lang.UnsupportedOperationException</span><br><span class="line"></span><br><span class="line">String a[] = new String[] &#123; &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot; &#125;;</span><br><span class="line">List&lt;String&gt; list5 = Arrays.asList(a);</span><br></pre></td></tr></table></figure>

<p>✅Array.asList创建方式：<br>java.util.Arrays 类的 asList() 方法用于返回一个由指定数组支持的固定大小的列表。<br>Arrays.asList 最大特点是整个集合允许有多个元素存入数组，一旦初始化后，这个数组的长度就是固定的，但数组的元素可以修改，所以也就是为什么 add 和 remove 方法报错的原因。如果在开发中碰到长度可以确定的集合，并且在初始化时已经确定了储存元素的情况下，推荐使用。<br>Arrays.asList 中传入的数组参数中允许存在 null，但不允许只有一个 null</p>
<p>✅Collections.singletonList()创建方式：<br>Collection.singletonList 长度为 1，初始完后不可修改。根据这个特性，在开发的时候遇到只要储存一个元素的集合，并且整个过程存储或者传递为主，不会进行修改或调整的情况下，推荐使用。<br>Collections.singletonList 中保存元素的是一个对象</p>
<p>✅Arrays.asList() 和 Collections.singletonList()区别 ：<br>1、Arrays.asList()得到的List中元素是可变的，大小不可变。<br>而Collections.singletonList是不可变的，一旦修改就会导致UnsupportedOperationException异常抛出<br>2、Collections.singletonList()得到的List元素只能有1个<br>3、Arrays.asList(strArray)不具有add方法，可以通过set方法进行改变值。Collections.singletonList()返回的是不可变的集合，但是这个长度的集合只有1。</p>
<p>参考：<a href="https://blog.csdn.net/weixin_41606477/article/details/108449415">https://blog.csdn.net/weixin_41606477/article/details/108449415</a></p>
<p>新建Set，除了上面的，还有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; list4 = Collections.singleton(&quot;1&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="二、对list排序：Comparator-java工具类"><a href="#二、对list排序：Comparator-java工具类" class="headerlink" title="二、对list排序：Comparator-java工具类"></a>二、对list排序：Comparator-java工具类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list.sort(Comparator.comparing(A::getB));</span><br><span class="line"></span><br><span class="line">List&lt;类&gt; list; 代表某集合</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一升序排序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一));</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一降序排序 注意两种写法</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).reversed());//先以属性一升序,结果进行属性一降序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()));//以属性一降序</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一升序 属性二升序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).thenComparing(类::属性二));</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一降序 属性二升序 注意两种写法</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二));//先以属性一升序,升序结果进行属性一降序,再进行属性二升序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()).thenComparing(类::属性二));//先以属性一降序,再进行属性二升序</span><br><span class="line"></span><br><span class="line">//含Null数据排序,nullsLast空的放后面，距离Date类型属性</span><br><span class="line">list.stream().sorted(Comparator.comparing(item -&gt; item.属性, Comparator.nullsLast(Date::compareTo))).collect(Collectors.toList());</span><br><span class="line">// nullLast或nullFirst里面带类型，可以用Comparator.nullsLast(Comparator.naturalOrder()))</span><br><span class="line"></span><br><span class="line">//空/Null数据分组</span><br><span class="line">Map&lt;String, List&lt;类&gt;&gt; map = list.stream().collect(Collectors.groupingBy(item -&gt; &#123;</span><br><span class="line">  if (item.属性一 == null || item.属性一.equals(&quot;&quot;)) &#123;</span><br><span class="line">  　　return &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return DateFormat.getDateInstance().format(item.属性一);</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>list可以直接使用sort。<br>用sorted就需要先.stream()，再.collect(Collectors.toList())<br>::都得是get属性</p>
<p>自定义排序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, new Comparator&lt;list中元素&gt;()&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public int compare(元素 o1, 元素 o2) &#123;</span><br><span class="line">    if(..)  return 1;  //表示o1在前</span><br><span class="line">    if(..)  return 0;  //表示一样</span><br><span class="line">    return -1；  //表示o2在前</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="三、list移除：-removeIf"><a href="#三、list移除：-removeIf" class="headerlink" title="三、list移除： removeIf"></a>三、list移除： removeIf</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">removeIf() 方法用于删除所有满足特定条件的数组元素。</span><br><span class="line">ArrayList&lt;String&gt; sites = new ArrayList&lt;&gt;();</span><br><span class="line">sites.add(&quot;Taobao&quot;);</span><br><span class="line">sites.removeIf(e -&gt; e.contains(&quot;Tao&quot;));</span><br><span class="line">用了String的contains方法</span><br></pre></td></tr></table></figure>
<p>list元素可以先设置，再更改。</p>
<p>不能在循环中用正序索引进行移除，因为移除的过程中索引会变。<br>可以用倒序索引。<br>如果非得用循环移除，用迭代器。</p>
<p>for的下标倒序遍历:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = list.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    if (&quot;b&quot;.equals(list.get(i))) &#123;</span><br><span class="line">        list.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用list.stream().filter().collect()：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; newList = list.stream()</span><br><span class="line">        .filter(e -&gt; !&quot;b&quot;.equals(e))</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>用迭代器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    String s = it.next();</span><br><span class="line">    if (&quot;b&quot;.equals(s)) &#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🤔总结一下list移除方法：<br>1、removeIf<br>2、倒叙for循环<br>3、stream filter<br>4、迭代器</p>
<p>⚠️迭代器中，又移除，又对list增加元素是不行的，会引发并发错误。<br>map也是一样，用Entry遍历时，不能又remove又put，而且再循环里不能put新的，只能put已有的，不然会并发错误。也不能remove。用迭代器移除元素。</p>
<p>所以，替换List中的元素，用set方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Long&gt; list = Lists.newArrayList(1L, 2L, 3L);</span><br><span class="line">list.set(1, 4L);  //[1, 4, 3]</span><br></pre></td></tr></table></figure>

<p>【JAVA】List常用移除、过滤、去重、flatMap、peek等操作：<br><a href="https://blog.csdn.net/qq_38397501/article/details/116494227">https://blog.csdn.net/qq_38397501/article/details/116494227</a></p>
<h4 id="四、判断list为空"><a href="#四、判断list为空" class="headerlink" title="四、判断list为空"></a>四、判断list为空</h4><p>if(CollectionUtils.isEmpty(list)){}</p>
<h4 id="五、indexOf方法"><a href="#五、indexOf方法" class="headerlink" title="五、indexOf方法"></a>五、indexOf方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">indexOf() 方法返回动态数组中元素的索引值。</span><br><span class="line">int i = arraylist.indexOf(Object obj)</span><br></pre></td></tr></table></figure>

<h4 id="六、list、set、String转换"><a href="#六、list、set、String转换" class="headerlink" title="六、list、set、String转换"></a>六、list、set、String转换</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//list直接变set：</span><br><span class="line">Set&lt;Long&gt; set2 = new HashSet&lt;&gt;(list);</span><br><span class="line">Set&lt;Long&gt; set1 = Sets.newHashSet(list);</span><br><span class="line">//set变list：</span><br><span class="line">List&lt;Long&gt; list2 = new ArrayList&lt;&gt;(set1);</span><br><span class="line">List&lt;Long&gt; list3 = Lists.newArrayList(set1);</span><br></pre></td></tr></table></figure>

<p>,分割的String转换为List，看下面Splitter。</p>
<p>List转换为,分割字符串，看下面Joiner连接字符串。</p>
<h4 id="七、foreach"><a href="#七、foreach" class="headerlink" title="七、foreach"></a>七、foreach</h4><p>forEach() 方法用于遍历动态数组中每一个元素并执行特定操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testArray()&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 往数组中添加元素</span><br><span class="line">    numbers.add(1);</span><br><span class="line">    numbers.add(2);</span><br><span class="line">    numbers.add(3);</span><br><span class="line">    numbers.add(4);</span><br><span class="line">    System.out.println(&quot;ArrayList: &quot; + numbers);</span><br><span class="line"></span><br><span class="line">    // 将 lambda 表达式传递给 forEach</span><br><span class="line">    numbers.forEach((e) -&gt; &#123;</span><br><span class="line">        System.out.print(e + &quot; &quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>forEach 增强for循环，用于遍历动态数组中每一个元素并执行特定操作。</p>
<p>List的forEach是在Iterable类中，<code>Collection&lt;E&gt; extends Iterable&lt;E&gt;</code>，stream的forEach在Stream中。</p>
<p>Iterable中的方法原型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">default void forEach(Consumer&lt;? super T&gt; action) &#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    for (T t : this) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️使用中出现：提示Variable used in lambda expression should be final or effectively final</p>
<p>这句话的意思是：lambda表达式中使用的变量应该是final或者有效的final。</p>
<p>其实在 Java 8 之前：<br>匿名类中如果要访问局部变量的话，那个局部变量必须显式的声明为final。<br>lambda表达式是由匿名内部类演变过来的，他们的作用都是实现接口方法，于是类比匿名内部类，lambda表达式中使用的变量也需要是final类型。</p>
<p>所以：需要赋值到另一个变量中使用。并且为final类型，不是final类型也可以，变量名中加final。<br>因为：Java 8 之后，在匿名类或 Lambda 表达式中访问的局部变量，如果不是 final 类型的话，编译器自动加上 final 修饰符。</p>
<p>为什么 lambda 表达式或者匿名内部类不能访问非 final 的局部变量，为什么呢？</p>
<p>其实这就要说到Jvm内存模型和线程了，因为实例变量存在堆中，而局部变量是在栈上分配，<strong>lambda 表达(匿名内部类) 会在另一个线程中执行</strong>。如果在线程中要直接访问一个局部变量，可能线程执行时该局部变量已经被销毁了，而 final 类型的局部变量在 Lambda 表达式(匿名类) 中其实是局部变量的一个拷贝。</p>
<p>转自：<a href="https://www.liangzl.com/get-article-detail-213550.html">https://www.liangzl.com/get-article-detail-213550.html</a></p>
<p>所以这个问题的原因不在forEach，而是在lambda表达式。<br>java的lambda表达式里不能出现变量，必须是final修饰的，但是可以让变量在定义时候就写入，这样就不算变量了。可以使用lambda表达式，不再报错。（只定义一次不再改，如果是需要多步才能定义出变量，那就写个方法出结果也可以）</p>
<p>不行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean ebola = false;</span><br><span class="line">ebola = list.size()&gt;10;//赋值</span><br><span class="line">taskExecutor.execute(() -&gt; &#123;</span><br><span class="line">  if(ebola)&#123;</span><br><span class="line">       //业务代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean ebola = checkEbola(list);//相当于定义时直接赋值</span><br><span class="line">taskExecutor.execute(() -&gt; &#123;</span><br><span class="line">  if(ebola)&#123;</span><br><span class="line">       //业务代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">private boolean checkEbola(ArrayList&lt;Object&gt; list)&#123;</span><br><span class="line">  return list.size()&gt;10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="八、List截取"><a href="#八、List截取" class="headerlink" title="八、List截取"></a>八、List截取</h4><p>List自己的suubList方法，传参数起始索引和终点索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() &#123;</span><br><span class="line">    List&lt;Long&gt; list = Lists.newArrayList(1L, 2L, 3L);</span><br><span class="line">    System.out.println(list.subList(1, list.size()));</span><br><span class="line">    // 2,3</span><br><span class="line"></span><br><span class="line">    // 新建固定大小的List</span><br><span class="line">    List&lt;Long&gt; list1 = Lists.newArrayListWithExpectedSize(3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="九、数组转换为List"><a href="#九、数组转换为List" class="headerlink" title="九、数组转换为List"></a>九、数组转换为List</h4><p>原文：<a href="https://www.jb51.net/article/221887.htm">https://www.jb51.net/article/221887.htm</a></p>
<p>1、使用ArrayList.asList(strArray)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] str = &#123;&quot;fgx&quot;, &quot;lzy&quot;&#125;;</span><br><span class="line">//注意这个List不是Collections包内的List,而是util包里面的List接口</span><br><span class="line">List&lt;String&gt; ints = Arrays.asList(str);</span><br><span class="line">//这里会报错</span><br><span class="line">ints.add(&quot;laopo&quot;);</span><br></pre></td></tr></table></figure>
<p>使用Arrays工具类Arrays.asList(strArray)方式,转换完成后,只能对List数组进行查改,不能增删,增删就会抛出UnsupportedOperationException 异常。<br>报错原因:Arrays.asList(str)返回值是java.util.Arrays类中一个私有静态内部类 java.utiil.Arrays.Arraylist,并不是我们平时用的java.util.ArrayList();</p>
<p>⚠️：使用的asList()方法会返回一个final的,固定长度的ArrayList类，并不是java.util.ArrayList，直接这样利用它进行add()或remove()是无效的。</p>
<p>2、使用new ArrayList(Arrays.asList(strArray))</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//注意这个List不是Collections包内的List,而是util包里面的List接口</span><br><span class="line">java.util.ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;(Arrays.asList(str));</span><br><span class="line">strings.add(&quot;aop&quot;);</span><br><span class="line">strings.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>通过ArrayList的构造器,将Arrays.asList(strArray)的返回值由java.utilArrays.ArrayList转为java.util.ArrayList.</p>
<p>3、集合工具类Collections.addAll()方法（用这个）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] str = &#123;&quot;fgx&quot;, &quot;lzy&quot;&#125;;</span><br><span class="line">java.util.ArrayList&lt;String&gt; stringList = new ArrayList&lt;&gt;(str.length);</span><br><span class="line">Collections.addAll(stringList,str);</span><br></pre></td></tr></table></figure>
<p>通过Collections.addAll(arrayList, strArray)方式转换，根据数组的长度创建一个长度相同的List，然后通过Collections.addAll()方法，将数组中的元素转为二进制，然后添加到List中，这是最高效的方法。</p>
<p>4、JDK8的Stream流将3总基本类型数组转为List</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long[] longs = &#123;1, 2, 3&#125;;</span><br><span class="line">double[] doubles = &#123;1, 2, 3&#125;;</span><br><span class="line">Arrays.stream(ints).boxed().collect(Collectors.toList());</span><br><span class="line">Arrays.stream(longs).boxed().collect(Collectors.toList());</span><br><span class="line">Arrays.stream(doubles).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>如果JDK版本在1.8以上,使用流stream来将下列3种数组快速转为List,分别是int[],long[],double[],不支持short[ ],byte[ ],char[]在JDK1.8中暂不支持.</p>
<p>⚠️ 不能把基本数据类型转化为列表<br>asList接受的参数是一个泛型的变长参数，而基本数据类型是无法泛型化的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int [] intarray = &#123; 1 ,  2 ,  3 ,  4 ,  5 &#125;;</span><br><span class="line">//List&lt;Integer&gt; list = Arrays.asList(intarray); 编译通不过</span><br><span class="line">List&lt; int []&gt; list = Arrays.asList(intarray);  //输出一个int[]元素的list</span><br></pre></td></tr></table></figure>

<p>要想把基本数据类型的数组转化为其包装类型的list，可以使用guava类库的工具方法“</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int [] intArray = &#123; 1 ,  2 ,  3 ,  4 &#125;;</span><br><span class="line">List&lt;Integer&gt; list = Ints.asList(intArray);</span><br></pre></td></tr></table></figure>

<p>为什么int[]不能直接转为List,而Integer[]可以转为List,而Integer[]就可以转为List了,因为List中的泛型必须是引用类型。？？？</p>
<p>⚠️asList方法返回的是数组的一个视图</p>
<p>视图意味着，对这个list的操作都会反映在原数组上，而且这个list是定长的，不支持add、remove等改变长度的方法。</p>
<h4 id="十、List转为数组"><a href="#十、List转为数组" class="headerlink" title="十、List转为数组"></a>十、List转为数组</h4><p>一般数组是不能添加元素的，因为他们在初始化时就已定好长度了，不能改变长度。</p>
<p>1、 list.toArray();</p>
<p>直接将 list 转换成 Object[] 类型的 数组；<br>Object ： 对象类，是所有类的父类</p>
<p><code>Object[]  ans1 = list.toArray();</code></p>
<p>2、list.toArray(T[] a);</p>
<p>输出指定类型的数组，输出的数组类型与括号中参数类型一致；<br>必须是包装类（String、Integer、Character等），不能是基本数据类型了（string、int、char）；<br>&#x2F;&#x2F; 创建数组时： int [ ] arr &#x3D; new int [ ] {}; 使用的是基本数据类型</p>
<p><code>Integer[] ans2 = list.toArray(new Integer[list.size()]);</code><br>注意：idea提示用空的：<br><code>Integer[] ans2 = list.toArray(new Integer[0]);</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建一个list，并且对list赋值        </span><br><span class="line">List&lt;Integer&gt;  list = new ArrayList&lt;&gt;();       </span><br><span class="line">for (int i = 1; i &lt; 11; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">//方法一：</span><br><span class="line">Object[]  ans1 = list.toArray();</span><br><span class="line">System.out.println(&quot;1:&quot; + Arrays.toString(ans1));</span><br><span class="line"> </span><br><span class="line">// 方法二：</span><br><span class="line">Integer[] ans2 = list.toArray(new Integer[list.size()]);</span><br><span class="line">System.out.println(&quot;2:&quot; + Arrays.toString(ans2));</span><br><span class="line"> </span><br><span class="line">1:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">2:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure>


<p>原文链接：<a href="https://blog.csdn.net/Gc_680/article/details/122568085">https://blog.csdn.net/Gc_680/article/details/122568085</a></p>
<h4 id="十、分割list"><a href="#十、分割list" class="headerlink" title="十、分割list"></a>十、分割list</h4><p>Lists的方法，com.google.guava中。</p>
<p>使用场景：list集合中数据量过大，可根据需要进行拆分，进而通过循环或者多线程来处理数据。<br>或者是list拆分后，分批插入数据库。<br>Lists.partition方法，根据传入的size，对list进行拆分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 将集合list按照 2 个元素一份进行划分</span><br><span class="line">List&lt;List&lt;String&gt;&gt; partition = Lists.partition(list, 2);</span><br></pre></td></tr></table></figure>

<h4 id="十一、list根据对象中某一元素去重"><a href="#十一、list根据对象中某一元素去重" class="headerlink" title="十一、list根据对象中某一元素去重"></a>十一、list根据对象中某一元素去重</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.RequiredArgsConstructor;</span><br><span class="line">import lombok.Setter;</span><br><span class="line">import lombok.ToString;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-09-11 22:25</span><br><span class="line"> **/</span><br><span class="line">public class TestRemoveDup &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *     TreeSet的本质是一个&quot;有序的，并且没有重复元素&quot;的集合，它是通过TreeMap实现的。</span><br><span class="line">     *     TreeSet注意事项：</span><br><span class="line">     *     如果向TreeSet集合中添加元素的时候，元素本身没有具备自然顺序的特性，并且元素所属的类也没有</span><br><span class="line">     *     实现Comparable接口，那么必须在创建TreeSet对象的时候传入一个比较器；</span><br><span class="line">     */</span><br><span class="line">    //根据名字进行比较，相等时TreeSet会将该元素视为重复元素，不允许添加；</span><br><span class="line">    private List&lt;Person&gt; removeDupByName(List&lt;Person&gt; people) &#123;</span><br><span class="line">        Set&lt;Person&gt; personSet = new TreeSet&lt;&gt;(Comparator.comparing(Person::getName));</span><br><span class="line">        personSet.addAll(people);</span><br><span class="line">        return new ArrayList&lt;&gt;(personSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;Person&gt; removeDupByName2(List&lt;Person&gt; people) &#123;</span><br><span class="line">        List&lt;Person&gt; unique = people.stream().collect(</span><br><span class="line">                Collectors.collectingAndThen(</span><br><span class="line">                        Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(Person::getName))), ArrayList::new)</span><br><span class="line">        );</span><br><span class="line">        return unique;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //filter的使用方式为： filter(item -&gt; item的逻辑判断 ) ，其中filter会保留判断条件为true的记录</span><br><span class="line">    private List&lt;Person&gt; removeDupByName3(List&lt;Person&gt; people) &#123;</span><br><span class="line">        //用一个name的list去重，没用TreeSet</span><br><span class="line">        List&lt;String&gt; names = new ArrayList&lt;&gt;();//用来临时存储person的id</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; personList = people.stream().filter(// 过滤去重</span><br><span class="line">                v -&gt; &#123;</span><br><span class="line">                    boolean flag = !names.contains(v.getName());</span><br><span class="line">                    names.add(v.getName());</span><br><span class="line">                    return flag;</span><br><span class="line">                &#125;</span><br><span class="line">        ).collect(Collectors.toList());</span><br><span class="line">        return personList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Person&gt; people = new ArrayList&lt;&gt;();</span><br><span class="line">        Person p1 = new Person(&quot;Liu&quot;,30);</span><br><span class="line">        people.add(p1);</span><br><span class="line">        Person p2 = new Person(&quot;Mi&quot;,36);</span><br><span class="line">        people.add(p2);</span><br><span class="line">        Person p3 = new Person(&quot;Liu&quot;,31);</span><br><span class="line">        people.add(p3);</span><br><span class="line">        TestRemoveDup testRemoveDup = new TestRemoveDup();</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; people1 = testRemoveDup.removeDupByName(people);</span><br><span class="line">        List&lt;Person&gt; people2 = testRemoveDup.removeDupByName2(people);</span><br><span class="line">        List&lt;Person&gt; people3 = testRemoveDup.removeDupByName3(people);</span><br><span class="line">        System.out.println(people1);</span><br><span class="line">        System.out.println(people2);</span><br><span class="line">        System.out.println(people3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Getter</span><br><span class="line">    @Setter</span><br><span class="line">    @ToString</span><br><span class="line">    @RequiredArgsConstructor</span><br><span class="line">    static class Person &#123;</span><br><span class="line">        private final String name;</span><br><span class="line">        private final Integer age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的第三种，用filter方法，自定义一个方法，优雅一点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unique = books.stream().filter(distinctByKey(o -&gt; o.getId())).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">private static &lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T, ?&gt; keyExtractor) &#123;</span><br><span class="line">    Map&lt;Object, Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    return t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter根据Predicate返回的布尔值来判断是否要过滤掉，</span><br><span class="line">会过滤掉返回值为false的数据。</span><br><span class="line">而我们自己定义的distinctByKey返回值就是Predicate，所以可以作为参数传入filter。</span><br><span class="line"></span><br><span class="line">distinctByKey也需要一个Function的参数。</span><br><span class="line">distinctByKey先是定义了一个线程安全的Map(相比于Hashtable以及Collections.synchronizedMap()，</span><br><span class="line">ConcurrentHashMap在线程安全的基础上提供了更好的写并发能力，</span><br><span class="line">但同时降低了对读一致性的要求)，因为在流计算中是多线程处理的，需要线程安全。</span><br><span class="line"></span><br><span class="line">然后将值作为key,TRUE作为value put到map中。</span><br><span class="line">这里的put方法使用的是putIfAbsent()。</span><br><span class="line">putIfAbsent()方法是如果key不存在则put如map中，并返回null。若key存在，则直接返回key所对应的value值。</span><br><span class="line"></span><br><span class="line">https://www.cnblogs.com/zwh0910/p/15877284.html</span><br></pre></td></tr></table></figure>


<h4 id="十二、list-add和addAll的一个NPE问题"><a href="#十二、list-add和addAll的一个NPE问题" class="headerlink" title="十二、list.add和addAll的一个NPE问题"></a>十二、list.add和addAll的一个NPE问题</h4><p>背景：addAll遇到的一个空指针问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test7() &#123;</span><br><span class="line">    Map&lt;Long, Long&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(1L, 1L);</span><br><span class="line">    List&lt;Long&gt; list = Lists.newArrayList();</span><br><span class="line">    System.out.println(map.get(2L)); //null</span><br><span class="line">    list.add(null); //没问题</span><br><span class="line">    //list.addAll(null); //会报空指针</span><br><span class="line">    //list.addAll(1L);  //addAll只能传Collection</span><br><span class="line"></span><br><span class="line">    list.add(1L);</span><br><span class="line">    list.add(3L);</span><br><span class="line">    list.add(1, 2L);</span><br><span class="line">    System.out.println(list);  //[null, 2, 1, 3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add方法是将元素可以插在指定的位置，如果参数只有一个的话就默认插在队列的尾部，而对于addAll方法，可以看其实作用差不多，但是参数必须为Collection 集合。</p>
<p>add方法参数为泛型E，所以他是支持任意类型的，但是这里要注意的一点是，如果你使用add方法并且传的参数为集合，那么其实 list集合会把这个参数中的集合当做一个整体，添加到原本的集合中。<br>而addAll方法，则会把参数里面的集合给分别放进原本的集合中。<br>(通过一个forEach 循环遍历后得到参数集合中的每个元素，在循环里面再分别调用add方法来实现这个功能)</p>
<p>⚠️addAll之后修改之前的list的元素：<br>修改是对新的list有效的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A a = new A();</span><br><span class="line">a.setName(&quot;lll&quot;);</span><br><span class="line">List&lt;A&gt; list1 = Lists.newArrayList(a);</span><br><span class="line">List&lt;A&gt; list2 = Lists.newArrayList();</span><br><span class="line">list2.addAll(list1);</span><br><span class="line">System.out.println(list2); //[A(name=lll)]</span><br><span class="line">a.setName(&quot;www&quot;);</span><br><span class="line">System.out.println(list1); //[A(name=www)]</span><br><span class="line">System.out.println(list2); //[A(name=www)]</span><br></pre></td></tr></table></figure>

<h4 id="十三、list反转"><a href="#十三、list反转" class="headerlink" title="十三、list反转"></a>十三、list反转</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.使用stream的sorted (这种方法只能用于普通类型)</span><br><span class="line">List&lt;Long&gt; li = Lists.newArrayList(1L, 2L);</span><br><span class="line">li = li.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());</span><br><span class="line">System.out.println(li);</span><br><span class="line"></span><br><span class="line">2.使用Collections.reverse方法</span><br><span class="line">A a1 = new A(&quot;lll&quot;);</span><br><span class="line">A a2 = new A(&quot;hhh&quot;);</span><br><span class="line">List&lt;A&gt; list = Lists.newArrayList(a1, a2);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line">3.保留原List进行反转</span><br><span class="line">List&lt;Integer&gt; listData = new ArrayList&lt;&gt;();</span><br><span class="line">listData.add(1);</span><br><span class="line">listData.add(2);</span><br><span class="line">List&lt;Integer&gt; tempData = Arrays.asList(new Integer[listData.size()]);</span><br><span class="line">Collections.copy(tempData, listData);</span><br><span class="line">Collections.reverse(listData);</span><br><span class="line">System.out.println(&quot;反转后原来:&quot; + tempData);</span><br><span class="line">System.out.println(&quot;反转后现在:&quot; + listData);</span><br></pre></td></tr></table></figure>

<h4 id="十四、list复制"><a href="#十四、list复制" class="headerlink" title="十四、list复制"></a>十四、list复制</h4><p>首先看一下初始化指定长度List的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(new Integer[10]);</span><br><span class="line">System.out.println(list.size());  //10</span><br><span class="line">System.out.println(list);  //都是null</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(10);</span><br><span class="line">System.out.println(list1.size());  //0</span><br><span class="line">System.out.println(list1);  //空[]</span><br></pre></td></tr></table></figure>

<p>list复制的几个方法：</p>
<p>1、copy一个List最简单方式就是使用构造器，这个构造器能接收一个集合参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3);</span><br><span class="line">List&lt;Integer&gt; copy = new ArrayList&lt;&gt;(list);</span><br><span class="line">System.out.println(copy);  //1 2 3</span><br><span class="line">list.add(4);</span><br><span class="line">System.out.println(copy);  //1 2 3</span><br><span class="line">list.set(0, 5);</span><br><span class="line">System.out.println(copy);  //1 2 3</span><br></pre></td></tr></table></figure>
<p>对原来的list进行add，或者set修改某元素，不会影响到复制的。</p>
<p>但是由于使用这种方式的内部机制是：复制对象的引用而不是clone对象，所以对对象的每一个修改都将同时影响两个list。</p>
<p>正式由于上述的原因，使用构造器这种方法比较适用于那些不可改变对象在list间的复制。比如Integer、String…</p>
<p>2、addAll方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; copy = new ArrayList&lt;&gt;();</span><br><span class="line">copy.addAll(list);</span><br></pre></td></tr></table></figure>
<p>和使用构造器一样，在使用这个方法时，两个list中的内容都将引用的是相同对象。</p>
<p>3、Collections.copy</p>
<p>Collections类提供了一些专门用于操作集合的静态方法。其中一个就是copy。Collections.copy(dest,source),这个方法接收两个参数，一个是source list 和一个dest list（dest list的长度应大于source list，不然会报错：IndexOutOfBoundsException）。</p>
<p>这个方法的特点是： 它将保持每一个被copy元素在目标集合中的下标和它们在源集合中的下标一样。  即： 源集合中下标为1的元素会被复制到目标集合的下标为1的位置上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; source = Arrays.asList(1,2,3);</span><br><span class="line">List&lt;Integer&gt; dest = Arrays.asList(4,5,6);</span><br><span class="line">Collections.copy(dest, source);</span><br><span class="line">System.out.println(dest);  //1 2 3</span><br><span class="line"></span><br><span class="line">A a1 = new A(&quot;111&quot;);</span><br><span class="line">A a2 = new A(&quot;222&quot;);</span><br><span class="line">List&lt;A&gt; list2 = Lists.newArrayList(a1, a2);</span><br><span class="line">// List&lt;A&gt; list3 = new ArrayList&lt;&gt;(2); //这种初始化大小不行</span><br><span class="line">List&lt;A&gt; list3 = Lists.newArrayList(new A[2]);</span><br><span class="line">System.out.println(list3);  //[null, null]</span><br><span class="line">Collections.copy(list3, list2);</span><br><span class="line">System.out.println(list3);  //[ListTest.A(name=111), ListTest.A(name=222)]</span><br><span class="line">list2.get(0).setName(&quot;333&quot;);</span><br><span class="line">System.out.println(list3);  //会同时改变复制的List</span><br></pre></td></tr></table></figure>

<p>注意：这种复制方法也是直接复制引用，而不是深拷贝对象，改变原来List的对象会影响复制的List。</p>
<p>4、使用Java8 stream</p>
<p>在Java8中，我们可以使用stream来解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;A&gt; list4 = list2.stream().collect(Collectors.toList());</span><br><span class="line">list2.get(0).setName(&quot;444&quot;);</span><br><span class="line">System.out.println(list4);  //会同时改变复制的List</span><br></pre></td></tr></table></figure>

<p>好处是可以用stream进行其他操作，但是还是浅拷贝。</p>
<p>5、对象深拷贝</p>
<p>首先，看下对象怎么深拷贝，重写Object的clone方法，并且需要实现Cloneable接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ToString</span><br><span class="line">static</span><br><span class="line">class A implements Cloneable &#123;</span><br><span class="line">    A(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected A clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return (A)super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不想要异常，就在clone方法里自己写set方法，新建对象返回。</p>
<p>对象的拷贝：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A a1 = new A(&quot;11&quot;);</span><br><span class="line">A a2 = a1;  //浅拷贝</span><br><span class="line">System.out.println(a2);</span><br><span class="line">System.out.println(a1 == a2);  //true</span><br><span class="line">A a3 = a1.clone();</span><br><span class="line">System.out.println(a1 == a3);  //false</span><br></pre></td></tr></table></figure>

<hr>
<p>Apache Commons Lang序列化 实现对象深拷贝</p>
<p>第一步、导入commons-lang3包</p>
<p>第二步、实体类实现Serializable接口</p>
<p>第三步、调用SerializationUtils工具类，实现深拷贝（注意：SerializationUtils不能直接拷贝List类型）<br><code>User user2 = SerializationUtils.clone(user1);</code></p>
<p>如果想拷贝List，需要新建一个实体类implements Serializable，然后将list变为其中属性，再用上面的操作深拷贝新建对象，再取其中的list。</p>
<p>或者用循环add深拷贝后的对象的方式实现list的深拷贝。</p>
<p>Java对象深拷贝详解（List深拷贝）:<br><a href="https://blog.csdn.net/weixin_42675423/article/details/128260074">https://blog.csdn.net/weixin_42675423/article/details/128260074</a></p>
<hr>
<p>6、json序列化实现list深拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A a4 = new A(&quot;111&quot;);</span><br><span class="line">A a5 = new A(&quot;222&quot;);</span><br><span class="line">List&lt;A&gt; list1 = Lists.newArrayList(a4, a5);</span><br><span class="line">List&lt;A&gt; list2 = JSONObject.parseArray(JSONObject.toJSONString(list1), A.class); //深拷贝</span><br><span class="line">System.out.println(list2);</span><br></pre></td></tr></table></figure>

<h4 id="十五、list交集并集"><a href="#十五、list交集并集" class="headerlink" title="十五、list交集并集"></a>十五、list交集并集</h4><p>求两个list的交集</p>
<p>需要导入apache的包：commons-collections</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 = Lists.newArrayList(&quot;11&quot;, &quot;22&quot;, &quot;33&quot;);</span><br><span class="line">List&lt;String&gt; list2 = Lists.newArrayList(&quot;44&quot;, &quot;22&quot;, &quot;33&quot;);</span><br><span class="line">Collection&lt;String&gt; list3 = CollectionUtils.intersection(list1, list2);</span><br></pre></td></tr></table></figure>

<hr>
<p>从list1中移除存在list2中的元素（差集）：<code>list1.removeAll(list2)</code></p>
<p>调用流程：removeAll-&gt;contains-&gt;equals方法，对于引用类型，要使用removeAll，需要重写equals方法。<br>contains方法中，当对象o不为空时，迭代判断用到了Object的equals方法，而Object的equals方法指的是两个对象的引用是否相等，如果我们要判断两个对象的内容相等，这里就需要重写equals方法。</p>
<p>两个list的并集：<code>a.addAll(b);</code></p>
<p>两个list的交集：<code>a.retainAll(b);</code></p>
<p>要去重的：<code>List newList = b.stream().distinct().collect(Collectors.toList());</code></p>
<hr>
<p>lambda表达式取交集、并集、差集：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list1 = new ArrayList&lt;String&gt;();</span><br><span class="line">    list1.add(&quot;1&quot;);</span><br><span class="line">    list1.add(&quot;2&quot;);</span><br><span class="line">    list1.add(&quot;3&quot;);</span><br><span class="line">    list1.add(&quot;5&quot;);</span><br><span class="line">    list1.add(&quot;6&quot;);</span><br><span class="line"> </span><br><span class="line">    List&lt;String&gt; list2 = new ArrayList&lt;String&gt;();</span><br><span class="line">    list2.add(&quot;2&quot;);</span><br><span class="line">    list2.add(&quot;3&quot;);</span><br><span class="line">    list2.add(&quot;7&quot;);</span><br><span class="line">    list2.add(&quot;8&quot;);</span><br><span class="line"> </span><br><span class="line">    // 交集</span><br><span class="line">    List&lt;String&gt; intersection = list1.stream().filter(item -&gt; list2.contains(item)).collect(toList());</span><br><span class="line">    System.out.println(&quot;---交集 intersection---&quot;);</span><br><span class="line">    intersection.parallelStream().forEach(System.out :: println);</span><br><span class="line"> </span><br><span class="line">    // 差集 (list1 - list2)</span><br><span class="line">    List&lt;String&gt; reduce1 = list1.stream().filter(item -&gt; !list2.contains(item)).collect(toList());</span><br><span class="line">    System.out.println(&quot;---差集 reduce1 (list1 - list2)---&quot;);</span><br><span class="line">    reduce1.parallelStream().forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line">    // 并集</span><br><span class="line">    List&lt;String&gt; listAll = list1.parallelStream().collect(toList());</span><br><span class="line">    List&lt;String&gt; listAll2 = list2.parallelStream().collect(toList());</span><br><span class="line">    listAll.addAll(listAll2);</span><br><span class="line">    System.out.println(&quot;---并集 listAll---&quot;);</span><br><span class="line">    listAll.parallelStream().forEachOrdered(System.out :: println);</span><br><span class="line"> </span><br><span class="line">    // 去重并集</span><br><span class="line">    List&lt;String&gt; listAllDistinct = listAll.stream().distinct().collect(toList());</span><br><span class="line">    System.out.println(&quot;---得到去重并集 listAllDistinct---&quot;);</span><br><span class="line">    listAllDistinct.parallelStream().forEachOrdered(System.out :: println);</span><br><span class="line"> </span><br><span class="line">    System.out.println(&quot;---原来的List1---&quot;);</span><br><span class="line">    list1.parallelStream().forEachOrdered(System.out :: println);</span><br><span class="line">    System.out.println(&quot;---原来的List2---&quot;);</span><br><span class="line">    list2.parallelStream().forEachOrdered(System.out :: println);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="十六、获取List中最小的begin"><a href="#十六、获取List中最小的begin" class="headerlink" title="十六、获取List&lt;DO&gt;中最小的begin"></a>十六、获取<code>List&lt;DO&gt;</code>中最小的begin</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DO do = list.stream().min(Comparator.comparing(DO::getBegin)).orElse(null);</span><br><span class="line">if (do != null) &#123;</span><br><span class="line">    Date min = do.getBegin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用下面Stream里的min，结合Optional。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt;Long&gt; minBegin = list.stream()</span><br><span class="line">    .map(DO::getBegin)</span><br><span class="line">    .min(Long::compareTo);</span><br><span class="line">if(minBegin.isPresent())&#123;</span><br><span class="line">    minBegin.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList是一种可以在任何位置进行高效地插入和移除操作的有序序列，它是基于双向链表实现的，是线程不安全的，允许元素为null的双向链表。</p>
<p><a href="https://zhuanlan.zhihu.com/p/162980143">https://zhuanlan.zhihu.com/p/162980143</a></p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="✅移除"><a href="#✅移除" class="headerlink" title="✅移除"></a>✅移除</h4><p>移除Set集合中的指定对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set = Sets.newHashSet();</span><br><span class="line">set.add(&quot;111&quot;);</span><br><span class="line">set.add(&quot;222&quot;);</span><br><span class="line">set.remove(&quot;111&quot;);</span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure>

<h4 id="获取上一个下一个元素"><a href="#获取上一个下一个元素" class="headerlink" title="获取上一个下一个元素"></a>获取上一个下一个元素</h4><p>用迭代器的<code>previous()</code>方法和<code>next()</code>方法</p>
<h3 id="Comparable、Comparator"><a href="#Comparable、Comparator" class="headerlink" title="Comparable、Comparator"></a>Comparable、Comparator</h3><p>要讲这个，就要讲list的排序，看上面，有几种办法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.list.sort(Comparator.comparing(A::getB))</span><br><span class="line">2.list.stream.sorted(Comparator.comparing(A::getB)).collect(Collectors.toList())</span><br><span class="line">3.list.stream.sorted((a1,a2)-&gt;a1.compareTo(a2))</span><br><span class="line">4.直接Collections.sort(list)  </span><br><span class="line">//这个需要list的元素实现Comparable接口，重写compareTo方法，比如String就实现了</span><br><span class="line">5.Collections.sort(list, new Comparator&lt;A&gt;()&#123;</span><br><span class="line">  @Oerride</span><br><span class="line">  public int compare(A a1, A a2)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>他们都是java的接口, 并且是用来对自定义的实体类比较大小的.</p>
<p>Comparable接口需要进行比较的实体类在定义时实现它，重写compareTo方法。<br>Comparator接口是在集合外部实现的排序，重写compare方法。Comparator接口比Comparable接口要灵活。</p>
<p>✅ compareTo()方法<br>Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现该接口的类必须实现该方法，实现了该接口的类的对象就可以比较大小。当一个对象调用该方法与另一个对象进行比较时，例如obj1.compareTo(obj2)，如果该方法返回0，则表示两个对象相等，如果该方法返回一个正整数，则表明obj1大于obj2；如果该方法返回一个负整数，则表明obj1小于obj2。</p>
<p>一些已经实现了Comparable接口的常用类：<br>Character：按照字符的UNICODE值进行比较<br>String：按照字符的UNICODE值进行比较<br>Date\Time：外面比里面新，返回1<br>Long：a.compareTo(b)，a比b大返回1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//以特定格式返回日期格式化程序</span><br><span class="line">DateFormat dateFormat = DateFormat.getDateInstance();</span><br><span class="line">Date oldTime = dateFormat.parse(&quot;2019-04-07 19:50:11&quot;);</span><br><span class="line">Date newTime = new Date();</span><br><span class="line">int result = oldTime.compareTo(newTime);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">// 日期变为字符串</span><br><span class="line">String str = dateFormat.format(new Date());</span><br></pre></td></tr></table></figure>

<h3 id="stream流-parallelStream流"><a href="#stream流-parallelStream流" class="headerlink" title="stream流 parallelStream流"></a>stream流 parallelStream流</h3><p>stream(): 是串行执行，按照顺序执行</p>
<p>parallelStream()：是并行执行，异步执行，多线程，并且使用的线程池是ForkJoinPool.common，可能存在共享资源、线程安全等问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">过滤：</span><br><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 3, 4, 5, 6);</span><br><span class="line">Stream&lt;Integer&gt; stream = integerList.stream().filter(i -&gt; i &gt; 3);   //filter里面的条件是留下来的条件</span><br><span class="line">integerList = stream.collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">排序：</span><br><span class="line">.stream().sorted((e1,e2)-&gt;e1.compareTo(e2)).</span><br><span class="line"></span><br><span class="line">去重：</span><br><span class="line">.stream().distinct().</span><br><span class="line"></span><br><span class="line">按照对象中某一元素去重：[tolook]</span><br><span class="line">.stream().filter(...)</span><br><span class="line"></span><br><span class="line">返回指定流个数：</span><br><span class="line">.limit(5)</span><br><span class="line"></span><br><span class="line">跳过流中元素：</span><br><span class="line">.skip(2)</span><br><span class="line"></span><br><span class="line">map流映射：将接收的元素映射成另外一个元素：</span><br><span class="line">.map(类::get属性).collect...</span><br><span class="line">.map(对象-&gt;&#123;</span><br><span class="line">  构造另一种对象;</span><br><span class="line">  return 另一对象;</span><br><span class="line">&#125;).</span><br><span class="line">.map(string-&gt;Long.valueOf(string)).  //String变为Long</span><br><span class="line"></span><br><span class="line">对象list根据某一个元素变为map：(变成 元素-对象list的map)</span><br><span class="line">list.stream().collect(Collectors.groupingBy(类::get属性))</span><br><span class="line"></span><br><span class="line">//流的过程中对元素进行操作</span><br><span class="line">List&lt;Long&gt; list = Lists.newArrayList();</span><br><span class="line">list2.stream().forEach(s -&gt; list.add(Long.valueOf(s)));</span><br><span class="line"></span><br><span class="line">anyMatch判断</span><br><span class="line">想比较list1中是否存在list2中的任何对象</span><br><span class="line">可以遍历两个列表并使用.contains()比较所有元素</span><br><span class="line">但是更高效的方法是anyMatch：</span><br><span class="line">List&lt;Item&gt; list1;</span><br><span class="line">List&lt;Item&gt; list2;</span><br><span class="line">boolean anyMatch = list1.stream().anyMatch(x -&gt; x.equals(list2.stream()));</span><br><span class="line">System.out.println(anyMatch);</span><br><span class="line">很容易理解，即是有一个或一个以上的元素满足函数参数计算结果为true那整个方法返回值为true。</span><br></pre></td></tr></table></figure>

<h4 id="✅list-stream-mapToDouble"><a href="#✅list-stream-mapToDouble" class="headerlink" title="✅list.stream().mapToDouble"></a>✅list.stream().mapToDouble</h4><p>求最大最小，求和求平均</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list.stream().mapToDouble(User::getAge).sum()//和</span><br><span class="line">list.stream().mapToDouble(User::getAge).max()//最大</span><br><span class="line">list.stream().mapToDouble(User::getAge).min()//最小</span><br><span class="line">list.stream().mapToDouble(User::getAge).average()//平均值</span><br><span class="line"></span><br><span class="line">double sum = list.stream().mapToDouble(Integer::doubleValue).sum();</span><br></pre></td></tr></table></figure>

<h4 id="✅list变map"><a href="#✅list变map" class="headerlink" title="✅list变map"></a>✅list变map</h4><p>第一种：会出现键重复异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//以id为主键转为map</span><br><span class="line">Map&lt;Long, User&gt; map = list.stream().collect(Collectors.toMap(User::getId,Function.identity()));</span><br></pre></td></tr></table></figure>

<p>第二种：不会出现重复键异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//给出key重复时，使用哪个key作为主键，以下代码中的(key1, key2) -&gt; key2)代表key1和key2键重复时返回key2做主键</span><br><span class="line">Map&lt;Long, User&gt; map = list.stream().collect(Collectors.toMap(User::getId, Function.identity(), (key1, key2) -&gt; key2));</span><br></pre></td></tr></table></figure>

<p>第三种：对象变为属性-属性map</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 不想返回对象，只返回对象里某个属性时 采用这种方式</span><br><span class="line">Map&lt;Long, String&gt; map = list.stream().collect(Collectors.toMap(User::getId, User::getAge, (key1, key2) -&gt; key2));</span><br></pre></td></tr></table></figure>

<p>第四种：以某一属性分组，变为属性-对象list map</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, List&gt; map = list.stream().collect(Collectors.groupingBy(User::getId));</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://blog.csdn.net/lizaiismy/article/details/121352640">https://blog.csdn.net/lizaiismy/article/details/121352640</a></p>
<p>ps：<code>Function.identity()</code><br>Function是一个接口，Java 8允许在接口中加入具体方法。接口中的具体方法有两种，default方法和static方法，identity()就是Function接口的一个静态方法。<br><code>Function.identity()</code>返回一个输出跟输入一样的Lambda表达式对象，等价于形如t -&gt; t形式的Lambda表达式。</p>
<p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static  Function identity() &#123;</span><br><span class="line">    return t -&gt; t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，<code>Function.identity()</code>是一个用来返回自己的lambda表达式</p>
<h4 id="✅stream流的max-min方法"><a href="#✅stream流的max-min方法" class="headerlink" title="✅stream流的max,min方法"></a>✅stream流的max,min方法</h4><p>max : 获取最大值<br>min : 获取最小值</p>
<p><code>Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)</code></p>
<p>max、min 方法参数类型为 Comparator 接口,利用比较器自定义排序。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class StreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Person&gt; personList = Arrays.asList(</span><br><span class="line">                new Person(1, &quot;大毛&quot;, 30, 175),</span><br><span class="line">                new Person(2, &quot;二毛&quot;, 35, 170),</span><br><span class="line">                new Person(3, &quot;三毛&quot;, 26, 173),</span><br><span class="line">                new Person(4, &quot;小毛&quot;, 30, 175));</span><br><span class="line"> </span><br><span class="line">        // 获取 person 类型流</span><br><span class="line">        Stream&lt;Person&gt; personStream = personList.stream();</span><br><span class="line">        // 按照年龄升序排序,然后获取排序后的最大值 o1-o2 代表升序排序;o2-o1 代表降序排序</span><br><span class="line">        Optional&lt;Person&gt; max = personStream.max(((o1, o2) -&gt; o1.getAge() - o2.getAge()));</span><br><span class="line">        System.out.println(max.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅有一个List想根据字段统计数量"><a href="#✅有一个List想根据字段统计数量" class="headerlink" title="✅有一个List&lt;Map&gt;想根据字段统计数量"></a>✅有一个<code>List&lt;Map&gt;</code>想根据字段统计数量</h4><p>使用Collectors.groupingBy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt;list = </span><br><span class="line">Map&lt;String, Long&gt; res = list.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(map -&gt; (String)map.get(&quot;city&quot;), Collectors.counting()));</span><br></pre></td></tr></table></figure>

<p>如果想统计去重后的数量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt;list = </span><br><span class="line">Map&lt;String, Long&gt; res = list.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(map -&gt; (String)map.get(&quot;city&quot;), </span><br><span class="line">    Collectors.maping(map -&gt; map.get(&quot;task_id&quot;), Collectors.toSet())))</span><br><span class="line">    .entrySet()</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.toMap(Map.Entry :: getKey, e -&gt; (long)e.getValue().size())));</span><br></pre></td></tr></table></figure>


<h3 id="Date相关"><a href="#Date相关" class="headerlink" title="Date相关"></a>Date相关</h3><h4 id="✅now-after"><a href="#✅now-after" class="headerlink" title="✅now.after()"></a>✅now.after()</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DateFormat dateformat = DateFormat.getDateInstance();</span><br><span class="line">Date old = dateformat.parse(&quot;2022-04-07 19:50:11&quot;);</span><br><span class="line">Date now = new Date();</span><br><span class="line">if(now.after(oldTime))&#123;</span><br><span class="line">    System.out.println(&quot;now比after新&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅DateFormat类"><a href="#✅DateFormat类" class="headerlink" title="✅DateFormat类"></a>✅DateFormat类</h4><p>DateFormat 是日期&#x2F;时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期&#x2F;时间格式化子类（如 SimpleDateFormat）允许进行格式化（也就是日期→文本）、解析（文本→日期）和标准化日期。</p>
<p>在创建 DateFormat 对象时不能使用 new 关键字，而应该使用 DateFormat 类中的静态方法 getDateInstance()：<br><code>DateFormat df = DateFormat.getDatelnstance();</code><br>在创建了一个 DateFormat 对象后，可以调用该对象中的方法来对日期&#x2F;时间进行格式化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义对象，日期、时间，也有getDateTimeInstance</span><br><span class="line">SHORT：18-10-15 上午9:30</span><br><span class="line">FULL：2018年10月15日 星期一 上午09时30分43秒 CST</span><br><span class="line">MEDIUM：2018-10-15 9:30:43</span><br><span class="line">LONG：2018年10月15日 上午09时30分43秒</span><br><span class="line"></span><br><span class="line">DateFormat df1 = DateFormat.getDateInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line">DateFormat df5 = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line"></span><br><span class="line">//字符串到Date</span><br><span class="line">Date old = dateformat.parse(&quot;2022-04-07 19:50:11&quot;);</span><br><span class="line"></span><br><span class="line">//Date到字符串</span><br><span class="line">String str = dateFormat.format(new Date());</span><br><span class="line"></span><br><span class="line">Date newTime = new Date();</span><br><span class="line">int result = oldTime.compareTo(newTime);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">DateFormat dateformat = DateFormat.getDateInstance();</span><br><span class="line">Date old = dateformat.parse(&quot;2022-04-07 19:50:11&quot;);</span><br><span class="line">Date now = new Date();</span><br><span class="line">if(now.after(old))&#123;</span><br><span class="line">    System.out.println(&quot;now比old新&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅SimpleDateFormat"><a href="#✅SimpleDateFormat" class="headerlink" title="✅SimpleDateFormat"></a>✅SimpleDateFormat</h4><p>DateFormat可以进行日期和字符串的格式化和解析，但是由于是抽象类，所以使用具体子类SimpleDateFormat</p>
<p>SimpleDateFormat 使得可以选择任何用户定义的日期&#x2F;时间格式的模式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date now = new Date(); // 创建一个Date对象，获取当前时间</span><br><span class="line">// 指定格式化格式</span><br><span class="line">SimpleDateFormat f = new SimpleDateFormat(&quot;今天是 &quot; + &quot;yyyy 年 MM 月 dd 日 E HH 点 mm 分 ss 秒&quot;);</span><br><span class="line">// Date转为String</span><br><span class="line">System.out.println(f.format(now)); // 将当前时间袼式化为指定的格式</span><br><span class="line">// String转为Date</span><br><span class="line">String str=&quot;2008-08-08 12:12:12&quot;;</span><br><span class="line">SimpleDateFormat sdf2=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">Date dd=sdf2.parse(str);</span><br><span class="line">System.out.println(dd);</span><br></pre></td></tr></table></figure>

<p>参考：<a href="http://c.biancheng.net/view/878.html">http://c.biancheng.net/view/878.html</a></p>
<h4 id="✅FastDataFormat"><a href="#✅FastDataFormat" class="headerlink" title="✅FastDataFormat"></a>✅FastDataFormat</h4><p>Apache commons-lang中的FastDateFormat。也可以做时间的格式化。<br>FastDateFormat是线程安全的，可以直接使用，不必考虑多线程的情况<br>JDK里自带的SimpleDateFormat存在线程不安全问题。<br>SimpleDateFormat在对时间进行格式化的方法format中，会先对calendar对象进行setTime的赋值，若是有多个线程同时操作一个SimpleDateFormat实例的话，就会对calendar的赋值进行覆盖，进而产生问题。</p>
<p>FastDateFormat用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FastDateFormat f = FastDateFormat.getInstance(&quot;yyyy-MM-dd HH:mm:ss&quot;);  </span><br><span class="line">String s = f.format(new Date());</span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line">Date dd=f.parse(s);</span><br></pre></td></tr></table></figure>


<h4 id="✅当前时间的后几秒："><a href="#✅当前时间的后几秒：" class="headerlink" title="✅当前时间的后几秒："></a>✅当前时间的后几秒：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 当前时间的后几秒</span><br><span class="line">Date data = new Date(System.currentTimeMillis() + 10 * 1000);</span><br><span class="line">System.out.println(data);</span><br><span class="line">加的是毫秒</span><br></pre></td></tr></table></figure>

<p>获取当前时间的月份：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int mon = LocalDate.now().getMonthValue();</span><br></pre></td></tr></table></figure>

<h4 id="✅LocalDate、LocalTime、LocalDateTime【java8新提供的类】"><a href="#✅LocalDate、LocalTime、LocalDateTime【java8新提供的类】" class="headerlink" title="✅LocalDate、LocalTime、LocalDateTime【java8新提供的类】"></a>✅LocalDate、LocalTime、LocalDateTime【java8新提供的类】</h4><p>为什么需要LocalDate、LocalTime、LocalDateTime</p>
<p>1.Date如果不格式化，打印出的日期可读性差<br>Tue Sep 10 09:34:04 CST 2019<br>Date对时间处理比较麻烦。<br>getYear、getMonth这些方法吗，获取年月日很Easy，但都被弃用了。</p>
<p>2.使用SimpleDateFormat对时间进行格式化，但SimpleDateFormat是线程不安全的。SimpleDateFormat的format方法中的calendar是共享变量，并且这个共享变量没有做线程安全控制。当多个线程同时使用相同的SimpleDateFormat对象【如用static修饰的SimpleDateFormat】调用format方法时，多个线程会同时调用calendar.setTime方法，可能一个线程刚设置好time值。另外的一个线程马上把设置的time值给修改了导致返回的格式化时间可能是错误的。在多并发情况下使用SimpleDateFormat需格外注意 SimpleDateFormat除了format是线程不安全以外，parse方法也是线程不安全的。</p>
<p>多线程并发如何保证线程安全 - 避免线程之间共享一个SimpleDateFormat对象，每个线程使用时都创建一次SimpleDateFormat对象 &#x3D;&gt; 创建和销毁对象的开销大 - 对使用format和parse方法的地方进行加锁 &#x3D;&gt; 线程阻塞性能差 - 使用ThreadLocal保证每个线程最多只创建一次SimpleDateFormat对象 &#x3D;&gt; 较好的方法。</p>
<p>LocalDate用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只会获取年月日</span><br><span class="line">//获取当前年月日</span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line"></span><br><span class="line">//构造指定的年月日</span><br><span class="line">LocalDate localDate1 = LocalDate.of(2019, 9, 10);</span><br><span class="line"></span><br><span class="line">获取年、月、日、星期几</span><br><span class="line">int year = localDate.getYear();  //2022</span><br><span class="line">int year1 = localDate.get(ChronoField.YEAR); //2022</span><br><span class="line">Month month = localDate.getMonth();  //JUNE</span><br><span class="line">int month1 = localDate.get(ChronoField.MONTH_OF_YEAR);  //6</span><br><span class="line"></span><br><span class="line">//获取当前日期是所在年的第几天、月的第几天、当前星期</span><br><span class="line">int day = localDate.getDayOfMonth();  //26</span><br><span class="line">int day1 = localDate.get(ChronoField.DAY_OF_MONTH);  //26</span><br><span class="line">DayOfWeek dayOfWeek = localDate.getDayOfWeek(); //SUNDAY</span><br><span class="line">int dayOfWeek1 = localDate.get(ChronoField.DAY_OF_WEEK); //7</span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">int year = now.getDayOfYear();  //一年的第几天</span><br><span class="line">int month = now.getDayOfMonth();  //月的第几天</span><br><span class="line"></span><br><span class="line">System.out.println(LocalDate.MAX);  //+999999999-12-31</span><br><span class="line">System.out.println(LocalDate.MIN);  //-999999999-01-01</span><br><span class="line"></span><br><span class="line">//获取当前月，当前月天数</span><br><span class="line">Month month = now.getMonth();  //JANUARY</span><br><span class="line">int monthValue = now.getMonthValue();</span><br><span class="line">int i = now.lengthOfMonth();</span><br><span class="line"></span><br><span class="line">//with指定年月日</span><br><span class="line">LocalDate localDate = now.withDayOfMonth(1);  //当月的指定日</span><br><span class="line">LocalDate localDate1 = now.withDayOfYear(21);  //获取今年第第几天</span><br><span class="line">LocalDate localDate2 = now.withMonth(3);  //今年指定月份，日为当天的日期</span><br><span class="line">LocalDate localDate3 = now.withYear(2004);  //指定年份的今天</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>LocalTime用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只会获取几点几分几秒</span><br><span class="line">创建LocalTime</span><br><span class="line">LocalTime localTime = LocalTime.of(13, 51, 10);</span><br><span class="line">LocalTime localTime1 = LocalTime.now();</span><br><span class="line">获取时分秒</span><br><span class="line">//获取小时</span><br><span class="line">int hour = localTime.getHour();</span><br><span class="line">int hour1 = localTime.get(ChronoField.HOUR_OF_DAY);</span><br><span class="line">//获取分</span><br><span class="line">int minute = localTime.getMinute();</span><br><span class="line">int minute1 = localTime.get(ChronoField.MINUTE_OF_HOUR);</span><br><span class="line">//获取秒</span><br><span class="line">int second = localTime.getSecond();</span><br><span class="line">int second1 = localTime.get(ChronoField.SECOND_OF_MINUTE);</span><br></pre></td></tr></table></figure>

<p>LocalDateTime:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取年月日时分秒，等于LocalDate+LocalTime</span><br><span class="line">创建LocalDateTime</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(2019, Month.SEPTEMBER, 10, 14, 46, 56);</span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(2019, 6, 26, 10, 14, 46, 56);</span><br><span class="line">LocalDateTime localDateTime2 = LocalDateTime.of(localDate, localTime);</span><br><span class="line">LocalDateTime localDateTime3 = localDate.atTime(localTime);</span><br><span class="line">LocalDateTime localDateTime4 = localTime.atDate(localDate);</span><br><span class="line">获取LocalDate</span><br><span class="line">LocalDate localDate2 = localDateTime.toLocalDate();</span><br><span class="line">获取LocalTime</span><br><span class="line">LocalTime localTime2 = localDateTime.toLocalTime();</span><br></pre></td></tr></table></figure>

<p>Instant: 可以精确到纳秒的时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取秒数</span><br><span class="line">创建Instant对象</span><br><span class="line">Instant instant = Instant.now();  //提前北京时间8小时</span><br><span class="line"></span><br><span class="line">//根据时期添加偏移量</span><br><span class="line">OffsetDateTime offsetDateTime1 = instance.atOffset(ZoneOffset.ofHours(8));</span><br><span class="line">System.out.println(&quot;处理后时间为：&quot;+offsetDateTime1);</span><br><span class="line"></span><br><span class="line">获取秒数</span><br><span class="line">long currentSecond = instant.getEpochSecond();</span><br><span class="line">获取毫秒数</span><br><span class="line">long currentMilli = instant.toEpochMilli();</span><br><span class="line">如果只是为了获取秒数或者毫秒数，使用System.currentTimeMillis()来得更为方便</span><br></pre></td></tr></table></figure>

<p>时间变化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalDate、LocalTime、LocalDateTime、Instant为不可变对象，修改这些对象对象会返回一个副本</span><br><span class="line">增加、减少年数、月数、天数等 以LocalDateTime为例</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.of(2019, Month.SEPTEMBER, 10,</span><br><span class="line">14, 46, 56);</span><br><span class="line">//增加一年</span><br><span class="line">localDateTime = localDateTime.plusYears(1);</span><br><span class="line">localDateTime = localDateTime.plus(1, ChronoUnit.YEARS);</span><br><span class="line">//减少一个月</span><br><span class="line">localDateTime = localDateTime.minusMonths(1);</span><br><span class="line">localDateTime = localDateTime.minus(1, ChronoUnit.MONTHS);</span><br><span class="line">通过with修改某些值</span><br><span class="line">//修改年为2019</span><br><span class="line">localDateTime = localDateTime.withYear(2020);</span><br><span class="line">//修改为2022</span><br><span class="line">localDateTime = localDateTime.with(ChronoField.YEAR, 2022);</span><br><span class="line">还可以修改月、日</span><br></pre></td></tr></table></figure>

<p>时间计算:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比如有些时候想知道这个月的最后一天是几号、下个周末是几号，通过提供的时间和日期API可以很快得到答案</span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">//得到今年第一天</span><br><span class="line">LocalDate localDate1 = localDate.with(firstDayOfYear());</span><br><span class="line">比如通过firstDayOfYear()返回了当前日期的第一天日期，还有很多方法这里不在举例说明</span><br></pre></td></tr></table></figure>

<p>格式化时间:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.of(2019, 9, 10);</span><br><span class="line">String s1 = localDate.format(DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">String s2 = localDate.format(DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">//自定义格式化</span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;dd/MM/yyyy&quot;);</span><br><span class="line">String s3 = localDate.format(dateTimeFormatter);</span><br><span class="line">DateTimeFormatter默认提供了多种格式化方式，如果默认提供的不能满足要求，可以通过DateTimeFormatter的ofPattern方法创建自定义格式化方式</span><br><span class="line"></span><br><span class="line">//变为字符串：</span><br><span class="line">String currentTime = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(LocalDateTime.now());</span><br><span class="line">System.out.println(currentTime);</span><br><span class="line">String currentTime1 = LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));</span><br><span class="line">System.out.println(currentTime1</span><br></pre></td></tr></table></figure>

<p>解析时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalDate localDate1 = LocalDate.parse(&quot;20190910&quot;, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">LocalDate localDate2 = LocalDate.parse(&quot;2019-09-10&quot;, DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">和SimpleDateFormat相比，DateTimeFormatter是线程安全的</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://baijiahao.baidu.com/s?id=1685414035437236647&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1685414035437236647&amp;wfr=spider&amp;for=pc</a></p>
<p>更多用法：<a href="https://zhuanlan.zhihu.com/p/158786867">https://zhuanlan.zhihu.com/p/158786867</a></p>
<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DateUtilsTest &#123;</span><br><span class="line">    public static final String DATE_PATTERN = &quot;yyyy-MM-dd HH:mm:ss&quot;;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        // 获取指定格式时间字符串</span><br><span class="line">        String date = LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_PATTERN));</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        // 获取当前月份</span><br><span class="line">        Integer month = LocalDateTime.now().getMonth().getValue();</span><br><span class="line">        System.out.println(month);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        // 时间戳</span><br><span class="line">        long timeStamp = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;时间戳：&quot; + timeStamp);</span><br><span class="line">        // 时间戳字符串到时间戳到LocalDateTime</span><br><span class="line">        LocalDateTime time = new Timestamp(timeStamp).toLocalDateTime();</span><br><span class="line">        System.out.println(&quot;LocatDateTime：&quot; + time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：获取指定天后的日期字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalDateTime.now().plusDays(1).format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;))</span><br></pre></td></tr></table></figure>

<h4 id="✅Calendar、Date、LocalDate-LocalTime关系"><a href="#✅Calendar、Date、LocalDate-LocalTime关系" class="headerlink" title="✅Calendar、Date、LocalDate&#x2F;LocalTime关系"></a>✅Calendar、Date、LocalDate&#x2F;LocalTime关系</h4><p>1、Date 类如今很多方法已经没有什么用处了，如今时间的处理并不直接在Date 类中进行，而是通过Calendar，或者LocalDate 来进行，我们在日常使用中，更多的是要来做一个记录日期的实例。</p>
<p>2、Date用于记录某一个含日期的、精确到毫秒的时间。重点在代表一刹那的时间本身。Calendar用于将某一日期放到历法中的互动——时间和年、月、日、星期、上午、下午、夏令时等这些历法规定互相作用关系和互动。Calendar本身代表公历的一个简化缩水版，姑且叫“计算机历”。</p>
<p>3、Java 8新增了LocalDate和LocalTime接口，为什么要搞一套全新的处理日期和时间的API？因为旧的java.util.Date实在是太难用了。<br>java.util.Date月份从0开始，一月是0，十二月是11，变态吧！java.time.LocalDate月份和星期都改成了enum，就不可能再用错了。<br>java.util.Date和SimpleDateFormatter都不是线程安全的，而LocalDate和LocalTime和最基本的String一样，是不变类型，不但线程安全，而且不能修改。</p>
<p>来自：<a href="https://www.cnblogs.com/jaycekon/p/6179700.html">https://www.cnblogs.com/jaycekon/p/6179700.html</a></p>
<h4 id="✅Calender"><a href="#✅Calender" class="headerlink" title="✅Calender"></a>✅Calender</h4><p>Calendar 是一个抽象类, 无法通过直接实例化得到对象. 因此, Calendar 提供了一个方法 getInstance（工厂方法）,来获得一个Calendar的子类对象, 得到的 Calendar 由当前时间初始化.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CalenderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        cal.set (2013, 5, 4, 13, 44, 51);//年月日时分秒 (月份0代表1月)</span><br><span class="line">        cal.set (Calendar.YEAR, 2014); //年</span><br><span class="line">        cal.set (Calendar.MONTH, 7); //月 (月份0代表1月)</span><br><span class="line">        cal.set (Calendar.DATE, 11); //日</span><br><span class="line">        cal.set (Calendar.HOUR_OF_DAY, 15); //时</span><br><span class="line">        cal.set (Calendar.MINUTE, 33); //分</span><br><span class="line">        cal.set (Calendar.SECOND, 32); //秒</span><br><span class="line"></span><br><span class="line">        //同时还有get、add方法，使用类似</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Calendar是父类，GregorianCalendar是子类。<br>GregorianCalendar（公历）是Calendar的一个具体子类，提供了世界上大多数国家&#x2F;地区使用的标准日历系统。可以使用new关键字创建实例。</p>
<p>例子：返回当前时间加10分钟后的日期时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Calendar calendar = new GregorianCalendar();</span><br><span class="line">Date date = new Date();</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">calendar.add(GregorianCalendar.MINUTE, 10);</span><br><span class="line">Date after = calendar.getTime();</span><br><span class="line">System.out.println(after);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1.创建Calendar对象</span><br><span class="line">Calendar calendar =Calendar.getInstance();</span><br><span class="line">System.out.println(calendar.getTime());//Calender变Date</span><br><span class="line">System.out.println(calendar.getTimeInMillis());//Calender变时间戳</span><br><span class="line">Calendar calendar1 = new GregorianCalendar();</span><br><span class="line">System.out.println(calendar1.getTime()); //输出一样</span><br><span class="line"></span><br><span class="line">//2.获取时间信息</span><br><span class="line">//获取年</span><br><span class="line">int year = calendar.get(Calendar.YEAR);</span><br><span class="line">//月</span><br><span class="line">int month = calendar.get(Calendar.MONTH);</span><br><span class="line">//日</span><br><span class="line">int day = calendar.get(Calendar.DAY_OF_MONTH);//DATE</span><br><span class="line">//小时</span><br><span class="line">int hour = calendar.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">//分钟</span><br><span class="line">int minute = calendar.get(Calendar.MINUTE);</span><br><span class="line">//秒</span><br><span class="line">int second = calendar.get(Calendar.SECOND);</span><br><span class="line">System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日&quot;+&quot;  &quot;+hour+&quot;时&quot;+minute+&quot;分&quot;+second+&quot;秒&quot;);</span><br><span class="line"></span><br><span class="line">//修改时间</span><br><span class="line">Calendar calendar2 =Calendar.getInstance();</span><br><span class="line">calendar2.set(Calendar.DAY_OF_MONTH,5);</span><br><span class="line">System.out.println(calendar2.getTime().toLocaleString());</span><br><span class="line"></span><br><span class="line">//add方法修改时间</span><br><span class="line">calendar2.add(Calendar.HOUR,-1);</span><br><span class="line">System.out.println(calendar2.getTime().toLocaleString());</span><br><span class="line"></span><br><span class="line">//获取当月多少天</span><br><span class="line">int max = calendar2.getActualMaximum(Calendar.DAY_OF_MONTH); //30</span><br><span class="line">int min = calendar2.getActualMinimum(Calendar.DAY_OF_MONTH); //1</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/a1439775520/article/details/98442556">https://blog.csdn.net/a1439775520/article/details/98442556</a> </p>
<p>🍎用Calender计算量日期相差天数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static int differentDays(Date date1,Date date2) &#123;</span><br><span class="line">    Calendar cal1 = Calendar.getInstance();</span><br><span class="line">    cal1.setTime(date1);</span><br><span class="line"></span><br><span class="line">    Calendar cal2 = Calendar.getInstance();</span><br><span class="line">    cal2.setTime(date2);</span><br><span class="line">    int day1= cal1.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">    int day2 = cal2.get(Calendar.DAY_OF_YEAR);</span><br><span class="line"></span><br><span class="line">    int year1 = cal1.get(Calendar.YEAR);</span><br><span class="line">    int year2 = cal2.get(Calendar.YEAR);</span><br><span class="line">    if(year1 != year2) &#123;//不同年</span><br><span class="line">        int timeDistance = 0 ;</span><br><span class="line">        for(int i = year1 ; i &lt; year2 ; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i%4==0 &amp;&amp; i%100!=0 || i%400==0)    //闰年</span><br><span class="line">            &#123;</span><br><span class="line">                timeDistance += 366;</span><br><span class="line">            &#125;</span><br><span class="line">            else    //不是闰年</span><br><span class="line">            &#123;</span><br><span class="line">                timeDistance += 365;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return timeDistance + (day2-day1) ;</span><br><span class="line">    &#125; else &#123;// 同年</span><br><span class="line">        System.out.println(&quot;判断day2 - day1 : &quot; + (day2-day1));</span><br><span class="line">        return day2-day1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int differentDaysByMillisecond(Date date1,Date date2)&#123;</span><br><span class="line">    int days = (int) ((date2.getTime() - date1.getTime()) / (1000*3600*24));</span><br><span class="line">    return days;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅时间戳"><a href="#✅时间戳" class="headerlink" title="✅时间戳"></a>✅时间戳</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void timeStampTest() &#123;</span><br><span class="line">  // 当前时间时间戳</span><br><span class="line">  long nowStamp = System.currentTimeMillis();</span><br><span class="line">  System.out.println(&quot;毫秒时间戳：&quot; + nowStamp);</span><br><span class="line">  long nowhaomiao = System.currentTimeMillis() * 1000;</span><br><span class="line">  System.out.println(&quot;微妙时间戳&quot; + nowhaomiao);</span><br><span class="line">  long nowhaomiao1 = System.nanoTime() / 1000;</span><br><span class="line">  System.out.println(&quot;微妙时间戳1&quot; + nowhaomiao1); //不行</span><br><span class="line"></span><br><span class="line">  // 昨天这个时间时间戳</span><br><span class="line">  Calendar calendar = Calendar.getInstance();</span><br><span class="line">  calendar.add(Calendar.DAY_OF_YEAR, -1);</span><br><span class="line">  //calender.getTime变Date，再getTime变时间戳（long型的）</span><br><span class="line">  System.out.println(&quot;昨天此时：&quot; + calendar.getTime().getTime());</span><br><span class="line"></span><br><span class="line">  // 昨天某时间的时间戳</span><br><span class="line">  Calendar calendar1 = Calendar.getInstance();</span><br><span class="line">  calendar.set(calendar1.get(Calendar.YEAR), calendar1.get(Calendar.MONTH), calendar1.get(Calendar.DAY_OF_MONTH) - 1, 23, 59, 59);</span><br><span class="line">  System.out.println(calendar.getTime().getTime());</span><br><span class="line"></span><br><span class="line">  // 时间戳转换为Date</span><br><span class="line">  Date now = new Date(nowStamp);  //long型</span><br><span class="line">  //如果是时间戳字符串，用下面</span><br><span class="line">  //Date now1 = new Date(Long.parseLong(nowStamp));</span><br><span class="line">  System.out.println(&quot;now: &quot; + now);</span><br><span class="line">  // 再转换为字符串</span><br><span class="line">  String format = &quot;yyyy-MM-dd HH:mm:ss&quot;;</span><br><span class="line">  SimpleDateFormat sdf = new SimpleDateFormat(format);</span><br><span class="line">  System.out.println(&quot;now: &quot; + sdf.format(now));</span><br><span class="line"></span><br><span class="line">  // 日期格式字符串转换为时间戳</span><br><span class="line">  String s = &quot;2022-06-25 12:12:12&quot;;</span><br><span class="line">  try &#123;</span><br><span class="line">      // String-Date-long型时间戳</span><br><span class="line">      System.out.println(&quot;时间戳：&quot; + String.valueOf(sdf.parse(s).getTime()));</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅DateUtils工具类"><a href="#✅DateUtils工具类" class="headerlink" title="✅DateUtils工具类"></a>✅DateUtils工具类</h4><p>apache.commons.lang3包下的工具类</p>
<p>1、获取指定日期的开始时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testDateUtils() throws ParseException &#123;</span><br><span class="line">    // 获取指定日期的开始时间</span><br><span class="line">    DateFormat df = DateFormat.getDateInstance();</span><br><span class="line">    Date date = df.parse(&quot;2022-06-24 14:01:01&quot;);</span><br><span class="line">    Date begin = org.apache.commons.lang3.time.DateUtils.truncate(date, Calendar.DATE);</span><br><span class="line">    System.out.println(&quot;初始时间：&quot; + begin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅计算两个时间段之间的所有天"><a href="#✅计算两个时间段之间的所有天" class="headerlink" title="✅计算两个时间段之间的所有天"></a>✅计算两个时间段之间的所有天</h4><p>输入：begin:‘2022-08-01’ end:‘2022-08-05’<br>输出：”2021-08-01”,”2021-08-02”,”2021-08-03”,”2021-08-04”,”2021-08-05”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static List&lt;String&gt; findDates(String beginTime, String endTime)</span><br><span class="line">        throws ParseException &#123;</span><br><span class="line">    List&lt;String&gt; allDate = new ArrayList();</span><br><span class="line">    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line"></span><br><span class="line">    Date dBegin = sdf.parse(beginTime);</span><br><span class="line">    Date dEnd = sdf.parse(endTime);</span><br><span class="line">    allDate.add(sdf.format(dBegin));</span><br><span class="line">    Calendar calBegin = Calendar.getInstance();</span><br><span class="line">    // 使用给定的 Date 设置此 Calendar 的时间</span><br><span class="line">    calBegin.setTime(dBegin);</span><br><span class="line">    Calendar calEnd = Calendar.getInstance();</span><br><span class="line">    // 使用给定的 Date 设置此 Calendar 的时间</span><br><span class="line">    calEnd.setTime(dEnd);</span><br><span class="line">    // 测试此日期是否在指定日期之后</span><br><span class="line">    while (dEnd.after(calBegin.getTime())) &#123;</span><br><span class="line">        // 根据日历的规则，为给定的日历字段添加或减去指定的时间量</span><br><span class="line">        calBegin.add(Calendar.DAY_OF_MONTH, 1);</span><br><span class="line">        allDate.add(sdf.format(calBegin.getTime()));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;时间==&quot; + allDate);</span><br><span class="line">    return allDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅判断是否同一天"><a href="#✅判断是否同一天" class="headerlink" title="✅判断是否同一天"></a>✅判断是否同一天</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static boolean isSameDay(Date date1, Date date2) &#123;</span><br><span class="line">    LocalDate localDate1 = date1.toInstant()</span><br><span class="line">            .atZone(ZoneId.systemDefault())</span><br><span class="line">            .toLocalDate();</span><br><span class="line">    LocalDate localDate2 = date2.toInstant()</span><br><span class="line">            .atZone(ZoneId.systemDefault())</span><br><span class="line">            .toLocalDate();</span><br><span class="line">    return localDate1.isEqual(localDate2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean isSameDay(Date date1, Date date2) &#123;</span><br><span class="line">    SimpleDateFormat fmt = new SimpleDateFormat(&quot;yyyyMMdd&quot;);</span><br><span class="line">    return fmt.format(date1).equals(fmt.format(date2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来自：<a href="https://blog.csdn.net/nandao158/article/details/121905050">https://blog.csdn.net/nandao158/article/details/121905050</a></p>
<h4 id="✅获取今天星期几"><a href="#✅获取今天星期几" class="headerlink" title="✅获取今天星期几"></a>✅获取今天星期几</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">Date date = new Date();</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_WEEK));</span><br></pre></td></tr></table></figure>

<p>获取到的数字，星期一到星期七对应数字{2，3，4，5，6, 7，0}，所以需要减一，减一之后判断是不是等于0，等于0就变成7.</p>
<h3 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h3><h4 id="int变String-String变int"><a href="#int变String-String变int" class="headerlink" title="int变String,String变int"></a>int变String,String变int</h4><p>第一种方式：使用int的封装类Integer，在Integer里面用他的toString方法。（性能最好）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i=3；</span><br><span class="line">String s=Integer.toString(i);</span><br></pre></td></tr></table></figure>

<p>第二种方式：String的valueOf方法，传参是Object（性能第二）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i=1;</span><br><span class="line">String s=String.valueOf(i);</span><br></pre></td></tr></table></figure>

<p>第三种方式，直接在int后面加一个空的字符串，因为在java里面，默认任务int类型和字符串类型相加，为字符串类型。（性能最差）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i=2；</span><br><span class="line">String s=i+&quot;&quot;;</span><br></pre></td></tr></table></figure>

<p>string变int&#x2F;Long：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer i1 = Integer.parseInt(s);</span><br><span class="line">Integer i = Integer.valueOf(s);</span><br><span class="line">Long l = Long.valueOf(s);</span><br><span class="line">Long l1 = Long.parseLong(s);</span><br></pre></td></tr></table></figure>

<p><code>Integer.parseInt</code> 方法：<br>parseInt(String s, int radix)： s表示字符串  radix表示字符串数值的进制，例如：parseInt(“100”, 16) &#x3D; 256<br>parseInt(String s)：相当于默认是10进制</p>
<h4 id="String-format"><a href="#String-format" class="headerlink" title="String.format"></a>String.format</h4><p>String.format(String format, Object… args)<br>字符串格式化方法，sout也这么用。</p>
<p><code>String str=String.format(&quot;Hi,%s %s %s&quot;, &quot;小超&quot;,&quot;是个&quot;,&quot;大帅哥&quot;);  </code></p>
<p>%s	字符串类型	“hello”<br>%c	字符类型	‘m’<br>%b	布尔类型	true<br>%d	整数类型（十进制）	88<br>%x	整数类型（十六进制）	FF<br>%o	整数类型（八进制）	77<br>%f	浮点类型	8.888<br>%a	十六进制浮点类型	FF.35AE<br>%e	指数类型	9.38e+5<br>%g	通用浮点类型（f和e类型中较短的）	不举例(基本用不到)<br>%h	散列码	不举例(基本用不到)<br>%%	百分比类型	％(%特殊字符%%才能显示%)<br>%n	换行符	不举例(基本用不到)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    String str=null;  </span><br><span class="line">    str=String.format(&quot;Hi,%s&quot;, &quot;小超&quot;);  </span><br><span class="line">    System.out.println(str);  </span><br><span class="line">    str=String.format(&quot;Hi,%s %s %s&quot;, &quot;小超&quot;,&quot;是个&quot;,&quot;大帅哥&quot;);            </span><br><span class="line">    System.out.println(str);                           </span><br><span class="line">    System.out.printf(&quot;字母c的大写是：%c %n&quot;, &#x27;C&#x27;);  </span><br><span class="line">    System.out.printf(&quot;布尔结果是：%b %n&quot;, &quot;小超&quot;.equal(&quot;帅哥&quot;));  </span><br><span class="line">    System.out.printf(&quot;100的一半是：%d %n&quot;, 100/2);  </span><br><span class="line">    System.out.printf(&quot;100的16进制数是：%x %n&quot;, 100);  </span><br><span class="line">    System.out.printf(&quot;100的8进制数是：%o %n&quot;, 100);  </span><br><span class="line">    System.out.printf(&quot;50元的书打8.5折扣是：%f 元%n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面价格的16进制数是：%a %n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面价格的指数表示：%e %n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面价格的指数和浮点数结果的长度较短的是：%g %n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面的折扣是%d%% %n&quot;, 85);  </span><br><span class="line">    System.out.printf(&quot;字母A的散列码是：%h %n&quot;, &#x27;A&#x27;);  </span><br><span class="line"></span><br><span class="line">日期格式：%tx x代表日期转换符</span><br><span class="line">c	包括全部日期和时间信息	星期六 十月 27 14:21:20 CST 2007</span><br><span class="line">F	“年-月-日”格式	2007-10-27</span><br><span class="line">D	“月/日/年”格式	10/27/07</span><br><span class="line">r	“HH:MM:SS PM”格式（12时制）	02:25:51 下午</span><br><span class="line">T	“HH:MM:SS”格式（24时制）	14:28:16</span><br><span class="line">R	“HH:MM”格式（24时制）	14:28</span><br><span class="line"></span><br><span class="line">Date date=new Date();                                  </span><br><span class="line">//c的使用  </span><br><span class="line">System.out.printf(&quot;全部日期和时间信息：%tc%n&quot;,date);          </span><br><span class="line">//f的使用  </span><br><span class="line">System.out.printf(&quot;年-月-日格式：%tF%n&quot;,date);  </span><br><span class="line">//d的使用  </span><br><span class="line">System.out.printf(&quot;月/日/年格式：%tD%n&quot;,date);  </span><br><span class="line">//r的使用  </span><br><span class="line">System.out.printf(&quot;HH:MM:SS PM格式（12时制）：%tr%n&quot;,date);  </span><br><span class="line">//t的使用  </span><br><span class="line">System.out.printf(&quot;HH:MM:SS格式（24时制）：%tT%n&quot;,date);  </span><br><span class="line">//R的使用  </span><br><span class="line">System.out.printf(&quot;HH:MM格式（24时制）：%tR&quot;,date);  </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.printf(&quot;%f&quot;, d);// &quot;f&quot;表示格式化输出浮点数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%9.2f&quot;, d);// &quot;9.2&quot;中的9表示输出的长度，2表示小数点后的位数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%+9.2f&quot;, d);// &quot;+&quot;表示输出的数带正负号。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%-9.4f&quot;, d);// &quot;-&quot;表示输出的数左对齐（默认为右对齐）。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%+-9.3f&quot;, d);// &quot;+-&quot;表示输出的数带正负号且左对齐。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%d&quot;, i);// &quot;d&quot;表示输出十进制整数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%o&quot;, i);// &quot;o&quot;表示输出八进制整数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%x&quot;, i);// &quot;d&quot;表示输出十六进制整数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%#x&quot;, i);// &quot;d&quot;表示输出带有十六进制标志的整数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%s&quot;, s);// &quot;d&quot;表示输出字符串。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;输出一个浮点数：%f，一个整数：%d，一个字符串：%s&quot;, d, i, s);  </span><br><span class="line">// 可以输出多个变量，注意顺序。  </span><br><span class="line">System.out.println();  </span><br></pre></td></tr></table></figure>

<h4 id="Strings-nullToEmpty"><a href="#Strings-nullToEmpty" class="headerlink" title="Strings.nullToEmpty"></a>Strings.nullToEmpty</h4><p>Strings、Lists、Maps 都是google提供的工具类。<br>使用之前导入包guava。</p>
<p>vo.setS(String.nullToEmpty(s));  一般用于给对象属性赋值，如果为null，就设空。</p>
<p>其他guava工具类使用：<a href="https://www.w3cschool.cn/article/17770773.html">https://www.w3cschool.cn/article/17770773.html</a></p>
<h4 id="StringUtils工具类"><a href="#StringUtils工具类" class="headerlink" title="StringUtils工具类"></a>StringUtils工具类</h4><p>StringUtils工具类是org.apache.commons.lang3包下的工具类，对String类型的操作作了封装，是对Java自带的API的有效补充，可以帮助我们更高效快速地处理字符串。</p>
<p>导入commons-lang3包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String substringAfter(String str,String separator)：</span><br><span class="line">在第一次出现分隔符后获取子字符串。</span><br><span class="line"></span><br><span class="line">String substringAfterLast(String str,String separator)：</span><br><span class="line">在最后一次出现分隔符之后获取子字符串。</span><br><span class="line"></span><br><span class="line">String substringBefore(String str,String separator)：</span><br><span class="line">也是第一次出现之前的</span><br><span class="line">StringUtils.substringBefore(&quot;www.baidu.com&quot;, &quot;.)  www</span><br></pre></td></tr></table></figure>

<p>工具类：一般是直接用它的静态方法，直接用类来调用，例如：Collections、Arrays等jaa自带的工具类；Lists、Maps等google工具类；CollectionUtils、StringUtils等apache工具类。</p>
<p>更多：<a href="https://cloud.tencent.com/developer/article/1662921">https://cloud.tencent.com/developer/article/1662921</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringUtils.EMPTY = &quot;&quot;</span><br><span class="line"></span><br><span class="line">// 只替换一次--&gt;结果是：phhhss</span><br><span class="line">StringUtils.replaceOnce(&quot;sshhhss&quot;, &quot;ss&quot;, &quot;p&quot;);</span><br><span class="line">// 全部替换</span><br><span class="line">StringUtils.replace(&quot;sshhhs&quot;, &quot;ss&quot;, &quot;p&quot;);</span><br><span class="line">// 定义替换次数</span><br><span class="line">StringUtils.replace(&quot;sshhhsshss&quot;, &quot;ss&quot;, &quot;7777&quot;,2);</span><br><span class="line">// 检验字符串是否不为null且不为“”</span><br><span class="line">if(!StringUtils.isEmpty(s))</span><br><span class="line"></span><br><span class="line">//忽略大小写的比较：</span><br><span class="line">System.out.println(StringUtils.equalsIgnoreCase(&quot;abc&quot;, &quot;aBC&quot;));</span><br></pre></td></tr></table></figure>

<p><code>ObjectUtils.allNotNull(o1, o2)</code> 是commons-lang3包下的，返回boolean，表示是否所有的对象都不为null，false表示有null。</p>
<h4 id="string自己的方法"><a href="#string自己的方法" class="headerlink" title="string自己的方法"></a>string自己的方法</h4><p>✅str.trim()  用于删除字符串的头尾空白符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str = new String(&quot;   hello   &quot;);</span><br><span class="line">System.out.println( str.trim() );</span><br></pre></td></tr></table></figure>

<p>✅str.replaceAll(正则表达式, 替换字符串)<br>使用给定的参数 replacement 替换字符串所有匹配给定的正则表达式的子字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String Str = new String(&quot;www.hello.com&quot;);</span><br><span class="line">System.out.println(Str.replaceAll(&quot;(.*)hello(.*)&quot;, &quot;hi&quot; ));</span><br></pre></td></tr></table></figure>

<p>✅str.replace(原字符&#x2F;字符串, 替换成的新字符&#x2F;字符串)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String replace(char oldChar, char newChar)</span><br><span class="line">用新字符newChar 替换所有的 旧字符oldChar 。</span><br><span class="line"></span><br><span class="line">String replace(CharSequence target, CharSequence replacement)</span><br><span class="line">用新字符串replacement替换所有的 旧字符串target。</span><br><span class="line"></span><br><span class="line">String replaceAll(String regex, String replacement)</span><br><span class="line">用新字符串replacement 替换所有的 正则模式匹配的串。——（替换的是模糊字串）</span><br><span class="line"></span><br><span class="line">String replaceFirst(String regex, String replacement)</span><br><span class="line">用新字符串replacement 替换第一个 正则模式匹配的串。——（替换的是模糊字串）</span><br><span class="line">————————————————</span><br><span class="line">另外，StringBuilder中也有该方法：</span><br><span class="line">replace(int start，int end，String str)</span><br><span class="line">用str 替换 start–end的子串。//不包括end</span><br></pre></td></tr></table></figure>

<p>✅str.indexof() 用于返回字符串中某部分的索引<br>1、 indexOf(String str): 返回指定字符str在字符串中（方法调用者）第一次出现处的起始索引，如果此字符串中没有这样的字符，则返回 -1。<br>2、indexOf(String str, int index): 返回从 index 位置开始查找指定字符str在字符串中第一次出现处的起始索引，如果此字符串中没有这样的字符，则返回 -1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str = &quot;01234567890123456789&quot;;</span><br><span class="line">System.out.println(str.indexOf(&quot;123&quot;));  //return 1</span><br><span class="line">System.out.println(str.indexOf(&quot;123&quot;,5));  //return 11</span><br></pre></td></tr></table></figure>

<p>str.lastIndexOf(“&#x2F;&#x2F;“)  返回最后一次出现字符&#x2F;字符串的位置。</p>
<p>✅String.join()静态方法<br>用于将list&#x2F;set变为String</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Long&gt; list = Lists.newArrayList(1L, 2L, 2L);</span><br><span class="line">// 元素中类型变换</span><br><span class="line">List&lt;String&gt; ls = list.stream().distinct().map(String::valueOf).collect(Collectors.toList());</span><br><span class="line">// 里面的ls不能为空，必须是String元素类型</span><br><span class="line">String s = String.join(&quot;,&quot;, ls);</span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line">//用set也可以</span><br><span class="line">Set&lt;Long&gt; set = Sets.newHashSet(1L, 2L);</span><br><span class="line">Set&lt;String&gt; ss = set.stream().map(i-&gt;String.valueOf(i)).collect(Collectors.toSet());</span><br><span class="line">s = String.join(&quot;,&quot;, ss);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>✅获取某个位置的字符<br><code>char c = s.charAt(index);</code></p>
<h4 id="Splitter工具类（String拆分成list）"><a href="#Splitter工具类（String拆分成list）" class="headerlink" title="Splitter工具类（String拆分成list）"></a>Splitter工具类（String拆分成list）</h4><p>是google出品的，guava包下的工具类，用于对字符串分割处理。</p>
<p>首先，已有的对字符串进行分割的方法：</p>
<p>1.String自带的split()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = &quot;1,2,3&quot;;</span><br><span class="line">String[] split = s.split(&quot;,&quot;);</span><br></pre></td></tr></table></figure>
<p>不足之处：如果,后有空格的话，还需要做进一步处理，<br>并且分割后以数组接收，如果数据过多，还需要再转为集合。</p>
<p>2.使用Patter类的split静态方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String input = &quot;This!!unusual use!!hh!!points&quot;;</span><br><span class="line">System.out.println(Arrays.toString(Pattern.compile(&quot;!!&quot;).split(input)));</span><br></pre></td></tr></table></figure>

<p>3.Splitter来分割字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SplitterTest &#123;</span><br><span class="line"></span><br><span class="line">    //定义一个拆分器，“,”分隔，去空格</span><br><span class="line">    private static final Splitter splitter = Splitter.on(&quot;,&quot;).trimResults().omitEmptyStrings();</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        String s = &quot;1,2, 3&quot;;</span><br><span class="line">        List&lt;String&gt; list = splitter.splitToList(s);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        List&lt;Long&gt; list1 = list.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Joiner连接字符串"><a href="#Joiner连接字符串" class="headerlink" title="Joiner连接字符串"></a>Joiner连接字符串</h4><p>google guava提供的用来连接字符串的类。需要导包：guava。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 连接字符串list</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;);</span><br><span class="line">String str = Joiner.on(&quot;:&quot;).join(list);</span><br><span class="line">System.out.println(str);</span><br><span class="line">// 输出：AA:BB:CC</span><br><span class="line"></span><br><span class="line">//过滤其中的null</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;AA&quot;, &quot;BB&quot;, null);</span><br><span class="line">String str = Joiner.on(&quot;:&quot;).skipNulls().join(list);</span><br><span class="line">System.out.println(str);</span><br><span class="line">// 输出：AA:BB</span><br><span class="line"></span><br><span class="line">// 可以先定义一个Join对象</span><br><span class="line">private static Joiner MY_JOINER = Joiner.on(&quot;/&quot;).skipNulls();</span><br><span class="line">String s = MY_JOINER.join(..);  里面的参数是Object类型，可以多个。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更多用法：<a href="https://blog.csdn.net/qq_44143796/article/details/122998799">https://blog.csdn.net/qq_44143796/article/details/122998799</a></p>
<h4 id="String操作"><a href="#String操作" class="headerlink" title="String操作"></a>String操作</h4><p>✅截取字符串</p>
<p>1、string自己的substring方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = &quot;hello&quot;;</span><br><span class="line">System.out.println(s.substring(2)); //llo</span><br><span class="line">System.out.println(s.substring(2, 4)); //ll 左闭右开</span><br></pre></td></tr></table></figure>

<p>2、StringUtils提供的方法（apache）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringUtils.substring(&quot;hello world&quot;, 4);   // 返回值，从第4位截取到字符串末尾 : o wrold</span><br><span class="line">StringUtils.substring(&quot;hello world&quot;, 4, 10); // 返回值，从第4位截取到第9位 :   o wrol</span><br><span class="line"></span><br><span class="line">//截取某个字符串之前的字符</span><br><span class="line">StringUtils.substringBefore(&quot;hello world&quot;, &quot;l&quot;); </span><br><span class="line">//结果是：he          这里是以第一个”l”，为标准。</span><br><span class="line">StringUtils.substringBeforeLast(&quot;hello world&quot;, &quot;l&quot;);</span><br><span class="line">//结果为：hello wor   这里以最后一个“l”为准。</span><br><span class="line"></span><br><span class="line">//截取某个字符串之后的字符</span><br><span class="line">StringUtils.substringAfter(&quot;hello world&quot;, &quot;l&quot;);</span><br><span class="line">//结果是：lo world   这里是以第一个”l”，为标准。</span><br><span class="line">StringUtils.substringAfterLast(&quot;hello world&quot;, &quot;l&quot;);</span><br><span class="line">//结果为：d          这里以最后一个“l”为准。</span><br><span class="line"></span><br><span class="line">//截取两个字符串之间隔的字符</span><br><span class="line">StringUtils.substringBetween(&quot;hello world&quot;, &quot;o&quot;);    </span><br><span class="line">//结果是： w   两个o之间的字符串。   </span><br><span class="line">StringUtils.substringBetween(&quot;hello world&quot;, &quot;l&quot;, &quot;r&quot;); </span><br><span class="line">//结果是： lo wo   第一个字符“l”与第一个字符“r”之间的字符串   </span><br><span class="line">StringUtils.substringsBetween(&quot;hello world&quot;, &quot;l&quot;, &quot;r&quot;);</span><br><span class="line">//结果是：数组 [lo wo]   第一个字符“l”与第一个字符“r”之间的字符串，以数组形式返回。   </span><br></pre></td></tr></table></figure>

<p>3、string自己的split方法<br>将字符串按照分割符截取，以数组形式返回</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str = &quot;hello, world, ni,  hao&quot;;</span><br><span class="line">String[]  strs=str.split(&quot;,&quot;);</span><br><span class="line">for(int i=0,len=strs.length;i&lt;len;i++)&#123;</span><br><span class="line">    System.out.println(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line">//空格也算了</span><br><span class="line">hello</span><br><span class="line"> world</span><br><span class="line"> ni</span><br><span class="line">  hao</span><br></pre></td></tr></table></figure>

<p><code>split(String regex)</code> 参数regex称为分割符,可以使用正则表达式来表示。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str= &quot;a33b444c555d&quot;;</span><br><span class="line">//正则表达式中\d+表示一个或多个数字,java中\\表示一个普通\</span><br><span class="line">//String[] split = str.split(Pattern.compile(&quot;\\d+&quot;).toString());</span><br><span class="line">//两种写法都是一样的,下面写法简洁</span><br><span class="line">String[] split = str.split(&quot;\\d+&quot;);</span><br><span class="line"></span><br><span class="line">String str= &quot;aaa|bbb|ccc&quot;;</span><br><span class="line">//使用|作为分隔符,其余特殊字符同理</span><br><span class="line">//两个\表示一个\,加了\后表示仅匹配字符本身</span><br><span class="line">String[] split = str.split(&quot;\\|&quot;);</span><br><span class="line"></span><br><span class="line">String str= &quot;aaa,bbb#ccc&quot;;</span><br><span class="line">//使用,或#分割字符串</span><br><span class="line">String[] split = str.split(&quot;,|#&quot;);</span><br></pre></td></tr></table></figure>

<p><code>split(String regex,int limit)</code> limit控制分割的次数，只填一个正则表达式的话,limit默认是0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）limit &gt; 0,(从左到右)最多分割 n - 1 次,数组的长度将不会大于 n,结尾的空字符串不会丢弃</span><br><span class="line">//limit=3,切割2次,末尾会分割出一个&quot;&quot;空字符串</span><br><span class="line">String[] split = &quot;abcb&quot;.split(&quot;b&quot;,3);</span><br><span class="line">//split:&#123;&quot;a&quot;,&quot;c&quot;,&quot;&quot;&#125;</span><br><span class="line"></span><br><span class="line">（2）limit &lt; 0,匹配到多少次就分割多少次,而且数组可以是任何长度。结尾的空字符串不会丢弃</span><br><span class="line"></span><br><span class="line">（3）limit=0不限制分割次数，要注意结尾的空字符串将会丢弃</span><br></pre></td></tr></table></figure>

<p>split方法完整用法：<a href="https://blog.csdn.net/qq_41740883/article/details/111696866">https://blog.csdn.net/qq_41740883/article/details/111696866</a></p>
<p>✅字符串拼接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() &#123;</span><br><span class="line">    // 1.直接用+，内部会替换成StringBuilder的append方法</span><br><span class="line">    // 不建议在 for 循环中使用 “+” 进行字符串拼接，会创建多个StringBuilder 对象</span><br><span class="line">    String s1 = &quot;hel&quot;;</span><br><span class="line">    String s2 = null;</span><br><span class="line">    System.out.println(s1 + s2); //helnull  如果是null，当作字符串null来处理</span><br><span class="line">    </span><br><span class="line">    // 2.StringBuilder的append方法 （非线程安全）</span><br><span class="line">    StringBuilder s3 = new StringBuilder(&quot;hel&quot;);</span><br><span class="line">    System.out.println(s3.append(&quot;lo&quot;));</span><br><span class="line">    </span><br><span class="line">    // 3.StringBuffer的append方法 （线程安全）</span><br><span class="line">    StringBuffer s4 = new StringBuffer(&quot;hel&quot;);</span><br><span class="line">    System.out.println(s4.append(&quot;lo&quot;));</span><br><span class="line">    </span><br><span class="line">    // 4.String类的concat方法</span><br><span class="line">    System.out.println(s1.concat(&quot;lo&quot;));</span><br><span class="line">    //System.out.println(s1.concat(null)); //NPE</span><br><span class="line">    </span><br><span class="line">    // 5.String类的静态join方法 JDK 1.8 提供，可以分隔符，也可以多个字符串(看上面，也可以是list/set)</span><br><span class="line">    System.out.println(String.join(&quot;&quot;, &quot;hel&quot;, &quot;lo&quot;)); //第一个参数为字符串连接符，后面可以是很多个字符串连接</span><br><span class="line">    </span><br><span class="line">    // 6.org.apache.commons.lang3.StringUtil的join方法（为什么使用这个会慢？？？）</span><br><span class="line">    // 不用担心 NullPointerException,内部使用的仍然是 StringBuilder</span><br><span class="line">    System.out.println(StringUtils.join(&quot;hel&quot;, &quot;lo&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/ChineseSoftware/article/details/122956817">https://blog.csdn.net/ChineseSoftware/article/details/122956817</a></p>
<p>concat与+的区别：<br>①如果拼接的字符串是 null，concat 时候就会抛出 NullPointerException，“+” 操作符会当做是 “null” 字符串来处理。<br>②如果拼接的字符串是一个空字符串(“”)，那么 concat 的效率要更高一点。毕竟不需要 new StringBuilder 对象。<br>③如果拼接的字符串非常多，concat 的效率就会下降，因为用到字符数组，开销就大。</p>
<p>✅字符串翻转</p>
<p>1、用stringBuffer或者stringBuilder自带的reverse方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String newS = new StringBuilder(old).reverse().toString();</span><br></pre></td></tr></table></figure>

<p>2、将字符串拆分为char数组，然后交换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char[] charArray = s.toCharArray();</span><br><span class="line">int start = 0, end = charArray.length - 1;</span><br><span class="line">for (; start &lt; end; start++, end--) &#123;</span><br><span class="line">    charArray[start] ^= charArray[end];//采用异或</span><br><span class="line">    charArray[end] ^= charArray[start];</span><br><span class="line">    charArray[start] ^= charArray[end];</span><br><span class="line">&#125;</span><br><span class="line">String newS = new String(charArray);</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">while (start &lt; end) &#123;</span><br><span class="line">    //交换首尾char值</span><br><span class="line">    char c = charArray[end];</span><br><span class="line">    charArray[end] = charArray[start];</span><br><span class="line">    charArray[start] = c;</span><br><span class="line">    start++;</span><br><span class="line">    end--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、stringBuffer倒序拼接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = new StringBuffer();</span><br><span class="line">for (int i = s.length() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    sb.append(s.charAt(i));</span><br><span class="line">&#125;</span><br><span class="line">String newS = sb.toString();</span><br></pre></td></tr></table></figure>

<p>4、利用栈的先进后出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = new StringBuffer();</span><br><span class="line">Stack stack = new Stack();</span><br><span class="line">for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">    stack.push(s.charAt(i));</span><br><span class="line">&#125;</span><br><span class="line">while (!stack.isEmpty()) &#123;</span><br><span class="line">    //stack会返回栈顶值，并且会把该值删除</span><br><span class="line">    sb.append(stack.pop());</span><br><span class="line">&#125;</span><br><span class="line">String newS = sb.toString();</span><br></pre></td></tr></table></figure>

<p>5、切割递归反转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static String reverse(String s) &#123;</span><br><span class="line">    if (s.length() &lt;= 1) &#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    //每次把第一个放在后面</span><br><span class="line">    return reverse(s.substring(1)) + s.substring(0, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、二分递归反转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static String reverse(String s) &#123;</span><br><span class="line">    int length = s.length();</span><br><span class="line">    if (length &lt;= 1) return s;</span><br><span class="line">    String left = s.substring(0, length / 2);</span><br><span class="line">    String right = s.substring(length / 2, length);</span><br><span class="line">    return reverse(right) + reverse(left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://www.jb51.net/article/237801.htm">https://www.jb51.net/article/237801.htm</a></p>
<p>✅删除字符串最后一个字符</p>
<p>1、String的substring方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = &quot;abcd&quot;;</span><br><span class="line">System.out.println(s.substring(0, s.length() - 1));</span><br></pre></td></tr></table></figure>

<p>2、replaceFirst方法 正则表达式匹配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str = &quot;abcd&quot;;</span><br><span class="line">str = str.replaceFirst(&quot;.$&quot;, &quot;&quot;);</span><br><span class="line">//匹配除“\n”和&quot;\r&quot;之外的任何单个字符</span><br><span class="line">//匹配输入行尾。</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/qq_35764295/article/details/126106534">https://blog.csdn.net/qq_35764295/article/details/126106534</a></p>
<h4 id="StringBuilder操作"><a href="#StringBuilder操作" class="headerlink" title="StringBuilder操作"></a>StringBuilder操作</h4><p>✅删除最后一个字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">sb.append(&#x27;a&#x27;).append(&#x27;b&#x27;).append(&#x27;c&#x27;);</span><br><span class="line">sb.deleteCharAt(sb.length()-1);</span><br><span class="line">System.out.println(sb); //ab</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">sb.delete(sb.length()-1, sb.length());</span><br></pre></td></tr></table></figure>

<h3 id="map相关"><a href="#map相关" class="headerlink" title="map相关"></a>map相关</h3><h4 id="map几种遍历方式"><a href="#map几种遍历方式" class="headerlink" title="map几种遍历方式"></a>map几种遍历方式</h4><p>一、Map.Entry遍历</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;  </span><br><span class="line">  System.out.println(&quot;key= &quot; + entry.getKey());</span><br><span class="line">  System.out.println(&quot;value= &quot; + entry.getValue());</span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
<p>二、通过Iterator迭代器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**通过entrySet()方法将key和value存放到Set集合中，Set集合中有迭代器**/</span><br><span class="line">Set&lt;Entry&lt;String,String&gt;&gt; entry = map.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String,String&gt;&gt; iterators = entry.iterator();</span><br><span class="line">while(iterators.hasNext())&#123;</span><br><span class="line">  Entry&lt;String,String&gt; entrys  = iterators.next();</span><br><span class="line">  System.out.println(&quot;key=&quot;+entrys.getKey()+&quot;&amp;&amp;value=&quot;+entrys.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三、通过keySet()遍历<br>keySet()：将Map中所有的key存放到Set集合中。因为Set集合有迭代器，可以通过迭代器循环key，再通过get()方法，得到每个key所对应的value；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**通过keySet()方法将所有的key值存放到Set集合中,Set集合中有迭代器**/</span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">  String key = iterator.next();</span><br><span class="line">  System.out.println(&quot;key=&quot;+key+&quot;  &quot;+map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可以不用迭代器，直接for循环</span><br><span class="line">for (String key: map.keySet()) &#123;</span><br><span class="line">  System.out.println(&quot;key:&quot; + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四、values()遍历<br>values()获取集合中的所有的value值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; collection = map.values();</span><br><span class="line">再for遍历得到value，同样也可以用迭代器</span><br><span class="line">Iterator var3 = values.iterator();</span><br><span class="line">while(var3.hasNext()) &#123;</span><br><span class="line">  String value = (String)var3.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>五、直接foreach map</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">  System.out.println(&quot;第五种:&quot; + key + &quot; ：&quot; + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="MapUtils工具类"><a href="#MapUtils工具类" class="headerlink" title="MapUtils工具类"></a>MapUtils工具类</h4><p>MapUtils是 org.apache.commons.collections 工具包中常用的工具类<br>需要导入包：commons-collections4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int value = MapUtils.getInteger(map, key, 0)</span><br><span class="line">//将结果转换为Integer，如果转换失败则使用默认值</span><br></pre></td></tr></table></figure>

<p>更多用法：<a href="https://blog.csdn.net/u012894692/article/details/82557843">https://blog.csdn.net/u012894692/article/details/82557843</a></p>
<h4 id="map的一些操作"><a href="#map的一些操作" class="headerlink" title="map的一些操作"></a>map的一些操作</h4><p>✅map的size</p>
<p>map.size() 返回 hashMap 中键&#x2F;值对的数量。</p>
<p>✅map的put和putIfAbsent<br>1.使用 put 方法添加键值对，如果 map 集合中没有该 key 对应的值，则直接添加，并返回 null；如果已经存在对应的值，则会<strong>覆盖旧值</strong>，value 为新的值，返回值为旧的value。<br><code>map.put(key, value)</code></p>
<p>2.使用 putIfAbsent 方法添加键值对，不存在才加入，如果 map 集合中没有该 key 对应的值，则直接添加，并返回 null，如果已经存在对应的值，则依旧为原来的值，返回值为 value（旧的值）。<br><code>map.putIfAbsent(key, value)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;11&quot;, &quot;11&quot;);</span><br><span class="line">    System.out.println(map.put(&quot;11&quot;, &quot;22&quot;));  //输出11</span><br><span class="line">    System.out.println(map.put(&quot;22&quot;, &quot;22&quot;));  //输出null</span><br><span class="line">    System.out.println(map.putIfAbsent(&quot;11&quot;, &quot;33&quot;));  //输出22</span><br><span class="line">    System.out.println(map.putIfAbsent(&quot;33&quot;, &quot;44&quot;));  //输出33</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>✅map.getOrDefault(key, defaultvalue)<br>用于map获取value，与.get(key)不同的是，如果得到的value是null的话，可以给一个默认值。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;StudentGrade&gt; gradeList = Lists.newArrayList();</span><br><span class="line">//把学生成绩list变为map：学生-成绩list</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; gradeMap = Maps.newHashMap();</span><br><span class="line">for(StudentGrade studentGrade : gradeList) &#123;</span><br><span class="line">  List&lt;String&gt; grades = gradeMap.getOrDefault(studentGrade.getName(), Lists.newArrayList());</span><br><span class="line">  grades.add(studentGrade.getGrade());</span><br><span class="line">  gradeMap.put(studentGrade.getName(), grades); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅对map的某个value加一</p>
<p>用<code>map.get(i)++;</code> 不行。得先：<code>int v = map.get(i) + 1;</code> 然后：<code>map.put(i, v);</code></p>
<p>✅某key是否存在<br><code>map.containsKey(key)</code></p>
<p>✅json字符串转换为map</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;Long, String&gt; map = JSON.parseObject(jsonString, Map.class);</span><br></pre></td></tr></table></figure>

<p>✅ceilingEntry()</p>
<p>java.util.TreeMap.ceilingEntry() 返回具有最小键值（大于或等于指定键）的键值对，如果没有这样的键，则返回null。(取比输入值大的)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;1&quot;);</span><br><span class="line">map.put(3, &quot;3&quot;);</span><br><span class="line">Map.Entry&lt;Integer, String&gt; entry = map.ceilingEntry(2);</span><br><span class="line">System.out.println(entry.getValue()); //3</span><br></pre></td></tr></table></figure>

<h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>定义枚举类，定义在一个包中，和impl、service、vo包平级。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum SexEnum:int &#123;</span><br><span class="line">    male,female;</span><br><span class="line">&#125;</span><br><span class="line">多个枚举成员之间使用逗号分隔，</span><br><span class="line">如果没有显式地声明基础类型的枚举，那么意味着它所对应的基础类型是 int。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">public enum DemoEnum &#123;</span><br><span class="line">  LIU(&quot;liu&quot;, 1),</span><br><span class="line">  WANG(&quot;wang&quot;, 2);</span><br><span class="line">  UN_KNOW(&quot;unknow&quot;, 99)</span><br><span class="line"></span><br><span class="line">  private final String name;</span><br><span class="line">  private final int age;</span><br><span class="line"></span><br><span class="line">  //构造函数</span><br><span class="line">  private DemoEnum(String name, int age)&#123; </span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //可以存一个map供外部使用，里面是直接的enum类</span><br><span class="line">  static Map&lt;String, DemoEnum&gt; map = new TreeMap&lt;&gt;();</span><br><span class="line">  static &#123;</span><br><span class="line">    for (DemoEnum enum : DemoEnum.values()) &#123;</span><br><span class="line">      map.put(enum.getName(), enum)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static DemoEnum getEnumByName(String name) &#123;</span><br><span class="line">    return map.get(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //根据属性获得enum，再获得另一属性</span><br><span class="line">  //可以使用上面构造个map，再从map获取的方法</span><br><span class="line">  //也可以加个方法，遍历获取，根据属性获取enum</span><br><span class="line">  public static DemoEnum nameOf(String name) &#123;</span><br><span class="line">    for (DemoEnum e : DemoEnum.values()) &#123;</span><br><span class="line">      if (e.name = name) &#123;</span><br><span class="line">        return e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return UN_KNOW;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类的values()方法，获取定义的成员数组：<br><code>DemoEnum[] values = DemoEnum.values();</code></p>
<p>Enum valueOf方法：<br>通过字符串来获取枚举enum：<br><code>DemoEnum e = DemoEnum.valueOf(&quot;LIU&quot;)</code></p>
<h3 id="File相关"><a href="#File相关" class="headerlink" title="File相关"></a>File相关</h3><h4 id="File"><a href="#File" class="headerlink" title="File"></a>File</h4><p>Java文件类以抽象的方式代表文件名和目录路径名。该类主要用于文件和目录的创建、文件的查找和文件的删除等。<br>File对象代表磁盘中实际存在的文件和目录。<br>自我理解：File对象就是文件路径在java里的一个抽象，并不代表真实文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新建文件：</span><br><span class="line">String dirname = &quot;/java&quot;;</span><br><span class="line">File f1 = new File(dirname);</span><br><span class="line"></span><br><span class="line">// 判断该文件是否是一个目录</span><br><span class="line">if (f1.isDirectory()) &#123; &#125;</span><br><span class="line">f1.isFile() 是否是文件</span><br><span class="line"></span><br><span class="line">// 返回由此抽象路径名所表示的目录中的文件和目录的名称所组成字符串数组。</span><br><span class="line">String s[] = f1.list();</span><br><span class="line">for (int i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  File f = new File(dirname + &quot;/&quot; + s[i]);</span><br><span class="line">  if (f.isDirectory()) &#123;</span><br><span class="line">    System.out.println(s[i] + &quot; is a directory&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    System.out.println(s[i] + &quot; is a file&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName()  返回此抽象路径名表示的文件或目录的名称。（文件名）</span><br><span class="line"></span><br><span class="line">public String getPath()  将此抽象路径名转换为一个路径名字符串。（路径名）</span><br><span class="line"></span><br><span class="line">public String getParent()  返回此抽象路径名的父路径名的路径名字符串（路径名）</span><br><span class="line"></span><br><span class="line">public File getParentFile()  返回父文件</span><br><span class="line"></span><br><span class="line">public boolean exists()  测试此抽象路径名表示的文件或目录是否存在。</span><br><span class="line"></span><br><span class="line">// 创建文件所在目录：</span><br><span class="line">File file = new File(&quot;/Users/liuxuan/MyProject/hi.md&quot;);</span><br><span class="line">File dirFile = file.getParentFile();</span><br><span class="line">if(dirFile != null &amp;&amp; !dirFile.exists())&#123;</span><br><span class="line">  dirFile.mkdirs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多方法：<a href="https://www.runoob.com/java/java-file.html">https://www.runoob.com/java/java-file.html</a></p>
<p>✅文件读写的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() throws IOException &#123;</span><br><span class="line">    // 1. 新建文件夹</span><br><span class="line">    String filePath = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    File file1 = new File(filePath);</span><br><span class="line">    boolean isSame = file.equals(file1);  //true 重写了，变值比较</span><br><span class="line">    boolean isSame1 = file == file1;  //false 地址比较</span><br><span class="line">    System.out.println(isSame);  //true</span><br><span class="line">    if(!file.getParentFile().exists()) &#123;</span><br><span class="line">        File dirFile = file.getParentFile();</span><br><span class="line">        dirFile.mkdirs();  //建立父文件夹</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.字节数组直接写文件，下面有加一步输出流的方式</span><br><span class="line">    String filePath1 = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hi.java&quot;;</span><br><span class="line">    File file2 = new File(filePath1);</span><br><span class="line">    if(file2.exists()) &#123;</span><br><span class="line">        boolean res = file2.delete();</span><br><span class="line">        System.out.println(&quot;delete:&quot; + res);</span><br><span class="line">    &#125;</span><br><span class="line">    byte[] data = &quot;hi&quot;.getBytes();</span><br><span class="line">    byte[] data1 = &quot;System.out.println(\&quot;hi\&quot;)&quot;.getBytes();  //String变字节数组</span><br><span class="line">    try &#123;</span><br><span class="line">        FileUtils.writeByteArrayToFile(file2, data);</span><br><span class="line">        FileUtils.writeByteArrayToFile(file2, data1);  //覆写的方式</span><br><span class="line">    &#125; catch(Exception e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.读取文件：用输入流 文件-&gt;输入流-&gt;字节数组</span><br><span class="line">    FileInputStream in = new FileInputStream(file2);  //也有传入路径字符串的构造函数</span><br><span class="line">    // 输入流变字节数组</span><br><span class="line">    byte[] data2 = IOUtils.toByteArray(in);</span><br><span class="line">    //String content = data2.toString();  //字节数组变String，用这个不对</span><br><span class="line">    String content = new String(data2);  //得用它</span><br><span class="line">    System.out.println(&quot;输入流内容：&quot; + content);</span><br><span class="line">    String content4 = Arrays.toString(data2);</span><br><span class="line">    System.out.println(&quot;输入流内容：&quot; + content4); //这样输出的是数字</span><br><span class="line"></span><br><span class="line">    // 3.读取文件：用输入流 文件-&gt;输入流-&gt;字节数组，另种方法</span><br><span class="line">    FileInputStream in1 = new FileInputStream(file2);</span><br><span class="line">    byte[] data3 = new byte[20];</span><br><span class="line">    String content3 = CharStreams.toString(new InputStreamReader(in1, Charsets.UTF_8)); //这里也消耗输入流</span><br><span class="line">    System.out.println(&quot;前面获取输入流内容：&quot; + content3);</span><br><span class="line">    int num = in1.read(data3);  //输入流消耗20个字节</span><br><span class="line">    System.out.println(&quot;几个字节：&quot; + num);</span><br><span class="line">    String content1 = IOUtils.toString(in1, String.valueOf(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(&quot;输入流内容：&quot; + content1);   //这里只剩几个可以展示</span><br><span class="line">    String content2 = IOUtils.toString(in1, String.valueOf(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(&quot;输入流内容2：&quot; + content2);  //这里已经没有了</span><br><span class="line"></span><br><span class="line">    // 4.写文件：用输出流 字节数组-&gt;输出流-&gt;文件</span><br><span class="line">    String filePath2 = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hi2.java&quot;;  //要写的文件，可以没建立</span><br><span class="line">    File file3 = new File(filePath2);</span><br><span class="line">    FileOutputStream out = new FileOutputStream(filePath2);</span><br><span class="line">    byte[] data4 = &quot;System.out.println(\&quot;hi2\&quot;)&quot;.getBytes();</span><br><span class="line">    out.write(data4);  //如果文件存在内容，则是覆盖的方式</span><br><span class="line">    if(file3.exists()) System.out.println(&quot;写入成功&quot;);</span><br><span class="line">    //关闭流</span><br><span class="line">    IOUtils.closeQuietly(in);</span><br><span class="line">    IOUtils.closeQuietly(out);</span><br><span class="line"></span><br><span class="line">    // 5.copy文件：文件-输入流-字节数组-输出流-文件，用IOUtils.copy()一步到位</span><br><span class="line">    String filePath3 = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hi3.java&quot;;  //要写的文件，可以没建立</span><br><span class="line">    File file4 = new File(filePath3);</span><br><span class="line">    FileInputStream in3 = new FileInputStream(file3);</span><br><span class="line">    FileOutputStream out2 = new FileOutputStream(file4);</span><br><span class="line">    IOUtils.copy(in3, out2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅获取文件大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() throws IOException &#123;</span><br><span class="line">    // 1.方法一：使用java io</span><br><span class="line">    String filePath = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    long size = file.length();</span><br><span class="line">    System.out.println(&quot;文件大小：&quot; + size + &quot;B&quot;);</span><br><span class="line"></span><br><span class="line">    // 2.方法二：使用java nio</span><br><span class="line">    Path filePath1 = Paths.get(&quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;);  //绝对路径</span><br><span class="line">    FileChannel fileChannel = FileChannel.open(filePath1);</span><br><span class="line">    long size1 = fileChannel.size();</span><br><span class="line">    System.out.println(&quot;文件大小：&quot; + size1 + &quot;B&quot;);</span><br><span class="line">    Path filePath2 = Paths.get(&quot;src/test/resources/hi.md&quot;);  //项目下路径</span><br><span class="line">    FileChannel fileChannel2 = FileChannel.open(filePath2);</span><br><span class="line">    long size2 = fileChannel2.size();</span><br><span class="line">    System.out.println(&quot;文件大小：&quot; + size2 + &quot;B&quot;);</span><br><span class="line"></span><br><span class="line">    // 3.方法三：使用  apache commons io (只能读文件夹的大小)</span><br><span class="line">    String dir = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile&quot;;</span><br><span class="line">    File file1 = new File(dir);</span><br><span class="line">    long size3 = FileUtils.sizeOfDirectory(file1);</span><br><span class="line">    System.out.println(&quot;文件夹大小：&quot; + size3 + &quot;B&quot;);</span><br><span class="line"></span><br><span class="line">    // 用户可读视角？</span><br><span class="line">    String display = FileUtils.byteCountToDisplaySize(size);</span><br><span class="line">    System.out.println(display);  //117 bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="File流"><a href="#File流" class="headerlink" title="File流"></a>File流</h4><p>JAVA中针对文件的读写操作设置了一系列的流，其中主要有FileInputStream,FileOutputStream,FileReader,FileWriter四种最为常用的流</p>
<p>一、FileInputStream流</p>
<p>被称为文件字节输入流，意思指对文件数据以字节的形式进行读取操作如读取图片视频等</p>
<p>若File类对象的所代表的文件不存在;不是文件是目录;或者其他原因不能打开的话，则会抛出FileNotFoundException。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">  File file=new File(&quot;xxxxxxxx&quot;); </span><br><span class="line">  //根据路径创建File类对象--这里路径即使错误也不会报错，因为只是产生File对象，还并未与计算机文件读写有关联</span><br><span class="line">        </span><br><span class="line">  try&#123;</span><br><span class="line">    FileInputStream fileInputStream=new FileInputStream(file);</span><br><span class="line">    //与根据File类对象的所代表的实际文件建立链接创建fileInputStream对象</span><br><span class="line">      &#125;catch (FileNotFoundException e)&#123;</span><br><span class="line">          System.out.println(&quot;文件不存在或者文件不可读或者文件是目录&quot;);</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 也可以根据文件路径名字符串进行建立</span><br><span class="line">FileInputStream fileInputStream=new FileInputStream(filepath);</span><br></pre></td></tr></table></figure>

<p>更多：<a href="https://blog.csdn.net/ai_bao_zi/article/details/81097898">https://blog.csdn.net/ai_bao_zi/article/details/81097898</a></p>
<p>IO流的关系：<a href="https://www.cnblogs.com/lianshan/p/11911773.html">https://www.cnblogs.com/lianshan/p/11911773.html</a><br><a href="https://blog.csdn.net/q306507291/article/details/118825930">https://blog.csdn.net/q306507291/article/details/118825930</a></p>
<h4 id="FileUtils-工具类"><a href="#FileUtils-工具类" class="headerlink" title="FileUtils 工具类"></a>FileUtils 工具类</h4><p>apache 的commons-io包下的FileUtils，导包：commons-io</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File file = new File(&quot;E:\\java\\file04\\abc雪.jpg&quot;);</span><br><span class="line">//删除指定文件，从不引发异常。</span><br><span class="line">FileUtils.deleteQuietly(file);</span><br><span class="line"></span><br><span class="line">//将byte数组写为File</span><br><span class="line">byte[] bytes = IOUtils.toByteArray(inputStream);</span><br><span class="line">FileUtils.writeByteArrayToFile(new File(path), bytes)</span><br><span class="line"></span><br><span class="line">//删除掉指定目录的文件</span><br><span class="line">FileUtils.deleteExistFile(new File(localpath));</span><br></pre></td></tr></table></figure>
<p>更多方法：<a href="https://blog.csdn.net/qq_42402854/article/details/83374559">https://blog.csdn.net/qq_42402854/article/details/83374559</a></p>
<h4 id="IOUtils工具类"><a href="#IOUtils工具类" class="headerlink" title="IOUtils工具类"></a>IOUtils工具类</h4><p>它是 Apache Commons IO 的一部分 。该类的所有成员函数都被用来处理输入 - 输出流。这些方法基于 InputStream,  OutputStream,  Reader 和 Writer工作。</p>
<p>所有成员字段和方法都是静态的，不需要创建对象，直接用类名调用。</p>
<p>✅输入流转为字节数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将输入流转换成字符数组:</span><br><span class="line">byte[] bytes = IOUtils.toByteArray(inputStream);</span><br></pre></td></tr></table></figure>

<p>✅关闭流<br>之前关闭流，往往在finally中，因为会抛出IOException，所以finally中需要try catch，并且close之前需要判断是否为null。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">finally &#123;</span><br><span class="line">  if (in != null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      in.close();</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">          LOGGER.warn(&quot;Fail to close stream : &quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候就可以使用 IOUtils.closeQuietly 来精简代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte[] data = new byte[1024];</span><br><span class="line">InputStream in = null;</span><br><span class="line">OutputStream out = null;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">      in = new FileInputStream(&quot;foo.txt&quot;);</span><br><span class="line">      in.read(data);</span><br><span class="line"></span><br><span class="line">      out = new FileOutputStream(&quot;foo.txt&quot;);</span><br><span class="line">      data = &quot;Hello, World&quot;.getBytes();</span><br><span class="line">      out.write(data);</span><br><span class="line"></span><br><span class="line">      IOUtils.copy(in, out);</span><br><span class="line"></span><br><span class="line">      in.close(); //close errors are handled</span><br><span class="line">      out.close();</span><br><span class="line">&#125; catch (IOException e) &#123; </span><br><span class="line">      // error handling</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">      IOUtils.closeQuietly(in);</span><br><span class="line">      IOUtils.closeQuietly(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多方法：<a href="https://blog.csdn.net/sulia1234567890/article/details/120569718">https://blog.csdn.net/sulia1234567890/article/details/120569718</a></p>
<p>✅写文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() throws IOException &#123;</span><br><span class="line">    String filePath = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    OutputStream out = new FileOutputStream(file, true);</span><br><span class="line">    IOUtils.write(&quot;hello&quot;, out);</span><br><span class="line">    IOUtils.write(&quot;\n&quot;, out);</span><br><span class="line">    IOUtils.write(&quot;hi&quot;, out);</span><br><span class="line">    //也可以传字节数组、字符数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️new FileOutputStream(“b.txt”,true);</p>
<p>默认第二个参数是false，表示不追加，每次new对象都会清空之前的内容创建新的内容，ture表示在之前的基础上追加内容</p>
<p>✅字节数组转换为String</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte[] data = &quot;hello world&quot;.getBytes();</span><br><span class="line">//apache里io的IOUtils需要commons-io包</span><br><span class="line">String s1 = IOUtils.toString(data, &quot;utf-8&quot;);</span><br><span class="line">String s2 = new String(data);</span><br><span class="line">System.out.println(s1);</span><br><span class="line">System.out.println(s2);</span><br></pre></td></tr></table></figure>

<h4 id="MultipartFile"><a href="#MultipartFile" class="headerlink" title="MultipartFile"></a>MultipartFile</h4><p>需要依赖：spring-web</p>
<p>首先，“流”是一个抽象的概念，它是对输入输出设备的一种抽象理解，在java中，对数据的输入输出操作都是以“流”的方式进行的。“流”具有方向性，输入流、输出流是相对的。当程序需要从数据源中读入数据的时候就会开启一个输入流，相反，写出数据到某个数据源目的地的时候也会开启一个输出流。</p>
<p>MultipartFile是SpringMVC提供简化上传操作的工具类。实现文件的快速上传，不需要先将File转换成output流 再传输过去 接收端接收流再生成文件。</p>
<p>在不使用框架之前，都是使用原生的HttpServletRequest来接收上传的数据，文件是以二进制流传递到后端的，然后需要我们自己转换为File类。使用了MultipartFile工具类之后，我们对文件上传的操作就简便许多了。<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/weixin_45393094/article/details/112056436">https://blog.csdn.net/weixin_45393094/article/details/112056436</a></p>
<p>✅内部方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface MultipartFile extends InputStreamSource &#123;</span><br><span class="line">    //getName() 返回参数的名称</span><br><span class="line">    String getName();</span><br><span class="line">    //获取源文件的昵称</span><br><span class="line">    @Nullable</span><br><span class="line">    String getOriginalFilename();</span><br><span class="line">    //getContentType() 返回文件的内容类型</span><br><span class="line">    @Nullable</span><br><span class="line">    String getContentType();</span><br><span class="line">    //isEmpty() 判断是否为空，或者上传的文件是否有内容</span><br><span class="line">    boolean isEmpty();</span><br><span class="line">    //getSize() 返回文件大小 以字节为单位</span><br><span class="line">    long getSize();</span><br><span class="line">    //getBytes() 将文件内容转化成一个byte[] 返回</span><br><span class="line">    byte[] getBytes() throws IOException;</span><br><span class="line">    //getInputStream() 返回InputStream读取文件的内容</span><br><span class="line">    InputStream getInputStream() throws IOException;</span><br><span class="line"></span><br><span class="line">    default Resource getResource() &#123;</span><br><span class="line">        return new MultipartFileResource(this);</span><br><span class="line">    &#125;</span><br><span class="line">    //transferTo(File dest) 用来把 MultipartFile 转换换成 File</span><br><span class="line">    void transferTo(File var1) throws IOException, IllegalStateException;</span><br><span class="line"></span><br><span class="line">    default void transferTo(Path dest) throws IOException, IllegalStateException &#123;</span><br><span class="line">        FileCopyUtils.copy(this.getInputStream(), Files.newOutputStream(dest));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅MockMultipartFile</p>
<p>可以用MockMultipartFile创建MultipartFile。需要导入spring-test.jar</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MockMultipartFile(String name, @Nullable String originalFilename, @Nullable String contentType, InputStream contentStream)</span><br><span class="line">第一个参数：传输后的文件名 </span><br><span class="line">第二个：旧文件名字（可为空） </span><br><span class="line">第三：类型</span><br><span class="line">第四：输入流</span><br></pre></td></tr></table></figure>

<p>✅MultipartFile与File的相互转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() throws IOException &#123;</span><br><span class="line">    // 1.File转为MultipartFile：file-InputStream-MultipartFile</span><br><span class="line">    String filePath = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    System.out.println(file.getName());  //hello.java</span><br><span class="line">    System.out.println(FilenameUtils.getExtension(file.getName()));  //后缀java</span><br><span class="line">    FileInputStream in = new FileInputStream(file);</span><br><span class="line">    MultipartFile mf = new MockMultipartFile(file.getName(), file.getName(), &quot;text/plain&quot;, in);</span><br><span class="line">    System.out.println(mf.getName()); //hello.java</span><br><span class="line">    System.out.println(mf.getOriginalFilename());  //hello.java</span><br><span class="line"></span><br><span class="line">    // 2.MultipartFile转为File</span><br><span class="line">    try &#123;</span><br><span class="line">        String uuid = UUID.randomUUID().toString();</span><br><span class="line">        //得到文件后缀</span><br><span class="line">        String originalName = mf.getOriginalFilename();</span><br><span class="line">        String ext = &quot;.&quot; + FilenameUtils.getExtension(originalName);</span><br><span class="line">        String fileName = uuid + ext;</span><br><span class="line">        File targetFile = new File(&quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/&quot;, fileName);</span><br><span class="line">        //第一个参数：文件夹  第二个参数：文件名</span><br><span class="line">        // 方法一：MultipartFile - 字节数组 - File本地</span><br><span class="line">        FileUtils.writeByteArrayToFile(targetFile, mf.getBytes());</span><br><span class="line">        // 方法二：MultipartFile - 字节数组 - 输出流 - File本地</span><br><span class="line">        byte[] data = mf.getBytes();</span><br><span class="line">        FileOutputStream out = new FileOutputStream(targetFile);</span><br><span class="line">        out.write(data);</span><br><span class="line">        IOUtils.closeQuietly(out);</span><br><span class="line">        // 方法三：直接用MultipartFile内部方法</span><br><span class="line">        mf.transferTo(targetFile);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        System.out.println(&quot;失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅使用MultipartFile实现文件上传的一个case</p>
<p>背景：文件上传备份希望它是和主业务线程处于异步情况下的，这样可以更快的响应给用户反馈，减少等待时间。<br>MultipartFile异步保存文件transferto 报错java.io.FileNotFoundException: XXX.tmp (No such file or directory)</p>
<p>原因：由于SpringBoot上传文件后会形成MultiPartFile的实例，在临时文件夹中生成临时文件，并且此实例执行此临时文件。当主线程执行结束后，<br>SpringMVC会清除掉此临时文件，导致子线程在处理此实例的时候找不到此实例指向的临时文件，MultipartFile对象就变成了null,从而报FileNotFoundException！</p>
<p>解决：先获取传InputStrem，传传InputStrem。</p>
<p>参考：<a href="https://blog.csdn.net/weixin_42408648/article/details/126272849">https://blog.csdn.net/weixin_42408648/article/details/126272849</a></p>
<p>✅MultipartFile 对上传的文件大小进行限制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class MultipartFileUtil &#123;</span><br><span class="line"></span><br><span class="line">private final static Integer FILE_SIZE = 5;//文件上传限制大小</span><br><span class="line">private final static String FILE_UNIT = &quot;M&quot;;//文件上传限制单位（B,K,M,G）</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param len  文件长度</span><br><span class="line">     * @param size 限制大小</span><br><span class="line">     * @param unit 限制单位（B,K,M,G）</span><br><span class="line">     * @描述 判断文件大小</span><br><span class="line">     */</span><br><span class="line">    public static boolean checkFileSize(Long len, int size, String unit) &#123;</span><br><span class="line">        double fileSize = 0;</span><br><span class="line">        if (&quot;B&quot;.equalsIgnoreCase(unit)) &#123;</span><br><span class="line">            fileSize = (double) len;</span><br><span class="line">        &#125; else if (&quot;K&quot;.equalsIgnoreCase(unit)) &#123;</span><br><span class="line">            fileSize = (double) len / 1024;</span><br><span class="line">        &#125; else if (&quot;M&quot;.equalsIgnoreCase(unit)) &#123;</span><br><span class="line">            fileSize = (double) len / 1048576;</span><br><span class="line">        &#125; else if (&quot;G&quot;.equalsIgnoreCase(unit)) &#123;</span><br><span class="line">            fileSize = (double) len / 1073741824;</span><br><span class="line">        &#125;</span><br><span class="line">        return !(fileSize &gt; size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //文件上传调用</span><br><span class="line">    public static String upload(MultipartFile file) &#123;</span><br><span class="line">        boolean flag = checkFileSize(file.getSize(), FILE_SIZE, FILE_UNIT);</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;上传文件大小超出限制&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转自：<a href="https://blog.csdn.net/w_shimmer/article/details/124341265">https://blog.csdn.net/w_shimmer/article/details/124341265</a></p>
<h4 id="java-nio-file-文件操作"><a href="#java-nio-file-文件操作" class="headerlink" title="java.nio.file 文件操作"></a>java.nio.file 文件操作</h4><p>自 Java7 开始，Java 终于简化了文件读写的基本操作，新增了 java.nio.file 库，通过与 Java8 新增的 stream 结合可以使得文件操作变得更加优雅。</p>
<p>1️⃣文件和目录路径Path</p>
<p>java.nio.file.Paths 类包含一个静态方法 <code>static.get()</code>，可以接受一系列 String 字符串或一个统一资源标识符 URI 作为参数，并且转换返回一个 <code>Path</code> 对象。</p>
<p>一个 Path 对象表示一个文件或者目录的路径，是一个跨操作系统和文件系统的抽象，目的是在构造路径时可以不必关注底层操作系统。如果 Path 仅由一个空的名称元素组成，则认为是空的路径。使用空路径访问文件等同于访问文件系统的默认目录。Path 接口的实现是不可变且安全的，可供多个并行线程使用.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Path path1 = Paths.get(&quot;C:&quot;, &quot;path&quot;, &quot;to&quot;, &quot;nowhere&quot;, &quot;NoFile.txt&quot;);</span><br><span class="line">System.out.println(path1); //C:/path/to/nowhere/NoFile.txt</span><br><span class="line">Path path2 = Paths.get(&quot;C:/path/to/nowhere/NoFile.txt&quot;);</span><br><span class="line">System.out.println(path2); //C:/path/to/nowhere/NoFile.txt</span><br><span class="line">URI uri = path2.toUri();  //转换为URI对象，可以用于构建web资源的绝对uri</span><br><span class="line">System.out.println(uri); //file:///Users/liuxuan/MyProject/mypro/spring-boot-demo/spring-boot-study/C:/path/to/nowhere/NoFile.txt</span><br><span class="line">Path path3 = Paths.get(uri);</span><br><span class="line">System.out.println(path3);</span><br><span class="line"></span><br><span class="line">// 返回表示此路径的绝对路径的Path对象</span><br><span class="line">Path p = Paths.get(&quot;FileTest.java&quot;).toAbsolutePath();  //相对于当前项目目录</span><br><span class="line">System.out.println(p); ///Users/liuxuan/MyProject/mypro/spring-boot-demo/spring-boot-study/FileTest.java</span><br><span class="line">// 返回表示此路径的真实路径的Path对象，也即是带上盘符（根路径）</span><br><span class="line">Path p2 = Paths.get(&quot;/Users/liuxuan/Downloads/test&quot;).toRealPath();</span><br><span class="line">// getNameCount() 返回路径中的名称元素的数量</span><br><span class="line">for(int i = 0; i &lt; p.getNameCount(); i++) &#123;</span><br><span class="line">    // 返回此路径的名称元素作为 Path对象</span><br><span class="line">    System.out.println(p.getName(i));</span><br><span class="line">&#125;</span><br><span class="line">// 测试路径是否以给定的路径结束，这里会输出 end with &#x27;.java&#x27;:false</span><br><span class="line">System.out.println(&quot;ends with &#x27;.java&#x27;: &quot; + p.endsWith(&quot;.java&quot;));</span><br><span class="line">// Path 也实现了 iterable 接口，会对路径中的名称元素进行遍历</span><br><span class="line">for(Path pp : p) &#123;</span><br><span class="line">    System.out.println(pp);</span><br><span class="line">&#125;</span><br><span class="line">// getRoot() 返回此路径的根路径作为Path对象，为null则该路径不具有根</span><br><span class="line">// startsWith() 效果和 endsWith() 相似</span><br><span class="line">// 这里会输出 Starts with C:\ true</span><br><span class="line">System.out.println(&quot;Starts with &quot; + p.getRoot() + &quot; &quot; + p.startsWith(p.getRoot()));</span><br></pre></td></tr></table></figure>

<p>有时我们还需要通过对 Path 对象增加或修改一部分来构造一个新的 path 对象，可以使用 relativize() 移除 Path 的根路径，或者使用 resolve() 添加 Path 的尾路径，注意添加的路径可以不是真实存在的.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用..可以跳转到上一级路径，但必须使用normalize()方法</span><br><span class="line">// 假设当前路径为/Users/liuxuan/MyProject/mypro/spring-boot-demo/spring-boot-study/FileTest.java</span><br><span class="line">Path base = Paths.get(&quot;..&quot;, &quot;..&quot;, &quot;..&quot;).toAbsolutePath().normalize();</span><br><span class="line">System.out.println(base); ///Users/liuxuan/MyProject</span><br><span class="line">// 构造此路径和给定路径之间的相对路径</span><br><span class="line">Path p4 = base.relativize(p);</span><br><span class="line">System.out.println(p4);</span><br><span class="line">// 使用resolve构造路径</span><br><span class="line">// 此时路径为C:\Users\Bruce\Documents\GitHub\string</span><br><span class="line">Path convoluted = p.getParent().resolve(&quot;string&quot;);</span><br><span class="line">System.out.println(convoluted);</span><br></pre></td></tr></table></figure>

<p>2️⃣Files工具类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取文件的字节数组：</span><br><span class="line">byte[] fileBytes = Files.readAllBytes(Paths.get(&quot;/Users/liuxuan/Downloads/test/cal.sh&quot;));</span><br><span class="line">System.out.println(new String(fileBytes));</span><br></pre></td></tr></table></figure>

<p>获取文件夹中的文件夹数量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String path = &quot;/Users/liuxuan/Downloads/&quot;;</span><br><span class="line">File fileDir = new File(path);</span><br><span class="line">if (!fileDir.exists() || !fileDir.isDirectory()) &#123;</span><br><span class="line">    throw new RuntimeException(&quot;不是文件夹&quot;);</span><br><span class="line">&#125;</span><br><span class="line">String[] fileList = fileDir.list();</span><br><span class="line">int count = 0;</span><br><span class="line">for (String file : fileList) &#123;</span><br><span class="line">    if (new File(path + file).isDirectory()) &#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(count);</span><br><span class="line">File[] files = fileDir.listFiles();</span><br><span class="line">for (File file : files) &#123;</span><br><span class="line">    System.out.println(file.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用Files实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Path path1 = Paths.get(&quot;/Users/liuxuan/Downloads/&quot;);</span><br><span class="line">if (!Files.exists(path1) || !Files.isDirectory(path1)) &#123;</span><br><span class="line">    throw new RuntimeException(&quot;不是文件夹&quot;);</span><br><span class="line">&#125;</span><br><span class="line">long dirCount = Files.list(path1).filter(Files :: isDirectory).count();</span><br><span class="line">System.out.println(dirCount);</span><br></pre></td></tr></table></figure>

<p>使用<code>Files.list(path)</code>需要注意，它返回的是<code>Stream&lt;Path&gt;</code>，如果没有关闭，并且代码频繁使用，将导致打开的文件过多而报错（每个进程可以打开的文件数量是有限制的）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jps -mlVv | grep javaTest</span><br><span class="line">lsof -p 进程id | wc -l</span><br></pre></td></tr></table></figure>

<p>所以要关闭流：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.手动关闭</span><br><span class="line">Stream&lt;Path&gt; paths = Files.list(path);</span><br><span class="line">paths.close();</span><br><span class="line"></span><br><span class="line">2.try resource自动关闭流</span><br><span class="line">try(Stream&lt;Path&gt; paths = Files.list(path)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多该包下的用法：<br><a href="https://blog.csdn.net/CSDN_handsome/article/details/109743637">https://blog.csdn.net/CSDN_handsome/article/details/109743637</a></p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>看《java基础》<br>针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set.stream().map(i-&gt;String.valueOf(i)).</span><br><span class="line">括号内的i，表示流处理中的元素，也是lambda表达式的输入</span><br><span class="line">只有一句语句，省去了&#123;&#125;，省去了return</span><br><span class="line"></span><br><span class="line">使用现有的方法，比如上面的，可以变成lambda表达式的引用形式::</span><br><span class="line">.map(String::valueOf).</span><br><span class="line"></span><br><span class="line">上面的方法例如map()，内部的传参是只有一个函数式接口，</span><br><span class="line">有的方法穿参，除了一个函数式接口还有其他，所以会有其他参数。</span><br><span class="line">例如：</span><br><span class="line">方法：showSum(int x, int y, Calculate cu)</span><br><span class="line">使用：showSum(10, 20, (x,y)-&gt;x+y);</span><br></pre></td></tr></table></figure>



<h3 id="spring-expression-Spel表达式-java语言解析"><a href="#spring-expression-Spel表达式-java语言解析" class="headerlink" title="spring-expression Spel表达式 java语言解析"></a>spring-expression Spel表达式 java语言解析</h3><p>ExpressionParse接口是springframework包下的。<br>对表达式进行解析，通过字符串传入解析器，进行解析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //将一整个语句直接定义了字符串 ,其中对字符串的开始索引与结束索引使用替代变量</span><br><span class="line">    //变量前需要加#</span><br><span class="line">    String str = &quot;#var + 2&quot;;</span><br><span class="line">    //1定义一个专属的表达式解析工具</span><br><span class="line">    ExpressionParser parser = new SpelExpressionParser() ;</span><br><span class="line">    //2定义一个表达式处理类</span><br><span class="line">    Expression exp = parser.parseExpression(str);</span><br><span class="line">    //3进行最终的表达式计算，这个上下文用来传参</span><br><span class="line">    EvaluationContext context = new StandardEvaluationContext() ;</span><br><span class="line">    context.setVariable(&quot;var&quot;, 5);</span><br><span class="line">    //4通过表达式进行结果计算</span><br><span class="line">    System.out.println(exp.getValue(context, Integer.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>AtomicInteger类是系统底层保护的int类型，通过提供执行方法的控制进行值的原子操作。AtomicInteger它不能当作Integer来使用。</p>
<p>从JAVA 1.5开始，AtomicInteger 属于java.util.concurrent.atomic 包下的一个类。</p>
<p>AtomicInteger通过调用构造函数可以直接创建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//初始值是 0</span><br><span class="line">AtomicInteger atomicInteger = new AtomicInteger(); </span><br><span class="line"> </span><br><span class="line">//初始值是 100</span><br><span class="line">AtomicInteger atomicInteger = new AtomicInteger(100);</span><br><span class="line"> </span><br><span class="line">int currentValue = atomicInteger.get();         //100</span><br><span class="line"> </span><br><span class="line">atomicInteger.set(1234);                        //当前值1234</span><br></pre></td></tr></table></figure>

<p>什么时候用？<br>1、作为多个线程同时使用的原子计数器。<br>2、在比较和交换操作中实现非阻塞算法。</p>
<p>原子计数器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一些以原子方式执行加法和减法操作的方法:</span><br><span class="line">addAndGet()- 以原子方式将给定值添加到当前值，并在添加后返回新值。</span><br><span class="line">getAndAdd() - 以原子方式将给定值添加到当前值并返回旧值。</span><br><span class="line">incrementAndGet()- 以原子方式将当前值递增1并在递增后返回新值。它相当于i ++操作。</span><br><span class="line">getAndIncrement() - 以原子方式递增当前值并返回旧值。它相当于++ i操作。</span><br><span class="line">decrementAndGet()- 原子地将当前值减1并在减量后返回新值。它等同于i-操作。</span><br><span class="line">getAndDecrement() - 以原子方式递减当前值并返回旧值。它相当于-i操作。</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger(100);</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.addAndGet(2));         //102</span><br><span class="line">        System.out.println(atomicInteger);                      //102</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.getAndAdd(2));         //102</span><br><span class="line">        System.out.println(atomicInteger);                      //104</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.incrementAndGet());    //105  </span><br><span class="line">        System.out.println(atomicInteger);                      //105  </span><br><span class="line">                 </span><br><span class="line">        System.out.println(atomicInteger.getAndIncrement());    //105</span><br><span class="line">        System.out.println(atomicInteger);                      //106</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.decrementAndGet());    //105</span><br><span class="line">        System.out.println(atomicInteger);                      //105</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.getAndDecrement());    //105</span><br><span class="line">        System.out.println(atomicInteger);                      //104</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较和交换：<br>1、比较和交换操作将内存位置的内容与给定值进行比较，并且只有它们相同时，才将该内存位置的内容修改为给定的新值。这是作为单个原子操作完成的。<br>2、原子性保证了新值是根据最新信息计算出来的; 如果在此期间该值已被另一个线程更新，则写入将失败。<br><code>boolean compareAndSet(int expect, int update)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        //1、默认初始值</span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger(100);</span><br><span class="line">        //2、默认初始值和给定值，都是100，所以会更改成功</span><br><span class="line">        boolean isSuccess = atomicInteger.compareAndSet(100,110);   //current value 100</span><br><span class="line">        //3、返回true</span><br><span class="line">        System.out.println(isSuccess);      //true</span><br><span class="line">        System.out.println(atomicInteger);  //110</span><br><span class="line">        //4、默认初始值是110,给定值是100，所以会更改失败</span><br><span class="line">        isSuccess = atomicInteger.compareAndSet(100,120);       //current value 110</span><br><span class="line">        //5、返回false</span><br><span class="line">        System.out.println(isSuccess);      //false</span><br><span class="line">        System.out.println(atomicInteger);  //110</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://www.jianshu.com/p/073096a729f6">https://www.jianshu.com/p/073096a729f6</a></p>
<h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><p>返回Class类型的对象。只是getClass()，返回当前运行时类。object.getClass()前面带对象.getClass()返回对象的类。</p>
<p>Class常用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() throws IllegalAccessException, InstantiationException, IOException &#123;</span><br><span class="line">  Class cl = getClass();</span><br><span class="line">  System.out.println(cl); //class org.example.javaer.ClassTest</span><br><span class="line">  String name = cl.getName(); // org.example.javaer.ClassTest</span><br><span class="line">  System.out.println(name);</span><br><span class="line">  Object classTest = cl.newInstance(); //创建实例</span><br><span class="line">  String packName = cl.getPackage().getName();</span><br><span class="line">  System.out.println(packName); //org.example.javaer</span><br><span class="line">  ClassLoader classLoader = cl.getClassLoader(); //获取类加载器</span><br><span class="line">  System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">  //getResourceAsStream从项目下文件中获取输入流</span><br><span class="line">  //读取文件内容为String</span><br><span class="line">  InputStream in = cl.getResourceAsStream(&quot;/hi.md&quot;); //加&quot;/&quot;，/表示src/test/resources下（ClassPath根目录）</span><br><span class="line">  System.out.println(IOUtils.toString(in, String.valueOf(StandardCharsets.UTF_8)));</span><br><span class="line"></span><br><span class="line">  //读取为字节数组</span><br><span class="line">  byte[] bytes = IOUtils.toByteArray(in);</span><br><span class="line">  System.out.println(bytes);</span><br><span class="line"></span><br><span class="line">  InputStream in1 = cl.getResourceAsStream(&quot;src/test/resources/hi.md&quot;); //不行，NPE</span><br><span class="line">  System.out.println(IOUtils.toString(in1, String.valueOf(StandardCharsets.UTF_8)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅获取各种路径"><a href="#✅获取各种路径" class="headerlink" title="✅获取各种路径"></a>✅获取各种路径</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() throws IOException &#123;</span><br><span class="line">    // 1.获取ClassPath根路径（类加载根路径），到src/test/resources，两种方法</span><br><span class="line">    String path1 = getClass().getResource(&quot;/&quot;).toString(); //file:/Users/liuxuan/MyProject/JavaProject/java/web/target/test-classes/</span><br><span class="line">    System.out.println(&quot;ClassPath根路径：&quot; + path1);</span><br><span class="line">    System.out.println(&quot;项目路径：&quot; + getClass().getClassLoader().getResource(&quot;&quot;)); //和上面一样</span><br><span class="line"></span><br><span class="line">    // 2.获取绝对路径</span><br><span class="line">    String path2 = getClass().getResource(&quot;&quot;).toString(); //file:/Users/liuxuan/MyProject/JavaProject/java/web/target/classes/org/example/javaer/</span><br><span class="line">    System.out.println(&quot;绝对路径：&quot; + path2);</span><br><span class="line"></span><br><span class="line">    // 3.获取项目路径 两种方法</span><br><span class="line">    File dir = new File(&quot;&quot;); //参数为空</span><br><span class="line">    String path3 = dir.getCanonicalPath(); ///Users/liuxuan/MyProject/JavaProject/java/web</span><br><span class="line">    System.out.println(&quot;项目路径：&quot; + path3);</span><br><span class="line">    String path4 = System.getProperty(&quot;user.dir&quot;); ///Users/liuxuan/MyProject/JavaProject/java/web</span><br><span class="line">    System.out.println(&quot;项目路径：&quot; + path4);</span><br><span class="line">    String allPath = System.getProperty(&quot;java.class.path&quot;); //所有jar包的路径</span><br><span class="line">    System.out.println(&quot;java类路径：&quot; + allPath);</span><br><span class="line"></span><br><span class="line">    // 再看看</span><br><span class="line">    String path5 = getClass().getResource(&quot;/&quot;).getPath(); //这样获得的前面没有file</span><br><span class="line">    System.out.println(&quot;ClassPath根路径：&quot; + path5);</span><br><span class="line">    URL url = getClass().getClassLoader().getResource(&quot;&quot;); //file:/Users/liuxuan/MyProject/JavaProject/java/web/target/test-classes/</span><br><span class="line">    System.out.println(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.51cto.com/u_15057811/4080631">https://blog.51cto.com/u_15057811/4080631</a></p>
<h4 id="✅System-getProperty-方法"><a href="#✅System-getProperty-方法" class="headerlink" title="✅System.getProperty()方法"></a>✅System.getProperty()方法</h4><p>获取当前系统的版本等一些信息。<br>内部key：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String path4 = System.getProperty(&quot;user.dir&quot;); ///Users/liuxuan/MyProject/JavaProject/java/web</span><br><span class="line">System.out.println(&quot;项目路径：&quot; + path4);</span><br><span class="line">String allPath = System.getProperty(&quot;java.class.path&quot;);</span><br><span class="line">System.out.println(&quot;java类路径：&quot; + allPath);</span><br><span class="line"></span><br><span class="line">Java.version</span><br><span class="line">Java 运行时环境版本</span><br><span class="line">java.vendor</span><br><span class="line">Java 运行时环境供应商</span><br><span class="line">java.vendor.url</span><br><span class="line">Java 供应商的 URL</span><br><span class="line">java.home</span><br><span class="line">Java 安装目录</span><br><span class="line">java.vm.specification.version</span><br><span class="line">Java 虚拟机规范版本</span><br><span class="line">java.vm.specification.vendor</span><br><span class="line">Java 虚拟机规范供应商</span><br><span class="line">java.vm.specification.name</span><br><span class="line">Java 虚拟机规范名称</span><br><span class="line">java.vm.version</span><br><span class="line">Java 虚拟机实现版本</span><br><span class="line">java.vm.vendor</span><br><span class="line">Java 虚拟机实现供应商</span><br><span class="line">java.vm.name</span><br><span class="line">Java 虚拟机实现名称</span><br><span class="line">java.specification.version</span><br><span class="line">Java 运行时环境规范版本</span><br><span class="line">java.specification.vendor</span><br><span class="line">Java 运行时环境规范供应商</span><br><span class="line">java.specification.name</span><br><span class="line">Java 运行时环境规范名称</span><br><span class="line">java.class.version</span><br><span class="line">Java 类格式版本号</span><br><span class="line">java.class.path</span><br><span class="line">Java 类路径</span><br><span class="line">java.library.path</span><br><span class="line">加载库时搜索的路径列表</span><br><span class="line">java.io.tmpdir</span><br><span class="line">默认的临时文件路径</span><br><span class="line">java.compiler</span><br><span class="line">要使用的 JIT 编译器的名称</span><br><span class="line">java.ext.dirs</span><br><span class="line">一个或多个扩展目录的路径</span><br><span class="line">os.name</span><br><span class="line">操作系统的名称</span><br><span class="line">os.arch</span><br><span class="line">操作系统的架构</span><br><span class="line">os.version</span><br><span class="line">操作系统的版本</span><br><span class="line">file.separator</span><br><span class="line">文件分隔符（在 UNIX 系统中是“/”）</span><br><span class="line">path.separator</span><br><span class="line">路径分隔符（在 UNIX 系统中是“:”）</span><br><span class="line">line.separator</span><br><span class="line">行分隔符（在 UNIX 系统中是“/n”）</span><br><span class="line">user.name</span><br><span class="line">用户的账户名称</span><br><span class="line">user.home</span><br><span class="line">用户的主目录</span><br><span class="line">user.dir</span><br><span class="line">用户的当前工作目录</span><br></pre></td></tr></table></figure>

<h4 id="✅类加载器"><a href="#✅类加载器" class="headerlink" title="✅类加载器"></a>✅类加载器</h4><p>用来把类装载进内存的。</p>
<p>非常不错的详解：<a href="https://blog.csdn.net/m0_68064743/article/details/123957150">https://blog.csdn.net/m0_68064743/article/details/123957150</a></p>
<h4 id="✅getSimpleName"><a href="#✅getSimpleName" class="headerlink" title="✅getSimpleName"></a>✅getSimpleName</h4><p>Class.getSimpleName()方法返回此Class对象表示的类或接口的简单名称，作为字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String className1 = SomeTest.class.getName();</span><br><span class="line">System.out.println(className1); //com.liuxuan.study.SomeTest</span><br><span class="line">String className2 = SomeTest.class.getSimpleName();</span><br><span class="line">System.out.println(className2); //SomeTest</span><br></pre></td></tr></table></figure>

<h3 id="Class-forName方法"><a href="#Class-forName方法" class="headerlink" title="Class.forName方法"></a>Class.forName方法</h3><p>Class类的静态方法forName()<br>和上面的一样，都是返回Class类型的对象，区别在于object.getClass()用于根据对象获取Class对象；Class.forName(className)用于根据类名获取Class对象。</p>
<h4 id="✅-首先讲述Class是个什么样的对象"><a href="#✅-首先讲述Class是个什么样的对象" class="headerlink" title="✅ 首先讲述Class是个什么样的对象"></a>✅ 首先讲述Class是个什么样的对象</h4><p>1、 Class类封装了类或接口的运行时状态</p>
<p>Java程序在运行时，系统一直对所有的对象进行所谓的运行时类型标识，这些标示纪录了每个对象所属的类。<br>虚拟机通常使用运行时类型信息选择正确方法去执行，用来保存这些类型信息的类是Class类。</p>
<p>2、Class类型的对象，是加载类时自动创建的</p>
<p>Class 没有公共构造方法。Class 对象是在加载类时，由Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。</p>
<p>3、虚拟机为每种类型管理一个独一无二的Class对象</p>
<p>每个类（型）都有一个Class对象。<br>运行程序时，Java虚拟机(JVM)首先检查所要加载的类对应的Class对象是否已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。</p>
<p>4、基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也都对应一个 Class 对象。</p>
<p>5、每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。</p>
<p>6、一般某个类的Class对象被载入内存，它就用来创建这个类的所有对象。</p>
<h4 id="✅-结合反射使用举例"><a href="#✅-结合反射使用举例" class="headerlink" title="✅ 结合反射使用举例"></a>✅ 结合反射使用举例</h4><p>对于任何一个类，都能知道这个类所有的属性和方法；对于任何一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。</p>
<p>getMethod()返回某个类的所有公用（public）方法包括其继承类的公用方法，当然也包括它所实现接口的方法。</p>
<p>getDeclaredMethod()对象表示的类或接口声明的所有方法,包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。当然也包括它所实现接口的方法。</p>
<p>一个实体类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.junit.demo;</span><br><span class="line"></span><br><span class="line">public class Book &#123;</span><br><span class="line">    private static final String defName = &quot;《程序猿植发》&quot;;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;我是静态代码块，输出: &quot; + defName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印生产日期：</span><br><span class="line">    public static String printProduceDate(String name) &#123;</span><br><span class="line">        return &quot;我是静态方法printProduceDate，输出: &quot; + name + &quot;, produce is:&quot; + System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Book() &#123;</span><br><span class="line">        System.out.println(&quot;我是Book声明的构造方法！&quot;);</span><br><span class="line">        name = defName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString(String msg) &#123;</span><br><span class="line">        return name + msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line"></span><br><span class="line">    //1-将指定类加载到JVM中（ClassNotFoundException）</span><br><span class="line">    Class aClass = Class.forName(&quot;com.junit.demo.Book&quot;); //加载过程会执行static静态代码块 out：我是静态代码块，输出: 《程序猿植发》</span><br><span class="line">    System.out.println(aClass);  //out:class com.junit.demo.Book</span><br><span class="line"></span><br><span class="line">    //2.1-访问静态方法：NoSuchMethodException，InvocationTargetException</span><br><span class="line">    Method method = aClass.getMethod(&quot;printProduceDate&quot;, String.class);</span><br><span class="line">    String result = (String) method.invoke(aClass, &quot;《程序猿的颈椎自传》&quot;);  </span><br><span class="line">    //反射静态方法 第一个参数是Class对象(也可以传入null？) 第二个参数是输入</span><br><span class="line">    System.out.println(result); //out：我是静态方法printProduceDate，输出: 《程序猿的颈椎自传》, produce is:1626682894095</span><br><span class="line">    System.out.println(&quot;---------------------------\n&quot;);</span><br><span class="line"></span><br><span class="line">    //2.2-初始化对象：</span><br><span class="line">    Book obj = (Book) aClass.newInstance();  //out:我是Book声明的构造方法！</span><br><span class="line">    System.out.println(&quot;得到对象后访问get方法：&quot; + obj.toString(&quot;&quot;));  //out:得到对象后访问get方法：《程序猿植发》</span><br><span class="line">    System.out.println(&quot;---------------------------\n&quot;);</span><br><span class="line"></span><br><span class="line">    //2.3-初始化对象后访问方法：</span><br><span class="line">    Method method3 = aClass.getMethod(&quot;toString&quot;, String.class);</span><br><span class="line">    String result3 = (String) method3.invoke(aClass.newInstance()/*obj*/, &quot;这本书是我的伙伴！&quot;); </span><br><span class="line">    //反射非静态方法，第一个参数是对象，第二个是输入。</span><br><span class="line">    System.out.println(result3); //out：《程序猿植发》这本书是我的伙伴！</span><br><span class="line">    System.out.println(&quot;---------------------------\n&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(Book.class.getName()); //com.junit.demo.Book</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>☝️通过反射方式访问静态方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 由Class获取方法：第一个参数为方法名，第二个参数为方法的参数类型。</span><br><span class="line">Method method = aClass.getMethod(&quot;printProduceDate&quot;, String.class);</span><br><span class="line">// 引用方法：(引用实例/调用静态方法可为null，参数值/有多个用逗号隔开)，参数值要和参数类型的数量匹配！</span><br><span class="line">String result = (String) method.invoke(aClass, &quot;《程序猿的颈椎自传》&quot;);</span><br><span class="line"></span><br><span class="line">简写：</span><br><span class="line">aClass.getMethod(&quot;printProduceDate&quot;, String.class).invoke(null, &quot;《程序猿的颈椎自传》&quot;);</span><br></pre></td></tr></table></figure>

<p>✌️通过反射方式访问实例方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//方法一：直接转化实例化后的对象，直接调用方法</span><br><span class="line">Book book= (Book) aClass.newInstance();</span><br><span class="line">// book.setName(&#x27;xxx&#x27;); or book.getName(); or more...</span><br><span class="line"></span><br><span class="line">//方法二：使用invoke调用指定实例a的指定方法b</span><br><span class="line">Method method3 = aClass.getMethod(&quot;toString&quot;, String.class);</span><br><span class="line">//这里的book可以是已实例化的对象，或者使用 aClass.newInstance() 传入，详见简写：</span><br><span class="line">String result3 = (String) method3.invoke(book, &quot;这本书是我的伙伴！&quot;);</span><br><span class="line"></span><br><span class="line">简写：</span><br><span class="line">aClass.getMethod(&quot;toString&quot;, String.class).invoke(aClass.newInstance(), &quot;xxx&quot;);</span><br></pre></td></tr></table></figure>

<p>值得注意的是，如果是类似于工具类可用于全部类访问的，可以使用一个实例化对象，而不需要每次都newInstance。</p>
<p>另外，方法一适用于需要映射的类是已知或少数时，反之需要统一按指定字符串反射调用方法的话，需使用方法二。</p>
<p>☝️通过反射方式访问私有方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.junit.demo;</span><br><span class="line"></span><br><span class="line">public class Netbar &#123;</span><br><span class="line">    private Double random = Math.random();</span><br><span class="line"></span><br><span class="line">    public Double getRandom() &#123;</span><br><span class="line">        return random;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Netbar createNew() &#123;</span><br><span class="line">        return new Netbar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Netbar getInstance() &#123;</span><br><span class="line">        return new Netbar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Netbar netbar = new Netbar();</span><br><span class="line">        System.out.println(&quot;Random:: &quot; + netbar.getRandom());</span><br><span class="line">        Netbar netbar2 = netbar.createNew();</span><br><span class="line">        System.out.println(&quot;Random2:: &quot; + netbar2.getRandom());</span><br><span class="line">        Netbar netbar3 = Netbar.getInstance();</span><br><span class="line">        System.out.println(&quot;Random3:: &quot; + netbar3.getRandom());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射方式访问私有非静态方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    Class aClass = Class.forName(&quot;com.junit.demo.Netbar&quot;);</span><br><span class="line">    Method method = aClass.getDeclaredMethod(&quot;createNew&quot;);//这里可以带参数</span><br><span class="line">    method.setAccessible(true);//对所有属性设置访问权限  当类中的成员变量为private时 必须设置此项</span><br><span class="line">    Netbar netbar = (Netbar) method.invoke(aClass.newInstance()); //传入对象</span><br><span class="line">    System.out.println(&quot;Random2:: &quot; + netbar.getRandom());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射方式访问私有静态方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    Class aClass = Class.forName(&quot;com.junit.demo.Netbar&quot;);</span><br><span class="line">    Method method = aClass.getDeclaredMethod(&quot;getInstance&quot;);//这里可以带参数</span><br><span class="line">    method.setAccessible(true);//对所有属性设置访问权限  当类中的成员变量为private时 必须设置此项</span><br><span class="line">    Netbar netbar = (Netbar) method.invoke(null);  //静态方法可以传入null</span><br><span class="line">    System.out.println(&quot;Random2:: &quot; + netbar.getRandom());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：Java之Class.forName方法详解：<br><a href="https://blog.csdn.net/qq_26599807/article/details/118900090">https://blog.csdn.net/qq_26599807/article/details/118900090</a></p>
<h3 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h3><p>首先，浅拷贝和深拷贝都是针对一个已有对象的操作。</p>
<p>在 Java 中，除了基本数据类型（元类型）之外，还存在 类的实例对象（引用数据类型）。而一般使用 『 &#x3D; 』号做赋值操作的时候。对于基本数据类型，实际上是拷贝的它的值，但是对于对象而言，其实赋值的只是这个对象的引用，将原对象的引用传递过去，他们实际上还是指向的同一个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() &#123;</span><br><span class="line">    // 1.直接</span><br><span class="line">    Student stu1 = new Student();</span><br><span class="line">    stu1.setNumber(12345);</span><br><span class="line">    Student stu2 = stu1;</span><br><span class="line">    stu2.setNumber(54321);</span><br><span class="line">    System.out.println(&quot;学生1:&quot; + stu1.getNumber());</span><br><span class="line">    System.out.println(&quot;学生2:&quot; + stu2.getNumber());  //改2，1跟着也改了</span><br><span class="line">    //原因出在(stu2 = stu1) 这一句。</span><br><span class="line">    //该语句的作用是将stu1的引用赋值给stu2。其实，stu1和stu2在堆内存中指向的是同一个对象</span><br><span class="line"></span><br><span class="line">    // 2.新建一个，再set</span><br><span class="line">    Student stu3 = new Student();</span><br><span class="line">    stu3.setNumber(stu1.getNumber());</span><br><span class="line">    stu3.setNumber(111);</span><br><span class="line">    System.out.println(&quot;学生1:&quot; + stu1.getNumber());</span><br><span class="line">    System.out.println(&quot;学生3:&quot; + stu3.getNumber());  //改2，1不会跟着也改了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而浅拷贝和深拷贝就是在这个基础之上做的区分，如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象，则认为是浅拷贝。反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是深拷贝。</p>
<p>所谓的浅拷贝和深拷贝，只是在拷贝对象的时候，对 类的实例对象 这种引用数据类型的不同操作而已。</p>
<p>总结来说：</p>
<p>1、浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</p>
<p>2、深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p>
<p>Object 上的 clone() 方法<br>在 Java 中，所有的 Class 都继承自 Object ，而在 Object 上，存在一个 clone() 方法，它被声明为了 protected ，所以我们可以在其子类中，使用它。<br>而无论是浅拷贝还是深拷贝，都需要实现 clone() 方法，来完成操作。</p>
<p>被复制的类需要实现Clonenable接口（不实现的话在调用clone方法会抛出CloneNotSupportedException异常) 该接口为标记接口(不含任何方法)<br>覆盖clone()方法，访问修饰符设为public。方法中调用super.clone()方法得到需要的复制对象（native为本地方法)</p>
<hr>
<p>转自：<a href="https://www.cnblogs.com/hongshi/p/16189920.html">https://www.cnblogs.com/hongshi/p/16189920.html</a></p>
<h4 id="✅浅拷贝"><a href="#✅浅拷贝" class="headerlink" title="✅浅拷贝"></a>✅浅拷贝</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() &#123;</span><br><span class="line">    // 1.浅拷贝</span><br><span class="line">    Student stu1 = new Student();</span><br><span class="line">    stu1.setNumber(1);</span><br><span class="line">    stu1.setName(&quot;ll&quot;);</span><br><span class="line">    stu1.setTeacher(new Teacher(23));</span><br><span class="line">    Student stu2 = (Student)stu1.clone();</span><br><span class="line">    stu2.setNumber(2);</span><br><span class="line">    stu2.setName(&quot;oo&quot;);</span><br><span class="line">    //stu2.setTeacher(new Teacher(24)); //新建不对</span><br><span class="line">    stu2.getTeacher().setAge(24);</span><br><span class="line">    System.out.println(&quot;学生1:&quot; + stu1 + &quot; hashCode:&quot; + stu1.hashCode());</span><br><span class="line">    //ClassTest.Student(number=1, name=ll, teacher=ClassTest.Teacher(age=24)) hashCode:1407343478</span><br><span class="line">    System.out.println(&quot;学生2:&quot; + stu2 + &quot; hashCode:&quot; + stu2.hashCode());</span><br><span class="line">    //ClassTest.Student(number=2, name=oo, teacher=ClassTest.Teacher(age=24)) hashCode:1940447180</span><br><span class="line">    System.out.println(&quot;teacher的hashCode：&quot; + stu1.getTeacher().hashCode() + &quot; &quot; + stu2.getTeacher().hashCode());</span><br><span class="line">    //teacher的hashCode：83 83</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ToString</span><br><span class="line">static class Student implements Cloneable &#123;</span><br><span class="line">    private int number;</span><br><span class="line">    private String name;</span><br><span class="line">    private Teacher teacher;</span><br><span class="line">    public int getNumber() &#123;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setNumber(int number) &#123;</span><br><span class="line">        this.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setTeacher(Teacher teacher) &#123;</span><br><span class="line">        this.teacher = teacher;</span><br><span class="line">    &#125;</span><br><span class="line">    public Teacher getTeacher() &#123;return teacher;&#125;</span><br><span class="line">    //浅拷贝</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            return super.clone();</span><br><span class="line">        &#125;catch(CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">class Teacher &#123;</span><br><span class="line">    private Integer age;</span><br><span class="line">    Teacher(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到里面的Teacher对象，实际上还是指向了同一个对象，只对对它的引用进行了传递。</p>
<p>注意⚠️：String作为不可更改的类（immutable class），在new赋值的时候，就已经创建了一个新的对象；表现出来的是深拷贝（和基本数据类型一样）。</p>
<h4 id="✅深拷贝"><a href="#✅深拷贝" class="headerlink" title="✅深拷贝"></a>✅深拷贝</h4><p>两种方法：<br>1、序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。<br>2、继续利用 clone() 方法，既然 clone() 方法，是我们来重写的，实际上我们可以对其内的引用类型的变量，再进行一次 clone()。也就是让Teacher类也实现Cloneable接口，重写clone方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() &#123;</span><br><span class="line">    // 1.浅拷贝</span><br><span class="line">    Student stu1 = new Student();</span><br><span class="line">    stu1.setNumber(1);</span><br><span class="line">    stu1.setName(&quot;ll&quot;);</span><br><span class="line">    stu1.setTeacher(new Teacher(23));</span><br><span class="line">    Student stu2 = (Student)stu1.clone();</span><br><span class="line">    stu2.setNumber(2);</span><br><span class="line">    stu2.setName(&quot;oo&quot;);</span><br><span class="line">    //stu2.setTeacher(new Teacher(24)); //新建不对</span><br><span class="line">    stu2.getTeacher().setAge(24);</span><br><span class="line">    System.out.println(&quot;学生1:&quot; + stu1 + &quot; hashCode:&quot; + stu1.hashCode());</span><br><span class="line">    System.out.println(&quot;学生2:&quot; + stu2 + &quot; hashCode:&quot; + stu2.hashCode());</span><br><span class="line">    System.out.println(&quot;teacher的hashCode：&quot; + stu1.getTeacher().hashCode() + &quot; &quot; + stu2.getTeacher().hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ToString</span><br><span class="line">static class Student implements Cloneable &#123;</span><br><span class="line">    private int number;</span><br><span class="line">    private String name;</span><br><span class="line">    private Teacher teacher;</span><br><span class="line">    public int getNumber() &#123;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setNumber(int number) &#123;</span><br><span class="line">        this.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setTeacher(Teacher teacher) &#123;</span><br><span class="line">        this.teacher = teacher;</span><br><span class="line">    &#125;</span><br><span class="line">    public Teacher getTeacher() &#123;return teacher;&#125;</span><br><span class="line">//        //浅拷贝</span><br><span class="line">//        @Override</span><br><span class="line">//        public Object clone() &#123;</span><br><span class="line">//            try&#123;</span><br><span class="line">//                return super.clone();</span><br><span class="line">//            &#125;catch(CloneNotSupportedException e) &#123;</span><br><span class="line">//                e.printStackTrace();</span><br><span class="line">//            &#125;</span><br><span class="line">//            return null;</span><br><span class="line">//        &#125;</span><br><span class="line">    //深拷贝</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Student stu = (Student)super.clone();</span><br><span class="line">            stu.setTeacher((Teacher)this.teacher.clone());</span><br><span class="line">            return stu;</span><br><span class="line"></span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">class Teacher implements Cloneable&#123;</span><br><span class="line">    private Integer age;</span><br><span class="line">    Teacher(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            return super.clone();</span><br><span class="line">        &#125;catch(CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BeanUtils-copyProperties"><a href="#BeanUtils-copyProperties" class="headerlink" title="BeanUtils.copyProperties"></a>BeanUtils.copyProperties</h4><p><code>BeanUtils.copyProperties（source,target）</code>有两个参数，用于将事件源的数据拷贝到目标源中。BeanUtils有两个，一个是spring的，一个是apache的commons下的。用法一样，但是两者的区别在于：一个是将前者拷贝给后者，另一个是将后者拷贝给前面的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student studentOne  = new StudentOne(&quot;张三&quot;);</span><br><span class="line">Student studentTwo  = new StudentOne();  //先新建一个要拷贝出来的对象</span><br><span class="line">//BeanUtils.copyProperties是将studentOne的数据拷贝给studentTwo</span><br><span class="line">BeanUtils.copyProperties(studentOne, studentTwo);</span><br><span class="line">//spring的第一个是输入，第二个谁输出</span><br></pre></td></tr></table></figure>

<p>如果两个类不一样时，只会拷贝属性一样的内容。<br>使用场景：开发中经常遇到，把父类的属性拷贝到子类中。<br>BeanUtils是浅拷贝。浅拷贝：引用的一个内存地址)。</p>
<p>通常用于转换器Convertor，用来转换一个类的对象为另一个类的对象，重写里面的convert方法来用。</p>
<h3 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h3><h4 id="hashcode-1"><a href="#hashcode-1" class="headerlink" title="hashcode"></a>hashcode</h4><p>1、hash和hash表是什么？</p>
<blockquote>
<p>hash是一个函数，该函数中的实现就是一种算法，就是通过一系列的算法来得到一个hash值。这个时候，我们就需要知道另一个东西，hash表，通过hash算法得到的hash值就在这张hash表中，也就是说，hash表就是所有的hash值组成的，有很多种hash函数，也就代表着有很多种算法得到hash值。</p>
</blockquote>
<p>2、hashcode　</p>
<blockquote>
<p>hashcode就是通过hash函数得来的，通俗的说，就是通过某一种算法得到的，hashcode就是在hash表中有对应的位置。<br>每个对象都有hashcode，对象的hashcode怎么得来的呢？<br>首先一个对象肯定有物理地址，在别的博文中会hashcode说成是代表对象的地址，这里肯定会让读者形成误区，对象的物理地址跟这个hashcode地址不一样，hashcode代表对象的地址说的是对象在hash表中的位置，物理地址说的对象存放在内存中的地址，那么对象如何得到hashcode呢？<br>通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过hash函数的算法就得到了hashcode。所以，hashcode是什么呢？就是在hash表中对应的位置。</p>
</blockquote>
<blockquote>
<p>这里如果还不是很清楚的话，举个例子，hash表中有 hashcode为1、hashcode为2、(…)3、4、5、6、7、8这样八个位置，有一个对象A，A的物理地址转换为一个整数17(这是假如)，就通过直接取余算法，17%8&#x3D;1，那么A的hashcode就为1，且A就在hash表中1的位置。</p>
</blockquote>
<p>3、hashcode有什么作用</p>
<blockquote>
<p>为什么hashcode不直接写物理地址呢，还要另外用一张hash表来代表对象的地址？<br>HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的(后半句说的用hashcode来代表对象就是在hash表中的位置)<br>为什么hashcode就查找的更快，比如：我们有一个能存放1000个数这样大的内存中，在其中要存放1000个不一样的数字，用最笨的方法，就是存一个数字，就遍历一遍，看有没有相同得数，当存了900个数字，开始存901个数字的时候，就需要跟900个数字进行对比，这样就很麻烦，很是消耗时间，用hashcode来记录对象的位置，来看一下。<br>hash表中有1、2、3、4、5、6、7、8个位置，存第一个数，hashcode为1，该数就放在hash表中1的位置，存到100个数字，hash表中8个位置会有很多数字了，1中可能有20个数字，存101个数字时，他先查hashcode值对应的位置，假设为1，那么就有20个数字和他的hashcode相同，他只需要跟这20个数字相比较(equals)，如果没一个相同，那么就放在1这个位置，这样比较的次数就少了很多，实际上hash表中有很多位置，这里只是举例只有8个，所以比较的次数会让你觉得也挺多的，实际上，如果hash表很大，那么比较的次数就很少很少了。<br>通过对原始方法和使用hashcode方法进行对比，我们就知道了hashcode的作用，并且为什么要使用hashcode了</p>
</blockquote>
<p>4、equals方法和hashcode的关系</p>
<blockquote>
<p>通过前面这个例子，大概可以知道，先通过hashcode来比较，如果hashcode相等，那么就用equals方法来比较两个对象是否相等。</p>
</blockquote>
<blockquote>
<p>用个例子说明：上面说的hash表中的8个位置，就好比8个桶，每个桶里能装很多的对象，对象A通过hash函数算法得到将它放到1号桶中，当然肯定有别的对象也会放到1号桶中，如果对象B也通过算法分到了1号桶，那么它如何识别桶中其他对象是否和它一样呢，这时候就需要equals方法来进行筛选了。</p>
</blockquote>
<blockquote>
<p>1、如果两个对象equals相等，那么这两个对象的HashCode一定也相同<br>2、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置</p>
</blockquote>
<p>5、为什么equals方法重写的话，建议也一起重写hashcode方法</p>
<blockquote>
<p>比如：有个A类重写了equals方法，但是没有重写hashCode方法，看输出结果，对象a1和对象a2使用equals方法相等，按照上面的hashcode的用法，那么他们两个的hashcode肯定相等，但是这里由于没重写hashcode方法，他们两个hashcode并不一样，所以，我们在重写了equals方法后，尽量也重写了hashcode方法，通过一定的算法，使他们在equals相等时，也会有相同的hashcode值。</p>
</blockquote>
<p>Integer的重写方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    if (obj instanceof Integer) &#123;</span><br><span class="line">        return value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;  // 变成比较Integer内部的final int常量的值是否相等</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//hashCode方法也是用的值</span><br><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    return Integer.hashCode(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int hashCode(int value) &#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hashCode是用于查找使用的，而 equals是用于比较两个对象的是否相等的。hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的.</p>
<p>如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致.</p>
<p>————————————————<br>原文链接：<a href="https://blog.csdn.net/weixin_44364444/article/details/120054230">https://blog.csdn.net/weixin_44364444/article/details/120054230</a></p>
<h4 id="java变量地址"><a href="#java变量地址" class="headerlink" title="java变量地址"></a>java变量地址</h4><p>java的变量不能直接获取真实的地址，只能使用<code>System.out.println(obj.hashcode())</code>输出的时对象的哈希码，而非内存地址。</p>
<p>在Java中是不可能得到对象真正的内存地址的，因为Java中堆是由JVM管理的不能直接操作。只能说此时打印出的Hash码表示了该对象在JAVA虚拟机中的内存位置，Java虚拟机会根据该hash码最终在真正的的堆空间中给该对象分配一个地址.</p>
<p>要想得到变量在物理内存中的真实地存，那只有用JNI技术调用c&#x2F;c++去实现，否则无能为力，因为java超不出JVM，而JVM对物理内存地址是“不可见”的，否则java中不就有了指针，而去直接操作内存了，当然这是与java语言相违背的。</p>
<p>转自：<a href="https://blog.csdn.net/feng3702592/article/details/126722686">https://blog.csdn.net/feng3702592/article/details/126722686</a></p>
<h4 id="、equals、hashCode"><a href="#、equals、hashCode" class="headerlink" title="&#x3D;&#x3D;、equals、hashCode"></a>&#x3D;&#x3D;、equals、hashCode</h4><p>1、&#x3D;&#x3D;对于普通变量是值比较，对于包装类型变量，是内存地址比较，也就是比较是不是同一个对象。</p>
<p>2、包装类型重写了equals方法，变成了值比较。</p>
<p>3、hashCode表示在hash表中的位置。equals一样，那么hashCode一定一样。（只要值是一样的，hashCode就会是相同的。）<br>原因：尽管不同的数值类型的包装类，计算hashCode的算法不一样，但是底层都是拿对应的原始数据类型的值去进行hashCode计算。<br>反过来：</p>
<p>4、同一个对象的，hashCode值一定相同，但是 hashCode相同，不一定是同一个对象，也不一定equals为true。</p>
<p>关系：同一个对象（&#x3D;&#x3D;）最小的圈，equals为true中间圈，hashCode一样最大圈。<code>（equals要看重写了没有，不重写就是==）</code></p>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-24 00:45</span><br><span class="line"> **/</span><br><span class="line">/**</span><br><span class="line"> *hashCode相同，不一定是同一个对象</span><br><span class="line"> *同一个对象的，hashCode值一定相同</span><br><span class="line"> *</span><br><span class="line"> *-------------------------------------------------------------------------------</span><br><span class="line"> *普通对象的HashCode值源码解释：</span><br><span class="line"> * equals相同则hashCode一定一样</span><br><span class="line"> *If two objects are equal according to the equals(Object) method, then calling</span><br><span class="line"> *the hashCode method on each of the two objects must produce the same integer result.</span><br><span class="line"> *-------------------------------------------------------------------------------</span><br><span class="line"> *equals不一样，hashCode不一定不一样</span><br><span class="line"> * It is not required that if two objects are unequal according to the</span><br><span class="line"> *java.lang.Object.equals(java.lang.Object) method, then calling the hashCode</span><br><span class="line"> *method on each of the two objects must produce distinct integer results.</span><br><span class="line"> *-------------------------------------------------------------------------------</span><br><span class="line"> *However, the programmer should be aware that producing distinct integer results</span><br><span class="line"> *for unequal objects may improve the performance of hash tables.</span><br><span class="line"> *-------------------------------------------------------------------------------</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class HashCodeTest &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HashCodeTest() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HashCodeTest(String name) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;--------------------普通对象-----------------------&quot;);</span><br><span class="line">        HashCodeTest test3=new HashCodeTest();</span><br><span class="line">        HashCodeTest test4=new HashCodeTest();</span><br><span class="line">        System.out.println(test3.equals(test4));//false(因为没重写还是==)</span><br><span class="line">        System.out.println(test3.hashCode() == test4.hashCode());//false</span><br><span class="line"></span><br><span class="line">        HashCodeTest test1=new HashCodeTest(&quot;我&quot;);</span><br><span class="line">        HashCodeTest test2=new HashCodeTest(&quot;我&quot;);</span><br><span class="line">        System.out.println(test1.equals(test2));//false(因为没重写还是==)</span><br><span class="line">        System.out.println(test1.hashCode() == test2.hashCode());//false</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------------------String-----------------------&quot;);</span><br><span class="line">        String s1=&quot;abc&quot;;</span><br><span class="line">        String s2=&quot;abc&quot;;</span><br><span class="line">        System.out.println(s1.equals(s2));//true(因为重写变值比较)</span><br><span class="line">        System.out.println(s1.hashCode() == s2.hashCode());//true</span><br><span class="line">        System.out.println(s1==s2); //true(是一个对象)</span><br><span class="line"></span><br><span class="line">        String s5=new String(&quot;abc&quot;);</span><br><span class="line">        String s6=new String(&quot;abc&quot;);</span><br><span class="line">        System.out.println(s5.equals(s6));//true(因为重写变值比较)</span><br><span class="line">        System.out.println(s5.hashCode() == s6.hashCode());//true</span><br><span class="line">        System.out.println(s5==s6); //false(不是一个对象)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String s3=new String();</span><br><span class="line">        String s4=new String();</span><br><span class="line">        System.out.println(s3.hashCode());//0</span><br><span class="line">        System.out.println(s4.hashCode());//0</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 数值型原始类型对应的包装类(Byte,Short,Integer,Float,Double)，hashCode算法都是基于</span><br><span class="line">         * 对应的原始数据类型，所以只要包装类的数值相同，那么hashCode必然相同</span><br><span class="line">         *</span><br><span class="line">         * Double类关于hashCode源码说明：</span><br><span class="line">         * Double类的hashCode是根据对应的double值计算获得的。</span><br><span class="line">         *</span><br><span class="line">         * Returns a hash code for a &#123;@code double&#125; value; compatible with</span><br><span class="line">         * &#123;@code Double.hashCode()&#125;.</span><br><span class="line">         *</span><br><span class="line">         * @param value the value to hash</span><br><span class="line">         * @return a hash code value for a &#123;@code double&#125; value.</span><br><span class="line">         * @since 1.8</span><br><span class="line">         */</span><br><span class="line">        /*Double类关于hashCode源码：</span><br><span class="line">         * public static int hashCode(double value) &#123;</span><br><span class="line">            long bits = doubleToLongBits(value);</span><br><span class="line">            return (int)(bits ^ (bits &gt;&gt;&gt; 32));</span><br><span class="line">        &#125;*/</span><br><span class="line">        System.out.println(&quot;--------------------原始类型对应的包装类-----------------------&quot;);</span><br><span class="line">        Double d1=5.0;</span><br><span class="line">        Double d2=5.0;</span><br><span class="line">        System.out.println(d1.equals(d2));//true(因为重写变值比较)</span><br><span class="line">        System.out.println(d1.hashCode() == d2.hashCode());//true</span><br><span class="line">        System.out.println(d1==d2);//false (？？？为啥是false，和String不一样)</span><br><span class="line"></span><br><span class="line">        Double d3=new Double(5.0);</span><br><span class="line">        Double d4=new Double(5.0);</span><br><span class="line">        System.out.println(d3.equals(d4));//true(因为重写变值比较)</span><br><span class="line">        System.out.println(d3.hashCode() == d4.hashCode());//true</span><br><span class="line">        System.out.println(d3==d4);//false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未解：<code>Double d1=5.0; Double d2=5.0</code> 不是共用一个对象。但是<code>String s1=&quot;1&quot;; String s2=&quot;1&quot;</code>是共用。</p>
<h3 id="java异常"><a href="#java异常" class="headerlink" title="java异常"></a>java异常</h3><p>背景：代码中需要捕获到专门的异常进行特殊处理，主要是为了不影响主流程，该用try…catch，是在调用的时候catch，还是在调用方法里catch？<br>🤔如果是只想在这次调用时补货异常就在调用处使用，如果是想把方法包装好随意调用不发生异常就在方法里捕获。作用是：发生异常了不中断流程，只是打个error log之类的。如果不加，就是自动抛出throws异常了。</p>
<p>背景：里面方法的异常，外面方法能不能catch到？里面方法也catch了，外面方法还能不能catch到？<br>🤔里面方法没有catch异常的话，外面方法是能捕获到的，并且运行时异常不用在里面的方法上加throws，外面方法就能捕获到。编译时异常必须做：catch住处理或者throw + throws，或者直接throws出去，这样才能在外面方法捕获到。如果里面方法捕获了异常，但是没throw出去（运行时异常throw了不需要throws，编译时异常throw了还需要throws），外面方法就捕获不到这个异常。</p>
<p>背景：什么时候需要在方法上throws异常，一定要throws吗？<br>🤔运行时异常，可以不在方法上throws，虚拟机会自动捕获抛出去。编译时异常通常在编译时就要求throws出去异常，或者用try…catch进行异常处理（打log之类）。</p>
<p>背景：什么时候需要try..catch..throw..throws<br>🤔首先运行时异常可以不throws，如果没有try..catch，会自动throws出去，所以如果不是try..catch..对特殊异常捕获，没必要try..catch..throws。编译型异常如果是try..catch..打log了，就不用throws了。如果想抛出去，就直接throws就行。所以不需要try..catch..throw..throws。如果即想用try..catch..finally..还想throws出去，就用。</p>
<h4 id="✅java的异常体系"><a href="#✅java的异常体系" class="headerlink" title="✅java的异常体系"></a>✅java的异常体系</h4><p>首先Exception和Error都是继承于Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p>
<p><img src="/images/java%E5%BC%82%E5%B8%B8.png"></p>
<p>Error是编译时错误和系统错误，系统错误在除特殊情况下，都不需要你来关心，基本不会出现。而编译时错误，如果你使用了编译器，那么编译器会提示。</p>
<p>Exception则是可以被抛出的基本类型，我们需要主要关心的也是这个类。<br>Exception又分为RunTimeException和其他Exception。</p>
<p>RunTimeException：运行时异常，又称不受检查异常，不受检查，因为不受检查，所以在代码中可能会有RunTimeException时Java编译检查时不会告诉你有这个异常，但是在实际运行代码时则会暴露出来，比如经典的1&#x2F;0，空指针等。如果不处理也会被Java自己处理。</p>
<p>其他Exception，受检查异常，编译时异常。可以理解为错误，必须要开发者解决以后才能编译通过，解决的方法有两种，<br>1：throw到上层，<br>2，try-catch处理。</p>
<hr>
<p>Error是java程序运行中不可预料的异常情况（正常情况下不大可能出现的情况），这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。所以这种异常不可能抓取到，比如OutOfMemoryError、NoClassDefFoundError等。【表示由JVM所侦测到的无法预期的错误，由于这是属于JVM层次的严重错误 ，导致JVM无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。 Error类体系描述了Java运行系统中的内部错误以及资源耗尽的情形.应用程序不应该抛出这种类型的对象(一般是由虚拟机抛出).假如出现这种错误,除了尽力使程序安全退出外,在其他方面是无能为力的。】</p>
<p>Exception：<br>1．可以是可被控制(checked) 或不可控制的(unchecked)。<br>2．表示一个由程序员导致的错误。<br>3．应该在应用程序级被处理。<br>Error：<br>1．总是不可控制的(unchecked)。<br>2．经常用来用于表示系统错误或低层资源的错误。<br>3．如何可能的话，应该在系统级被捕捉。</p>
<hr>
<h4 id="✅常见的-Error-和-Exception："><a href="#✅常见的-Error-和-Exception：" class="headerlink" title="✅常见的 Error 和 Exception："></a>✅常见的 Error 和 Exception：</h4><p>1）运行时异常（RuntimeException）也称 【非检查型异常 UncheckedException】：</p>
<p>Nullpointer Exception：空指针异常；<br>ClassCastException：类型强制转换异常<br>IllegalArgumentException：传递非法参数异常<br>IndexOutOfBoundsException：下标越界异常<br>NumberFormatException：数字格式异常<br>ArrayIndexOutOfBoundsException: 数组越界异常<br>ArrayStoreException: 数据存储异常，操作数组时类型不一致<br>ArithmeticException： (算术异常)<br>BufferOverflowException： (缓冲区溢出异常)</p>
<p>2）非运行时异常（CheckedException）也称 【检查型异常】：</p>
<p>ClassNotFoundException：找不到指定 class 的异常<br>IOException：IO 操作异常<br>FileNotFoundException：文件不存在异常<br>SQLException：SQL语句异常<br>InterruptedException： (中断异常-调用线程睡眠时候)</p>
<p>3）错误（Error）：</p>
<p>NoClassDefFoundError：找不到 class 定义异常<br>StackOverflowError：深递归导致栈被耗尽而抛出的异常<br>OutOfMemoryError：内存溢出异常</p>
<h4 id="✅遇到的异常记录"><a href="#✅遇到的异常记录" class="headerlink" title="✅遇到的异常记录"></a>✅遇到的异常记录</h4><h4 id="ExecutionException"><a href="#ExecutionException" class="headerlink" title="ExecutionException"></a>ExecutionException</h4><p>future.get()抛出的，ExecutionException包装正在执行的线程抛出的任何异常。没明白，应该是个检查型异常。是必须要程序员处理的。</p>
<p><a href="https://www.orcode.com/question/618888_kb0916.html">https://www.orcode.com/question/618888_kb0916.html</a><br><a href="https://www.mianshigee.com/question/91669mas/">https://www.mianshigee.com/question/91669mas/</a></p>
<h4 id="InterruptException"><a href="#InterruptException" class="headerlink" title="InterruptException"></a>InterruptException</h4><p>future.get()会抛出，Thread.sleep也会抛出。<br>当线程正在等待、休眠或以其他方式被占用，并且线程在活动之前或活动期间被中断时抛出。 有时，方法可能希望测试当前线程是否被中断，如果是，则立即抛出此异常。<br>活动线程的执行中断行为，可以抛出这样的异常。<br><a href="https://blog.csdn.net/kevinmeanscool/article/details/123566970">https://blog.csdn.net/kevinmeanscool/article/details/123566970</a></p>
<h4 id="java-lang-NoClassDefFoundError"><a href="#java-lang-NoClassDefFoundError" class="headerlink" title="java.lang.NoClassDefFoundError"></a>java.lang.NoClassDefFoundError</h4><p>NoClassDefFoundError可能出现的情况<br>目前有发现几种情况<br>1.一种情况就是因为静态变量加载不到原因<br>2.工程里没有将jar添加到classpath，maven项目的，需要根据项目情况排查</p>
<p>实际原因：在报错的test类所在的包里，没有引某个包，导致找不到某类。<br>首先用：<code>mvn dependency:tree</code>，查看依赖jar的关系，看一下这个类的包是哪个，引用了没。<br>发现在父pom里有这个包，但是在报错的包里没有用父pom，也没引那个包。<br>所以，在报错的包的pom里，引用那个包就解决。</p>
<h4 id="NoUniqueBeanDefinitionException"><a href="#NoUniqueBeanDefinitionException" class="headerlink" title="NoUniqueBeanDefinitionException"></a>NoUniqueBeanDefinitionException</h4><p>不唯一的bean定义异常<br>没有一个合适的bean类型（cn.cy.bean.Tool）可用，预期有一个单独的匹配的bean，但是找到了多个。</p>
<p>看看是不是一个接口有多个实现类，然后在某类中注入该接口中没有指定注入哪个。</p>
<blockquote>
<p>通常如果一个接口多个实现类，会根据条件Enum选择哪个类执行的话，加一个ServiceFacade类来根据条件选择，这个类实现Service接口和InitializingBean接口，里面定义一个map&lt;Enum, 接口Service&gt;，在使用到实现类的方法中，注入ServiceFacade就行。</p>
</blockquote>
<p>解决方法：<br>1、注入接口的地方 <code>@Autowired + @Qualifer(&quot;whichImpl&quot;)</code><br>2、注入接口的地方 <code>@Resource(name=&quot;whichImpl&quot;)</code></p>
<p>参考：<a href="https://blog.csdn.net/weixin_46030002/article/details/125661107">https://blog.csdn.net/weixin_46030002/article/details/125661107</a></p>
<h4 id="BeanCreationException"><a href="#BeanCreationException" class="headerlink" title="BeanCreationException"></a>BeanCreationException</h4><p>Bean创建过程中抛出异常。具体有以下几种常见异常，包括上面的NoUniqueBeanDefinitionException 也是一种。</p>
<p>1.org.springframework.beans.factory.NoSuchBeanDefinitionException</p>
<p>上下文中不存在此Bean，一般原因在没有声明Bean，BeanA尝试注入BeanB，但是spring上下文中不存在BeanB。检查是否用@Component @Service @Controller @Repository 注入了bean。</p>
<p>2.org.springframework.beans.factory.NoUniqueBeanDefinitionException</p>
<p>当一个Bean有多个实现，例如BeanB1 和BeanB2都实现了同一个接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class BeanB1 implements IBeanB &#123; ... &#125;</span><br><span class="line">@Component</span><br><span class="line">public class BeanB2 implements IBeanB &#123; ... &#125;</span><br><span class="line"> </span><br><span class="line">@Component</span><br><span class="line">public class BeanA &#123;</span><br><span class="line"> </span><br><span class="line">    @Autowired</span><br><span class="line">    private IBeanB dependency;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.org.springframework.beans.BeanInstantiationException</p>
<p>Bean 实例化过程中出现异常，具体原因需要查看nested exception后面报错</p>
<p>3.1 Custom Exception<br>业务自定义抛出异常，如下抛出空指针异常</p>
<p>3.2 java.lang.InstantiationException<br>在xml配置中使用抽象类定义bean</p>
<p>3.3 java.lang.NoSuchMethodException<br>如果一个bean类没有默认的构造方法，spring在创建bean实例时.</p>
<p>4.org.springframework.beans.factory.CannotLoadBeanClassException</p>
<p>当spring加载不到bean对应的类文件时，这种异常将会被抛出。这种情况很有可能发生在当配置文件中的类路径全称找不到对应文件时。</p>
<p>更多：<a href="https://blog.csdn.net/m0_37578675/article/details/117075030">https://blog.csdn.net/m0_37578675/article/details/117075030</a></p>
<hr>
<h4 id="✅NoClassDefFoundError-和-ClassNotFoundException-的区别："><a href="#✅NoClassDefFoundError-和-ClassNotFoundException-的区别：" class="headerlink" title="✅NoClassDefFoundError 和 ClassNotFoundException 的区别："></a>✅NoClassDefFoundError 和 ClassNotFoundException 的区别：</h4><p>区别一：<br>NoClassDefFoundError它是Error，<br>ClassNotFoundException是Exception。</p>
<p>区别二：<br>NoClassDefFoundError是JVM运行时通过classpath加载类时，找不到对应的类而抛出的错误。<br>ClassNotFoundException是编译时异常，在编译过程中必须将ClassNotFoundException异常抛出！</p>
<p>NoClassDefFoundError发生场景如下：<br>1、类依赖的class或者jar不存在 （简单说就是maven生成运行包后被篡改）<br>2、类文件存在，但是存在不同的域中 （简单说就是引入的类不在对应的包下)<br>3、大小写问题，javac编译的时候是无视大小的，很有可能你编译出来的class文件就与想要的不一样！这个没有做验证？？？</p>
<p>ClassNotFoundException发生场景如下：<br>1、调用class的forName方法时，找不到指定的类<br>2、ClassLoader 中的 findSystemClass() 方法时，找不到指定的类<br>举例说明如下:<br>Class.forName(“abc”); 比如abc这个类不存项目中，代码编写时，就会提示此异常是检查性异常，比如将此异常抛出。</p>
<hr>
<h4 id="✅运行时异常（Runtime-exception-与检查型异常（checked-exception）的区别："><a href="#✅运行时异常（Runtime-exception-与检查型异常（checked-exception）的区别：" class="headerlink" title="✅运行时异常（Runtime exception)与检查型异常（checked exception）的区别："></a>✅运行时异常（Runtime exception)与检查型异常（checked exception）的区别：</h4><p>1:checked （检查型异常）也就是我们经常遇到的IO异常，以及SQL异常都是这种异常。编译器要检查这类异常，检查的目的一方面是因为该类异常的发生难以避免，<br>另一方面就是让开发者去解决掉这类异常，所以称为必须处理（try …catch）的异常。如果不处理这类异常，集成开发环境中的编译器一般会给出错误提示。</p>
<p>如果一个方法没有捕获一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法名的后边，eg:  方法名（） throws  IOExecption。</p>
<p>理解：检查型异常，要么：try… catch.. 打log，要么：try..catch..throw..throws（多此一举，没必要），要么只是throws。</p>
<p>2:runtime exception（运行时异常），编译器不会检查这类异常，不检查的则开发者在代码的编辑编译阶段就不是必须处理，这类异常一般可以避免，因此无需处理（try …catch）,会直接throws出去，如果不想throws出去，就try catch 打log。<br>如果不处理这类异常，集成开发环境中的编译器也不会给出错误提示。  当出现这样的异常时，总是由虚拟机接管。</p>
<p>原文：<a href="https://www.cnblogs.com/liangbaolong/p/12884224.html">https://www.cnblogs.com/liangbaolong/p/12884224.html</a></p>
<hr>
<h4 id="✅多异常捕获："><a href="#✅多异常捕获：" class="headerlink" title="✅多异常捕获："></a>✅多异常捕获：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#125; catch(NullPointerException | IOException e) &#123;</span><br><span class="line">    //log.error(e);</span><br><span class="line"></span><br><span class="line">&#125; catch(Exception e) &#123;</span><br><span class="line">    //log.error(e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>| 符合 可以 写多个，符合其中之一。<br>注意要把异常范围小的放在前面，范围大的放在后面。<br>⚠️注意在try内return或者break了，finally也会执行的。</p>
<h4 id="catch-Exeception-e-和catch-Throwable-e"><a href="#catch-Exeception-e-和catch-Throwable-e" class="headerlink" title="catch(Exeception e)和catch(Throwable e)"></a>catch(Exeception e)和catch(Throwable e)</h4><p>Throwable可以捕获Error和Exception两大类的异常，其中Error是比较严重不可控的异常。而Exception是可以被编程处理的异常。<br>Exception只能捕获RuntimeException和IOException。</p>
<p>回顾一下java的异常体系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Throwable: Java中所有异常和错误类的父类。只有这个类的实例（或者子类的实例）可以被虚拟机抛出或者被java的throw关键字抛出。同样，只有其或其子类可以出现在catch子句里面。</span><br><span class="line">Error: Throwable的子类，表示严重的问题发生了，而且这种错误是不可恢复的。</span><br><span class="line">Exception: Throwable的子类，应用程序应该要捕获其或其子类（RuntimeException例外），称为checked exception。比如：IOException, NoSuchMethodException...</span><br><span class="line">RuntimeException: Exception的子类，运行时异常，程序可以不捕获，称为unchecked exception。比如：NullPointException.</span><br></pre></td></tr></table></figure>

<p>❓应该catch (Throwable th) 还是 catch (Exception)?</p>
<p>这两种处理的区别在于，catch throwable会把Error和其他继承Throwable的类捕捉到。而catch Exception只会捕捉Exception极其子类，捕捉的范围更小。第一种catch相当于比第二种catch多捕捉了把Error和其子类。</p>
<p>❓Error是否需要捕捉?</p>
<p>JDK中Error类的的注释里提到过，Error是一种严重的问题，应用程序不应该捕捉它。<br>Error继承自Throwable而不是继承自Exception，是为了方便程序可以使用 “catch (Exception)”来捕捉异常而不会把Error也捕捉在内，因为Exception发生后可以进行一些恢复工作的，但是Error发生后一般是不可恢复的。</p>
<p>❓Error可以catch吗？ 可以catch了后做些其他处理吗？</p>
<p>Error是可以catch的，而且也可以向常规Exception一样被处理，而且就算不捕捉的话也只是导致当前线程挂掉，其他线程还是可以正常运行，如果有需要的话捕捉Error之后也可以做些其他处理。但是Error是一种系统内部的错误，这种错误不像Exception一样是可能是程序和业务上的错误是可以恢复的。</p>
<p>假设进行网络连接操作的时候，IOException 发生了，可能是网络中断，我可以再尝试几次。</p>
<p>假设OutOfMemoryError发生了，就算被捕捉了，可以有什么手段让程序正常运行下去吗？ 假设ExceptionInInitializerError发生了，类无法被正常初始化，这个是可以通过捕捉来恢复的吗？</p>
<p>👌结论：Java本身设计思路就是希望大家catch Exception就足够了，如果有Error发生，catch了也不会有什么作用</p>
<p>转自：如何处理异常? catch Exception OR catch Throwable<br><a href="https://www.cnblogs.com/smile361/p/5521278.html">https://www.cnblogs.com/smile361/p/5521278.html</a></p>
<p>举一个用<code>catch (Throwable e)</code>的例子：<br>目的是确保异常被打印，一个无线递归，导致的StackOverflowError</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Throwable_demo &#123;</span><br><span class="line">    static void generate_throwable() &#123;</span><br><span class="line">        generate_throwable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //此种情形下我们要catch Throwable, 以确保异常被打印...</span><br><span class="line">        try &#123;</span><br><span class="line">            final int[] times = &#123; 0 &#125;;</span><br><span class="line">            Thread thread1 = new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    while (true) &#123;</span><br><span class="line">                        ++times[0];</span><br><span class="line">                        System.out.println(times[0]);</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Thread.sleep(10);</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread1.start();</span><br><span class="line">            generate_throwable();</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            //若catch的是Exception：</span><br><span class="line">            //因finally中的exit指令，在打印异常前程序就会终止。</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;end.&quot;);</span><br><span class="line">            //如果不exit: 因 thread1 未停止，程序不会终止。</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅项目中的自定义异常"><a href="#✅项目中的自定义异常" class="headerlink" title="✅项目中的自定义异常"></a>✅项目中的自定义异常</h4><p>继承RuntimeException扩展一个新的异常作为整个类库的异常基类。<br>里面定义异常编码啥的。</p>
<p>如果需要根据异常进行不同的处理，建议给自定义异常增加一个ERROR_CODE字段，这样无论在服务器还是客户端都可以根据不同的ERROR_CODE进行对应的处理。但是出现这种情况的时候，应该需要考虑一下设计思路了，一般来讲根据异常来决定业务流程不是一个好的设计方案。</p>
<h4 id="✅e-getMeasage-和e-toString"><a href="#✅e-getMeasage-和e-toString" class="headerlink" title="✅e.getMeasage()和e.toString()"></a>✅e.getMeasage()和e.toString()</h4><p>e.getMeasage()返回异常的简短描述信息，是一个字符串。<br>e.toString()返回异常的详细信息，包括异常类型和异常消息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空指针：</span><br><span class="line">message:null</span><br><span class="line">toString:java.lang.NullPointerException</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList线程安全问题"><a href="#ArrayList线程安全问题" class="headerlink" title="ArrayList线程安全问题"></a>ArrayList线程安全问题</h3><p>ArrayList 是线程不安全的集合类，当多线程环境下，并发对同一个ArrayList执行add，可能会丢数据。如果多线程又是add，又是输出list，会发生并发错误。</p>
<p>⚠️为什么说可能呢，因为有时候add得太快，就没出问题。</p>
<blockquote>
<p>ConcurrentModificationException: 并发修改异常<br>使用迭代器循环，在循环中用ArrayList的add&#x2F;remove方法会出现该异常。原因及解决方法：<a href="https://blog.csdn.net/u013168615/article/details/116570591">https://blog.csdn.net/u013168615/article/details/116570591</a></p>
</blockquote>
<hr>
<p>多线程对List进行add又遍历：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() throws InterruptedException &#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i = 1; i &lt;= 30; i++)&#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(0, 8));</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread.sleep(60 * 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常：Exception in thread “Thread-0” java.util.ConcurrentModificationException</p>
<h4 id="✅ArrayList为什么线程不安全"><a href="#✅ArrayList为什么线程不安全" class="headerlink" title="✅ArrayList为什么线程不安全"></a>✅ArrayList为什么线程不安全</h4><p>多线程对ArrayList进行add有可能会造成数据丢失。也有可能会造成数组越界。</p>
<blockquote>
<p>线程安全：指当多线程访问时，采用了加锁的机制；即当一个线程访问该类的某个数据时，会对这个数据进行保护，其他线程不能对其访问，直到该线程读取完之后，其他线程才可以使用。防止出现数据不一致或者数据被污染等意外情况。</p>
<p>线程不安全：就是不提供数据访问时的数据保护，多个线程能够同时操作某个数据，从而出现数据不一致或者数据污染等意外情况。</p>
</blockquote>
<p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line"> implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 列表元素集合数组如果新建ArrayList对象时没有指定大小，那么会将 </span><br><span class="line">    * EMPTY_ELEMENTDATA赋值给elementData，</span><br><span class="line">    * 并在第一次添加元素时，将列表容量设置为DEFAULT_CAPACITY </span><br><span class="line">    */</span><br><span class="line">    transient Object[] elementData; </span><br><span class="line">    // 列表大小，elementData中存储的元素个数</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1); // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList 的实现主要就是：<br>1️⃣用了一个 Object 的数组，用来保存所有的元素；<br>2️⃣一个 size 变量用来保存当前数组中已经添加了多少元素。</p>
<p>ensureCapacityInternal() 的作用就是如果将当前的新元素加到列表后面，判断列表的 elementData 数组的大小是否满足。如果 size + 1 的这个需求长度大于 elementData 这个数组的长度，那么就要对这个数组进行扩容。由此看到 add 元素时，实际有两个大的步骤：<br>1️⃣判断 elementData 数组 capacity 容量是否满足需求，是否需要扩容。<br>2️⃣在 elementData 对应位置上设置值。<br><code>这样就出现了第一个导致线程不安全的隐患，在多个线程进行 add 操作时可能会导致 elementData 数组越界。</code></p>
<hr>
<p>为什么会数组越界ArrayIndexOutOfBoundsException？</p>
<p>ArrayList 默认数组大小为 10。假设现在已经添加进去 9 个元素了，size &#x3D; 9。</p>
<p>1、线程 A 执行完 add 方法中的 ensureCapacityInternal(size+1) 挂起了。<br>2、线程 B 开始执行，校验数组容量发现不需要扩容。于是把 “b” 放在了下标为 9 的位置，且 size 自增 1。此时 size &#x3D; 10。<br>3、线程 A 接着执行，尝试把 “a” 放在下标为 10 的位置，因为 size &#x3D; 10。但因为数组还没有扩容，最大的下标才为 9，所以会抛出数组越界异常ArrayIndexOutOfBoundsException。</p>
<hr>
<p>为什么会数据丢失？</p>
<p>ArrayList线程不安全，当一条线程执行list.add()的时候会出现被另一条线程的值覆盖，比如线程A对list进行add，携带的size是n，同时线程B也进行add操作，携带的size也是n，所以ArrayList没有达到扩容的条件，A的值应该放在ArrayList的第n位，但是B的值也将放在第n位，覆盖了A的值，导致数据丢失。</p>
<p>源码：<br>第二步 elementData[size++] &#x3D; e 设置值的操作同样会导致线程不安全。从这里可以看出，这步操作也不是一个原子操作，它由如下两步操作构成：<br>elementData[size] &#x3D; e;<br>size &#x3D; size + 1;</p>
<p>ArrayList 为什么线程不安全：<br><a href="https://blog.csdn.net/ChineseSoftware/article/details/117047757">https://blog.csdn.net/ChineseSoftware/article/details/117047757</a></p>
<hr>
<p>ArrayList的所有方法都没有加Lock，也没有加synchronized，因此在并发操作下，扩容函数grow()会存在问题。</p>
<p>举个简单的例子：<br>elementData数组刚刚添加了最后一个元素，也就是刚好满员了<br>这时2个线程同时又调用了add，那么就必须要执行grow进行扩容<br>第1个线程调用完grow()，然后也调用了elementData[size++] &#x3D; e，把新元素添加上去<br>第2个线程又调用一次grow()，整个elementData数组就乱掉了。</p>
<h4 id="✅多线程情况下该用什么："><a href="#✅多线程情况下该用什么：" class="headerlink" title="✅多线程情况下该用什么："></a>✅多线程情况下该用什么：</h4><p>1、使用 Vector 初始化 list 对象，效率低<br><code>List&lt;String&gt; list = new Vector&lt;&gt;();</code><br>Vector.add使用了synchronized加锁<br>转换成ArrayList：<br><code>List&lt;String&gt; newList = new ArrayList&lt;String&gt;(vector);</code></p>
<p>2、使用 Collections.synchronizedList<br><code>List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</code><br><code>List&lt;String&gt; list = Collections.synchronizedList(Lists.newArrayList());</code><br>add方法同样加了 synchronized 锁。</p>
<p>3、使用 CopyOnWriteArrayList<br><code>List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</code></p>
<p>写时复制，即向一个容器添加元素的时候，不直接向当前容器添加，而是将当前容器进行复制，然后向新容器进行添加操作，最后将原容器的引用指向新的容器。</p>
<p>这样的好处是允许并发的读而不需要加锁（因为容器内元素未发生变化），提升效率，仅写时上锁，读和写再不同的容器中，体现了读写分离的思想 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原文：<a href="https://www.cnblogs.com/fhblikesky/p/13692641.html">https://www.cnblogs.com/fhblikesky/p/13692641.html</a></p>
<h4 id="✅list的ConcurrentModificationException问题"><a href="#✅list的ConcurrentModificationException问题" class="headerlink" title="✅list的ConcurrentModificationException问题"></a>✅list的ConcurrentModificationException问题</h4><p>除了多线程修改ArrayList的操作会造成该问题之外，在迭代器中用list.add或list.remove去添加删除list元素，也会造成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Iterator it = myList.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    String value = it.next();</span><br><span class="line">        if (value.equals( &quot;3&quot;)) &#123;</span><br><span class="line">            myList.remove(value);  // error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (Iterator it = myList.iterator(); it.hasNext();) &#123;</span><br><span class="line">    String value = it.next();</span><br><span class="line">        if (value.equals( &quot;3&quot;)) &#123;</span><br><span class="line">            myList.remove(value);  // error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (String value : myList) &#123;</span><br><span class="line">    System. out.println( &quot;List Value:&quot; + value);</span><br><span class="line">        if (value.equals( &quot;3&quot;)) &#123;</span><br><span class="line">            myList.remove(value);  // error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>原因看源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    int cursor;       // index of next element to return</span><br><span class="line">    int lastRet = -1; // index of last element returned; -1 if no such</span><br><span class="line">    int expectedModCount = modCount;</span><br><span class="line">    </span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        int i = cursor;</span><br><span class="line">        if (i &gt;= size)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">        if (i &gt;= elementData.length)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        cursor = i + 1;</span><br><span class="line">        return (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        if (lastRet &lt; 0)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList.this.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -1;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final void checkForComodification() &#123;</span><br><span class="line">        if (modCount != expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>cursor：表示下一个要访问的元素的索引，从next()方法的具体实现就可看出</li>
<li>lastRet：表示上一个访问的元素的索引</li>
<li>expectedModCount：表示对ArrayList修改次数的期望值，它的初始值为modCount。</li>
<li>modCount: 是在 ArrayList 中赋值的，并且初始值为 0，在 add 和 remove 的时候（修改元素的时候）会增加 1.</li>
</ul>
<p>hasNext方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean hasNext() &#123;</span><br><span class="line">    return cursor != size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hasNext 方法，在方法中的 size 是 ArrayList 中的变量，这个 ConcurrentModificationException 异常存在的原因之一就在这个方法体现出来了，在多线程的情况下，如果使用迭代器遍历时，ArrayList数组元素变少导致 cursor &gt; size，然后数组越界。在正常情况下当 cursor &#x3D;&#x3D; size代表已经到数组尽头了.</p>
<p>next 方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public E next() &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    int i = cursor;</span><br><span class="line">    if (i &gt;= size)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">    if (i &gt;= elementData.length)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    cursor = i + 1;</span><br><span class="line">    return (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next 方法中先是判断了 modCount 是否等于 expectedModCount，不相等则抛出 并发修改异常，否则取到游标，然后判断游标是否大于数组长度或者元素个数。最后游标加一，然后返回数的同时使 lastRet 等于 i。</p>
<p>remove方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">    if (lastRet &lt; 0)</span><br><span class="line">        throw new IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ArrayList.this.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -1;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 remove 掉元素的时候更新下自己的 expectedModCount。注意的是remove后 lastRet 会变成 -1，也就是不能连续 remove 两次，因为在 next 中检查了 lastRet 的值不能小于 0。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">if (modCount != expectedModCount)</span><br><span class="line">throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当modCount !&#x3D; expectedModCount时，执行next()就会抛出ConcurrentModificationException<br>而什么时候会造成modCount !&#x3D; expectedModCount呢？<br>ArrayList.add()和remove()方法，每执行一次都会modCount++，但不改变expectedModCount的值。expectedModCount的值是在构建迭代的时候初始为expectedModCount&#x3D;modCount的。<br>在构建迭代器之后，再使用ArrayList.add()方法就造成了modCount !&#x3D; expectedModCount<br>构建迭代器后，用迭代器来add和remove就没有问题。因为它会在改变modCount的值之后，又把值赋给了expectedModCount，从而保证modCount&#x3D;expectedModCount</p>
<hr>
<p>解决方法：用迭代器的remove方法<br>多线程情况下，iterator是线程私有，也即是说expectedModCount是每个线程私有。使用Vector也不行。<br>所以：<br>在使用iterator迭代的时候使用synchronized或者Lock进行同步。不推荐，因为增删造成的同步锁可能会阻塞遍历操作。<br>使用并发容器CopyOnWriteArrayList或者ConcurrentHashMap代替ArrayList和Vector。CopyOnWriteArrayList不能使用Iterator.remove()进行删</p>
<p>ConcurrentModificationException异常原因和解决方法：<br><a href="https://blog.csdn.net/qq_44613591/article/details/114108920">https://blog.csdn.net/qq_44613591/article/details/114108920</a></p>
<p>Java 遍历List ConcurrentModificationException 异常解析：<br><a href="https://blog.csdn.net/qq_30051139/article/details/54019515">https://blog.csdn.net/qq_30051139/article/details/54019515</a></p>
<h4 id="总结多线程下ArrayList的几个问题"><a href="#总结多线程下ArrayList的几个问题" class="headerlink" title="总结多线程下ArrayList的几个问题"></a>总结多线程下ArrayList的几个问题</h4><p>1.多线程add可能会丢数据，也可能数组越界，但不会并发错误<br>2.多线程add又打印ArrayList，会并发错误，应为System.out方法里用了迭代器。<br>3.用迭代器遍历中又用ArrayList的add和remove方法，会并发错误。</p>
<p>实验：对partition后的某个subList进行add的话，会牵一发而动全身，因为每个subList是多大已经规定好，对前面的subList进行add，add的元素会跑到下一个subList，以此类推。原来的list也会改变。</p>
<p>实验：对ArrayList分partition：<code>List&lt;List&lt;A&gt;&gt; partion = Lists.partition(list, 2);</code>，循环将各个subList传入不同的线程，并且在线程中对subList进行add，会并发错误。<br>🤔为什么单纯ArrayList多线程add不会并发错误，这里就会。<br>这里使用的是AbstractList的add方法，其中用到ArrayList的size方法会检查modCount。但是ArrayList的add方法用的是ArrayList的add方法。</p>
<p>实验：对ArrayList分partition：<code>List&lt;List&lt;A&gt;&gt; partion = Lists.partition(list, 2);</code>，循环将各个subList传入不同的线程，并且在线程中对subList只是打印，在主线程里再add，会并发错误。原因：打印List也会用到迭代器。<br>如果是在线程里循环遍历打印单个元素，不会有错误。并且会实时反映增加的元素。</p>
<h3 id="java泛型"><a href="#java泛型" class="headerlink" title="java泛型"></a>java泛型</h3><p>1、泛型与Object的区别</p>
<p>方法的声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object doSomething(Object obj) &#123;....&#125;</span><br><span class="line">​</span><br><span class="line">public &lt;T&gt; T doSomething(T t) &#123;....&#125;</span><br></pre></td></tr></table></figure>

<p>无论是T还是 obj，你都只能调用Object类型的参数和返回值。</p>
<p>但是，如果是使用了泛型的类，和普通的调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyClass&lt;Foo&gt; my = new MyClass&lt;Foo&gt;();</span><br><span class="line">Foo foo = new Foo();</span><br><span class="line"></span><br><span class="line">泛型：</span><br><span class="line">Foo newFoo = my.doSomething(foo);</span><br><span class="line"></span><br><span class="line">Object:</span><br><span class="line">Foo newFoo = (Foo) my.doSomething(foo);</span><br></pre></td></tr></table></figure>

<p>因此，使用泛型的好处：</p>
<p>1.不需要做强制类型转换</p>
<p>2.编译时更安全。如果使用Object类的话，你没法保证返回的类型一定是Foo，也许是其它类型。这时你就会在运行时得到一个类型转换异常（ClassCastException）</p>
<p>转自：<a href="https://blog.csdn.net/SDDDDDSA/article/details/120733398">https://blog.csdn.net/SDDDDDSA/article/details/120733398</a></p>
<p>2、泛型<code>&lt;T&gt; T</code> 与 T 的区别</p>
<p>方法返回前的<code>&lt;T&gt; </code>是告诉编译器，当前方法的值传入类型可以和类初始化的泛型类型不同，也是就是该方法的泛型类可以自定义，不需要跟类初始化的泛型类相同.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.jt.test;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * @Description</span><br><span class="line"> * 有的方法返回值为 &lt;T&gt; T ，有的方法返回值为 T ,区别在那里 ？</span><br><span class="line"> **/</span><br><span class="line">public class Request&lt;E&gt; &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    public &lt;T&gt; T getObject(Class&lt;T&gt; tClass) throws IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        T t = tClass.newInstance();</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 方法返回前的 &lt;T&gt; 是告诉编译器，当前方法的值传入类型可以和类初始化的泛型类型不同，</span><br><span class="line">     * 也是就是该方法的泛型类可以自定义，不需要跟类初始化的泛型类相同</span><br><span class="line">     *</span><br><span class="line">     * 参数 T</span><br><span class="line">     *  第一个 表示是泛型</span><br><span class="line">     *  第二个 表示是返回是T类型的数据</span><br><span class="line">     *  第三个 表示限制参数类型为T</span><br><span class="line">     * @param data</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private &lt;T&gt; T getListFirst(List&lt;T&gt; data) &#123;</span><br><span class="line">        if (data == null || data.size() == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return data.get(0);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 这个只能传T类型的数据</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private E getListFirst2(List&lt;E&gt; data) &#123;</span><br><span class="line">        if (data == null || data.size() == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return data.get(0);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; data = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; data2 = new ArrayList&lt;&gt;();</span><br><span class="line">        // 入参由List&lt;T&gt;的T 决定，因为返回值为&lt;T&gt; T ,所以入参不受 Request&lt;T&gt; 影响</span><br><span class="line">        Integer a = new Request&lt;String&gt;().getListFirst(data);</span><br><span class="line"> </span><br><span class="line">        // 编译出错，入参由Request&lt;T&gt; T的决定，受Request&lt;T&gt;影响</span><br><span class="line">        //new Request&lt;String&gt;().getListFirst2(data);</span><br><span class="line"> </span><br><span class="line">        // 没什么区别</span><br><span class="line">        String aa = new Request&lt;String&gt;().getListFirst(data2);</span><br><span class="line">        String bb = new Request&lt;String&gt;().getListFirst2(data2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转自：<a href="https://blog.csdn.net/qianzhitu/article/details/107962657">https://blog.csdn.net/qianzhitu/article/details/107962657</a></p>
<p>3、泛型通配符</p>
<p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>常用的 T，E，K，V，？</p>
<p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。通常情况下，T，E，K，V，？是这样约定的：</p>
<p>？表示不确定的 java 类型<br>T (type) 表示具体的一个java类型<br>K V (key value) 分别代表java键值中的Key Value<br>E (element) 代表Element</p>
<p>更多：<a href="https://blog.csdn.net/minkeyto/article/details/116205607">https://blog.csdn.net/minkeyto/article/details/116205607</a></p>
<p>学长教学妹java泛型：<a href="https://blog.csdn.net/m0_67401499/article/details/125401501">https://blog.csdn.net/m0_67401499/article/details/125401501</a></p>
<h3 id="java可变参数"><a href="#java可变参数" class="headerlink" title="java可变参数"></a>java可变参数</h3><p>java可变参数是指在调用方法时传入不定长度的参数，本质上是基于数组实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//参数为可变参数</span><br><span class="line">//在定义方法时，在最后一个形参上加&quot;…&quot;就表示该形参可以接受多个参数值，多个参数值被当做数组传入。</span><br><span class="line">public static void element(Integer... args)&#123; &#125;</span><br><span class="line">//参数为数组</span><br><span class="line">public static void element(Integer[] args)&#123; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//参数为可变参数</span><br><span class="line">public static void element(Integer... args) &#123;</span><br><span class="line">    for (int arg : args) &#123;</span><br><span class="line">        System.out.print(arg + &quot;  &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //都可以</span><br><span class="line">    element(1,2,3);</span><br><span class="line">    int[] array=&#123;1,2,3&#125;;</span><br><span class="line">    element(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️可变参数只能做为函数的最后一个参数，前面有没有其他参数都可以，一个函数最多只能有一个可变参数。</p>
<p>可变参数在编译为字节码后，在方法签名中是以数组形态出现的，如果两个方法签名编译后的是一致的话，是不能编译通过的，不可以作为方法的重载。</p>
<p>可变参数作为参数的方法可以传入数组类型的数据或者直接传入多个数据，但是数组作为参数的方法只能传入数组类型的数据。</p>
<p>反射时，可变参数的注意事项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line"></span><br><span class="line">    public static void element(Integer... args)&#123;</span><br><span class="line">        System.out.println(args.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer[] arrry=&#123;1,2,3&#125;;</span><br><span class="line">        try &#123;</span><br><span class="line">            //反射是运行时获取的，在运行时看来，可变参数和数组上是一致的。因而方法的签名为([java/lang/Integer;)V</span><br><span class="line">            //Method对象的方法声明为Object invoke (Object obj,Object.. args)</span><br><span class="line">            //args虽然是一个可变长度的参数，但是args的长度受限于该方法对象代表的真实方法的参数列表长度,</span><br><span class="line">            //从运行时签名来看，([java/lang/Integer;)V实际上是一个形参，即Integer[] args,因此invoke (Object obj,Object.. args)中可变参数args的实际参数长度只能为1。</span><br><span class="line">            Method method = Demo5.class.getMethod(&quot;element&quot;, Integer[].class);</span><br><span class="line">            //array的长度为3，不符合</span><br><span class="line">            method.invoke(null,arrry);</span><br><span class="line">            //将Integer[]转为Object[]，长度还是为3，不符合</span><br><span class="line">            method.invoke(null,(Object[])arrry);</span><br><span class="line">            //将整个Integer[]转为一个Object，长度为1，符合</span><br><span class="line">            method.invoke(null,(Object)arrry);</span><br><span class="line">            //Object[]的长度为1，符合，和上面相同</span><br><span class="line">            method.invoke(null,new Object[]&#123;arrry&#125;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://blog.csdn.net/weixin_43413307/article/details/125485292">https://blog.csdn.net/weixin_43413307/article/details/125485292</a></p>
<h3 id="类中的布尔类型get方法注意"><a href="#类中的布尔类型get方法注意" class="headerlink" title="类中的布尔类型get方法注意"></a>类中的布尔类型get方法注意</h3><p>@Getter自动生成getter方法，但是：<br>1.Boolean类型,生成的get方法是get开头的(建议使用这个).<br>2.boolean类型,生成的get方法是is开头的(用这个最好重写getXxx()格式的方法).</p>
<p>用到布尔值的属性时,最好统一使用大写的包装类Boolean.<br>如果用小写的booean基本类型,最好重写get方法,保证是getXxxx的格式即可.<br>*如果这个对象涉及到反射,反射一般会默认调取对象的get方法,对于这个is的情况,是走不通的.</p>
<h3 id="java的native方法"><a href="#java的native方法" class="headerlink" title="java的native方法"></a>java的native方法</h3><p>什么是native方法？<br>一个Native Method是一个java调用非java代码的接口。Native Method的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern “C”告知C＋＋编译器去调用一个C的函数。</p>
<p>使用native关键字说明这个方法是原生函数，也就是这个方法是用C&#x2F;C++语言实现的，并且被编译成了DLL，由java去调用。 这些函数的实现体在DLL中，JDK的源代码中并不包含，你应该是看不到的。对于不同的平台它们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的。</p>
<p>例如：<br>Thread.sleep(1000); 还有 Thread.start0() 都是native方法。<br>在JDK 源码 Object.class 类中的 getClass() 方法、hashCode()方法、clone() 方法</p>
<p>native的意思就是通知操作系统， 这个函数你必须给我实现，因为我要使用。 所以native关键字的函数都是操作系统实现的， java只能调用。<br>java是跨平台的语言，既然是跨了平台，所付出的代价就是牺牲一些对底层的控制，而java要实现对底层的控制，就需要一些其他语言的帮助，这个就是native的作用了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.native方法是java与其他语言协作的时候使用的，底层实现不是java(c,c++)</span><br><span class="line">2.native并不是java实现的，所以直接调用就好，不需要管他底层实现</span><br><span class="line">3.native方法实际上是java用于调用底层操作系统的方法,java只能调用，不能查看和修改</span><br><span class="line">4.java是跨平台语言，自然而然会失去对底层的控制，于是想要调用底层方法，就必须使用native方法间接调用底层操作系统的方法(c,c++实现)</span><br><span class="line">5.随着java的不断发展，native方法越来越少</span><br><span class="line">6.native是一个关键字，其修饰的方法只说明不实现</span><br><span class="line">7.native方法加载到 本地栈中</span><br><span class="line">————————————————</span><br><span class="line">原文链接：https://blog.csdn.net/TheWayForDream/article/details/122202601</span><br></pre></td></tr></table></figure>

<p>JNI：Java Native Interface：<a href="https://www.zhihu.com/question/28001771/answer/2049534464">https://www.zhihu.com/question/28001771/answer/2049534464</a><br>native用法：<a href="https://www.jb51.net/article/195760.html">https://www.jb51.net/article/195760.html</a></p>
<h3 id="printStackTrace-方法"><a href="#printStackTrace-方法" class="headerlink" title="printStackTrace()方法"></a>printStackTrace()方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">… &#125; catch(Exception e) &#123;</span><br><span class="line">e.printStackTrace() ; &#125;</span><br></pre></td></tr></table></figure>

<p>try语句中出现异常时，系统会自动将catch括号中的Exception e 初始化。</p>
<p>printStackTrace()：在命令行打印异常信息在程序中出错的位置及原因。<br>System.out.println(e)：打印异常</p>
<p>不建议使用printStackTrace()的原因：<br>e.printStackTrace() 语句要产生的字符串记录的是堆栈信息，太长太多，内存会被填满。</p>
<p>短时间内大量请求访问此接口 -&gt; 代码本身有问题，很多情况下抛异常  -&gt; e.printStackTrace() 来打印异常到控制台 -&gt; 产生错误堆栈字符串到字符串池内存空间 -&gt; 此内存空间一下子被占满了 -&gt; 开始在此内存空间产出字符串的线程未完成，就没空间了 -&gt;  大量线程产出字符串产出到一半，等在这儿（等有内存了继续搞）-&gt; 相互等待，等内存，锁死了，整个应用挂掉了。</p>
<p>为什么不建议printStackTrace：<a href="https://blog.csdn.net/kzadmxz/article/details/89914896">https://blog.csdn.net/kzadmxz/article/details/89914896</a></p>
<p>建议：logger.error(“***”,  e);</p>
<h3 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h3><p>✅1.使用Math方法</p>
<p>java本身的，不需要导入包，Math.random()随机生成一个double类型[0，1)，如果想生成1~100的随机数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num = (int)(Math.random()*100)+1;</span><br><span class="line">System.out.println(num);</span><br><span class="line">System.out.println((int)0.01); //0</span><br></pre></td></tr></table></figure>

<p>✅2.使用Random方法生成随机数</p>
<p>Random类是java.until下的一个根据随机算法的起源数字进行一些变化，从而得到随机数字的方法。</p>
<p>随机算法的起源数字被成为种子数（seed）。</p>
<p>虽然Random类产生的数字是随机的，但在相同种子数（seed）下的相同次数产生的随机数是相同的（伪随机）。</p>
<p>Random中共有两种构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、public Random（）</span><br><span class="line">此构造方法是以系统自身的时间为种子数来构造Random对象。</span><br><span class="line"></span><br><span class="line">2、public Random（long seed）</span><br><span class="line">此构造方法可以自己来选定具体的种子来构造Random对象。</span><br></pre></td></tr></table></figure>

<p>常用方法：都可以加参数表示范围，范围是左闭右开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">random.nextInt()	返回值为整数,范围是int类型范围</span><br><span class="line">random.nextLong()	返回值为长整型，范围是long类型的范围</span><br><span class="line">random.nextFloat()	返回值为小数，范围是[0,0.1]</span><br><span class="line">random.nextDouble()	返回值为小数，范围是[0,0.1]</span><br><span class="line">random.nextBoolean（）	返回值为boolean值，true和false概率相同</span><br><span class="line">radom.nextGaussian()	返回值为呈高斯（“正态”）分布的 double 值，其平均值是 0.0，标准差是 1.0</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Random r = new Random();//以系统自身时间为种子数</span><br><span class="line">int i = r.nextInt();</span><br><span class="line">System.out.println(&quot;i&quot;+i);</span><br><span class="line">Scanner sc  =new Scanner(System.in);</span><br><span class="line">int j = sc.nextInt();</span><br><span class="line">Random r2 = new Random(j);//自定义种子数</span><br><span class="line">Random r3 = new Random(j);//这里是为了验证上方的注意事项：Random类是伪随机，相同种子数相同次数产生的随机数相同</span><br><span class="line">int num  = r2.nextInt(1000);</span><br><span class="line">int num2 = r3.nextInt(1000);</span><br><span class="line">System.out.println(&quot;num&quot;+num);</span><br><span class="line">System.out.println(&quot;num2&quot;+num2);</span><br></pre></td></tr></table></figure>

<p>✅3.使用SecureRandom生成随机数</p>
<p>java.util.Random的实例不是加密安全的，要是知道setSeed值(即时间戳)，很明显能把随机数给猜出来。所以不建议使用Random。SecureRandom来获取加密安全的伪随机数生成器，以供对安全敏感的应用程序使用。</p>
<p>在安全应用场景，随机数应该使用安全的随机数。密码学意义上的安全随机数，要求必须保证其不可预测性。</p>
<p>密码学安全的伪随机数产生器：JDK的java.security.SecureRandom</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SecureRandom random = new SecureRandom();</span><br><span class="line">String returnValue = &quot;&quot;;</span><br><span class="line">int randomInt = 0;</span><br><span class="line">int range = 9;</span><br><span class="line">for(int i=0; i&lt;5; i++ )&#123;</span><br><span class="line">    randomInt = random.nextInt(range+1);</span><br><span class="line">    returnValue = returnValue + randomInt;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(returnValue);</span><br><span class="line"></span><br><span class="line">secureRandom.setSeed(System.currentTimeMillis()); //使用系统时间作为种子</span><br><span class="line">如果同一毫秒连续调用，则得到的随机数则是相同的。</span><br><span class="line">不要自己指定种子。应当使用系统随机源。采用无参构造方法实例化</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSecureRandom() throws NoSuchAlgorithmException &#123;</span><br><span class="line">    //指定算法名称</span><br><span class="line">    SecureRandom secureRandom = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span><br><span class="line">    secureRandom.setSeed(10000L);</span><br><span class="line">    for(int i = 0 ; i &lt; 10 ; i ++) &#123;</span><br><span class="line">        System.out.println(secureRandom.nextInt(1000));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;-------------------&quot;);</span><br><span class="line">    secureRandom = new SecureRandom();</span><br><span class="line">    secureRandom.setSeed(10000L);</span><br><span class="line">    for(int i = 0; i &lt; 10 ; i ++) &#123;</span><br><span class="line">        System.out.println(secureRandom.nextInt(1000));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getInstance方法"><a href="#getInstance方法" class="headerlink" title="getInstance方法"></a>getInstance方法</h3><p>两个使用场景：</p>
<p>✅1.抽象类</p>
<p>抽象类是无法直接new出来的，所以想要通过实例化的话只能通过getInstance()方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GetInstanceTest &#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        Person p = Person.getInstance(&quot;Limbo&quot;);</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Person &#123;</span><br><span class="line">    private String title;</span><br><span class="line">    public Person(String title) &#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    abstract public void eat();</span><br><span class="line">    public static  PersonImpl getInstance(String title) &#123;</span><br><span class="line">        return new PersonImpl(title);</span><br><span class="line">    &#125;</span><br><span class="line">    //必须static：</span><br><span class="line">    static class PersonImpl extends Person</span><br><span class="line">    &#123;</span><br><span class="line">        public PersonImpl(String title) &#123;</span><br><span class="line">            super(title);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void eat()</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Eat!!!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅2.单例设计模式</p>
<p>一般在单例模式下使用.getInstance()创建对象.<br>单例模式：一个类有且只有一个实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SingleTest &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Singleton s = Singleton.getInstance();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Singleton &#123;</span><br><span class="line">    private String title;</span><br><span class="line">    private String content;</span><br><span class="line">    //在自己内部定义自己的一个实例</span><br><span class="line">    private static Singleton SINGLETON = null;</span><br><span class="line">    //private 只能在自己内部供自己去访问</span><br><span class="line">    private Singleton(String title, String content) &#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    //此静态方法供外部直接访问</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (SINGLETON == null)</span><br><span class="line">            SINGLETON = new Singleton(&quot;Kobe&quot;, &quot;MVP&quot;);</span><br><span class="line">        return SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return this.title + &quot; - &quot; + this.content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getInsance()t:在主函数开始时调用，返回一个实例化对象，此对象是static的，在内存中保留着它的引用，即内存中有一块区域专门用来存放静态方法和变量，可以直接使用，调用多次返回同一个对象。</p>
<p>(1)对象使用之前通过getinstance得到，而不需要自己定义，用完之后不需要delete；</p>
<p>(2)new 一定要生成一个新对象，分配内存；getInstance() 则不一定要再次创建，它可以把一个已存在的引用给你使用，这在效能上优于new；</p>
<p>(3) new创建后只能当次使用，而getInstance()可以跨栈区域使用，或者远程跨区域使用。所以getInstance()通常是static静态实例方法。</p>
<p>摘自：<a href="https://www.cnblogs.com/baxianhua/p/9341953.html">https://www.cnblogs.com/baxianhua/p/9341953.html</a></p>
<h3 id="lang3下的Pair"><a href="#lang3下的Pair" class="headerlink" title="lang3下的Pair"></a>lang3下的Pair</h3><p>org.apache.commons.lang3.tuple.Pair</p>
<p>Pair 用于存储左右元素对，Pair&lt;Left, Right&gt;。主要有两个子类，ImmutablePair 和 MutablePair。</p>
<p>Pair 实现了 java.util.Map.Entry，因此 left 和 right 也可以视作 key-value。不同于Map，Pair只能存一组键值对。</p>
<p>of 方法 以 static 调用的形式创建一个 Pair 实例. 默认创建的是 ImmutablePair。left, right值final 修饰， 值第一次被设置后不可变。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer, String&gt; pair = Pair.of(1, &quot;1&quot;);</span><br><span class="line">System.out.println(pair.getLeft());</span><br><span class="line">System.out.println(pair.getKey());</span><br><span class="line">System.out.println(pair.getRight());</span><br><span class="line">System.out.println(pair.getValue());</span><br><span class="line">pair.setValue(&quot;2&quot;); //java.lang.UnsupportedOperationException</span><br></pre></td></tr></table></figure>

<p>org.apache.commons.lang3.tuple.MutablePair<br>继承了 Pair，left 和 right 值可变。</p>
<p>Pair与Map：<br>1.共通点: Pair 和 Map 都是以 key, value 进行存储。<br>2.不同点:<br>Pair 通过 getKey(), getValue() 获取 key 和 value，没有增加键值对的操作。<br>Map 是通过 get(key) 获取 key 对应的 value，通过 values() 获取所有的value，而且还可以通过 put 增加键值对。<br>Pair 保存的是一对 key-value，而 Map 可以保存多对 key-value。</p>
<p>⚠️Pair的一个使用场景：VO中用到的小数据结构，不想再构造一个pojo了，有两组键值对的数据，比如Point，只有x和y。就可以用<code>List&lt;Pair&lt;String, Double&gt;&gt;</code> 表示。<br>⚠️但是Pair不能被json解析。</p>
<h3 id="几种排序算法"><a href="#几种排序算法" class="headerlink" title="几种排序算法"></a>几种排序算法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-交换排序</span><br><span class="line"> -冒泡排序</span><br><span class="line"> -快速排序</span><br><span class="line">-插入排序</span><br><span class="line"> -直接插入排序</span><br><span class="line"> -希尔排序</span><br><span class="line">-选择排序</span><br><span class="line"> -简单选择排序</span><br><span class="line"> -堆排序</span><br><span class="line">-归并排序</span><br><span class="line">-基数排序</span><br></pre></td></tr></table></figure>

<h4 id="✅冒泡排序"><a href="#✅冒泡排序" class="headerlink" title="✅冒泡排序"></a>✅冒泡排序</h4><p>1.从第一个元素开始，比较相邻的两个元素。如果第一个比第二个大，则进行交换,此时最后的元素应是最大的数。<br>2.对剩余元素重复以上步骤，直到没有任何一对元素需要比较为止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void bubbleSortOpt(int[] arr) &#123;</span><br><span class="line">    if(arr == null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    if(arr.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp = 0;</span><br><span class="line">    for(int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        for(int j = 0; j &lt; arr.length - i - 1; j++) &#123;</span><br><span class="line">            if(arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒泡排序优化：<br>假如待排序数组是 2、1、3、4、5 这样的情况，按照上述代码实现，第一次循环即可得出正确结果。但循环并不会停止，而是继续执行，直到结束为止。显然，之后的循环遍历是没有必要的。</p>
<p>为了解决这个问题，我们可以设置一个标志位，用来表示当前次循环是否有交换，如果没有，则说明当前数组已经完全排序，直接返回。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int bubbleSortOpt2(int[] arr) &#123;</span><br><span class="line">    if (arr == null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125; else if (arr.length &lt; 2) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        int flag = 1;</span><br><span class="line">        for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">                flag = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没有发生交换，排序已经完成</span><br><span class="line">        if (flag == 1) &#123;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒泡排序再优化：<br>比如 3、4、2、1、6、7、8 这个数组，第一次循环后，变为 3、2、1、4、6、7、8 的顺序，我们发现，1 之后的 4 、6、7、8 已经有序了，第二次循环就没必要对后面这段再遍历比较。<br>记录最后发生交换的地点，就是我们要找的分界点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int bubbleSortOpt3(int[] arr) &#123;</span><br><span class="line"></span><br><span class="line">    if (arr == null) &#123;</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125; else if (arr.length &lt; 2) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp;</span><br><span class="line">    int count = 0;</span><br><span class="line">    int len = arr.length - 1;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        // 记录最后一次交换位置</span><br><span class="line">        int lastChange = 0;</span><br><span class="line">        for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">                // 每交换一次更新一次</span><br><span class="line">                lastChange = j;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没有发生交换，排序已经完成</span><br><span class="line">        if (lastChange == 0) &#123;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">        len = lastChange;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅快速排序"><a href="#✅快速排序" class="headerlink" title="✅快速排序"></a>✅快速排序</h4><p>快速排序的思想很简单，先找一个基准数，先把待排序的数组根据基准数拆成左右两个区间，左边都比中间的基准数小，右边都比基准数大。接着左右两边各自再做同样的操作，完成后再拆分再继续，一直到各区间只有一个数为止。<br>算法的实现需要用到递归。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void quickSort(int[] arr, int start, int end) &#123;</span><br><span class="line"></span><br><span class="line">    if(start &lt; end) &#123;</span><br><span class="line">        // 把数组中的首位数字作为基准数</span><br><span class="line">        int pivot = arr[start];</span><br><span class="line">        // 记录需要排序的下标</span><br><span class="line">        int low = start;</span><br><span class="line">        int high = end;</span><br><span class="line">        // 循环找到比基准数大的数和比基准数小的数</span><br><span class="line">        while(low &lt; high) &#123;</span><br><span class="line">            // 右边的数字比基准数大</span><br><span class="line">            while(low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            // 使用右边的数替换左边的数</span><br><span class="line">            arr[low] = arr[high];</span><br><span class="line">            // 左边的数字比基准数小</span><br><span class="line">            while(low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 使用左边的数替换右边的数</span><br><span class="line">            arr[high] = arr[low];</span><br><span class="line">        &#125;</span><br><span class="line">        // 把标准值赋给下标重合的位置</span><br><span class="line">        arr[low] = pivot;</span><br><span class="line">        // 处理所有小的数字</span><br><span class="line">        quickSort(arr, start, low);</span><br><span class="line">        // 处理所有大的数字</span><br><span class="line">        quickSort(arr, low + 1, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 Java 实现的八种常用排序算法:<br><a href="https://blog.csdn.net/CSDN_handsome/article/details/109055036">https://blog.csdn.net/CSDN_handsome/article/details/109055036</a></p>
<p>想实现一个根据对象某属性首尾相接的排序，用Comparator自定义排序没行得通，所以：先弄一个end的Set，然后便利start，找到第一个对象，然后造一个start-对象的Map，然后用end找对象，一个一个找到。</p>
<h3 id="java链式编程"><a href="#java链式编程" class="headerlink" title="java链式编程"></a>java链式编程</h3><p>链式编程的原理是返回一个this对象，也就是返回对象本身，从而达到链式效果。</p>
<p>链式编程，中间操作的返回值都是自己，每个操作的输出是体现在自己对象的改变中的，类似于<code>Stream&lt;T&gt;</code></p>
<p>链式编程的案例：</p>
<p>1、StringBuilder 和 StringBuffer中的append()方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuilder buffer = new StringBuilder();</span><br><span class="line">buffer.append(&quot;你&quot;).append(&quot;好&quot;).append(&quot;!&quot;);</span><br><span class="line"></span><br><span class="line">源码：</span><br><span class="line">@Override</span><br><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、String 进行字符串操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String string = String.valueOf(&quot;123&quot;).concat(&quot;,4567890&quot;).replace(&#x27;,&#x27;, &#x27;!&#x27;).substring(2, 8);</span><br><span class="line"></span><br><span class="line">源码：</span><br><span class="line">返回的是对象本身，所以可以使用链式编程</span><br><span class="line">public static String valueOf(Object obj) &#123;</span><br><span class="line">    return (obj == null) ? &quot;null&quot; : obj.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String concat(String str) &#123;</span><br><span class="line">     // 省略...</span><br><span class="line">    return new String(buf, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、 Stream 流式计算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    // 相同元素去重</span><br><span class="line">    .distinct()</span><br><span class="line">    // 升序排序</span><br><span class="line">    .sorted((c1, c2) -&gt; c1.compareTo(c2))</span><br><span class="line">    // 遍历</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">源码：</span><br><span class="line">方法返回的是对象本身，所以可以使用链式编程</span><br><span class="line">Stream&lt;T&gt; distinct();</span><br><span class="line">Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator);</span><br></pre></td></tr></table></figure>

<p>自己做一个链式编程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        person.setAge(10).setName(&quot;11&quot;);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ToString</span><br><span class="line">    static class Person &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private Integer age;</span><br><span class="line"></span><br><span class="line">        public Person setName(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        public Person setAge(Integer age) &#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="java数组、字符串、list的最大长度"><a href="#java数组、字符串、list的最大长度" class="headerlink" title="java数组、字符串、list的最大长度"></a>java数组、字符串、list的最大长度</h3><p>✅数组的最大长度：<br>数组的length属性是int类型，占4个字节，最大值为Integer.MAX_VALUE&#x3D; 2^31-1【21亿多】<br>注意：这是理论上的最大长度，堆内存不一定能开辟那么大的存储空间来存储该数组。</p>
<p>✅字符串的最大长度：<br>运行时：<br>String、StringBuilder、StringBuffer底层都是基于字符数组char[ ]的，该数组的最大长度也为Integer.MAX_VALUE，所以一个字符串最大21亿多个字符【每个字符在java8中占1个字节】，即占2^32-2个字节，即差2个字节达到4GB。<br>2^10字节&#x3D;1KB，2^20&#x3D;1MB，2^30&#x3D;1GB</p>
<p>编译时：<br>java源码通过javac编译后生成的字节码文件中，静态常量池中字符串常量的长度最多为65535，因为JVM为了解决历史上的一个BUG，所以强制要求编译时字符串的最大长度为65534。</p>
<p>✅ArrayList和LinkedList的最大长度<br>ArrayList底层是数组，最大值为Integer.MAX_VALUE&#x3D; 231-1【21亿多】<br>LinkedList底层是链表，理论是无上限长度。</p>
<h3 id="Java元组Tuple"><a href="#Java元组Tuple" class="headerlink" title="Java元组Tuple"></a>Java元组Tuple</h3><p>Java中的Tuple是一种数据结构，可存放多个元素，每个元素的数据类型可不同。Tuple与List集合类似，但是不同的是，List集合只能存储一种数据类型，而Tuple可存储多种数据类型。<br>可能你会说，Object类型的List实际也是可以存储多种类型的啊？但是在创建List的时候，需要指定元素数据类型，也就是只能指定为Object类型，获取的元素类型就是Object，如有需要则要进行强转。而Tuple在创建的时候，则可以直接指定多个元素数据类型。</p>
<p>元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。关系数据库中的 一条记录就是一个元组， 一个表就是一个关系， 纪录组成表， 元组生成关系， 这就是关系数据库的核心理念。</p>
<p>元组的使用就是通过泛型定义一个类，然后去保存多个类型属性。所以可以认为元组完全是基于泛型的。返回的所有类型属性外包一层对象然后返回这个对象，其实就是作为元组的实现定义。</p>
<p>元组不同于List，List存储相同的数据类型，虽然也可以存储不同的数据类型，那就不符合泛型了。</p>
<p>元组不同于数组，数组种存储的相同的数据类型。</p>
<p>元组不同于map，map类型是键值对存在的，而元组中的值，值之间没有关系。</p>
<p>元组的值可以是不同数据类型，值与值之间没有关系。</p>
<p>理解：元祖相当于定义一个VO，里面有不同的属性类型，可以包装不同类型。和list区别是，十元祖就可以放10个不同类型的数据。元祖的优点其实还是可以防止代码的冗余，不用写更多的方法，可以通过一个返回多个我想要的类型属性。上面的Pair就是实现这么一个功能，也是元祖。</p>
<hr>
<p>依赖Jar包：javatuples</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.javatuples&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javatuples&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>jar包中的结构很简单，其中的类主要是tuple基础类、扩展的一元组、二元组…十元组，以及键值对元组；接口的作用是提供【获取创建各元组时传入参数值】的方法。</p>
<p>其中三元祖的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.javatuples;</span><br><span class="line"></span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">import org.javatuples.valueintf.IValue0;</span><br><span class="line">import org.javatuples.valueintf.IValue1;</span><br><span class="line">import org.javatuples.valueintf.IValue2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * A tuple of three elements.</span><br><span class="line"> * &lt;/p&gt; </span><br><span class="line"> * </span><br><span class="line"> * @since 1.0</span><br><span class="line"> * </span><br><span class="line"> * @author Daniel Fern&amp;aacute;ndez</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public final class Triplet&lt;A,B,C&gt; </span><br><span class="line">        extends Tuple</span><br><span class="line">        implements IValue0&lt;A&gt;,</span><br><span class="line">                    IValue1&lt;B&gt;,</span><br><span class="line">                    IValue2&lt;C&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -1877265551599483740L;</span><br><span class="line"></span><br><span class="line">    private static final int SIZE = 3;</span><br><span class="line"></span><br><span class="line">    private final A val0;</span><br><span class="line">    private final B val1;</span><br><span class="line">    private final C val2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static &lt;A,B,C&gt; Triplet&lt;A,B,C&gt; with(final A value0, final B value1, final C value2) &#123;</span><br><span class="line">        return new Triplet&lt;A,B,C&gt;(value0,value1,value2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般调用静态方法with，传入元组数据，创建一个元组。可以自定义一个工具类，提供公共方法，根据传入的参数个数，返回不同的元组对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.liuxuan.study;</span><br><span class="line"></span><br><span class="line">import com.liuxuan.repository.domain.Student;</span><br><span class="line">import org.javatuples.Pair;</span><br><span class="line">import org.javatuples.Triplet;</span><br><span class="line">import org.javatuples.Unit;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2023-02-06 22:32</span><br><span class="line"> **/</span><br><span class="line">public class TupleUtils&#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 单元素元祖</span><br><span class="line">     */</span><br><span class="line">    public static &lt;A&gt; Unit&lt;A&gt; with(final A value0) &#123;</span><br><span class="line">        return Unit.with(value0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 双元素元祖</span><br><span class="line">     */</span><br><span class="line">    public static &lt;A, B&gt; Pair&lt;A, B&gt; with(final A value0, final B value1) &#123;</span><br><span class="line">        return Pair.with(value0, value1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 三元素元祖</span><br><span class="line">     */</span><br><span class="line">    public static &lt;A, B, C&gt; Triplet&lt;A, B, C&gt; with(final A value0, final B value1, final C value2) &#123;</span><br><span class="line">        return Triplet.with(value0, value1, value2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Triplet&lt;Integer, String, String&gt;&gt; roleList = new ArrayList&lt;Triplet&lt;Integer, String, String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        Triplet&lt;Integer, String, String&gt; studentTriplet = TupleUtils.with(11, &quot;sid&quot;, &quot;graduate&quot;);</span><br><span class="line">        Triplet&lt;Integer, String, String&gt; teacherTriplet = TupleUtils.with(22, &quot;tid&quot;, &quot;graduate&quot;);</span><br><span class="line">        Triplet&lt;Integer, String, String&gt; programmerTriplet = TupleUtils.with(33, &quot;id&quot;, &quot;graduate&quot;);</span><br><span class="line"></span><br><span class="line">        roleList.add(studentTriplet);</span><br><span class="line">        roleList.add(teacherTriplet);</span><br><span class="line">        roleList.add(programmerTriplet);</span><br><span class="line"></span><br><span class="line">        for (Triplet&lt;Integer, String, String&gt; triplet : roleList) &#123;</span><br><span class="line">            System.out.println(triplet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TupleUtils中提供了with的重载方法，调用时根据传入的参数值个数，返回对应的元组对象。</p>
<p>参考：<a href="https://blog.csdn.net/qq_35006663/article/details/100301416">https://blog.csdn.net/qq_35006663/article/details/100301416</a></p>
<hr>
<p>org.apache.commons.lang3.tuple 中的元祖</p>
<p>用于处理一对键值的对象pair类似于Map.entry，commons lang3增加了可以处理3个值的Triple基类，此包下定义了<code>Pair&lt;L,R&gt;</code>抽象基类，及MutablePair,MutableTriple,ImmutablePair,ImmutableTriple子类。一个线程非安全，另一个线程安全。</p>
<p>接口：<br>1.<code>Pair</code>：封装一对键值对。<br>实现类：可变：<code>MutablePair&lt;L,R&gt;</code>，不可变：<code>ImmutablePair</code><br>2.<code>Triple</code>：封装3个值的类<br>实现类：<code>ImmutableTriple</code>; <code>MuttableTriple&lt;L,M,R&gt;</code></p>
<h3 id="Preconditions-checkArgument校验字段"><a href="#Preconditions-checkArgument校验字段" class="headerlink" title="Preconditions.checkArgument校验字段"></a>Preconditions.checkArgument校验字段</h3><p>guava中的静态方法，用来确认参数是不是符合要求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;31.0.1-jre&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String param = &quot;&quot;;</span><br><span class="line">//旧式写法</span><br><span class="line">if (StringUtils.isEmpty(param)) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;param字段不能为空&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//新式写法：期望这个字段不能为空</span><br><span class="line">Preconditions.checkArgument(StringUtils.isNotEmpty(param), &quot;param字段不能为空&quot;);</span><br></pre></td></tr></table></figure>

<p>新式的校验是：要求我们对某个字段的要求是什么，当逻辑未命中要求时，则抛出异常。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>drainTo()方法：<br>ArrayBlockingQueue是有界的阻塞队列，该队列内部使用数组支持的元素存储。<br>drainTo()方法用于将所有元素传输到集合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int capacity = 10;</span><br><span class="line">ArrayBlockingQueue queue = new ArrayBlockingQueue(capacity);</span><br><span class="line">queue.add(11);</span><br><span class="line">queue.add(22);</span><br><span class="line">queue.add(33);</span><br><span class="line">System.out.println(&quot;queue = &quot; + queue); //[11, 22, 33]</span><br><span class="line">ArrayList list = new ArrayList();</span><br><span class="line">queue.drainTo(list);</span><br><span class="line">System.out.println(&quot;queue = &quot; + queue); //[]</span><br><span class="line">System.out.println(&quot;collection = &quot; + list); //[11, 22, 33]</span><br></pre></td></tr></table></figure>

<h3 id="java获取本地ip"><a href="#java获取本地ip" class="headerlink" title="java获取本地ip"></a>java获取本地ip</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String localIP = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">System.out.println(localIP);</span><br></pre></td></tr></table></figure>

<h3 id="guava中的ImmutableList"><a href="#guava中的ImmutableList" class="headerlink" title="guava中的ImmutableList"></a>guava中的ImmutableList</h3><p>ImmutableList是一个不可变、线程安全的列表集合，它只会获取传入对象的一个副本，而不会影响到原来的变量或者对象。</p>
<p>ImmutableList创建不可变对象有两种方法，一种是使用静态of方法，另外一种是使用静态内部类Builder。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">静态内部类构建方法 :</span><br><span class="line">ImmutableList&lt;Integer&gt; list = ImmutableList .&lt;Integer&gt;builder()</span><br><span class="line">                        .add(12)</span><br><span class="line">                        .add(23)</span><br><span class="line">                        .add(34)</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">静态方法提供了多个参数的of静态方法:</span><br><span class="line">ImmutableList&lt;String&gt; list3 = ImmutableList .&lt;String&gt;of(&quot;12&quot;,&quot;23&quot;);</span><br><span class="line"></span><br><span class="line">复制数组中的元素到ImmutableList中:</span><br><span class="line"> List&lt;String&gt; list4 = new ArrayList&lt;String&gt;();</span><br><span class="line">list4.add(&quot;1&quot;);</span><br><span class="line">list4.add(&quot;2&quot;);</span><br><span class="line">list4.add(&quot;3&quot;);</span><br><span class="line">//copy数组list4的一个副本</span><br><span class="line">List&lt;String&gt; list5 = ImmutableList .&lt;String&gt;copyOf(list4);</span><br></pre></td></tr></table></figure>

<h3 id="System-getProperty"><a href="#System-getProperty" class="headerlink" title="System.getProperty()"></a>System.getProperty()</h3><p>获取系统属性，即在java虚拟机启动时定义的环境变量的值，第一个参数是属性名称，第二个参数是属性的默认值。</p>
<p><code>String s = System.getProperty(&quot;line.separator&quot;)</code> 获取系统空格。</p>
<p>System.getProperty() 是获取系统的相关属性，包括文件编码、操作系统名称、区域、用户名等，此属性一般是由 JVM 自动获取，不能设置。这个必须接收一个 String 类型的参数，并且返回一个 String 类型的值。如果想要获取所有的系统的相关属性值可以使用 System.getProperties() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.runtime.name-------Java(TM) SE Runtime Environment</span><br><span class="line">sun.boot.library.path-------C:\Program Files\Java\jdk1.8.0_60\jre\bin</span><br><span class="line">java.vm.version-------25.60-b23</span><br><span class="line">java.vm.vendor-------Oracle Corporation</span><br><span class="line">java.vendor.url-------http://java.oracle.com/</span><br><span class="line">path.separator-------;</span><br><span class="line">java.vm.name-------Java HotSpot(TM) 64-Bit Server VM</span><br><span class="line">file.encoding.pkg-------sun.io</span><br><span class="line">user.country-------CN</span><br><span class="line">user.script-------</span><br><span class="line">sun.java.launcher-------SUN_STANDARD</span><br><span class="line">sun.os.patch.level-------</span><br><span class="line">java.vm.specification.name-------Java Virtual Machine Specification</span><br><span class="line">user.dir-------F:\siwei\dayunmotor-tbox\dayunmotor-forward-hbase</span><br><span class="line">java.runtime.version-------1.8.0_60-b27</span><br><span class="line">java.awt.graphicsenv-------sun.awt.Win32GraphicsEnvironment</span><br><span class="line">java.endorsed.dirs-------C:\Program Files\Java\jdk1.8.0_60\jre\lib\endorsed</span><br><span class="line">os.arch-------amd64</span><br><span class="line">java.io.tmpdir-------C:\Users\yesway\AppData\Local\Temp\</span><br><span class="line">line.separator-------</span><br><span class="line"></span><br><span class="line">java.vm.specification.vendor-------Oracle Corporation</span><br><span class="line">user.variant-------</span><br><span class="line">os.name-------Windows 10</span><br><span class="line">sun.jnu.encoding-------GBK</span><br><span class="line">java.library.path-------C:\Program Files\Java\jdk1.8.0_60\bin;C:\WINDOWS\Sun\Java\bin;C:\WINDOWS\system32;C:\WINDOWS;C:\ProgramData\Oracle\Java\javapath;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\WINDOWS\System32\OpenSSH\;D:\Program Files\Git\cmd;C:\Users\yesway\AppData\Local\Microsoft\WindowsApps;;.</span><br><span class="line">java.specification.name-------Java Platform API Specification</span><br><span class="line">java.class.version-------52.0</span><br><span class="line">sun.management.compiler-------HotSpot 64-Bit Tiered Compilers</span><br><span class="line">os.version-------10.0</span><br><span class="line">user.home-------C:\Users\yesway</span><br><span class="line">user.timezone-------</span><br><span class="line">java.awt.printerjob-------sun.awt.windows.WPrinterJob</span><br><span class="line">file.encoding-------UTF-8</span><br><span class="line">java.specification.version-------1.8</span><br><span class="line">java.class.path-------C:\Program Files\Java\jdk1.8.0_60\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\rt.jar;F:\siwei\dayunmotor-tbox\dayunmotor-forward-hbase\target\classes;D:\dayunMaven\org\springframework\boot\spring-boot-starter\2.4.0\spring-boot-starter-2.4.0.jar;D:\dayunMaven\org\springframework\boot\spring-boot\2.4.0\spring-boot-2.4.0.jar;D:\dayunMaven\org\springframework\spring-context\5.3.1\spring-context-5.3.1.jar;D:\dayunMaven\org\springframework\boot\spring-boot-autoconfigure\2.4.0\spring-boot-autoconfigure-2.4.0.jar;D:\dayunMaven\jakarta\annotation\jakarta.annotation-api\1.3.5\jakarta.annotation-api-1.3.5.jar;D:\dayunMaven\org\springframework\spring-core\5.3.1\spring-core-5.3.1.jar;D:\dayunMaven\org\springframework\spring-jcl\5.3.1\spring-jcl-5.3.1.jar;D:\dayunMaven\org\yaml\snakeyaml\1.27\snakeyaml-1.27.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-aop\2.4.0\spring-boot-starter-aop-2.4.0.jar;D:\dayunMaven\org\springframework\spring-aop\5.3.1\spring-aop-5.3.1.jar;D:\dayunMaven\org\springframework\spring-beans\5.3.1\spring-beans-5.3.1.jar;D:\dayunMaven\org\aspectj\aspectjweaver\1.9.6\aspectjweaver-1.9.6.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-amqp\2.4.0\spring-boot-starter-amqp-2.4.0.jar;D:\dayunMaven\org\springframework\spring-messaging\5.3.1\spring-messaging-5.3.1.jar;D:\dayunMaven\org\springframework\amqp\spring-rabbit\2.3.1\spring-rabbit-2.3.1.jar;D:\dayunMaven\org\springframework\amqp\spring-amqp\2.3.1\spring-amqp-2.3.1.jar;D:\dayunMaven\org\springframework\retry\spring-retry\1.3.0\spring-retry-1.3.0.jar;D:\dayunMaven\javax\annotation\javax.annotation-api\1.3.2\javax.annotation-api-1.3.2.jar;D:\dayunMaven\com\rabbitmq\amqp-client\5.9.0\amqp-client-5.9.0.jar;D:\dayunMaven\org\springframework\spring-tx\5.3.1\spring-tx-5.3.1.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-log4j2\2.4.0\spring-boot-starter-log4j2-2.4.0.jar;D:\dayunMaven\org\apache\logging\log4j\log4j-slf4j-impl\2.13.3\log4j-slf4j-impl-2.13.3.jar;D:\dayunMaven\org\apache\logging\log4j\log4j-jul\2.13.3\log4j-jul-2.13.3.jar;D:\dayunMaven\org\slf4j\jul-to-slf4j\1.7.30\jul-to-slf4j-1.7.30.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-web\2.4.0\spring-boot-starter-web-2.4.0.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-json\2.4.0\spring-boot-starter-json-2.4.0.jar;D:\dayunMaven\com\fasterxml\jackson\datatype\jackson-datatype-jdk8\2.11.3\jackson-datatype-jdk8-2.11.3.jar;D:\dayunMaven\com\fasterxml\jackson\module\jackson-module-parameter-names\2.11.3\jackson-module-parameter-names-2.11.3.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-tomcat\2.4.0\spring-boot-starter-tomcat-2.4.0.jar;D:\dayunMaven\org\apache\tomcat\embed\tomcat-embed-core\9.0.39\tomcat-embed-core-9.0.39.jar;D:\dayunMaven\org\glassfish\jakarta.el\3.0.3\jakarta.el-3.0.3.jar;D:\dayunMaven\org\apache\tomcat\embed\tomcat-embed-websocket\9.0.39\tomcat-embed-websocket-9.0.39.jar;D:\dayunMaven\org\springframework\spring-web\5.3.1\spring-web-5.3.1.jar;D:\dayunMaven\org\springframework\spring-webmvc\5.3.1\spring-webmvc-5.3.1.jar;D:\dayunMaven\org\springframework\spring-expression\5.3.1\spring-expression-5.3.1.jar;D:\dayunMaven\net\minidev\json-smart\2.3\json-smart-2.3.jar;D:\dayunMaven\net\minidev\accessors-smart\1.2\accessors-smart-1.2.jar;D:\dayunMaven\org\ow2\asm\asm\5.0.4\asm-5.0.4.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-data-redis\2.4.0\spring-boot-starter-data-redis-2.4.0.jar;D:\dayunMaven\org\springframework\data\spring-data-redis\2.4.1\spring-data-redis-2.4.1.jar;D:\dayunMaven\org\springframework\data\spring-data-keyvalue\2.4.1\spring-data-keyvalue-2.4.1.jar;D:\dayunMaven\org\springframework\data\spring-data-commons\2.4.1\spring-data-commons-2.4.1.jar;D:\dayunMaven\org\springframework\spring-oxm\5.3.1\spring-oxm-5.3.1.jar;D:\dayunMaven\org\springframework\spring-context-support\5.3.1\spring-context-support-5.3.1.jar;D:\dayunMaven\io\lettuce\lettuce-core\6.0.1.RELEASE\lettuce-core-6.0.1.RELEASE.jar;D:\dayunMaven\io\netty\netty-common\4.1.53.Final\netty-common-4.1.53.Final.jar;D:\dayunMaven\io\netty\netty-handler\4.1.53.Final\netty-handler-4.1.53.Final.jar;D:\dayunMaven\io\netty\netty-resolver\4.1.53.Final\netty-resolver-4.1.53.Final.jar;D:\dayunMaven\io\netty\netty-buffer\4.1.53.Final\netty-buffer-4.1.53.Final.jar;D:\dayunMaven\io\netty\netty-codec\4.1.53.Final\netty-codec-4.1.53.Final.jar;D:\dayunMaven\io\netty\netty-transport\4.1.53.Final\netty-transport-4.1.53.Final.jar;D:\dayunMaven\io\projectreactor\reactor-core\3.3.11.RELEASE\reactor-core-3.3.11.RELEASE.jar;D:\dayunMaven\org\reactivestreams\reactive-streams\1.0.3\reactive-streams-1.0.3.jar;D:\dayunMaven\commons-lang\commons-lang\2.6\commons-lang-2.6.jar;D:\dayunMaven\org\apache\commons\commons-pool2\2.8.0\commons-pool2-2.8.0.jar;D:\dayunMaven\org\projectlombok\lombok\1.18.8\lombok-1.18.8.jar;D:\dayunMaven\org\apache\logging\log4j\log4j-core\2.11.2\log4j-core-2.11.2.jar;D:\dayunMaven\org\apache\logging\log4j\log4j-api\2.11.2\log4j-api-2.11.2.jar;D:\dayunMaven\org\slf4j\slf4j-api\1.7.5\slf4j-api-1.7.5.jar;D:\dayunMaven\com\fasterxml\jackson\core\jackson-annotations\2.9.0\jackson-annotations-2.9.0.jar;D:\dayunMaven\com\alibaba\fastjson\1.2.47\fastjson-1.2.47.jar;D:\dayunMaven\org\apache\hadoop\hadoop-client\3.0.0\hadoop-client-3.0.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-hdfs-client\3.0.0\hadoop-hdfs-client-3.0.0.jar;D:\dayunMaven\com\squareup\okhttp\okhttp\2.4.0\okhttp-2.4.0.jar;D:\dayunMaven\com\squareup\okio\okio\1.4.0\okio-1.4.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-yarn-api\3.0.0\hadoop-yarn-api-3.0.0.jar;D:\dayunMaven\javax\xml\bind\jaxb-api\2.2.11\jaxb-api-2.2.11.jar;D:\dayunMaven\org\apache\hadoop\hadoop-yarn-client\3.0.0\hadoop-yarn-client-3.0.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-mapreduce-client-core\3.0.0\hadoop-mapreduce-client-core-3.0.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-yarn-common\3.0.0\hadoop-yarn-common-3.0.0.jar;D:\dayunMaven\org\eclipse\jetty\jetty-util\9.3.19.v20170502\jetty-util-9.3.19.v20170502.jar;D:\dayunMaven\com\sun\jersey\jersey-client\1.19\jersey-client-1.19.jar;D:\dayunMaven\com\fasterxml\jackson\module\jackson-module-jaxb-annotations\2.7.8\jackson-module-jaxb-annotations-2.7.8.jar;D:\dayunMaven\com\fasterxml\jackson\jaxrs\jackson-jaxrs-json-provider\2.7.8\jackson-jaxrs-json-provider-2.7.8.jar;D:\dayunMaven\com\fasterxml\jackson\jaxrs\jackson-jaxrs-base\2.7.8\jackson-jaxrs-base-2.7.8.jar;D:\dayunMaven\org\apache\hadoop\hadoop-mapreduce-client-jobclient\3.0.0\hadoop-mapreduce-client-jobclient-3.0.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-mapreduce-client-common\3.0.0\hadoop-mapreduce-client-common-3.0.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-annotations\3.0.0\hadoop-annotations-3.0.0.jar;D:\dayunMaven\org\apache\hbase\hbase-shaded-client\2.1.0\hbase-shaded-client-2.1.0.jar;D:\dayunMaven\com\github\stephenc\findbugs\findbugs-annotations\1.3.9-1\findbugs-annotations-1.3.9-1.jar;D:\dayunMaven\org\apache\htrace\htrace-core4\4.2.0-incubating\htrace-core4-4.2.0-incubating.jar;D:\dayunMaven\commons-logging\commons-logging\1.2\commons-logging-1.2.jar;D:\dayunMaven\org\apache\htrace\htrace-core\3.1.0-incubating\htrace-core-3.1.0-incubating.jar;D:\dayunMaven\log4j\log4j\1.2.17\log4j-1.2.17.jar;D:\dayunMaven\org\apache\yetus\audience-annotations\0.5.0\audience-annotations-0.5.0.jar;D:\dayunMaven\junit\junit\4.12\junit-4.12.jar;D:\dayunMaven\org\hamcrest\hamcrest-core\1.3\hamcrest-core-1.3.jar;D:\dayunMaven\org\apache\hadoop\hadoop-common\3.0.0\hadoop-common-3.0.0.jar;D:\dayunMaven\com\google\guava\guava\11.0.2\guava-11.0.2.jar;D:\dayunMaven\commons-cli\commons-cli\1.2\commons-cli-1.2.jar;D:\dayunMaven\org\apache\commons\commons-math3\3.1.1\commons-math3-3.1.1.jar;D:\dayunMaven\org\apache\httpcomponents\httpclient\4.5.2\httpclient-4.5.2.jar;D:\dayunMaven\org\apache\httpcomponents\httpcore\4.4.4\httpcore-4.4.4.jar;D:\dayunMaven\commons-codec\commons-codec\1.4\commons-codec-1.4.jar;D:\dayunMaven\commons-io\commons-io\2.4\commons-io-2.4.jar;D:\dayunMaven\commons-net\commons-net\3.1\commons-net-3.1.jar;D:\dayunMaven\commons-collections\commons-collections\3.2.2\commons-collections-3.2.2.jar;D:\dayunMaven\javax\servlet\javax.servlet-api\3.1.0\javax.servlet-api-3.1.0.jar;D:\dayunMaven\javax\servlet\jsp\jsp-api\2.1\jsp-api-2.1.jar;D:\dayunMaven\com\sun\jersey\jersey-core\1.19\jersey-core-1.19.jar;D:\dayunMaven\javax\ws\rs\jsr311-api\1.1.1\jsr311-api-1.1.1.jar;D:\dayunMaven\com\sun\jersey\jersey-servlet\1.19\jersey-servlet-1.19.jar;D:\dayunMaven\com\sun\jersey\jersey-json\1.19\jersey-json-1.19.jar;D:\dayunMaven\org\codehaus\jettison\jettison\1.1\jettison-1.1.jar;D:\dayunMaven\com\sun\xml\bind\jaxb-impl\2.2.3-1\jaxb-impl-2.2.3-1.jar;D:\dayunMaven\org\codehaus\jackson\jackson-core-asl\1.9.2\jackson-core-asl-1.9.2.jar;D:\dayunMaven\org\codehaus\jackson\jackson-mapper-asl\1.9.2\jackson-mapper-asl-1.9.2.jar;D:\dayunMaven\org\codehaus\jackson\jackson-jaxrs\1.9.2\jackson-jaxrs-1.9.2.jar;D:\dayunMaven\org\codehaus\jackson\jackson-xc\1.9.2\jackson-xc-1.9.2.jar;D:\dayunMaven\com\sun\jersey\jersey-server\1.19\jersey-server-1.19.jar;D:\dayunMaven\commons-beanutils\commons-beanutils\1.9.3\commons-beanutils-1.9.3.jar;D:\dayunMaven\org\apache\commons\commons-configuration2\2.1.1\commons-configuration2-2.1.1.jar;D:\dayunMaven\org\apache\commons\commons-lang3\3.4\commons-lang3-3.4.jar;D:\dayunMaven\org\slf4j\slf4j-log4j12\1.7.25\slf4j-log4j12-1.7.25.jar;D:\dayunMaven\org\apache\avro\avro\1.7.7\avro-1.7.7.jar;D:\dayunMaven\com\thoughtworks\paranamer\paranamer\2.3\paranamer-2.3.jar;D:\dayunMaven\org\xerial\snappy\snappy-java\1.0.5\snappy-java-1.0.5.jar;D:\dayunMaven\com\google\re2j\re2j\1.1\re2j-1.1.jar;D:\dayunMaven\com\google\protobuf\protobuf-java\2.5.0\protobuf-java-2.5.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-auth\3.0.0\hadoop-auth-3.0.0.jar;D:\dayunMaven\com\nimbusds\nimbus-jose-jwt\4.41.1\nimbus-jose-jwt-4.41.1.jar;D:\dayunMaven\com\github\stephenc\jcip\jcip-annotations\1.0-1\jcip-annotations-1.0-1.jar;D:\dayunMaven\org\apache\curator\curator-framework\2.12.0\curator-framework-2.12.0.jar;D:\dayunMaven\com\jcraft\jsch\0.1.54\jsch-0.1.54.jar;D:\dayunMaven\org\apache\curator\curator-client\2.12.0\curator-client-2.12.0.jar;D:\dayunMaven\org\apache\curator\curator-recipes\2.12.0\curator-recipes-2.12.0.jar;D:\dayunMaven\com\google\code\findbugs\jsr305\3.0.0\jsr305-3.0.0.jar;D:\dayunMaven\org\apache\zookeeper\zookeeper\3.4.9\zookeeper-3.4.9.jar;D:\dayunMaven\jline\jline\0.9.94\jline-0.9.94.jar;D:\dayunMaven\io\netty\netty\3.10.5.Final\netty-3.10.5.Final.jar;D:\dayunMaven\org\apache\commons\commons-compress\1.4.1\commons-compress-1.4.1.jar;D:\dayunMaven\org\tukaani\xz\1.0\xz-1.0.jar;D:\dayunMaven\org\apache\kerby\kerb-simplekdc\1.0.1\kerb-simplekdc-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-client\1.0.1\kerb-client-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerby-config\1.0.1\kerby-config-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-core\1.0.1\kerb-core-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerby-pkix\1.0.1\kerby-pkix-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerby-asn1\1.0.1\kerby-asn1-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerby-util\1.0.1\kerby-util-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-common\1.0.1\kerb-common-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-crypto\1.0.1\kerb-crypto-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-util\1.0.1\kerb-util-1.0.1.jar;D:\dayunMaven\org\apache\kerby\token-provider\1.0.1\token-provider-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-admin\1.0.1\kerb-admin-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-server\1.0.1\kerb-server-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-identity\1.0.1\kerb-identity-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerby-xdr\1.0.1\kerby-xdr-1.0.1.jar;D:\dayunMaven\org\codehaus\woodstox\stax2-api\3.1.4\stax2-api-3.1.4.jar;D:\dayunMaven\com\fasterxml\woodstox\woodstox-core\5.0.3\woodstox-core-5.0.3.jar;D:\dayunMaven\com\fasterxml\jackson\core\jackson-databind\2.9.6\jackson-databind-2.9.6.jar;D:\dayunMaven\com\fasterxml\jackson\core\jackson-core\2.9.6\jackson-core-2.9.6.jar;D:\dayunMaven\com\fasterxml\jackson\datatype\jackson-datatype-jsr310\2.9.6\jackson-datatype-jsr310-2.9.6.jar;D:\dayunMaven\com\google\code\gson\gson\2.6.2\gson-2.6.2.jar;D:\Program Files\JetBrains\IntelliJ IDEA 2020.2.4\lib\idea_rt.jar</span><br><span class="line">user.name-------yesway</span><br><span class="line">java.vm.specification.version-------1.8</span><br><span class="line">sun.java.command-------com.dayunmotor.forward.hbase.ForwardHbaseApplication</span><br><span class="line">java.home-------C:\Program Files\Java\jdk1.8.0_60\jre</span><br><span class="line">sun.arch.data.model-------64</span><br><span class="line">user.language-------zh</span><br><span class="line">java.specification.vendor-------Oracle Corporation</span><br><span class="line">awt.toolkit-------sun.awt.windows.WToolkit</span><br><span class="line">java.vm.info-------mixed mode</span><br><span class="line">java.version-------1.8.0_60</span><br><span class="line">java.ext.dirs-------C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext;C:\WINDOWS\Sun\Java\lib\ext</span><br><span class="line">sun.boot.class.path-------C:\Program Files\Java\jdk1.8.0_60\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\rt.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\sunrsasign.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_60\jre\classes</span><br><span class="line">java.vendor-------Oracle Corporation</span><br><span class="line">file.separator-------\</span><br><span class="line">java.vendor.url.bug-------http://bugreport.sun.com/bugreport/</span><br><span class="line">sun.io.unicode.encoding-------UnicodeLittle</span><br><span class="line">sun.cpu.endian-------little</span><br><span class="line">sun.desktop-------windows</span><br><span class="line">sun.cpu.isalist-------amd64</span><br></pre></td></tr></table></figure>


<h3 id="用反射获取Java对象中所有的属性名称和属性值"><a href="#用反射获取Java对象中所有的属性名称和属性值" class="headerlink" title="用反射获取Java对象中所有的属性名称和属性值"></a>用反射获取Java对象中所有的属性名称和属性值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ReflectTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws NoSuchMethodException &#123;</span><br><span class="line">        Person person = new Person(&quot;zhangsan&quot;, 30, &quot;男&quot;);</span><br><span class="line">        StringBuilder sbName = new StringBuilder();</span><br><span class="line">        StringBuilder sbValue = new StringBuilder();</span><br><span class="line">        String[] fieldNames = getFiledName(person);</span><br><span class="line"></span><br><span class="line">        for(int j=0 ; j&lt;fieldNames.length ; j++)&#123; //遍历所有属性</span><br><span class="line">            String name = fieldNames[j]; //获取属性的名字</span><br><span class="line">            Object value = getFieldValueByName(name, person);</span><br><span class="line">            sbName.append(name);</span><br><span class="line">            sbValue.append(value);</span><br><span class="line">            if(j != fieldNames.length - 1) &#123;</span><br><span class="line">                sbName.append(&quot;/&quot;);</span><br><span class="line">                sbValue.append(&quot;/&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;attribute name:&quot;+sbName.toString());</span><br><span class="line">        System.out.println(&quot;attribute value:&quot;+sbValue.toString());</span><br><span class="line">        // 根据Method获取类名</span><br><span class="line">        Method method = person.getClass().getMethod(&quot;printName&quot;, new Class[] &#123;&#125;);</span><br><span class="line">        String className = method.getDeclaringClass().getName(); //类名</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        System.out.println(&quot;full name:&quot; + className + &quot;.&quot; + methodName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取属性名数组</span><br><span class="line">     * */</span><br><span class="line">    private static String[] getFiledName(Object o)&#123;</span><br><span class="line">        Field[] fields=o.getClass().getDeclaredFields();</span><br><span class="line">        String[] fieldNames=new String[fields.length];</span><br><span class="line">        for(int i=0;i&lt;fields.length;i++)&#123;</span><br><span class="line">            // System.out.println(fields[i].getType());</span><br><span class="line">            fieldNames[i]=fields[i].getName();</span><br><span class="line">        &#125;</span><br><span class="line">        return fieldNames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据属性名获取属性值</span><br><span class="line">     **/</span><br><span class="line">    private static Object getFieldValueByName(String fieldName, Object o) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String firstLetter = fieldName.substring(0, 1).toUpperCase();</span><br><span class="line">            String getter = &quot;get&quot; + firstLetter + fieldName.substring(1);</span><br><span class="line">            Method method = o.getClass().getMethod(getter, new Class[] &#123;&#125;);</span><br><span class="line">            Object value = method.invoke(o, new Object[] &#123;&#125;);</span><br><span class="line">            return value;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Person &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private int age;</span><br><span class="line">        private String gender;</span><br><span class="line"></span><br><span class="line">        public Person(String n,int a,String g) &#123;</span><br><span class="line">            name = n;</span><br><span class="line">            age = a;</span><br><span class="line">            gender = g;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getAge() &#123;</span><br><span class="line">            return age;</span><br><span class="line">        &#125;</span><br><span class="line">        public String getGender() &#123;</span><br><span class="line">            return gender;</span><br><span class="line">        &#125;</span><br><span class="line">        public void printName() &#123;</span><br><span class="line">            System.out.println(&quot;name is &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://www.cnblogs.com/xiadongqing/p/16298207.html">https://www.cnblogs.com/xiadongqing/p/16298207.html</a></p>
<p>关于反射的概念：<br>Java中的反射是通过反射API来实现的。Java反射API主要包括以下几个重要的类和接口：<br>1、Class 类：表示一个类或接口，在运行时JVM中每个类都有一个对应的Class对象。<br>2、Constructor类：表示一个类的构造方法。<br>3、Method 类：表示一个类的方法。<br>4、Field 类：表示一个类的成员变量（字段）。</p>
<p>反射实现的核心是 Class 类，一个类在编译后会生成对应的 class文件，这个文件中包含了类的结构信息，包括字段、方法、构造函数等信息。在运行时，JVM会读取这个 文件并将其加载到内存中。当需要使用一个类时，JVM会通过类的全限定名来找到对应的 class 文件，并将其加载到内存中。在加载后，JVM 会为每个类创建一个对应的 Class对象，该对象包含了类的所有结构信息。</p>
<p>通过 Class 对象可以获取类的所有结构信息，包括构造函数、方法、字段等。可以通过 Constructor、Method 和Field 等类来表示类的构造函数、方法和字段，通过这些类可以获取和调用类的构造函数数、方法和字段。</p>
<p>反射的实现主要依靠JVM 中的类加载机制和 Class对象，通过 class 对象可以获取类的所有结构信息，通过这些信息可以实现对类的动态操作。在运行时，通过反射可以动态地创建对象、调用方法、访问字段等，从而实现了比较灵活的编程方式。</p>
<p>反射是指在程序运行时动态获取对象信息的能力。它可以让程序在运行时通过对象的引用来获取对象的类型信息、属性、方法等，而不需要在编译时进行硬编码。具体实现反射的方式是通过反射APl来获取对象的类信息，包括类名、父类、接口、方法、属性等，然后通过反射API提供的方法来操作这些信息。在Java中，反射API主要包括 Class 类、Constructor类、Field类和Method类等。通过这些类，可以实现动态创建对象、调用方法、获取属性等操作。</p>
<p>反射是一种强大的编程技术，但也需要谨慎使用，因为它会增加代码的复杂度和运行时开销。</p>
<h3 id="java中的StopWatch"><a href="#java中的StopWatch" class="headerlink" title="java中的StopWatch"></a>java中的StopWatch</h3><p>StopWatch不在java标准包中的，可以在以下两个程序包中找到StopWatch工具类</p>
<p>org.apache.commons.lang3.time<br>Apache Commons Lang提供了一些Java标准库中没有提供的类与方法，尤其是在String操作方法，基础数值方法，对象引用，并发行，创建及序列化，系统属性等方面提供了强大的功能</p>
<p>org.springframework.util<br>spring框架为现代java企业级应用提供了一个简洁并且富有表达能力的可以运行在任何部署平台的编程与设置模型</p>
<p>看一下spring中的怎么用，可以优雅地打印出多个任务的详细耗时情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class StopWatchTest &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        StopWatch sw = new StopWatch(&quot;模板测试&quot;);</span><br><span class="line"></span><br><span class="line">        sw.start(&quot;任务1&quot;);</span><br><span class="line">        Thread.sleep(1000 * 1);</span><br><span class="line">        sw.stop();</span><br><span class="line"></span><br><span class="line">        sw.start(&quot;任务2&quot;);</span><br><span class="line">        Thread.sleep(1000 * 2);</span><br><span class="line">        sw.stop();</span><br><span class="line"></span><br><span class="line">        sw.start(&quot;任务3&quot;);</span><br><span class="line">        Thread.sleep(1000 * 3);</span><br><span class="line">        sw.stop();</span><br><span class="line"></span><br><span class="line">        //打印各子任务耗时比例</span><br><span class="line">        System.out.println(sw.prettyPrint());</span><br><span class="line">        System.out.println(&quot;所有任务总耗时：&quot; + sw.getTotalTimeMillis() + &quot;ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多：<a href="https://blog.csdn.net/qfzhaohan/article/details/121379893">https://blog.csdn.net/qfzhaohan/article/details/121379893</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java常规接口、类</title>
    <url>/2022/04/30/myblog/java/java%E6%8E%A5%E5%8F%A3&amp;%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h3><p>位于java.io.Serializable包中，一般在创建实体类的时候会去实现这个接口，目的是为了序列化。</p>
<p>序列化指的是把对象转化成字节序列的过程，就是把内存中的对象转换成一连串的字节bytes描述的过程。<br>反序列化就是将字节bytes数据恢复为对象的过程。</p>
<p>需要将内存中对象状态数据保存到文件或数据库中时，需要进行序列化。这个比较直观的就是通过ObjectOutputStream和FileOutputStream向文件中保存对象时，实现了Serializable接口的对象会以二进制数据的形式保存到文件中，而未实现Serializable接口的对象则会直接报错，无法保存。</p>
<p>serialVersionUID：<br>如果在进行反序列化前，将某个实体类原有的serialVersionUID改变，在进行反序列化时就会报InvalidClassException异常。<br>如果没有指定serialVersionUID，在进行序列化时，JVM会通过计算给该类一个默认的serialVersionUID值。<br>但是不建议不指定serialVersionUID，高度依赖于JVM默认生成serialVersionUID，可能会导致其与编译器的实现细节耦合，这样可能会导致在反序列化的过程中发生意外的InvalidClassException异常。个人认为应该是指不同编译器编译的不同类可能产生一个相同的默认serialVersionUID。<br>另外尽量用private来修饰serialVersionUID。</p>
<hr>
<p>Serializable其实是个空接口，用来标识当前类可以被序列化。<br>告诉jvm，让jvm帮忙做序列化。</p>
<p>实现了Serializable接口的类可以被ObjectOutputStream转换为字节流，同时也可以通过ObjectInputStream再将其解析为对象。</p>
<p>✅什么是序列化？</p>
<p>序列化（serialize） - 序列化是将对象转换为字节流。<br>反序列化（deserialize） - 反序列化是将字节流转换为对象。</p>
<p>作用：<br>序列化可以将对象的字节序列持久化——保存在内存、文件、数据库中。<br>在网络上传送对象的字节序列。<br>RMI(远程方法调用)</p>
<p>什么时候用：<br>1、想把内存中的对象状态保存到一个文件中或者数据库中时<br>2、想把对象通过网络进行传输时</p>
<p>✅如何使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Gender类，表示性别</span><br><span class="line">// 每个枚举类型都会默认继承类java.lang.Enum，而Enum类实现了Serializable接口，所以枚举类型对象都是默认可以被序列化的。</span><br><span class="line">public enum Gender &#123;  </span><br><span class="line">    MALE, FEMALE  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// Person 类实现了 Serializable 接口，它包含三个字段。另外，它还重写了该类的 toString() 方法，以方便打印 Person 实例中的内容。</span><br><span class="line">public class Person implements Serializable &#123;  </span><br><span class="line">    private String name = null;  </span><br><span class="line">    private Integer age = null;  </span><br><span class="line">    private Gender gender = null;  </span><br><span class="line"></span><br><span class="line">    public Person() &#123;  </span><br><span class="line">        System.out.println(&quot;none-arg constructor&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    public Person(String name, Integer age, Gender gender) &#123;  </span><br><span class="line">        System.out.println(&quot;arg constructor&quot;);  </span><br><span class="line">        this.name = name;  </span><br><span class="line">        this.age = age;  </span><br><span class="line">        this.gender = gender;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    // 省略 set get 方法</span><br><span class="line">    @Override </span><br><span class="line">    public String toString() &#123;  </span><br><span class="line">        return &quot;[&quot; + name + &quot;, &quot; + age + &quot;, &quot; + gender + &quot;]&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">// SimpleSerial类，是一个简单的序列化程序，它先将Person对象保存到文件person.out中，然后再从该文件中读出被存储的Person对象，并打印该对象。</span><br><span class="line">public class SimpleSerial &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        File file = new File(&quot;person.out&quot;);  </span><br><span class="line">        ObjectOutputStream oout = new ObjectOutputStream(new FileOutputStream(file)); // 注意这里使用的是 ObjectOutputStream 对象输出流封装其他的输出流</span><br><span class="line">        Person person = new Person(&quot;John&quot;, 101, Gender.MALE);  </span><br><span class="line">        oout.writeObject(person);  </span><br><span class="line">        oout.close();  </span><br><span class="line"> </span><br><span class="line">        ObjectInputStream oin = new ObjectInputStream(new FileInputStream(file));  // 使用对象输入流读取序列化的对象</span><br><span class="line">        Object newPerson = oin.readObject(); // 没有强制转换到Person类型  </span><br><span class="line">        oin.close();  </span><br><span class="line">        System.out.println(newPerson);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">// 上述程序的输出的结果为：</span><br><span class="line">arg constructor  </span><br><span class="line">[John, 31, MALE]</span><br></pre></td></tr></table></figure>

<p>转自：简书<br><a href="https://www.jianshu.com/p/8e4a9cac727f">https://www.jianshu.com/p/8e4a9cac727f</a></p>
<p>csdn：<a href="https://blog.csdn.net/u011568312/article/details/57611440">https://blog.csdn.net/u011568312/article/details/57611440</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">✅Serializable是java中的一个接口，主要用于实现对象的序列化和反序列化。</span><br><span class="line">序列化是将对象转换成字节流的过程，通常用于将对象保存到文件中或网络中。</span><br><span class="line">反序列化是将字节流转换回对象的过程，通常用于读取文件或网络中的对象。</span><br><span class="line"></span><br><span class="line">实现Serializable接口后，就可以使用java提供的ObjectOutputStream和ObjectInputStream将对象序列化和反序列化。</span><br><span class="line"></span><br><span class="line">将一个Person对象序列化到文件中：</span><br><span class="line">Person person = new Person(&quot;name&quot;);</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;person.txt&quot;);</span><br><span class="line">ObjectOutputStream oos = new ObjectOutputStream(fos);</span><br><span class="line">oos.writeObject(person);</span><br><span class="line"></span><br><span class="line">从文件中读取一个Person对象并反序列化：</span><br><span class="line">FileInputStream fis = new FileInputStream(&quot;person.txt&quot;);</span><br><span class="line">ObjectInputStream ois = new ObjectInputStream(fis);</span><br><span class="line">Person person = (Person)ois.readObject();</span><br><span class="line"></span><br><span class="line">反序列化和序列化的过程中，需要保证对象的所有属性都是可序列化的，</span><br><span class="line">如果某个属性不可序列化，可以使用transient关键字修饰，表示该属性不参与序列化。</span><br><span class="line">private transient int age;</span><br><span class="line"></span><br><span class="line">✅Serializable和JSON序列化的关系是什么？</span><br><span class="line">Serializable和JSON序列化都是java中两种不同的序列化方式，它们各自有不同的应用场景和特点。</span><br><span class="line"></span><br><span class="line">Serializable 是Java 中的一种默认的序列化方式，它是将对象序列化为二进制格式，</span><br><span class="line">可以将Java 对象存储到文件或网络中。serializable 序列化方式可以支持 Java 中的所有类和对象，包括自定义类和第三方库中的类，但是序列化后的数据通常比较难以阅读和处理。</span><br><span class="line">JSON 序列化是将对象序列化为 JSON 格式，可以将Java 对象转换为 JSON 字符串或字节数组，</span><br><span class="line">通常用于 Web 应用中的数据传输、API接口的开发等场景。</span><br><span class="line">与Serializable 序列化方式不同，JSON 序列化可以跨语言使用，因为 JSON 格式是一种通用的数据交换格式，可以被几乎所有编程语言解析和处理。</span><br><span class="line">在Java 中，使用JSON 序列化可以使用第三方库，例如 Jackson、Gson 等等。这些库提供了丰富的 API 和配置选项，可以方便地将Java对象序列化为JSON 格式，并且支持反序列化，将JSON 格式的宇符串或字节数组转换回 Java 对象。</span><br><span class="line"></span><br><span class="line">✅被@RequestBody修饰的自定义变量需要实现Serializable吗？</span><br><span class="line">在 Spring MVC 中，@ReauestBody注解用于接收 HTTP 请求中的JSONXML格式的数据，并将其转换为 Java 对象。</span><br><span class="line">被 @RequestBody 修饰的自定义变量在接收请求数据并进行转换时，并不需要实现 Serializable 接口。</span><br><span class="line">Serializable 接口主要用于 Java 对象的序列化和反序列化，即将 Java 对象转换为字节流，或将字节流转换为 Java 对象。</span><br><span class="line">而 @RequestBody 注解接收的请求数据是 JSON/XML格式的宇符串，而不是Java 对象的字节流，因此不需要实现 Serializable 接口。</span><br><span class="line"></span><br><span class="line">✅什么情况下的网络传输需要自定义变量实现 Serializable？</span><br><span class="line">在Java 中，如果需要将对象通过网络进行传输，需要将对象序列化为二进制格式，然后再进行传输。</span><br><span class="line">此时，被传输的对象需要实现 Serializable 接口，确保对象的属性可以被正确地序列化和反序列化。</span><br><span class="line">实现 Serializable 接口的对象可以被序列化为二进制格式，然后通过网络进行传输。在网络传输的过程中，JVM 会将对象转换为字节流，然后发送到其他计算机上，接收方再将字节流转换为对象。</span><br><span class="line"></span><br><span class="line">1远程方法调用 (Remote Method lInvocation，简称 RMI)：RMI允许Java 程序在分布式网络环境中进行远程方法调用，其中需要将方法的参数和返回值通过网络进行传输，因此需要使用 Serializable 序列化传输的对象。</span><br><span class="line">2.Java 序列化和反序列化框架：例如 Spring Boot、Apache Dubb。 等框架，它们可以将Java 对象序列化为二进制格式，并进行网络传输，以实现分布式系统的开发和部署。</span><br><span class="line">3. Web 应用中的数据传输：例如使用 Ajax 向服务器发送数据，在服务器和客户端之间传递JSON 或 xML格式的数据等场景。</span><br><span class="line"></span><br><span class="line">@JSONField(serialize = false)什么意思？</span><br><span class="line">@JSONField(serialize = false) 是阿里巴巴 FastJSON 库摄供的一个注解，</span><br><span class="line">用于在将 Java 对象序列化为 JSON 字符串时，忽略当前属性的值。</span><br><span class="line">该注解可以用在 Java类的属性上，表示在序列化时不将该属性的值序列化到 JSON 宇符串中。</span><br></pre></td></tr></table></figure>

<h3 id="MultipartFile接口"><a href="#MultipartFile接口" class="headerlink" title="MultipartFile接口"></a>MultipartFile接口</h3><p>用于http中获取前台传来的文件</p>
<p>位于：package org.springframework.web.multipart;包下<br>中文名：多组件文档<br>继承自：InputStreamSource,并封装了getInputStream()方法<br>此方法用法：<code>@RequesParam(&quot;file&quot;)MultipartFile file</code><br><code>InputStream is  = file.getInputStream();</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String getName():得到的是@RequesParam(value = &quot;file&quot;)中的value值，不会为空。</span><br><span class="line">String getOriginalFilename():获取的是文件的完整名称，包括文件名称+文件拓展名。</span><br><span class="line">String getContentType()：返回文件内容类型，不是文件扩展名（例如：jpeg图片：image/jpeg）</span><br><span class="line">boolean isEmpty()：返回上传的文件是否为空，即multipart形式中没有选择任何文件或者选择的文件没有内容</span><br><span class="line">long getSize()：以字节为单位返回文件大小</span><br><span class="line">byte[] getBytes()：以字节数组的形式返回文件内容</span><br><span class="line">InputStream getInputStream()：返回一个字节流</span><br><span class="line">void transferTo()：用来将接收文件传输到给定目标路径，会抛出IOException、IllegalStateException异常。该方法在实际项目开发中使用较少。</span><br></pre></td></tr></table></figure>





<h3 id="Pattern类-Matcher类"><a href="#Pattern类-Matcher类" class="headerlink" title="Pattern类&amp;Matcher类"></a>Pattern类&amp;Matcher类</h3><p>Pattern类是java.util.regex包中的final类。是正则表达式的编译表示形式，此类的实例是不可变的，可供多个并发线程安全使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义</span><br><span class="line">public final class Pattern extends Object implements Serializable</span><br><span class="line"></span><br><span class="line">//Pattern调用静态方法compile返回Pattern实例。</span><br><span class="line">// 将给定的正则表达式编译并赋予给Pattern类</span><br><span class="line">Pattern pattern = Pattern.compile(paternStr);</span><br><span class="line"></span><br><span class="line">// 增加flag参数的指定，可选的flag参数包括：CASE INSENSITIVE,MULTILINE,DOTALL,UNICODE CASE， CANON EQ </span><br><span class="line">static Pattern compile(String regex, int flags) </span><br><span class="line">//先不明白</span><br><span class="line"></span><br><span class="line">//Pattern.split()（静态方法）和string.split()用途一样，</span><br><span class="line">//是将字符串从正则表达式匹配的地方分开</span><br><span class="line">String input = &quot;This!!unusual use!!hh!!points&quot;;</span><br><span class="line">System.out.println(Arrays.toString(Pattern.compile(&quot;!!&quot;).split(input)));</span><br><span class="line">System.out.println(Arrays.toString(Pattern.compile(&quot;!!&quot;).split(input, 3)));</span><br><span class="line">// 第二种，第二个参数用来限制将输入分割成字符串的数量</span><br></pre></td></tr></table></figure>

<p>正则表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\d 表示数字，前面多了第一个\，是转义的意思。</span><br><span class="line">+表示重复前面的</span><br><span class="line">\\d+ 表示多个数字</span><br></pre></td></tr></table></figure>

<p>Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查，此类的实例用于多个并发线程是不安全的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pattern.matcher 静态方法：</span><br><span class="line">Pattern.matcher(String regex,CharSequence input)</span><br><span class="line">静态方法,用于快速匹配字符串,匹配全部字符串</span><br><span class="line"></span><br><span class="line">pattern.matcher(CharSequence input):</span><br><span class="line">返回一个Matcher对象。</span><br><span class="line">Matcher类的构造方法也是私有的,不能随意创建,</span><br><span class="line">只能通过pattern.matcher(CharSequence input)方法得到该类的实例</span><br><span class="line"></span><br><span class="line">Pattern p=Pattern.compile(&quot;\\d+&quot;); </span><br><span class="line">Matcher m=p.matcher(&quot;22bb23&quot;); </span><br><span class="line">m.pattern();//返回p 也就是返回该Matcher对象是由哪个Pattern对象的创建的</span><br></pre></td></tr></table></figure>

<p>用Pattern以及Matcher匹配例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str = &quot;aa11bb&quot;;</span><br><span class="line">String paternStr = &quot;\\d+&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(paternStr);</span><br><span class="line">Matcher matcher = pattern.matcher(str);</span><br><span class="line">if (matcher.find()) &#123;   //有匹配就行</span><br><span class="line">    System.out.println(matcher.group(0));  //输出11</span><br><span class="line">&#125;</span><br><span class="line">if (matcher.matches()) &#123;  //需要完全匹配</span><br><span class="line">    System.out.println(matcher.group(0));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>更多方法：<br><a href="https://blog.csdn.net/woniu317/article/details/52186694">https://blog.csdn.net/woniu317/article/details/52186694</a><br><a href="http://www.51gjie.com/java/759.html">http://www.51gjie.com/java/759.html</a></p>
<h3 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h3><p>JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 java.util.function 包中被提供。 </p>
<p>java.util.function.Function&lt;T,R&gt; 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Function&lt;T, R&gt; &#123;</span><br><span class="line">    R apply(T t);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：起到了转换类型的作用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FunctionTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        method(s -&gt; Integer.parseInt(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void method(Function&lt;String, Integer&gt; function) &#123;</span><br><span class="line">        int num = function.apply(&quot;10&quot;);</span><br><span class="line">        System.out.println(num + 20);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他方法：如andThen方法<br><a href="http://t.zoukankan.com/liyihua-p-12286100.html">http://t.zoukankan.com/liyihua-p-12286100.html</a></p>
<p>和@FunctionalInterface作用一样？</p>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口就是只有一个抽象方法的接口。</p>
<p>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。可以有多个default方法。</p>
<p>为了避免别人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成”非函数接口”，可以在接口上加上一个注解<code>@FunctionalInterface</code>, 这样别人就无法在里面添加新的接口函数了。</p>
<p><code>@FunctionalInterface public interface Function&lt;T, R&gt; &#123;   &#125;</code></p>
<p>在java.util.function包下：</p>
<h4 id="✅Function接口"><a href="#✅Function接口" class="headerlink" title="✅Function接口"></a>✅Function接口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Function&lt;T, R&gt; &#123;</span><br><span class="line">    R apply(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数型接口：<code>Function&lt;T, R&gt;</code>，有参有返回值，接受一个T类型的参数，并返回一个R类型的返回值。</p>
<p>其中的抽象方法：<code>R apply(T t);</code></p>
<p>T是输入，R是输出，表示一个类型转换，lambda表达式实现apply方法。<br>stream的map方法，传参就是Function，表示映射。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FunctionTest &#123;</span><br><span class="line">    Function&lt;String, String&gt; function = (str) -&gt; &#123;</span><br><span class="line">        return &quot;hello,&quot; + str;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    String funDemo(String str2, Function&lt;String, String&gt; function) &#123;</span><br><span class="line">        return function.apply(str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testFunDemo() &#123;</span><br><span class="line">        System.out.println(funDemo(&quot;小明&quot;, function));</span><br><span class="line">        System.out.println(funDemo(&quot;小美&quot;, str -&gt; &quot;hello&quot;+str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅Predicate接口"><a href="#✅Predicate接口" class="headerlink" title="✅Predicate接口"></a>✅Predicate接口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Predicate&lt;T&gt; &#123;</span><br><span class="line">    boolean test(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>断言型接口：<code>Predicate&lt;T&gt;</code> 有参有返回值，返回值是boolean类型，用来判断某项条件是否满足。经常用来进行筛滤操作。</p>
<p>其中的抽象方法：<code>boolean test(T t);</code></p>
<p>T是输入，输出boolean类型，表示一种条件过滤。<br>stream的filter方法穿参是Predicate。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PredicateTest &#123;</span><br><span class="line">    Predicate&lt;Integer&gt; predicate = (i) -&gt; &#123;</span><br><span class="line">        return i &gt; 10;</span><br><span class="line">    &#125;;</span><br><span class="line">    boolean preDemo(Integer i, Predicate&lt;Integer&gt; predicate) &#123;</span><br><span class="line">        return predicate.test(i);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void testPreDemo() &#123;</span><br><span class="line">        System.out.println(preDemo(12, predicate));//打印结果：true</span><br><span class="line">        System.out.println(preDemo(12, i -&gt; i &gt; 13));//打印结果：false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅Consumer接口"><a href="#✅Consumer接口" class="headerlink" title="✅Consumer接口"></a>✅Consumer接口</h4><p>消费型接口：Consumer 有参无返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Consumer&lt;T&gt; &#123;</span><br><span class="line">    void accept(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConsumerTest &#123;</span><br><span class="line">    Consumer&lt;String&gt; consumer = (str) -&gt; &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;;</span><br><span class="line">    public void conDemo(String str, Consumer&lt;String&gt; consumer) &#123;</span><br><span class="line">        consumer.accept(str);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void testConDemo() &#123;</span><br><span class="line">        conDemo(&quot;hello&quot;, consumer);//打印结果：hello</span><br><span class="line">        conDemo(&quot;hello&quot;, s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>更多函数式接口：<br><a href="https://blog.csdn.net/weixin_45580378/article/details/124853396">https://blog.csdn.net/weixin_45580378/article/details/124853396</a></p>
<p>迷惑：<br>1.函数式接口中的default方法是干嘛的<br>2.泛型。<code>Function&lt;T, R&gt;</code>代表两个泛型；<code>Function&lt;? super T, ? extends R&gt; mapper</code>代表限制泛型类型？</p>
<h4 id="✅Supplier接口"><a href="#✅Supplier接口" class="headerlink" title="✅Supplier接口"></a>✅Supplier接口</h4><p>供给型接口：Supplier 无参有返回值，用于提供数据源的。</p>
<p>该接口通常用于延迟计算，只有在需要结果的时候才进行计算，可以被用作一种工厂模式，生产不同的对象，具体实现可以由Lambda表达式传入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Supplier&lt;String&gt; supplier = () -&gt; &quot;hello&quot;;</span><br><span class="line">String res = supplier.get();</span><br><span class="line">System.out.println(res);</span><br></pre></td></tr></table></figure>

<h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>Java 8 提供的，是一个包含有可选值的包装类，这意味着 Optional 类既可以含有对象也可以为空。</p>
<p>Optional，可以避免没有必要的 null 值检查.</p>
<p><code>public final class Optional&lt;T&gt; &#123;&#125;</code></p>
<p>Optional 是 Java 实现函数式编程的强劲一步，并且帮助在范式中实现。<br>在 Java 8 之前，任何访问对象方法或属性的调用都可能导致NullPointerException.</p>
<p>✅创建Optional对象</p>
<p>1）可以使用静态方法 empty() 创建一个空的 Optional 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; empty = Optional.empty();</span><br><span class="line">System.out.println(empty); // 输出：Optional.empty</span><br><span class="line"></span><br><span class="line">@Test(expected = NoSuchElementException.class)</span><br><span class="line">public void whenCreateEmptyOptional_thenNull() &#123;</span><br><span class="line">    Optional&lt;Person&gt; emptyOpt = Optional.empty();</span><br><span class="line">    System.out.println(emptyOpt);</span><br><span class="line">    emptyOpt.get(); //NoSuchElementException</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）可以使用静态方法 of() 创建一个非空的 Optional 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(&quot;11&quot;);</span><br><span class="line">System.out.println(opt); // 输出：Optional[11]</span><br></pre></td></tr></table></figure>

<p>传递给 of() 方法的参数必须是非空的，也就是说不能为 null，否则仍然会抛出 NullPointerException。</p>
<p>3）可以使用静态方法 ofNullable() 创建一个即可空又可非空的 Optional 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String name = null;</span><br><span class="line">Optional&lt;String&gt; optOrNull = Optional.ofNullable(name);</span><br><span class="line">System.out.println(optOrNull); // 输出：Optional.empty</span><br></pre></td></tr></table></figure>

<p>✅ifPresent方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean isPresent() &#123;</span><br><span class="line">    return value != null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void ifPresent(Consumer&lt;? super T&gt; consumer) &#123;</span><br><span class="line">    if (value != null)</span><br><span class="line">        consumer.accept(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过方法 isPresent() 判断一个 Optional 对象是否存在，如果存在，该方法返回 true，否则返回 false——取代了 obj !&#x3D; null 的判断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(&quot;11&quot;);</span><br><span class="line">System.out.println(opt.isPresent()); // 输出：false</span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; optOrNull = Optional.ofNullable(null);</span><br><span class="line">System.out.println(opt.isPresent()); // 输出：true</span><br></pre></td></tr></table></figure>

<p>ifPresent(Consumer&lt;? super T&gt; consumer) 是如果不为null的话，对对象做什么操作。</p>
<p>java中的Optional：<br><a href="https://www.jb51.net/article/214824.htm">https://www.jb51.net/article/214824.htm</a><br>一文彻底搞懂 Java 的 Optional：<br><a href="https://blog.csdn.net/qing_gee/article/details/104767082">https://blog.csdn.net/qing_gee/article/details/104767082</a></p>
<h3 id="GenericConverter接口"><a href="#GenericConverter接口" class="headerlink" title="GenericConverter接口"></a>GenericConverter接口</h3><p>是spring框架中用于进行类型转换的接口，可以将一种类型的对象转换成另一种类型的对象。</p>
<p>GenericConverter是converter接口的一个比较精致的实现，它支持多个source和目标类型的转化，同时还提供了source和目标类型的上下文，这个上下文能让你实现基于属性上的注解或信息来进行类型转换。</p>
<p>getConvertibleTypes返回一个source-&gt;target的键值对，然后通过实现convert接口来实现你的转换逻辑。sourceTypeDescrptor能让你获取到存放着即将被转换的值的field，而targetTypeDescriptor能让你获得被转换后的值将被存放的field。</p>
<p>GenericConverter的一个很好的例子就是能将array转collection的ArrayToCollectionConverter。</p>
<p>例子：<br>1、首先需要写一个配置类，它作为converter们的注册中心，然后将自己重写的GenericConverter注册进来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public ConvertService getConvertService() &#123;</span><br><span class="line">    ConversionServiceFactoryBean bean = new ConversionServiceFactoryBean();</span><br><span class="line">    Set&lt;?&gt; sets = Sets.newHashSet(new MyGenericConverter());</span><br><span class="line">    bean.setConverters(sets);</span><br><span class="line">    bean.afterPropertiesSet();</span><br><span class="line">    return bean.getObject();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyGenericConverter implements GenericConverter &#123;</span><br><span class="line">    /**</span><br><span class="line">        * 告诉转换器总部，我这个转换器支持什么样的转换，可以支持多个转换</span><br><span class="line">        * 此处支持 string -&gt; list 和 string -&gt; map</span><br><span class="line">        */</span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;ConvertiblePair&gt; getConvertibleTypes() &#123;</span><br><span class="line">        Set&lt;ConvertiblePair&gt; convertiblePairs = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        ConvertiblePair stringToArray = new ConvertiblePair(String.class, Array.class);</span><br><span class="line">        ConvertiblePair stringToMap = new ConvertiblePair(String.class, Map.class);</span><br><span class="line">        convertiblePairs.add(stringToArray);</span><br><span class="line">        convertiblePairs.add(stringToMap);</span><br><span class="line">        return convertiblePairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * @param source     被转换的东西</span><br><span class="line">        * @param sourceType 被转换的东西的上下文，可以用于设置条件，具体咋玩看typeDescriptor，比如可以用来判断转换源是否拥有某些注解</span><br><span class="line">        *                   @see TypeDescriptor</span><br><span class="line">        * @param targetType 转换目标类型的上下文</span><br><span class="line">        * @return</span><br><span class="line">        * 案例场景：如果转换源被@Resource标识，并且目标类型为List，则转换list</span><br><span class="line">        *                                         目标类型为map，则转换为map</span><br><span class="line">        */</span><br><span class="line">    @Override</span><br><span class="line">    public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) &#123;</span><br><span class="line">        Resource annotation = sourceType.getAnnotation(Resource.class);</span><br><span class="line">        if (annotation!= null)&#123;</span><br><span class="line">            if (targetType.getType() == List.class)&#123;</span><br><span class="line">                return Arrays.asList(source.toString().split(&quot;:&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">            if (targetType.getType() == Map.class)&#123;</span><br><span class="line">                Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">                map.put(&quot;a&quot;,source.toString().split(&quot;:&quot;)[0]);</span><br><span class="line">                map.put(&quot;b&quot;,source.toString().split(&quot;:&quot;)[1]);</span><br><span class="line">                return map;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws NoSuchFieldException &#123;</span><br><span class="line">        DefaultConversionService defaultConversionService = new DefaultConversionService();</span><br><span class="line">        defaultConversionService.addConverter(new MyGenericConverter());</span><br><span class="line"></span><br><span class="line">        Apple apple = new Apple();</span><br><span class="line">        apple.setName(&quot;1:2&quot;);</span><br><span class="line"></span><br><span class="line">        List convert = (List) defaultConversionService.convert(apple.getName(),</span><br><span class="line">                new TypeDescriptor(Apple.class.getDeclaredField(&quot;name&quot;)),</span><br><span class="line">                new TypeDescriptor(ResolvableType.forRawClass(List.class),null,null));</span><br><span class="line">        System.out.println(convert.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、getConvertibleTypes 用于告诉注册中心，你重写的converter能够支持什么样的转换，比如我的就支持string到list，string到map的转换</p>
<p>参考：GenericConverter的用法随笔<br><a href="https://blog.csdn.net/qq_26950567/article/details/103685810">https://blog.csdn.net/qq_26950567/article/details/103685810</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《java并发编程的艺术》笔记</title>
    <url>/2022/08/25/myblog/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="第一章-并发编程的挑战"><a href="#第一章-并发编程的挑战" class="headerlink" title="第一章 并发编程的挑战"></a>第一章 并发编程的挑战</h2><h3 id="1-上下文切换"><a href="#1-上下文切换" class="headerlink" title="1.上下文切换"></a>1.上下文切换</h3><p>CPU通过给每个线程分配CPU时间片来实现多线程，时间片一般几十毫秒。</p>
<p>上下文切换是指切换前需要保存上一个任务的状态。</p>
<p>由于线程有创建和上下文切换的开销，并发执行的速度不一定比串行快。</p>
<p>上下文每1s切换1000多次。</p>
<p>如何减少上下文切换？<br>1、无锁并发编程，多线程竞争锁时会引起上下文切换，可以将数据id根据hash算法取模分段，不同线程处理不同段的数据。<br>2、CAS算法，Atomic包下，不需要加锁。<br>3、避免创建不需要的线程。每次从waiting到runnable都需要进行一次上下文切换。<br>4、协程：在单线程中实现多任务调度，维持多个任务间的切换。</p>
<h3 id="2-死锁"><a href="#2-死锁" class="headerlink" title="2.死锁"></a>2.死锁</h3><p>线程a和线程b互相等待对方释放锁。</p>
<p>一旦出现死锁，业务可感知，使用jstack命令dump线程。</p>
<p>避免死锁的几个方法：<br>1、避免一个线程同时获取多个锁。<br>2、避免一个线程在锁内同时占用多个资源。<br>3、尝试使用定时锁，使用lock.tryLock(timeout)来替代内部锁机制<br>4、对于数据库锁，加锁和解锁必须在一个数据库连接中，否则会出现解锁失败。</p>
<h3 id="3-资源限制"><a href="#3-资源限制" class="headerlink" title="3.资源限制"></a>3.资源限制</h3><p>并发编程时的资源限制：<br>硬件限制：带宽的上传&#x2F;下载速度（2Mb&#x2F;s）、硬盘读写速度、CPU处理速度<br>软件限制：数据库连接数、socket连接数<br>例如：线程数比数据库连接数大很多，则某些线程会被阻塞，等待数据库连接。</p>
<p>使用等待超时模式模拟数据库连接池：<br><a href="https://blog.csdn.net/m0_52043808/article/details/125759727">https://blog.csdn.net/m0_52043808/article/details/125759727</a></p>
<p>受到资源限制时，并发执行可能会编程串行执行，但是增加了上下文切换和资源调度的时间，比串行还慢。</p>
<p>如何解决？<br>1、对于硬件约束，考虑使用集群并行执行程序，不同机器处理不同数据。<br>2、对于软件限制，考虑使用资源池将资源复用。</p>
<h3 id="4-jstack命令dump线程"><a href="#4-jstack命令dump线程" class="headerlink" title="4.jstack命令dump线程"></a>4.jstack命令dump线程</h3><h4 id="✅什么是jstack？"><a href="#✅什么是jstack？" class="headerlink" title="✅什么是jstack？"></a>✅什么是jstack？</h4><p>如果有一天，你的Java程序长时间停顿，也许是它病了，需要用jstack拍个片子分析分析，才能诊断具体什么病症，是死锁综合征，还是死循环等其他病症。</p>
<p>jstack是JVM自带的Java堆栈跟踪工具，它用于打印出给定的java进程ID、core file、远程调试服务的Java堆栈信息.</p>
<pre><code>1、jstack命令用于生成虚拟机当前时刻的线程快照。
2、线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因， 如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。
3、线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。
4、如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。
5、另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。
</code></pre>
<h4 id="✅怎么用："><a href="#✅怎么用：" class="headerlink" title="✅怎么用："></a>✅怎么用：</h4><p>首先使用 jps命令查看需要打印线程栈的java进程号pid。<br>然后 jstack pid。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-F	当正常输出的请求不被响应时，强制输出线程堆栈</span><br><span class="line">-m	如果调用到本地方法的话，可以显示C/C++的堆栈</span><br><span class="line">-l	除堆栈外，显示关于锁的附加信息，在发生死锁时可以用jstack -l pid来观察锁持有情况</span><br></pre></td></tr></table></figure>

<p>输出解读：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;jstack 9348</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.281-b09 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;DestroyJavaVM&quot; #13 prio=5 os_prio=0 tid=0x0000018da5881000 nid=0x34c8 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">[通过 jstack查看线程栈信息时通常看到的最多的是RUNNABLE,BLOCKED,WAITING和TIMED_WAITING这几种状态，</span><br><span class="line">我们一般看不到线程的NEW和TERMINATED状态，是因为在代码的运行过程中这两种状态只占很小一部分，</span><br><span class="line">我们捕捉到这两种状态前这两种状态已经一闪而过了。</span><br><span class="line"></span><br><span class="line">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x0000000002e7e800 nid=0x2a1c in Object.wait() [0x0000000002f7f000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line"></span><br><span class="line">其中开头是线程名称，后面的为线程信息：</span><br><span class="line"> #1 表示当前线程ID，从 main线程开始，JVM 根据线程创建的顺序为线程编号.</span><br><span class="line">prio 是priority优先级的缩写，表名了当前线程的优先级，取值范围为[1-10]，默认为 5。在虚拟机进行线程调度的时候会参考该优先级为线程分配计算资源，这个数值越低越有优先获取到计算资源，一般不设置直接使用默认的优先级。</span><br><span class="line">os_prio为线程对应系统的优先级。</span><br><span class="line">nid 本地线程编号NativeID的缩写,对应JVM 虚拟机中线程映射在操作系统中的线程编号。我们可以使用 top 查看进程对应的线程情况进行相关映射。</span><br></pre></td></tr></table></figure>

<p>nid表示的是线程对应的系统本地的线程编号.</p>
<h4 id="✅案例：jstack-分析死锁问题"><a href="#✅案例：jstack-分析死锁问题" class="headerlink" title="✅案例：jstack 分析死锁问题"></a>✅案例：jstack 分析死锁问题</h4><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法进行下去</p>
<p>死锁demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Java 死锁demo</span><br><span class="line"> */</span><br><span class="line">public class DeathLockTest &#123;</span><br><span class="line">    private static Lock lock1 = new ReentrantLock();</span><br><span class="line">    private static Lock lock2 = new ReentrantLock();</span><br><span class="line"> </span><br><span class="line">    public static void deathLock() &#123;</span><br><span class="line">        Thread t1 = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock1.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock1&quot;);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    lock2.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock2&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2 = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock2.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock2&quot;);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    lock1.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock1&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //设置线程名字，方便分析堆栈信息</span><br><span class="line">        t1.setName(&quot;mythread-jay&quot;);</span><br><span class="line">        t2.setName(&quot;mythread-tianluo&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        deathLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排查步骤：<br>1、在终端中输入jsp查看当前运行的java程序<br>2、使用 jstack -l pid 查看线程堆栈信息<br>3、分析堆栈信息</p>
<p>会出现：Found one Java-level deadlock: 信息。</p>
<p>当一个线程占有一个锁的时候，线程堆栈会打印一个－locked&lt;0x22bffb60&gt;<br>当一个线程正在等在其他线程释放该锁，线程堆栈会打印一个－waiting to lock&lt;0x22bffb60&gt;<br>当一个线程占有一个锁，但又执行在该锁的wait上，线程堆栈中首先打印blocked,然后打印－waiting on &lt;0x22c03c60&gt;</p>
<h4 id="✅案例：分析CPU过高"><a href="#✅案例：分析CPU过高" class="headerlink" title="✅案例：分析CPU过高"></a>✅案例：分析CPU过高</h4><p>导致CPU过高的demo程序，一个死循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 有个导致CPU过高程序的demo，死循环</span><br><span class="line"> */</span><br><span class="line">public class JstackCase &#123;</span><br><span class="line"> </span><br><span class="line">     private static ExecutorService executorService = Executors.newFixedThreadPool(5);</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        Task task1 = new Task();</span><br><span class="line">        Task task2 = new Task();</span><br><span class="line">        executorService.execute(task1);</span><br><span class="line">        executorService.execute(task2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Object lock = new Object();</span><br><span class="line"> </span><br><span class="line">    static class Task implements Runnable&#123;</span><br><span class="line"> </span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                long sum = 0L;</span><br><span class="line">                while (true)&#123;</span><br><span class="line">                    sum += 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排查步骤：<br>1、jps 命令获取目标 java 进程号<br>2、在服务器上，我们可以通过top命令查看各个进程的cpu使用情况，它默认是按cpu使用率由高到低排序的，拿到pid<br>top -Hp pid 【奇怪，不能用，只能top -p pid】<br>通过top -Hp pid可以查看该进程下，各个线程的cpu使用情况<br>3、把线程pid换成nid<br>将该线程好打印成 16进制的<br><code>printf &quot;%x\n&quot; 19343</code><br>4、jstack -l [PID] &gt;&#x2F;tmp&#x2F;log.txt<br>一般在生成环境，我们可以把这些堆栈信息打到一个文件里，再回头仔细分析<br>jstack 进程pid | grep -10 线程<br>nid<br>可以看到目标线程的线程堆栈信息了</p>
<p>转自：<br><a href="https://blog.csdn.net/weixin_44588186/article/details/124680586">https://blog.csdn.net/weixin_44588186/article/details/124680586</a><br>【jstack案例】<br><a href="https://blog.csdn.net/qq_19922839/article/details/115379649">https://blog.csdn.net/qq_19922839/article/details/115379649</a><br>【里面还有pstree 查看进程树，jvm 监控工具Liberica Mission Control】</p>
<h4 id="✅dump线程"><a href="#✅dump线程" class="headerlink" title="✅dump线程"></a>✅dump线程</h4><p>线程dump的目的是转存线程快照。快照中是当前JVM所有线程正在执行方法的堆栈信息。</p>
<p>通过线程dump来分析定位线程出现长时间停顿的原因，如线程死锁、线程死循环、线程请求外部资源长时间等待等。</p>
<p>可以用arthas获取dump文件，dump文件很大，几个G，可以用IDEA打开，或者用其他分析工具。arthas也可以输出所有线程。</p>
<p>线程dump：<a href="https://blog.csdn.net/HaierFiller/article/details/117367228">https://blog.csdn.net/HaierFiller/article/details/117367228</a></p>
<h2 id="第二章-java并发机制的底层实现原理"><a href="#第二章-java并发机制的底层实现原理" class="headerlink" title="第二章 java并发机制的底层实现原理"></a>第二章 java并发机制的底层实现原理</h2><p>.java代码 -编译为- .class字节码文件 -加载到- jvm -执行字节码- 转化为汇编语言在cpu执行。</p>
<p>java的并发机制依赖于jvm的实现和cpu的执行。</p>
<h3 id="1-volatile"><a href="#1-volatile" class="headerlink" title="1.volatile"></a>1.volatile</h3><h4 id="✅volatile底层"><a href="#✅volatile底层" class="headerlink" title="✅volatile底层"></a>✅volatile底层</h4><p>volatile是轻量级的synchronized，在多处理器开发中保证了共享变量的可见性（所有线程看到的这个变量的值是一致的）。比synchronized执行成本低，不会引起线程上下文的切换和调度。</p>
<p>首先，了解一下cpu处理逻辑：<br>为了提高处理速度，cpu不直接与内存进行通信，而是先将内存的数据读到自己的内存缓存（以缓存行为单位）中。</p>
<p>处理器 - 高速缓存 - 缓存   \<br>处理器 - 高速缓存 - 一致性  - 总线 - 主内存<br>处理器 - 高速缓存 - 协议   &#x2F;</p>
<p>存储大体上分两种, 主存是堆内存, 工作内存是栈内存, 属于线程私有。<br>对字段操作都需要先从主存读取数据加载进工作内存, 工作内存对这个副本数据进行操作<br>volatile修饰的变量, 等于在堆中这个变量的内存区域上打了个标, 所有操作都必须从主存中读取, 由MESI&lt;缓存一致性协议&gt;实现</p>
<p>对volatile声明的变量进行写操作会发生什么：<br>1、jvm向处理器发送一条lock前缀的指令，将这个变量所在缓存行的数据写回系统内存。lock指令执行期间会锁住总线&#x2F;缓存，保证不会同时多个cpu修改共享变量。<br>2、多处理下，实现缓存一致性协议，每个处理器使用嗅探技术，保证它的内部缓存和系统内存的数据在总线上保持一致（发现自己缓存行对应的内存地址被修改，首先将缓存行置为无效，重新从系统内存中将数据读到缓存）。</p>
<p>volitale的使用优化：<br>jdk7中的LinkedTransferQueue，使用volitale时，采用追加字节的方式优化出队入队效率。</p>
<p>为什么？<br>因为处理器的高速缓存行是64个字节宽，不支持部分填充缓存行。这样头节点和尾节点在一个高速缓存行中，多处理器下，一个处理器修改头节点，会将整个缓存行锁定，在缓存一致性的作用下，导致其他处理器不能访问自己高速缓存行中的尾节点。<br>节点追加到64字节，可以避免头尾节点加载到同一个缓存行中，修改时不会相互锁定。</p>
<p>注意：缓存行非64字节的别这么做，共享变量不会被频繁写的话别这么做。</p>
<h4 id="✅volatile使用"><a href="#✅volatile使用" class="headerlink" title="✅volatile使用"></a>✅volatile使用</h4><p>⚠️注意：volatile能保证可见性，但不能保证原子性。<br>在 volatile 字段上进行了非原子类操作，会idea提示：<code>Non-atomic operations on volatile fields</code><br>比如：count++ 就是非原子操作，分三步：<br>1、从主存读取 i<br>2、在寄存器中进行加一运算, 自增操作, 此时已经修改工作内存中的值<br>3、将计算后的值赋给 i, 也就是刷回主存</p>
<p><strong>可见性</strong></p>
<p>volatile和static的可见性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//private boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">//private static boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">private volatile  boolean tag = false; //会运行tag is true,exit</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void visibleTest() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //当tag标志变为true时结束循环并打印退出信息</span><br><span class="line">            while(!tag)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;tag is true,exit......&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            tag = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(100);</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>volatile的可见性：是多个线程间的共享变量，当一个线程修改时，其他的线程能够知道这个修改。<br>static不能知道变化，它的可见性：可访问。</p>
<p>volatile修饰的共享变量对其他线程具有可见性，可以保证线程安全。<br>static修饰的变量为全局变量, 对所有线程可访问, 可用于线程间的通信，但是不能保证线程安全。</p>
<p>static线程安全测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class VolatileDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static int count = 0;</span><br><span class="line"></span><br><span class="line">    private static void count() &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService es = Executors.newCachedThreadPool();</span><br><span class="line">        long start = System.nanoTime();</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            es.execute(VolatileDemo::count);</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (es.isTerminated()) &#123;</span><br><span class="line">                System.out.println(&quot;end...&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long end = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;count:&quot; + count);</span><br><span class="line">        System.out.println(&quot;cost:&quot; + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动一个缓存线程池进行对static字段进行自增，结果不是100.<br>t1线程与 t2线程读取 count 值, 然后同步修改为 1, 再写回内存, 写了两遍 1。</p>
<p>因此，static修饰的变量确实可以在线程间通信, 对各个线程都是可见的。但是不能保证线程安全。</p>
<p>那么用volatile，相当于每次修改volatile变量都需要重新读取数据。<br>但是结果依然不是100.</p>
<p>volatile的可见性测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//private boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">//private static boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">private volatile  boolean tag = false; //会运行tag is true,exit</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void visibleTest() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //当tag标志变为true时结束循环并打印退出信息</span><br><span class="line">            while(!tag)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;tag is true,exit......&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            tag = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(100);</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非原子性</strong></p>
<p>t1线程与t2线程同时从主存中读取了count &#x3D; 1,自增, 这时候两个线程的寄存器中存的计算后的值都是 2, 然后要写回count的主存, 假设这时 t1成功了, 那么主存中的count就是2, 然后根据MESI协议, t2需要重新从主存读取count值, 得到的是2, 再将寄存器中的计算结果2 赋值给count, 刷回主存, 此时主存中的count值还是2, 而不是期望中的3。</p>
<p>怎么解决？<br>synchronized关键字，或者 atomic原子类 + volatile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private volatile static AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">private static void count() &#123;</span><br><span class="line">    count.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-09-12 20:14</span><br><span class="line"> **/</span><br><span class="line">public class VolatileDemo &#123;</span><br><span class="line"></span><br><span class="line">    private volatile AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testVolatile() throws InterruptedException &#123;</span><br><span class="line">        Thread thread1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @SneakyThrows</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">                    count.incrementAndGet();</span><br><span class="line">                    System.out.println(Thread.currentThread() + &quot; count:&quot; + count);</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @SneakyThrows</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">                    count.incrementAndGet();</span><br><span class="line">                    System.out.println(Thread.currentThread() + &quot; count:&quot; + count);</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(&quot;count:&quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>1、static修饰的变量是静态变量, 表示不管对象有多少实例, 只有这一个变量, 强调变量的唯一性<br>2、volatile是基于JMM与MESI提出的一种内存一致性解决方案, 强调的是对共享变量的修改是可见的, 变量值是唯一的<br>3、volatile 可以保证对其所修饰的共享变量的原子性操作是线程安全的</p>
<p>转自：<br>volatile的可见性和非原子性：<a href="https://www.codenong.com/js5a773b9fb9cb/">https://www.codenong.com/js5a773b9fb9cb/</a></p>
<h3 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2.synchronized"></a>2.synchronized</h3><p>synchronized之前被称为重量级锁，但是java se 1.6 对synchronized进行优化：减少获取锁和释放锁带来的性能消耗而引入偏向锁、轻量级锁。</p>
<h4 id="✅synchronized锁三种形式"><a href="#✅synchronized锁三种形式" class="headerlink" title="✅synchronized锁三种形式"></a>✅synchronized锁三种形式</h4><p>1.对于普通同步⽅法：锁的是当前实例对象，通常指this，所有的普通同步⽅法⽤的都是同⼀把锁，即实例对象本身。</p>
<p>2.对于静态同步⽅法：锁的是当前类的Class对象。</p>
<p>3.对于同步⽅法块：锁的是synchronized 括号内的对象。</p>
<p>⚠️几个锁的区别：<br>1.静态方法同步和静态代码块同步：所有的静态同步⽅法⽤的也是同⼀把锁——类对象本身，⼀旦⼀个静态同步⽅法获取锁后，其他的静态同步⽅法都必须等待该⽅法释放锁后才能获取锁。（和实例没关系）</p>
<p>2.静态同步和普通同步：具体实例对象this和唯⼀模板Class，这两把锁是两个不同的对象，所以静态同步⽅法与普通同步⽅法之间是不会有竞态条件的</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-09-17 14:11</span><br><span class="line"> **/</span><br><span class="line">//资源类</span><br><span class="line">class Phone&#123;</span><br><span class="line">    //1.静态方法（加锁）</span><br><span class="line">    public static synchronized void sendEmail() &#123;</span><br><span class="line">        //暂停几秒钟线程</span><br><span class="line">        try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread() + &quot;-------sendEmail&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //2.普通方法（加锁）</span><br><span class="line">    public synchronized void sendSMS() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread() + &quot;-------sendSMS&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //3. 普通方法不加锁</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread() + &quot;-------hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//主方法</span><br><span class="line">public class SynchronizedDemo&#123;</span><br><span class="line">    //一切程序的入口，主线程</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Phone phone = new Phone();//资源类1</span><br><span class="line">        Phone phone2 = new Phone();//资源类2</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //phone.sendSMS(); //1、2</span><br><span class="line">                //phone.hello();</span><br><span class="line">                phone.sendEmail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //phone.sendSMS(); //1、2</span><br><span class="line">                //phone.hello();</span><br><span class="line">                phone2.sendEmail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        try &#123; TimeUnit.MILLISECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        t2.start();</span><br><span class="line">        try &#123; TimeUnit.MILLISECONDS.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅synchronized锁的实现原理"><a href="#✅synchronized锁的实现原理" class="headerlink" title="✅synchronized锁的实现原理"></a>✅synchronized锁的实现原理</h4><p>反编译命令：<code>javap -v -p *.class &gt; 类.txt </code>（将进⾏输出到txt中）</p>
<p>synchronized在jvm中的实现原理：jvm基于进入和退出Monitor对象来实现方法同步和代码块同步，monitor是一个对象的监视器。</p>
<p><strong>同步代码块：</strong></p>
<p>同步代码块是通过monitorenter和monitorexit指令实现的。</p>
<p>monitorenter：在编译后插入到同步代码块的开始位置，会尝试获取对象所对应的monitor的所有权，即尝试获取对象的锁。</p>
<p>monitorexit：代表执行完synchronized代码块之后，要从对象监视器中退出，也就是释放锁。</p>
<p><strong>同步普通⽅法：</strong></p>
<p>1.同步普通⽅法反编译后的结构：可以看到在synchronized修饰实例方法中，不会再有monitorenter和monitorexit指令，而是在这个方法上多了一个ACC_SYNCHRONIZED的flag。</p>
<p>2.调用普通方法的流程：当程序在运行时，调用method()方法时，会检查该方法是否有ACC_SYNCHRONIZED访问标识，如果有，则表明该方法是同步方法，这时候该线程会先尝试去获取该方法对应的监视器（monitor）对象，如果获取成功，则继续执行该method()方法。</p>
<p>3.在执行期间，任何其他线程都不能再获取该方法监视器的使用权，直到该方法正常退出或者抛出异常，才会释放，其他线程可以重新获得该监视器。</p>
<p><strong>同步静态方法：</strong></p>
<p>synchronized修饰静态方法和实例方法没有区别，都是增加一个ACC_SYNCHRONIZED的flag，静态方法只是比实例方法多一个ACC_STATIC标识代表这个方法是静态的。</p>
<p><strong>阿里开发手册说明：</strong></p>
<p>⾼并发时，同步调⽤应该去考量锁的性能损耗。<br>1.能⽤⽆锁数据结构，就不要⽤有锁；<br>2.能锁区块，就不要锁整个⽅法体；<br>3.能⽤对象锁，就不要⽤类锁；</p>
<p>参考：<br>synchronized三种加锁方式：<a href="https://blog.csdn.net/weixin_38963649/article/details/126139304">https://blog.csdn.net/weixin_38963649/article/details/126139304</a></p>
<h4 id="✅java对象头"><a href="#✅java对象头" class="headerlink" title="✅java对象头"></a>✅java对象头</h4><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<p>HotSpot虚拟机的对象头包括三部分信息：<br>1、mark word 2、元类指针 3、数组长度<br>普通对象头有两个区域（1，2）、数组对象头有三个区域（1,2,3）</p>
<p><strong>Mark Word</strong></p>
<p>这部分主要存储对象自身的运行数据，如Hashcode、gc分代年龄、对象锁，锁状态标志，偏向锁（线程）ID，偏向时间等等。mark word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark word为32位。</p>
<p>Java对象头一般占有2个机器码（64位虚拟机中，1个机器码是8个字节，也就是64bit），但是 如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。</p>
<p><strong>指向类的指针</strong></p>
<p>该指针在32位JVM的长度是32Bit，64是64bit<br>它主要指向类的数据，也就是指向方法区中的位置。</p>
<p><strong>数组长度</strong></p>
<p>只有数组对象保存了这部分数据<br>该数据在32位和64位JVM都是32bit</p>
<p>参考：<br>java对象头以及打印对象头：<a href="https://blog.csdn.net/sumengnan/article/details/125035218">https://blog.csdn.net/sumengnan/article/details/125035218</a><br>java对象头以及锁升级过程：<a href="https://www.cnblogs.com/Alei777/p/16308553.html">https://www.cnblogs.com/Alei777/p/16308553.html</a></p>
<h4 id="✅锁的升级与对比"><a href="#✅锁的升级与对比" class="headerlink" title="✅锁的升级与对比"></a>✅锁的升级与对比</h4><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。<br>在 Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状 态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。<br>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<p><strong>偏向锁</strong></p>
<p>背景：<br>大多数情况下，锁不仅不存在多线程竞争，而且总是由同 一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<p>偏向锁原理：<br>当一个线程访问同步块并获取锁时，会在<strong>对象头</strong>和<strong>栈帧</strong>中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<p>偏向锁释放和升级：<br>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。<br>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正 在执行的字节码）。<br>1、首先暂停拥有偏向锁的线程<br>2、然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；<br>3、如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁（升级为轻量级锁），最后唤醒暂停的线程。</p>
<p>关闭偏向锁<br>偏向锁在Java 6和Java 7里是默认启用，如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：<br><code>-XX:-UseBiasedLocking=false</code></p>
<p><strong>轻量级锁</strong></p>
<p>升级为轻量级锁后，线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用<strong>自旋</strong>来获取锁。自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁。</p>
<p><strong>重量级锁</strong></p>
<p>轻量级锁 -&gt; 重量级锁 的方式有两种：</p>
<p>1 若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。</p>
<p>2 另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。</p>
<p>自旋会消耗CPU，一旦重量级锁，就不会恢复为轻量级锁。当锁处于这个状态下，其他线程试图获取锁时， 都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<p><strong>几种锁的对比</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">锁	优点	缺点	使用场景</span><br><span class="line">偏向锁	加锁和解锁不需要额外的消耗,和执行非同步方法相比仅存在纳秒级的差距	如果线程间存在锁竞争，会带来额外的撤销消耗	适用于只有一个线程访问同步块场景</span><br><span class="line">轻量级锁	竞争的线程不会阻塞，提高了程序的响应速度	如果始终得不到锁竞争的线程，会自旋消耗CPU	追求响应时间、同步块执行非常快</span><br><span class="line">重量级锁	线程不使用自旋，不会消耗CPU	线程阻塞，响应时间缓慢	追求吞吐量、同步块执行速度较快</span><br></pre></td></tr></table></figure>

<p>参考：<br>《书中内容》：<a href="https://blog.csdn.net/Hello_mengkebao/article/details/119874999">https://blog.csdn.net/Hello_mengkebao/article/details/119874999</a></p>
<p><strong>总结：锁的升级过程</strong></p>
<p>JVM一般是这样使用锁和Mark Word的：</p>
<p>1，当没有被当成锁时，这就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否偏向锁那一位是0。</p>
<p>2，当对象被当做同步锁并有一个线程A抢到了锁时，锁标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程id，表示进入偏向锁状态。</p>
<p>3，当线程A再次试图来获得锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程id就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码。</p>
<p>4，当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁，这里的获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5。</p>
<p>5，偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在当前线程的线程栈中开辟一块单独的空间，里面保存指向对象锁Mark Word的指针，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6。</p>
<p>6，轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7。</p>
<p>7，自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞。</p>
<h3 id="3-Atomic原子操作"><a href="#3-Atomic原子操作" class="headerlink" title="3.Atomic原子操作"></a>3.Atomic原子操作</h3><p>原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。</p>
<h4 id="✅处理器如何实现原子操作"><a href="#✅处理器如何实现原子操作" class="headerlink" title="✅处理器如何实现原子操作"></a>✅处理器如何实现原子操作</h4><p>首先处理器会自动保证<strong>基本的内存操作的原子性</strong>。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。Pentium 6和最新的处理器能自动保证单处理器对同一个缓存行里进行16&#x2F;32&#x2F;64位的操作是原子的。</p>
<p>但是<strong>复杂的内存操作处理器是不能自动保证其原子性的</strong>，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供<strong>总线锁定</strong>和<strong>缓存锁定</strong>两个机制来保证复杂内存操作的原子性。</p>
<p>首先我们要明确一点：a++是三步操作（取数，加一，赋值），而计算机和Java都只保证一步操作的原子性，多步操作是不保证原子性的。所以a++不是原子性的。想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。</p>
<p>⚠️volitale保证可见性为什么不能实现i++的线程安全？</p>
<blockquote>
<p>可见性是指瞬时可见性，是指那一时刻的可见性。放在这个例子里，就是指当线程1把（a&#x3D;0，a++）的结果a&#x3D;1刷回到主存中时，所有目前有a这个变量的缓存此时都应该变为a&#x3D;1，而不是使用原来的值。所以，线程2也执行加一后，还没有写回到缓存中，保存在寄存器中，线程2缓存里面的a&#x3D;0被置为无效，所以线程2又从主存中取得a&#x3D;1替换掉了自己缓存中的a&#x3D;0，然后线程2将a&#x3D;1写入自己的缓存中，随后a&#x3D;1又一次被立刻刷回到主存中。最后主存中的值还是a&#x3D;1。</p>
</blockquote>
<p><strong>总线锁</strong></p>
<p>总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</p>
<p><strong>缓存锁</strong></p>
<p>总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大。</p>
<p>频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium 6和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。</p>
<p>“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</strong>，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</p>
<p>不能使用缓存锁的情况：<br>1、第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行。<br>2、有些处理器不支持缓存锁定</p>
<h4 id="✅java如何实现原子操作"><a href="#✅java如何实现原子操作" class="headerlink" title="✅java如何实现原子操作"></a>✅java如何实现原子操作</h4><p><strong>循环CAS</strong></p>
<p>CAS 全称是 compare and swap，是一种用于在多线程环境下实现同步功能的机制。CAS 操作包含三个操作数 – 内存位置、预期数值和新值。CAS 的实现逻辑是将内存位置处的数值与预期数值相比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。（像改密码需要先验证旧密码一样）</p>
<p>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。</p>
<p>从Java 1.5开始，JDK的并发包里提供了一些类来支持原子操作，如AtomicBoolean（用原子方式更新的boolean值）、AtomicInteger（用原子方式更新的int值）和AtomicLong（用原子方式更新的long值）。这些原子包装类还提供了有用的工具方法，比如以原子的方式将当前值自增1和自减1。</p>
<p>CAS仍然存在<strong>三大问题</strong>。ABA问题，循环时间长开销大，以及只能保证一个共享变量的原子操作。</p>
<p>1、ABA问题<br>CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。</p>
<p>从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p>2、循环时间长开销大<br>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p>
<p>3、只能保证一个共享变量的原子操作<br>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j&#x3D;a，合并一下ij&#x3D;2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证<strong>引用对象之间的原子性</strong>，就可以把多个变量放在一个对象里来进行CAS操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private AtomicInteger count = new AtomicInteger(0);</span><br><span class="line">count.incrementAndGet(); //原子自增</span><br><span class="line">int i = count.get();</span><br><span class="line">boolean suc = count.compareAndSet(i, ++i); //cas</span><br></pre></td></tr></table></figure>

<p><strong>使用锁实现原子操作</strong></p>
<p>使用锁机制实现原子操作锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p>
<p>参考：<br>书的笔记：<a href="https://zhuanlan.zhihu.com/p/412363896">https://zhuanlan.zhihu.com/p/412363896</a><br>jdk中的原子操作类：<a href="https://www.jianshu.com/p/a47285790467">https://www.jianshu.com/p/a47285790467</a><br>cas原理、synchronized悲观锁和cas乐观锁：<a href="https://www.cnblogs.com/huansky/p/15746624.html">https://www.cnblogs.com/huansky/p/15746624.html</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>几个java实现多线程安全的操作：<br>1、synchronized加锁<br>2、Volatile关键字<br>3、CAS</p>
<h2 id="第三章-Java内存模型"><a href="#第三章-Java内存模型" class="headerlink" title="第三章 Java内存模型"></a>第三章 Java内存模型</h2><h3 id="1-java内存模型的基础"><a href="#1-java内存模型的基础" class="headerlink" title="1.java内存模型的基础"></a>1.java内存模型的基础</h3><h4 id="✅并发编程的两个关键问题"><a href="#✅并发编程的两个关键问题" class="headerlink" title="✅并发编程的两个关键问题"></a>✅并发编程的两个关键问题</h4><p>1、线程之间如何通信：<br>通信是指线程之间以何种机制来交换信息<br>通信机制有两种：共享内存和消息传递</p>
<p>2、线程之间如何同步：<br>同步：指程序中用于控制不同线程间操作发生相对顺序的机制</p>
<p>java的并发采用的是共享内存模型，java线程之间的通信总是隐式进行，整个过程对程序员完全透明。</p>
<h4 id="✅java内存模型"><a href="#✅java内存模型" class="headerlink" title="✅java内存模型"></a>✅java内存模型</h4><p>堆内存：实例域、静态域、数组元素；在线程之间共享。<br>栈内存：局部变量、方法定义参数、异常处理器参数；不在线程之间共享，没有内存可见性问题。</p>
<p>Java线程之间的通信由Java内存模型(JMM)控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见</p>
<p>线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存(抽象概念)，本地内存中存储了该线程以读&#x2F;写共享变量的副本。</p>
<p>JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证<br>两个线程要通信，要经历下面2个步骤：<br>线程A把本地内存A中更新过的共享变量刷新到主内存中去。<br>线程B到主内存中去读取线程A之前已更新过的共享变量</p>
<h4 id="✅从源代码到指令序列的重排序"><a href="#✅从源代码到指令序列的重排序" class="headerlink" title="✅从源代码到指令序列的重排序"></a>✅从源代码到指令序列的重排序</h4><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序</p>
<p>重排序分3种类型，第一种属于编译器重排，后两种属于处理器重排：<br>编译器优化的重排序<br>指令级并行的重排序<br>内存系统的重排序</p>
<p>JMM通过禁止特定类型的编译器重排序和处理器重排序（插入特定类型的内存屏障），提供内存可见性保证。</p>
<p>处理器利用写缓冲区来临时保存向内存写入的数据。但是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。例如a&#x3D;1，先写在缓冲区，然后下一个语句用了a，然后缓冲区才将a&#x3D;1写入主内存。这就算重排序了。</p>
<h4 id="✅happens-before"><a href="#✅happens-before" class="headerlink" title="✅happens-before"></a>✅happens-before</h4><p>JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系（一种阐述内存可见性的概念）。就是要求前一个操作的执行结果对后一个操作可见。并不意味着操作A就一定在操作B之前执行。</p>
<p>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。<br>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。<br>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读</p>
<h3 id="2-重排序"><a href="#2-重排序" class="headerlink" title="2.重排序"></a>2.重排序</h3><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段</p>
<h4 id="✅数据依赖性"><a href="#✅数据依赖性" class="headerlink" title="✅数据依赖性"></a>✅数据依赖性</h4><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。<br>数据依赖可分为：读后写、写后读、写后写。</p>
<p>编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<p>数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑</p>
<h4 id="✅as-if-serial语义"><a href="#✅as-if-serial语义" class="headerlink" title="✅as-if-serial语义"></a>✅as-if-serial语义</h4><p>一个概念，意思是：不管怎么重排序，单线程的程序的执行结果不能被改变</p>
<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。</p>
<p>意思就是，编译器和处理器为了提高单线程的并行度，会对没有依赖关系的操作重排序，但是不影响结果和可见性。</p>
<h4 id="✅重排序对多线程的影响"><a href="#✅重排序对多线程的影响" class="headerlink" title="✅重排序对多线程的影响"></a>✅重排序对多线程的影响</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ReorderExample &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    boolean flag = false;</span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        a = 1; // 1</span><br><span class="line">        flag = true; // 2</span><br><span class="line">    &#125;</span><br><span class="line">    Public void reader() &#123;</span><br><span class="line">        if (flag) &#123; // 3</span><br><span class="line">        int i = a * a; // 4</span><br><span class="line">    ……</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法.</p>
<p>操作1和操作2没有数据依赖关系，且操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两对操作重排序.</p>
<p>对线程A的两个操作进行重排序：<br>1、线程A首先写标记变量flag<br>2、随后线程B读这个变量。由于条件判断为真，线程B将读取变量a<br>3、此时，变量a还没有被线程A写入，多线程程序的语义被重排序破坏</p>
<p>对线程B的两个操作进行重排序：<br>1、由于操作3和操作4存在控制依赖关系，执行线程B的处理器可提前读取并计算a*a<br>2、然后把计算结果临时保存到一个名为重排序缓冲(Reorder Buffer，ROB)的硬件缓存中<br>3、当操作3的条件判断为真时，就把该计算结果写入变量i中，多线程程序的语义被重排序破坏</p>
<h3 id="3-顺序一致性"><a href="#3-顺序一致性" class="headerlink" title="3.顺序一致性"></a>3.顺序一致性</h3><p>数据竞争的定义：在一个线程中写一个变量，在另一个线程读同一个变量，而且写和读没有通过同步来排序</p>
<p>顺序一致性：如果程序是正确同步的，程序的执行将具有顺序一致性(即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同)【是一个理想化的概念】</p>
<h4 id="✅顺序一致性模型"><a href="#✅顺序一致性模型" class="headerlink" title="✅顺序一致性模型"></a>✅顺序一致性模型</h4><p>在顺序一致性模型（理论参考模型）中（不管有没有同步）：<br>任意时刻最多只有一个线程可以连接到内存。<br>一个线程的所有操作按程序的顺序串行执行。<br>每个操作必须立即对任意线程可见。<br>所有线程都只能看到一个一致的整体执行顺序。</p>
<blockquote>
<p>JMM中没有上述保证。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致</p>
</blockquote>
<h4 id="✅同步程序的执行效果"><a href="#✅同步程序的执行效果" class="headerlink" title="✅同步程序的执行效果"></a>✅同步程序的执行效果</h4><p>在JMM中，临界区（一个同步块儿）内的代码可以重排序(因为JMM目的是在不改变程序执行结果的前提下，尽可能优化编译器和处理器)。</p>
<p>结果是：重排序提高了执行效率，而且没有改变程序的执行结果。</p>
<h4 id="✅未同步程序的执行效果"><a href="#✅未同步程序的执行效果" class="headerlink" title="✅未同步程序的执行效果"></a>✅未同步程序的执行效果</h4><p>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致（一致也没意义）。因为如果想要保证执行结果一致，JMM需要禁止大量的处理器和编译器的优化，这对程序的执行性能会产生很大的影响。</p>
<p>JMM不保证单线程内的操作会按程序顺序执行。所有线程看到的操作顺序可能不一致。执行顺序可能是：2-3-4-1，语义被破坏。可能是4的右边-1-2-3-4的左边，语义被破坏。</p>
<h4 id="✅处理器总线事务"><a href="#✅处理器总线事务" class="headerlink" title="✅处理器总线事务"></a>✅处理器总线事务</h4><p>总线事务包括读事务（内存-处理器）和写事务（处理器-内存），中间都要通过总线，总线会同步试图并发使用总线的事务，一次只有一个事务可以操作总线访问内存。</p>
<p>所以，一次最多只有一个处理器可以访问内存，这保证了单个总线事务之中的内存读写（读跟写，不是i++）具有原子性。</p>
<p>但是：32位的处理器上，对long型和double型这俩64位的数据的写操作拆分成了两个写事务，会分配在不同的总线事务中执行。所以不具有原子性。</p>
<h3 id="4-volatile的内存语义"><a href="#4-volatile的内存语义" class="headerlink" title="4.volatile的内存语义"></a>4.volatile的内存语义</h3><h4 id="✅volatile的特性："><a href="#✅volatile的特性：" class="headerlink" title="✅volatile的特性："></a>✅volatile的特性：</h4><p>1、可见性：对volatile变量的单个读写，相当于是用同一个锁对单个读写方法做了同步。对volatile变量的读，总能看到最后的写入。被volatile修饰的变量对所有线程总是立即可见的，对volatile变量的所有写操作总是能立刻反应到其他线程中。</p>
<p>2、原子性：对单个volatile变量的读写（64位的long和double类型也是）具有原子性，volatile++的复合操作不具有原子性。</p>
<h4 id="✅volatile变量读写实现线程之间通信"><a href="#✅volatile变量读写实现线程之间通信" class="headerlink" title="✅volatile变量读写实现线程之间通信"></a>✅volatile变量读写实现线程之间通信</h4><p>volatile变量的写、读，与锁的释放、获取有相同的内存效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">volatile boolean flag = false;</span><br><span class="line"></span><br><span class="line">public void writer() &#123;</span><br><span class="line">    a = 1;//1</span><br><span class="line">    flag = true;//2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void reader() &#123;</span><br><span class="line">    if (flag) &#123;  //3</span><br><span class="line">        int i = a; //4</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1 happens-before 2  (执行顺序可能在一个临界区内重排序)<br>3 happens-before 4<br>2 happens-before 3 （volatile带来的）<br>so: 1 happens-before 4</p>
<p>疑问：1.2没有数据依赖，可能被重排序。<br>指令重排使得执行顺序不会变成：2-3-4-1 吗？ 下面给答案。</p>
<h4 id="✅volatile写读的内存语义"><a href="#✅volatile写读的内存语义" class="headerlink" title="✅volatile写读的内存语义"></a>✅volatile写读的内存语义</h4><p>线程 - 本地内存 - 主内存</p>
<p>1、当写一个volatile变量时，JMM会把线程对应的本地内存中的共享变量（那个a）值刷新到主内存。（实质就是A向接下来要读这个volatile变量的某个线程发出了消息（我对共享变量做出的修改））</p>
<p>2、当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。（实质就是接受了之前某个线程发出的消息）</p>
<p>3、A写，B读，实质就是A通过主内存向B发送消息，实现线程之间通信</p>
<h4 id="✅volatile内存语义的实现-禁止指令重排。"><a href="#✅volatile内存语义的实现-禁止指令重排。" class="headerlink" title="✅volatile内存语义的实现-禁止指令重排。"></a>✅volatile内存语义的实现-禁止指令重排。</h4><p>背景：上面实现线程间通信那一小节，疑惑的是1.2是不是能重排序，3.4是不是能重排序。在这里给出答案，</p>
<p>为了实现volatile的内存语义，JMM会限制重排序类型。</p>
<p>1、当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到写之后。</p>
<p>2、当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到读之前。</p>
<p>3、当第一个操作是volatile写时，第二个操作是volatile读时，不能重排序。</p>
<p>那么，如何实现限制指令重排？<br>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。<br>尽管内存屏障会降低效率，但是JMM 在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p>
<h4 id="✅JSR-133增强volatile的内存语义"><a href="#✅JSR-133增强volatile的内存语义" class="headerlink" title="✅JSR-133增强volatile的内存语义"></a>✅JSR-133增强volatile的内存语义</h4><p>Java内存模型是一个雄心勃勃的计划，它是编程语言规范第一次尝试合并一个能够在各种处理器架构中为并发提供一致语义的内存模型。不过，定义一个既一致又直观的内存模型远比想象要更难。JSR133为Java语言定义了一个新的内存模型，它修复了早期内存模型中的缺陷。为了实现JSR133，final和volatile的语义需要重新定义。</p>
<p>旧的内存模型中，volatile的写读没有锁的释放和获取的内存语义，也就是实现线程之间通信那一小节里，会指令重排。</p>
<p>JSR-133，严格限制编译器和处理器对volatile变量与普通变量的重排序，确保了volatile的写读有锁的释放和获取的内存语义。</p>
<p>volatile与锁对比：<br>锁在功能上比volatile更强大，可以确保整个临界区代码具有原子性。volatile只能对单个volatile变量读写具有原子性。（所以不能单纯用volatile实现计数器）<br>在可伸缩性和执行性能上，volatile更具有优势。</p>
<h3 id="5-锁的内存语义"><a href="#5-锁的内存语义" class="headerlink" title="5.锁的内存语义"></a>5.锁的内存语义</h3><p>达到效果：线程A在释放锁之前所有可见的共享变量，在线程B获取同一个锁之后，将立即变得对B线程可见。</p>
<h4 id="✅锁释放和获取的内存语义"><a href="#✅锁释放和获取的内存语义" class="headerlink" title="✅锁释放和获取的内存语义"></a>✅锁释放和获取的内存语义</h4><p>1、当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。（实质上是线程A向接下来要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。）</p>
<p>2、当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器锁保护的临界区代码必须从主内存中读取共享变量。（实质上是线程B接受了之前某个线程发出的（在释放这个锁对共享变量锁做的修改的）消息。）</p>
<p>3、线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</p>
<h4 id="✅锁内存语义的实现"><a href="#✅锁内存语义的实现" class="headerlink" title="✅锁内存语义的实现"></a>✅锁内存语义的实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">lock.lock();                 // 获取锁</span><br><span class="line">try &#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();          // 释放锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronized(AQS) 。AQS使用一个整型的volatile变量（state）来维护同步状态，这个volatile变量是ReentrantLock内存语义实现的关键。</p>
<p><strong>公平锁：</strong></p>
<p>加锁方法首先读取volatile变量state。<br>释放锁的最后写volatile变量state。</p>
<p>效果：释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取到同一个volatile变量后将立即变得对获取锁的线程可见。</p>
<p><strong>非公平锁：</strong></p>
<p>非公平锁的释放和公平锁的释放完全一致。</p>
<p>加锁：用了：<code>unsafe.compareAndSwapInt(this, stateOffset, expect, update);</code></p>
<p>该方法以原子操作的方式更新state变量，也就是compareAndSet() (CAS)操作。JDK文档对该方法说明如下：如果当前状态值等于预期值，则以原子方式同步状态设置为给定更新的值。此操作具有volatile读和写的内存语义。<br>（编译器不能对CAS与CAS前面和后面任意内存操作重排序。）</p>
<p>CAS具有volatile读写内存语义的实现方式：lock前缀<br>intel手册对lock前缀的说明：<br>对内存的读-改-写操作原子执行。（总线锁定&#x2F;缓存锁定）<br>禁止该指令，与之前的读和写指令重排序<br>把写缓冲区的所有数据刷新到内存中<br>上面的2、3两点所具有的内存屏障的效果，足以同时实现volatile读和volatile写的内存语义。所以JDK文档说CAS 具有volatile读和volatile写的内存语义对于处理器也是符合的。</p>
<p><strong>总结：</strong><br>释放锁-获取锁的内存语义的实现方式总结 ：<br>利用volatile变量的写-读所具有的内存语义<br>利用CAS所附带的volatile读和volatile写的内存语义</p>
<h4 id="✅concurrent包的实现"><a href="#✅concurrent包的实现" class="headerlink" title="✅concurrent包的实现"></a>✅concurrent包的实现</h4><p>Java的CAS会使用现代处理器上提供的高效机器级别的原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器实现同步的关键。同时volatile变量的读&#x2F;写和CAS可以实现线程之间的通信。这些特性就是Java整个concurrent包的基石。</p>
<p>concurrent包的通用化实现模式：<br>1、声明共享变量volatile<br>2、使用CAS的原子条件更新来实现线程之间的同步<br>3、配合volatile的读&#x2F;写和CAS具有的volatile读和写的内存语义来实现线程之间的通信。</p>
<p>AQS（java.util.concurrent.locks.AbstractQueuedSynchronizer）、非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中基础类都是使用这个模式来实现的，而concurrent包中的高层类又是依赖于这些基础类。</p>
<p>图示concurrent包的实现示意图：</p>
<p><img src="/images/concurrent%E5%8C%85.png"></p>
<h3 id="6-final域的内存语义"><a href="#6-final域的内存语义" class="headerlink" title="6.final域的内存语义"></a>6.final域的内存语义</h3><p>文中探讨的变量对线程可见，是保证线程安全的方式，如果不可见，那就要同步加锁，反言之，加锁也是为了变量对线程可见。</p>
<h4 id="✅final域的重排序规则"><a href="#✅final域的重排序规则" class="headerlink" title="✅final域的重排序规则"></a>✅final域的重排序规则</h4><p>对于final域，编译器和处理器要遵守两个重排序规则。</p>
<p>1）在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p>
<blockquote>
<p>写final域的重排序规则禁止把final域的写重排序到构造函数之外。</p>
<p>写普通域的操作可能被编译器重排序到了构造函数之外，读线程B错误地读取了普通变量i初始化之前的值，很可能obj对象还没有构造完成，初始值1还没有写入普通域i。而写final域的操作，被写final域的重排序规则“限定”在了构造函数之内，读线程B正确地读取了final变量初始化之后的值。</p>
</blockquote>
<blockquote>
<p>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。</p>
</blockquote>
<p>2）初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</p>
<blockquote>
<p>编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如alpha处理器），这个规则就是专门用来针对这种处理器的。</p>
</blockquote>
<blockquote>
<p>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FinalExample &#123;</span><br><span class="line">    int i;  //普通变量</span><br><span class="line">    final int j;  //final变量</span><br><span class="line">    static FinalExample obj;</span><br><span class="line">    public FinalExample() &#123; //构造函数</span><br><span class="line">        i = 1; //写普通域</span><br><span class="line">        j = 2; //写final域</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writer() &#123; //写线程A执行</span><br><span class="line">        obj = new FinalExample();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void reader() &#123; //读线程B执行</span><br><span class="line">        FinalExample object = obj; //读对象引用</span><br><span class="line">        int a = object.i; //读普通域</span><br><span class="line">        int b = object.j; //读final域</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅final域为引用类型"><a href="#✅final域为引用类型" class="headerlink" title="✅final域为引用类型"></a>✅final域为引用类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FinalReferenceExample &#123;</span><br><span class="line">    final int[] intArray; //final是引用类型</span><br><span class="line">    static FinalReferenceExample obj;</span><br><span class="line">    public FinalReferenceExample() &#123; //构造函数</span><br><span class="line">        intArray = new int[1]; //1</span><br><span class="line">        intArray[0] = 1; //2</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writerOne() &#123; //写线程A执行</span><br><span class="line">        obj = new FinalReferenceExample(); //3</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writerTwo() &#123; //写线程B执行</span><br><span class="line">        obj.intArray[0] = 2; //4</span><br><span class="line">    &#125;</span><br><span class="line">    public static void reader() &#123; //读线程C执行</span><br><span class="line">        if (obj != null) &#123; //5</span><br><span class="line">            int temp1 = obj.intArray[0]; //6</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例final域为一个引用类型，它引用一个int型的数组对象。对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：在<strong>构造函数内</strong>对一个final引用的对象的成员域的写入(2)，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量(3)，这两个操作之间不能重排序。</p>
<p>1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。</p>
<p>写线程B对数组元素的写入，读线程C可能看得到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。</p>
<p>如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步原语（lock或volatile）来确保内存可见性。</p>
<h4 id="✅为什么含final的对象引用不能从构造函数内“溢出”"><a href="#✅为什么含final的对象引用不能从构造函数内“溢出”" class="headerlink" title="✅为什么含final的对象引用不能从构造函数内“溢出”"></a>✅为什么含final的对象引用不能从构造函数内“溢出”</h4><p>写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实，要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中“逸出”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FinalReferenceEscapeExample &#123;</span><br><span class="line">    final int                          i;</span><br><span class="line">    static FinalReferenceEscapeExample obj;</span><br><span class="line">    public FinalReferenceEscapeExample() &#123;</span><br><span class="line">        i = 1; //1写final域</span><br><span class="line">        obj = this; //2 this引用在此“逸出”</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writer() &#123;</span><br><span class="line">        new FinalReferenceEscapeExample();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void reader() &#123;  //线程B</span><br><span class="line">        if (obj != null) &#123; //3</span><br><span class="line">            int temp = obj.i; //4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作2使得对象还未完成构造前就为线程B可见。这里的操作1和操作2之间可能被重排序。线程B看到了此时的final域可能还没有被初始化。</p>
<p>final不同于普通变量达到的效果是：在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。</p>
<h4 id="✅处理器中如何实现final语义"><a href="#✅处理器中如何实现final语义" class="headerlink" title="✅处理器中如何实现final语义"></a>✅处理器中如何实现final语义</h4><p>本来应该要插入内存屏障的。<br>X86处理器不会对写-写操作做重排序，X86处理器不会对存在间接依赖关系的操作做重排序，也就是说，在X86处理器中，final域的读&#x2F;写不会插入任何内存屏障！（普通变量也有依赖关系吧，也有final语义？）</p>
<h4 id="✅JSR-133为什么要增强final的语义"><a href="#✅JSR-133为什么要增强final的语义" class="headerlink" title="✅JSR-133为什么要增强final的语义"></a>✅JSR-133为什么要增强final的语义</h4><p>在旧的Java内存模型中，一个最严重的缺陷就是线程可能看到final域的值会改变。比如，一个线程当前看到一个整型final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值时，却发现值变为1（被某个线程初始化之后的值）。</p>
<p>为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为Java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</p>
<h3 id="7-happens-before"><a href="#7-happens-before" class="headerlink" title="7.happens-before"></a>7.happens-before</h3><h4 id="✅设计初衷"><a href="#✅设计初衷" class="headerlink" title="✅设计初衷"></a>✅设计初衷</h4><p>设计内存模型JMM的初衷：让程序员易于理解，易于编程，提供内存可见性保证。对编译器和处理器的束缚越少越好，方便它们优化来提高性能。</p>
<p>JMM 对于这两种类型的重排序做了不同的处理：<br>对于有数据依赖的重排序，JMM 要求编译器和处理器禁止这种重排序<br>对于没有数据依赖的重排序，JMM 要求编译器和处理器不做处理</p>
<p>JMM 的 happens - before 向程序员提供了足够强的内存可见性保证，但是其中有些内存可见性保证其实不一定存在，【比如 int a&#x3D;1; int b&#x3D;2; 这个就只是可见，不保证执行顺序，但也是happens-before】。</p>
<p>JMM 对于编译器和处理器的优化已经尽可能少了。JMM 其实在遵循一个规则：单线程下或者已经同步的多线程下（synchronized，volatile等），只要不改变程序的执行结果，编译器和处理器想要怎么优化都可以。【比如 对于volatile 变量，如果编译器分析后认定这个变量只会被单线程访问，不存在多线程的可见性问题，那么编译器就会把 volatile 变量当作普通变量进行处理】。</p>
<h4 id="✅happens-before的定义"><a href="#✅happens-before的定义" class="headerlink" title="✅happens-before的定义"></a>✅happens-before的定义</h4><p>JSR - 133中提出，JSR - 133 使用 happens - before 关系来向程序员提供跨线程的内存可见性保证。</p>
<p>1、如果一个操作 happens - before 另一个操作，那么另一个操作的执行结果将对第二个操作可见。</p>
<p>2、两个操作之间存在 happens - before 关系，并不意味这 Java 平台必须要按照 happens - before 规定的顺序来执行。只要重排序之后的结果是不改变的，那么 JMM 是默认不对这种重排序处理的</p>
<p>核心原则是：只要不改变程序的执行结果（<strong>单线程和正确同步的多线程</strong>），编译器和处理器怎么优化都行。程序员对于这两个操作是否真的被重排序并不关心，程序员只需要关系的是程序执行时的语义不能被改变（就是执行结果不能被改变）。</p>
<p>happens - before 给编写正确同步的多线程程序的程序员一个幻觉：正确同步的多线程程序是按照 happens - before 指定的顺序来执行的。实际上不是，但是语义和按顺序执行是一样的。<br>（实际上是可见性，但也是一种假的顺序）</p>
<h4 id="✅happens-before规则"><a href="#✅happens-before规则" class="headerlink" title="✅happens-before规则"></a>✅happens-before规则</h4><p>1、程序顺序规则：一个线程中的每个操作，happens - before 于该程序的任意后续操作。</p>
<p>2、监视器规则：对一个锁的解锁，happens - before 于随后对这个锁的加锁。</p>
<p>3、volatile 变量规则：对一个 volatile 域的写，happens - before 于任意后续对这个 volatile 域的读。</p>
<p>4、传递性，如果 A happens - before B， B happens - before C，那么 A happens - before C</p>
<p>5、start() 规则：如果线程 A 执行操作 ThreadB.start()（启动线程B），那么线程 A 的 ThreadB.start() 操作 happens - before 线程 B 中的任意操作。</p>
<p>6、join() 规则：如果线程 A 执行操作 ThreadB.join() 并成功返回，那么线程 B 中的任意操作 happens- before 于线程 A 从 Thread.join() 操作成功返回。</p>
<p>⚠️像volitale变量一样，线程a写volatile变量前还写一个共享变量，线程b读那个volatile变量后还读那个共享变量，如何保证共享变量的安全性，因为线程a里的操作可能重排序，是由volitile的内存屏障插入策略和volatile的禁止编译器重排序规则来保证的，其他start方法和join方法也一样。因为重排序了的话，执行结果会不一样。</p>
<p>原书笔记：<a href="https://blog.csdn.net/laohuangaa/article/details/122773633">https://blog.csdn.net/laohuangaa/article/details/122773633</a></p>
<h3 id="8-双重检查锁定与延迟初始化"><a href="#8-双重检查锁定与延迟初始化" class="headerlink" title="8.双重检查锁定与延迟初始化"></a>8.双重检查锁定与延迟初始化</h3><p>在Java多线程程序中，有时候需要采用延迟初始化来降低初始化类和创建对象的开销。双重检查锁定是常见的延迟初始化技术，但它是一个错误的用法。</p>
<p>下面会讲述双重检查锁定为什么错误，以及两种线程安全的延迟初始化方案。</p>
<h4 id="✅双重检查锁定的由来"><a href="#✅双重检查锁定的由来" class="headerlink" title="✅双重检查锁定的由来"></a>✅双重检查锁定的由来</h4><p>在Java程序中，有时候可能需要推迟一些高开销的对象初始化操作，并且只有在使用这些对象时才进行初始化。此时，程序员可能会采用延迟初始化。</p>
<p>因为初始化可能在多线程环境下，它们共用一个对象，是需要一个线程创建就好了。非线程安全的延迟初始化对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UnsafeLazyInitialization &#123;</span><br><span class="line">    private static Instance instance;</span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null) //1：A线程执行</span><br><span class="line">            instance = new Instance(); //2：B线程执行</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A线程执行代码1的同时，B线程执行代码2。此时，线程A可能会看到instance引用的对象还没有完成初始化. 导致AB线程都初始化对象。</p>
<p>同步处理来实现线程安全的延迟初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SafeLazyInitialization &#123;</span><br><span class="line">    private static Instance instance;</span><br><span class="line">    public synchronized static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">            instance = new Instance();</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：synchronized将导致性能开销。如果getInstance()方法被多个线程频繁的调用，将会导致程序执行性能的下降。</p>
<p>因此，双重检查锁定来实现延迟初始化诞生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DoubleCheckedLocking &#123; //1</span><br><span class="line">    private static Instance instance; //2</span><br><span class="line">    public static Instance getInstance() &#123; //3</span><br><span class="line">        if (instance == null) &#123; //4:第一次检查</span><br><span class="line">            synchronized (DoubleCheckedLocking.class) &#123; //5:加锁</span><br><span class="line">                if (instance == null) //6:第二次检查</span><br><span class="line">                    instance = new Instance(); //7:问题的根源出在这里</span><br><span class="line">            &#125; //8</span><br><span class="line">        &#125; //9</span><br><span class="line">        return instance; //10</span><br><span class="line">    &#125; //11</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心思想：不会每个线程都加锁，检查instance不为null，那么就不需要执行下面的加锁和初始化操作。获取锁之后，再检查一次是不是为null，因为在第一次判断是否为null时，可能另一个线程正在初始化。<br>（获取锁之前检查一次，获取锁之后检查一次）</p>
<p>但是是错误的：在线程执行到第4行，代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</p>
<h4 id="✅双重检查锁定的问题"><a href="#✅双重检查锁定的问题" class="headerlink" title="✅双重检查锁定的问题"></a>✅双重检查锁定的问题</h4><p>第7行（instance&#x3D;new Singleton();）创建了一个对象。这一行代码可以分解为如下的3行伪代码。</p>
<p>memory &#x3D; allocate();　　&#x2F;&#x2F; 1**：分配对象的内存空间（引用变量）<br>ctorInstance(memory);　 &#x2F;&#x2F; 2**：初始化对象<br>instance &#x3D; memory;　　 &#x2F;&#x2F; 3**：设置instance指向刚分配的内存地址（赋值引用变量）（这个时候就不为null了）</p>
<p>上面3行伪代码中的2和3之间，可能会被重排序，因为这个重排序在没有改变单线程程序执行结果的前提下，可以提高程序的执行性能。</p>
<p>如果发生重排序，另一个并发执行的线程B就有可能在第4行判断instance不为null。线程B接下来将访问instance所引用的对象，但此时这个对象可能还没有被A线程初始化。<strong>线程B将会访问到一个还未初始化的对象</strong>。</p>
<p>如何解决，来实现线程安全的延迟初始化：<br>1） 不允许2和3重排序。<br>2）允许2和3重排序，但不允许其他线程“看到”这个重排序。</p>
<h4 id="✅基于volatile的解决方案"><a href="#✅基于volatile的解决方案" class="headerlink" title="✅基于volatile的解决方案"></a>✅基于volatile的解决方案</h4><p>把instance声明为volatile型，就可以实现线程安全的延迟初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SafeDoubleCheckedLocking &#123;</span><br><span class="line">    private volatile static Instance instance;</span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (SafeDoubleCheckedLocking.class) &#123;</span><br><span class="line">                if (instance == null)</span><br><span class="line">                    instance = new Instance();//instance为volatile，现在没问题了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要JDK 5或更高版本（因为从JDK 5开始使用新的JSR-133内存模型规范).</p>
<p>原理：使用了volatile修饰后，2、3将不会重排序。</p>
<h4 id="✅基于类初始化的解决方案"><a href="#✅基于类初始化的解决方案" class="headerlink" title="✅基于类初始化的解决方案"></a>✅基于类初始化的解决方案</h4><p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class InstanceFactory &#123;</span><br><span class="line">    private static class InstanceHolder &#123;</span><br><span class="line">        public static Instance instance = new Instance();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        return InstanceHolder.instance; //这里将导致InstanceHolder类被初始化</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设两个线程并发执行getInstance()方法，但是只有一个线程能获取class对象的初始化锁，然后执行对象初始化。</p>
<p>💡初始化类的时机和原理：</p>
<p>初始化一个类，包括<strong>执行这个类的静态初始化和初始化在这个类中声明的静态字段</strong>。根据Java语言规范，在首次发生下列任意一种情况时，一个类或接口类型T将被立即初始化：<br>1）T是一个类，而且一个T类型的实例被创建。<br>2）T是一个类，且T中声明的一个静态方法被调用。<br>3）T中声明的一个静态字段被赋值。<br>4）T中声明的一个静态字段被使用，而且这个字段不是一个常量字段。<br>5）T是一个顶级类（Top Level Class），而且一个断言语句嵌套在T内部被执行。</p>
<p>在InstanceFactory示例代码中，首次执行getInstance()方法的线程将导致InstanceHolder类被初始化，是情况4.<br>（相当于是用一个工厂类来初始化另一个类？）</p>
<p>Java语言是多线程的，多个线程可能在同一时间尝试去初始化同一个类或接口（比如这里多个线程可能在同一时刻调用getInstance()方法来初始化InstanceHolder类）。因此，在Java中初始化一个类或者接口时，需要做细致的同步处理。</p>
<p>Java语言规范规定，对于每一个类或接口C，都有一个唯一的初始化锁LC与之对应。从C到LC的映射，由JVM的具体实现去自由实现。JVM在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了。</p>
<p>（<strong>多个线程初始化类不是创建不同的对象吗？难道初始化类和创建对象不一样？</strong> 是的，先初始化类再创建对象）</p>
<p>对于类或接口的初始化，Java语言规范制定了精巧而复杂的类初始化处理过程。Java初始化一个类或接口的处理过程如下：</p>
<p>第1阶段：通过在Class对象上同步（即获取Class对象的初始化锁），来控制类或接口的初始化，获取锁之后，初始化维护一个状态，设置state&#x3D;initialing，然后释放锁。获取不到的话，这个获取锁的线程会一直等待，直到当前线程能够获取到这个初始化锁。</p>
<p>第2阶段：线程A执行类的初始化（上面的三步），同时线程B获取到初始化锁，发现状态是initialing，然后释放锁。后在初始化锁对应的condition上等待。</p>
<p>第3阶段：线程A获取初始化锁，设置state&#x3D;initialized后，唤醒在condition中等待的所有线程，释放锁。</p>
<p>第4阶段：线程B获取锁，发现状态是initialed，释放锁，结束类的初始化处理。</p>
<p>所以，线程A执行类的初始化时的写入操作（执行类的静态初始化和初始化类中声明的静态字段），线程B一定能看到。</p>
<p>注意：这里的condition和state标记是本文虚构出来的。</p>
<p><strong>总结：</strong></p>
<p>基于类初始化的方案的实现代码更简洁，但只能对静态字段使用。但基于volatile的双重检查锁定的方案有一个额外的优势：除了可以对静态字段实现延迟初始化外，还可以对实例字段实现延迟初始化。</p>
<p>字段延迟初始化降低了初始化类或创建实例的开销，但增加了访问被延迟初始化的字段的开销。</p>
<p>原书笔记：<a href="https://dandelioncloud.cn/article/details/1462953051467345921/">https://dandelioncloud.cn/article/details/1462953051467345921/</a></p>
<h3 id="9-java内存模型综述"><a href="#9-java内存模型综述" class="headerlink" title="9.java内存模型综述"></a>9.java内存模型综述</h3><h4 id="✅处理器的内存模型"><a href="#✅处理器的内存模型" class="headerlink" title="✅处理器的内存模型"></a>✅处理器的内存模型</h4><p>JMM：相当于是java编译器的内存模型</p>
<p>顺序一致性内存模型是一个理论参考模型，JMM和处理器内存模型在设计时通常会以顺序一致性内存模型为参照。在设计时，JMM和处理器内存模型会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。内存模型的束缚越少，处理器性能越好。</p>
<p>根据对不同类型的读&#x2F;写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为如下几种类型：<br>1、放松程序中写-读操作的顺序，由此产生了Total Store Ordering内存模型（简称为TSO）<br>2、在上面的基础上，继续放松程序中写-写操作的顺序，由此产生了Partial Store Order内存模型（简称为PSO）。<br>3、在前面两条的基础上，继续放松程序中读-写和读-读操作的顺序，由此产生了Relaxed Memory Order内存模型（简称为RMO）和PowerPC内存模型。</p>
<p>这里处理器对读&#x2F;写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守as-if-serial语义，<strong>处理器不会对存在数据依赖性的两个内存操作做重排序</strong>）。</p>
<p>所有处理器内存模型都允许写-读重排序，原因是：使用了写缓存区。写缓存区可能导致写-读操作重排序。都允许更早读到当前处理器的写，原因同样是因为写缓存区。由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己写缓存区中的写。</p>
<p><strong>虚拟机对不同操作系统反映的一致性：</strong></p>
<p>由于常见的处理器内存模型比JMM要弱，Java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱不同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入的内存屏障的数量和种类也不相同。JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现了一个一致的内存模型。</p>
<h4 id="✅各种内存模型之间的关系"><a href="#✅各种内存模型之间的关系" class="headerlink" title="✅各种内存模型之间的关系"></a>✅各种内存模型之间的关系</h4><p>JMM是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。</p>
<p>处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计得会越弱。</p>
<p>执行性能越好，易编程性越差。</p>
<h4 id="✅JMM的内存可见性保证"><a href="#✅JMM的内存可见性保证" class="headerlink" title="✅JMM的内存可见性保证"></a>✅JMM的内存可见性保证</h4><p>1、单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</p>
<p>2、正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</p>
<p>3、未同步&#x2F;未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）。</p>
<p>最小安全性“发生”在对象被任意线程使用之前。64位数据的非原子性写“发生”在对象被多个线程使用的过程中（写共享变量）。如果是写了一半的，那就是线程B写了一半的，并不是null。<br>最小安全性保证线程读取到的值不会无中生有的冒出来，但并不保证线程读取到的值一定是正确的。</p>
<p>只要多线程程序是正确同步的，JMM保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。</p>
<h4 id="✅JSR-133对旧内存模型的修补"><a href="#✅JSR-133对旧内存模型的修补" class="headerlink" title="✅JSR-133对旧内存模型的修补"></a>✅JSR-133对旧内存模型的修补</h4><p>JSR-133对JDK 5之前的旧内存模型的修补主要有两个。</p>
<p>· 增强volatile的内存语义。旧内存模型允许volatile变量与普通变量重排序。JSR-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和锁的释放-获取具有相同的内存语义。</p>
<p>· 增强final的内存语义。在旧内存模型中，多次读取同一个final变量的值可能会不相同。为此，JSR-133为final增加了两个重排序规则。在保证final引用不会从构造函数内逸出的情况下，final具有了初始化安全性。</p>
<h2 id="第四章-java并发编程"><a href="#第四章-java并发编程" class="headerlink" title="第四章 java并发编程"></a>第四章 java并发编程</h2><p>Java从诞生开始就明智地选择了内置对多线程的支持，这使得Java语言相比同一时期的其他语言具有明显的优势。</p>
<p>线程作为操作系统调度的最小单元，多个线程能够同时执行（多核同时，单核并发），这将显著提升程序性能，在多核环境中表现得更加明显。但是，过多地创建线程和对线程的不当管理也容易造成问题。</p>
<h3 id="1-线程简介"><a href="#1-线程简介" class="headerlink" title="1.线程简介"></a>1.线程简介</h3><h4 id="✅什么是线程"><a href="#✅什么是线程" class="headerlink" title="✅什么是线程"></a>✅什么是线程</h4><p>现代操作系统在运行一个程序时，会为其创建一个进程。操作系统调度的最小单元是线程，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。</p>
<p>处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。</p>
<p>Java程序天生就是多线程程序，使用JMX来查看一个普通的Java程序包含哪些线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MultiThread&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 获取Java线程管理 MXBean</span><br><span class="line">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">        // 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span><br><span class="line">        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);</span><br><span class="line">        // 遍历线程信息，仅打印线程 ID 和 线程名称信息</span><br><span class="line">        for (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">            System.out.println(&quot;[&quot; + threadInfo.getThreadId() + &quot;] &quot; + threadInfo.getThreadName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅为什么使用多线程"><a href="#✅为什么使用多线程" class="headerlink" title="✅为什么使用多线程"></a>✅为什么使用多线程</h4><p>1、更多的处理器核心<br>如果该程序使用多线程技术，将计算逻辑分配到多个处理器核心上，就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。</p>
<p>2、更快的响应时间<br>使用多线程技术，将数据一致性不强的操作派发给不同线程处理（消息队列也可以做到），响应用户请求的线程能够尽可能快地处理完成，缩短了响应时间，提升了用户体验。</p>
<p>3、更好的编程模式<br>Java为多线程编程提供了良好、考究并且一致的编程模型，使开发人员能够更加专注于问题的解决</p>
<h4 id="✅线程优先级"><a href="#✅线程优先级" class="headerlink" title="✅线程优先级"></a>✅线程优先级</h4><p>现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。</p>
<p>时间片就是分配给线程的处理器资源，在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。</p>
<p>设置线程优先级时，针对频繁阻塞（休眠或者I&#x2F;O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。</p>
<p>一个计数线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class Job implements Runnable &#123;</span><br><span class="line">            private int priority;</span><br><span class="line">            private long jobCount;</span><br><span class="line">            public Job(int priority) &#123;</span><br><span class="line">                    this.priority = priority;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (notStart) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">                while (notEnd) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                    jobCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看10s多个不同优先级的计数，操作系统可能会忽略对线程优先级的设定。</p>
<h4 id="✅线程的状态"><a href="#✅线程的状态" class="headerlink" title="✅线程的状态"></a>✅线程的状态</h4><p>线程创建之后，调用start()方法开始运行。当线程执行wait()方法之后，线程进入等待状态（释放锁）。</p>
<p>进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而超时等待状态相当于在等待状态的基础上增加了超时限制，也就是超时时间到达时将会返回到运行状态。</p>
<p>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到阻塞状态。线程在执行Runnable的run()方法之后将会进入到终止状态。</p>
<p>等待和超时等待的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//该线程在waiting.class实例上等待</span><br><span class="line">static class Waiting implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (Waiting.class) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Waiting.class.wait();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//该线程不断进行睡眠，超时等待</span><br><span class="line">static class TimeWaiting implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            SleepUtils.second(100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java将操作系统中的运行和就绪两个状态合并称为运行状态。<br>阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在java.concurrent包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法。</p>
</blockquote>
<h4 id="✅Daemon线程"><a href="#✅Daemon线程" class="headerlink" title="✅Daemon线程"></a>✅Daemon线程</h4><p>守护线程。</p>
<p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出，所有Daemon线程都需要立即终止。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。</p>
<p>Daemon属性需要在启动线程之前设置，不能在启动线程之后设置。Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。因此，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</p>
<h3 id="2-启动和终止线程"><a href="#2-启动和终止线程" class="headerlink" title="2.启动和终止线程"></a>2.启动和终止线程</h3><p>调用start方法进行启动线程，随着run方法的执行完毕，线程随之终止。</p>
<h4 id="✅构造线程"><a href="#✅构造线程" class="headerlink" title="✅构造线程"></a>✅构造线程</h4><p>在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，如线程所属的线程组、线程优先级、是否是Daemon线程等信息。</p>
<p>个新构造的线程对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的ID来标识这个child线程。</p>
<p>一个能够运行的线程对象就初始化好了，在堆内存中等待着运行。</p>
<h4 id="✅启动线程"><a href="#✅启动线程" class="headerlink" title="✅启动线程"></a>✅启动线程</h4><p>线程对象在初始化完成之后，调用start()方法就可以启动这个线程。</p>
<p>线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。</p>
<h4 id="✅中断线程"><a href="#✅中断线程" class="headerlink" title="✅中断线程"></a>✅中断线程</h4><p>中断，效果是终止一个线程，可以理解为线程的一个标识位属性 （并不能直接终止一个线程），它表示一个运行中的线程是否被其他线程进行了中断操作。</p>
<p>中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的 interrupt() 方法对其进行中断操作。线程通过检查自身是否被中断来进行响应，线程通过方法 isInterrupted() 来进行判断是否被中断。</p>
<p>从Java的API中可以看到，许多声明抛出InterruptedException的方法（例如Thread.sleep （long millis）方法）这些方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。</p>
<p>如下所示的例子中，首先创建了两个线程，SleepThread和BusyThread，前者不停地睡眠，后者一直运行，然后对这两个线程分别进行中断操作，观察二者的中断标识位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Interrupted &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // sleepThread不停的尝试睡眠</span><br><span class="line">        Thread sleepThread = new Thread(new SleepRunner(), &quot;SleepThread&quot;);</span><br><span class="line">        sleepThread.setDaemon(true);</span><br><span class="line">        // busyThread不停的运行</span><br><span class="line">        Thread busyThread = new Thread(new BusyRunner(), &quot;BusyThread&quot;);</span><br><span class="line">        busyThread.setDaemon(true);</span><br><span class="line">        sleepThread.start();</span><br><span class="line">        busyThread.start();</span><br><span class="line">        // 休眠5秒，让sleepThread和busyThread充分运行</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        sleepThread.interrupt();</span><br><span class="line">        busyThread.interrupt();</span><br><span class="line">        System.out.println(&quot;SleepThread interrupted is &quot; + sleepThread.isInterrupted());</span><br><span class="line">        System.out.println(&quot;BusyThread interrupted is &quot; + busyThread.isInterrupted());</span><br><span class="line">        // 防止sleepThread和busyThread立刻退出</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125;</span><br><span class="line">    static class SleepRunner implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(10000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // 对于Sleep，如果发生了中断，就会抛出中断异常。抛出后，interrupt的表示位会被重置。</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class BusyRunner implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，抛出InterruptedException的线程SleepThread，其中断标识位被清除了，返回false。而一直忙碌运作的线程BusyThread，中断标识位没有被清除，返回true。</p>
<h4 id="✅过期的suspend-、resume-和stop"><a href="#✅过期的suspend-、resume-和stop" class="headerlink" title="✅过期的suspend()、resume()和stop()"></a>✅过期的suspend()、resume()和stop()</h4><p>suspend()、resume()和stop()方法完成了线程的暂停、恢复和终止工作，而且非常“人性化”。但是这些API是过期的，也就是不建议使用的。</p>
<p>不建议使用的原因主要是：</p>
<p>以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。<br>同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</p>
<p>暂停和恢复操作可以用后面提到的等待&#x2F;通知机制来替代。</p>
<h4 id="✅安全地终止线程"><a href="#✅安全地终止线程" class="headerlink" title="✅安全地终止线程"></a>✅安全地终止线程</h4><p>中断状态是线程的一个标识位，而中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。</p>
<p>除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。</p>
<p>方法1：使用中断interrupt方法进行中断。按说是直接中断线程了，没加代码中的判断也应该中断的。❓<br>方法2：使用一个volatile的boolean类型变量来控制，实际上是中断while方法，然后执行完run方法，终止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Shutdown &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Runner one = new Runner();</span><br><span class="line">        Thread countThread = new Thread(one, &quot;CountThread&quot;);</span><br><span class="line">        countThread.start();</span><br><span class="line">        // 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        countThread.interrupt();</span><br><span class="line">        Runner two = new Runner();</span><br><span class="line">        countThread = new Thread(two, &quot;CountThread&quot;);</span><br><span class="line">        countThread.start();</span><br><span class="line">        // 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        two.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    private static class Runner implements Runnable &#123;</span><br><span class="line">        private long i;</span><br><span class="line">            private volatile boolean on = true;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">            while (on &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;Count i = &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">        public void cancel() &#123;</span><br><span class="line">            on = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例在执行过程中，main线程通过中断操作和cancel()方法均可使CountThread得以终止。</p>
<p>这种通过标识位或者中断操作的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止，因此这种终止线程的做法显得更加安全和优雅。</p>
<h3 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3.线程间通信"></a>3.线程间通信</h3><p>线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。多个线程配合工作，才更有价值。</p>
<h4 id="✅volatile和synchronized关键字"><a href="#✅volatile和synchronized关键字" class="headerlink" title="✅volatile和synchronized关键字"></a>✅volatile和synchronized关键字</h4><p>背景：<br>Java支持多个线程同时访问一个对象或者对象的成员变量，由于每个线程可以拥有这个变量的拷贝（虽然对象以及成员变量分配的内存是在共享内存中的，但是每个执行的线程还可以拥有一份拷贝，这样做的目的是加速程序的执行，这是现代多核处理器的一个显著特性）（就是线程的本地内存），所以程序在执行过程中，一个线程看到的变量并不一定是最新的。</p>
<p>volatile怎么解决：<br>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</p>
<p>sychronized怎么解决：<br>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p>
<p>一点sychronized的实现原理：</p>
<p>看字节码文件，monitorenter和monitorexit指令，是对一个对象的监视器的获取，这个获取过程是排他的，一个时刻只有一个线程能够获取到由sychronized保护的对象的监视器。</p>
<p>任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器（执行该方法）的线程将会被阻塞在同步块和同步方法的入口处（进入同步队列），进入BLOCKED状态。当获锁线程释放了锁，该释放操作唤醒阻塞在同步队列中的线程，重新尝试对监视器的获取。</p>
<h4 id="✅等待-通知机制"><a href="#✅等待-通知机制" class="headerlink" title="✅等待&#x2F;通知机制"></a>✅等待&#x2F;通知机制</h4><p>背景：生产者线程修改某个变量的值，消费者线程能够感知到。简单的办法是让消费者线程不断地循环检查变量是否符合预期。但是开销大。</p>
<p>Java通过内置的等待&#x2F;通知机制能够很好地解决这个矛盾并实现所需的功能。<br>等待&#x2F;通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超类java.lang.Object上。（监视器方法）</p>
<p>等待&#x2F;通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。<br>上述两个线程通过对象O来完成交互，而对象上的wait()和notify&#x2F;notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。（两个notify都是通知等待队列里的，不是阻塞状态的同步队列，notify通知一个，notifyAll通知所有）。</p>
<p>例子：创建了两个线程——WaitThread和NotifyThread，前者检查flag值是否为false，如果符合要求，进行后续操作，否则在lock上等待，后者在睡眠了一段时间后对lock进行通知。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class WaitNotify &#123;</span><br><span class="line">    static boolean flag = true;</span><br><span class="line">    static Object lock = new Object();</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Thread waitThread = new Thread(new Wait(), &quot;WaitThread&quot;);</span><br><span class="line">        waitThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        Thread notifyThread = new Thread(new Notify(), &quot;NotifyThread&quot;);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    static class Wait implements Runnable &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            // 加锁，拥有lock的Monitor</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                // 当条件不满足时，继续wait，同时释放了lock的锁</span><br><span class="line">                while (flag) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + &quot; flag is true. wait@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 条件满足时，完成工作</span><br><span class="line">                System.out.println(Thread.currentThread() + &quot; flag is false. running@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Notify implements Runnable &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            // 加锁，拥有lock的Monitor</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                // 获取lock的锁，然后进行通知，通知时不会释放lock的锁，</span><br><span class="line">                // 直到当前线程释放了lock后，WaitThread才能从wait方法中返回</span><br><span class="line">                System.out.println(Thread.currentThread() + &quot; hold lock. notify @ &quot; +</span><br><span class="line">                        new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                flag = false;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 再次加锁</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + &quot; hold lock again. sleep@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用wait()、notify()以及notifyAll()时需要注意的细节:</p>
<p>1、使用wait()、notify()和notifyAll()时需要先对调用对象加锁。</p>
<p>2、调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列，并释放锁。</p>
<p>3、notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。</p>
<p>4、notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为BLOCKED。</p>
<p>5、从wait()方法返回的前提是获得了调用对象的锁。<strong>等待&#x2F;通知机制依托于同步机制</strong>，其目的就是确保等待线程从wait()方法返回时能够感知到通知线程对变量做出的修改（也就是flag变量）。</p>
<p>梳理一下等待线程的状态变化：<br>1、wait线程首先获取锁，调用lock的wait方法，放弃了锁，进入等待队列，等待状态。（可以有很多个wait线程）<br>2、notify线程获取了锁，调用lock的notify方法，将wait线程从等待队列移动到了同步队列，是阻塞状态。（notify只能唤醒一个）<br>3、notify线程运行完了，释放锁，wait线程获取到锁，从wait方法返回并继续执行。</p>
<p>sleep不会释放锁<br>wait会释放锁</p>
<h4 id="✅等待-通知的经典范式"><a href="#✅等待-通知的经典范式" class="headerlink" title="✅等待&#x2F;通知的经典范式"></a>✅等待&#x2F;通知的经典范式</h4><p>范式分为两部分，分别针对等待方（消费者）和通知方（生产者）</p>
<p>等待方遵循如下原则：<br>1、获取对象的锁。<br>2、如果条件不满足（flag变量），那么调用对象的wait()方法，被通知后仍要检查条件。<br>3、条件满足则执行对应的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized(对象) &#123;</span><br><span class="line">	while(条件不满足) &#123;</span><br><span class="line">		对象.wait();</span><br><span class="line">	&#125;</span><br><span class="line">	对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知方遵循如下原则：<br>1、获得对象的锁。<br>2、改变条件。<br>3、通知所有等待在对象上的线程。（先改变条件还是先通知都行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized(对象) &#123;</span><br><span class="line">	改变条件(flag)</span><br><span class="line">	对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>1、flag的目的：相当于是一个线程修改了某个值，另一个线程能感知到，起到一个多线程通信达到什么条件做什么事的效果。<br>2、同步的目的：获取了锁才能wait和notify，同步的目的是把修改变量和notify包在一起，让wait出来的时候能感知到变量的变化。<br>3、其实这个模式已经是偏底层了。<br>4、flag和lock可以用一个，直接用flag来当锁（就像后面的手写线程池）</p>
<h4 id="✅管道输入-输出流"><a href="#✅管道输入-输出流" class="headerlink" title="✅管道输入&#x2F;输出流"></a>✅管道输入&#x2F;输出流</h4><p>管道输入&#x2F;输出流和普通的文件输入&#x2F;输出流或者网络输入&#x2F;输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p>
<p>管道输入&#x2F;输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。</p>
<p>例子：printThread线程接受main线程的输入，任何main线程的输入均通过PipedWriter写入，而printThread在另一端通过PipedReader将内容读出并打印。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Piped &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        PipedWriter out = new PipedWriter();</span><br><span class="line">        PipedReader in = new PipedReader();</span><br><span class="line">        // 将输出流和输入流进行连接，否则在使用时会抛出IOException</span><br><span class="line">        out.connect(in);</span><br><span class="line">        Thread printThread = new Thread(new Print(in), &quot;PrintThread&quot;);</span><br><span class="line">        printThread.start();</span><br><span class="line">        int receive = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            while ((receive = System.in.read()) != -1) &#123;</span><br><span class="line">                out.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Print implements Runnable &#123;</span><br><span class="line">        private PipedReader in;</span><br><span class="line"></span><br><span class="line">        public Print(PipedReader in) &#123;</span><br><span class="line">            this.in = in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int receive = 0;</span><br><span class="line">            try &#123;</span><br><span class="line">                while ((receive = in.read()) != -1) &#123;</span><br><span class="line">                    System.out.print((char) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️对于Piped类型的流，必须先要进行绑定，也就是调用connect()方法，如果没有将输入&#x2F;输出流绑定起来，对于该流的访问将会抛出异常。</p>
<h4 id="✅Thread-join-的使用"><a href="#✅Thread-join-的使用" class="headerlink" title="✅Thread.join()的使用"></a>✅Thread.join()的使用</h4><p>如果一个线程A执行了thread.join()语句，其含义是：<br>当前线程A等待thread线程终止之后才从thread.join()返回，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。</p>
<p>例子：创建了10个线程，编号0~9，每个线程调用前一个线程的join()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Join &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Thread previous = Thread.currentThread();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">			// 每个线程拥有前一个线程的引用，需要等待前一个线程终止，才能从等待中返回</span><br><span class="line">            Thread thread = new Thread(new Domino(previous), String.valueOf(i));</span><br><span class="line">            thread.start();</span><br><span class="line">            previous = thread;</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; terminate.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Domino implements Runnable &#123;</span><br><span class="line">        private Thread thread;</span><br><span class="line"></span><br><span class="line">        public Domino(Thread thread) &#123;</span><br><span class="line">            this.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; terminate.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：等待&#x2F;通知机制（等待前驱线程结束，接收前驱线程结束通知）。加锁、循环和处理逻辑3个步骤。</p>
<p>1、线程a执行线程b的join方法，相当于用线程b对象做同步，内部本线程wait进入等待，并用一个变量flag进行条件判断。<br>2、线程b终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的线程。</p>
<h4 id="✅ThreadLocal的使用"><a href="#✅ThreadLocal的使用" class="headerlink" title="✅ThreadLocal的使用"></a>✅ThreadLocal的使用</h4><p>ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。它不是线程共有的，而是私有的。即修改不会影响其他线程。一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的值。set()方法设置，get()方法获取设置的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line">取出后，(T)value强转即可</span><br></pre></td></tr></table></figure>

<p>例子：一个Profile类，具有begin()和end()两个方法，而end()方法返回从begin()方法调用开始到end()方法被调用时的时间差，单位是毫秒。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Profiler &#123;</span><br><span class="line">    // 第一次get()方法调用时会进行初始化（如果set方法没有调用），每个线程会调用一次</span><br><span class="line">    private static final ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = new ThreadLocal&lt;Long&gt;() &#123;</span><br><span class="line">        protected Long initialValue() &#123;</span><br><span class="line">            return System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static final void begin() &#123;</span><br><span class="line">        TIME_THREADLOCAL.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final long end() &#123;</span><br><span class="line">        return System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        System.out.println(&quot;Cost: &quot; + Profiler.end() + &quot; mills&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用途：Profiler可以被复用在方法调用耗时统计的功能上，在方法的入口前执行begin()方法，在方法调用后执行end()方法。好处是两个方法的调用不用在一个方法或者类中。</p>
<h3 id="4-线程应用案例"><a href="#4-线程应用案例" class="headerlink" title="4.线程应用案例"></a>4.线程应用案例</h3><h4 id="✅等待超时模式"><a href="#✅等待超时模式" class="headerlink" title="✅等待超时模式"></a>✅等待超时模式</h4><p>在前面等待&#x2F;通知模式的基础上，如果该方法能够在给定的时间段之内得到结果，那么将结果立刻返回，反之，超时返回默认结果。</p>
<p>范式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 对当前对象加锁</span><br><span class="line">public synchronized Object get(long mills) throws InterruptedException &#123;</span><br><span class="line">	long future = System.currentTimeMillis() + mills;</span><br><span class="line">	long remaining = mills;</span><br><span class="line">	// 当超时大于0并且result返回值不满足要求</span><br><span class="line">	while ((result == null) &amp;&amp; remaining &gt; 0) &#123;</span><br><span class="line">		wait(remaining);</span><br><span class="line">		remaining = future - System.currentTimeMillis();</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等待超时模式就是在等待&#x2F;通知范式基础上增加了超时控制，这使得该模式相比原有范式更具有灵活性，因为即使方法执行时间过长，也不会“永久”阻塞调用者，而是会按照调用者的要求“按时”返回。</p>
<p>并且，不是只wait固定的时间就完事，而是循环检查是不是wait够了，够了就直接返回不wait了。</p>
<h4 id="✅一个简单的数据库连接池示例"><a href="#✅一个简单的数据库连接池示例" class="headerlink" title="✅一个简单的数据库连接池示例"></a>✅一个简单的数据库连接池示例</h4><p>使用等待超时模式来构造一个简单的数据库连接池，在示例中模拟从连接池中获取、使用和释放连接的过程，而客户端获取连接的过程被设定为等待超时的模式，也就是在1000毫秒内如果无法获取到可用连接，将会返回给客户端一个null。</p>
<p>设定连接池的大小为10个，然后通过调节客户端的线程数来模拟无法获取连接的场景。</p>
<p>首先看一下连接池的定义。它通过构造函数初始化连接的最大上限，通过一个双向队列来维护连接，调用方需要先调用fetchConnection(long)方法来指定在多少毫秒内超时获取连接，当连接使用完成后，需要调用releaseConnection(Connection)方法将连接放回线程池，示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConnectionPool &#123;</span><br><span class="line">	//连接池</span><br><span class="line">    private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">    //构造</span><br><span class="line">    public ConnectionPool(int initialSize) &#123;</span><br><span class="line">        if (initialSize &gt; 0) &#123;</span><br><span class="line">        	//创建数据库连接</span><br><span class="line">            for (int i = 0; i &lt; initialSize; i++) &#123;</span><br><span class="line">                pool.addLast(ConnectionDriver.createConnection());//该类在后面实现，用于初始化线程池</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void releaseConnection(Connection connection) &#123;</span><br><span class="line">        if (connection != null) &#123;</span><br><span class="line">            synchronized (pool) &#123;</span><br><span class="line">                // 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                // 唤醒所有等待，让他们去竞争锁</span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在mills内无法获取到连接，将会返回null</span><br><span class="line">    //获取连接</span><br><span class="line">    public Connection fetchConnection(long mills) throws InterruptedException &#123;</span><br><span class="line">        synchronized (pool) &#123;</span><br><span class="line">        	// 该部分代码逻辑为</span><br><span class="line">        	// 当完全超时时，必然会获得一个连接池对象,也即是无线等待时间。当传入mills &gt; 0时，不会走入该分支。因为else分支会处理其中超时情况</span><br><span class="line">        	// 非完全超时时，获得就返回一个连接池对象，不然就返回空</span><br><span class="line">        	</span><br><span class="line">            // 完全超时</span><br><span class="line">            if (mills &lt;= 0) &#123;</span><br><span class="line">            	// 连接池为空</span><br><span class="line">                while (pool.isEmpty()) &#123;</span><br><span class="line">                    //以连接池为通知对象，等待直到被唤醒，不在主动醒来</span><br><span class="line">                    pool.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                // 拿出连接池中第一个连接，并返回给当前请求者</span><br><span class="line">                return pool.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            //未超时 </span><br><span class="line">            else &#123;</span><br><span class="line">                long future = System.currentTimeMillis() + mills;</span><br><span class="line">                long remaining = mills;</span><br><span class="line">                //连接池为空且未超时</span><br><span class="line">                while (pool.isEmpty() &amp;&amp; remaining &gt; 0) &#123;</span><br><span class="line">                	//以连接池为通知对象，等待remaining毫秒,或者被唤醒</span><br><span class="line">                    pool.wait(remaining);</span><br><span class="line">                    // 获取剩余时间，通过它来判断是主动醒来（超时），还是被动唤醒（notify）</span><br><span class="line">                    // 无论是被动还是主动醒来，都尝试获取连接池这个对象锁</span><br><span class="line">                    remaining = future - System.currentTimeMillis();</span><br><span class="line">                    // 获得锁以后判断连接池是不是空的，空的的话再判断是否超时，超时就离开循环</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Connection result = null;</span><br><span class="line">                //抢到连接池这个对象锁后，若此时连接池不为空</span><br><span class="line">                if (!pool.isEmpty()) &#123;</span><br><span class="line">                	// 拿出连接池中第一个连接，并返回给当前请求者</span><br><span class="line">                    result = pool.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                // 否则此时为空</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于java.sql.Connection是一个接口，最终的实现是由数据库驱动提供方来实现的，考虑到只是个示例，我们通过<strong>动态代理</strong>构造了一个Connection，该Connection的代理实现仅仅是在commit()方法（提交sql）调用时休眠100毫秒，示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConnectionDriver &#123;</span><br><span class="line"></span><br><span class="line">    static class ConnectionHandler implements InvocationHandler &#123;</span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123;</span><br><span class="line">         // 在方法执行之前</span><br><span class="line">        // 当方法是提交时，我们睡眠100毫秒</span><br><span class="line">        if (method.getName().equals(&quot;commit&quot;))&#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 执行原本方法，此处就不执行了</span><br><span class="line">       	// Object invoke = method.invoke(vehical, args);</span><br><span class="line">       	</span><br><span class="line">		// 执行方法之后，此处也不处理，直接放回null</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    // 创建一个Connection的代理，在commit时休眠100毫秒</span><br><span class="line">    public static final Connection createConnection() &#123;</span><br><span class="line">    	// 创建一个代理实例</span><br><span class="line">    	// 类加载器(用哪个类加载器去加载代理对象) + 代理的类(接口，切入点) + 代理方法</span><br><span class="line">    	// 可以理解我们为Connection的&quot;commit&quot;方法，通过JDK的方式代理了一层(AOP)</span><br><span class="line">    	// 返回的就是我们Spring中学习的 代理额外增加的层 + 原本的类对象</span><br><span class="line">        return (Connection) Proxy.newProxyInstance(ConnectionDriver.class.getClassLoader(),new Class &lt;?&gt;[]&#123;</span><br><span class="line">            Connection.class</span><br><span class="line">        &#125;,new ConnectionHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面通过一个示例来测试简易数据库连接池的工作情况，模拟客户端ConnectionRunner获取、使用、最后释放连接的过程，当它使用时连接将会增加获取到连接的数量，反之，将会增加未获取到连接的数量，示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConnectionPoolTest &#123;</span><br><span class="line">    static ConnectionPool pool = new ConnectionPool(10);</span><br><span class="line">    // 保证所有ConnectionRunner能够同时开始</span><br><span class="line">    static CountDownLatch start = new CountDownLatch(1);</span><br><span class="line">    // main线程将会等待所有ConnectionRunner结束后才能继续执行</span><br><span class="line">    static CountDownLatch end;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 线程数量，可以修改线程数量进行观察</span><br><span class="line">        int threadCount = 10;</span><br><span class="line">        end = new CountDownLatch(threadCount);</span><br><span class="line">        int count = 20;</span><br><span class="line">        // 用原子记录 获取到的与没有获取到的</span><br><span class="line">        AtomicInteger got = new AtomicInteger();</span><br><span class="line">        AtomicInteger notGot = new AtomicInteger();</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">        	// 运行线程</span><br><span class="line">            Thread thread = new Thread(new ConnetionRunner(count, got, notGot),</span><br><span class="line">                    &quot;ConnectionRunnerThread&quot;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        //运行到这里start值-1，此时为0，因此所有线程不再会被阻塞，开始执行</span><br><span class="line">        start.countDown();</span><br><span class="line">        //主线程阻塞在这里，等待end为0，即等待所有线程结束</span><br><span class="line">        end.await();   //等10个线程都执行完</span><br><span class="line">        System.out.println(&quot;total invoke: &quot; + (threadCount * count));</span><br><span class="line">        System.out.println(&quot;got connection: &quot; + got);</span><br><span class="line">        System.out.println(&quot;not got connection &quot; + notGot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ConnetionRunner implements Runnable &#123;</span><br><span class="line">        int count;</span><br><span class="line">        AtomicInteger got;</span><br><span class="line">        AtomicInteger notGot;</span><br><span class="line"></span><br><span class="line">		// got、noteGot因为是引用，所以本质还是原来的那个</span><br><span class="line">        public ConnetionRunner(int count, AtomicInteger got, AtomicInteger notGot) &#123;</span><br><span class="line">            this.count = count;</span><br><span class="line">            this.got = got;</span><br><span class="line">            this.notGot = notGot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            	// 阻塞在这里，等待start为0</span><br><span class="line">                start.await();  //等10个线程都创建好后一起执行</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            // 当count &gt; 0 时，再次执行</span><br><span class="line">            while (count &gt; 0) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 从线程池中获取连接，如果1000ms内无法获取到，将会返回null</span><br><span class="line">                    // 分别统计连接获取的数量got和未获取到的数量notGot</span><br><span class="line">                    Connection connection = pool.fetchConnection(1000);</span><br><span class="line">                    // 如果获取到了</span><br><span class="line">                    if (connection != null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                        	// 创建SQL语句</span><br><span class="line">                            connection.createStatement();</span><br><span class="line">                            // 执行提交</span><br><span class="line">                            connection.commit();</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                        	// 释放</span><br><span class="line">                            pool.releaseConnection(connection);</span><br><span class="line">                            // 获取到got + 1</span><br><span class="line">                            got.incrementAndGet();</span><br><span class="line">                        &#125;</span><br><span class="line">                     // 没有获取到</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                    	// 没有获取到notGot + 1</span><br><span class="line">                        notGot.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception ex) &#123;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                </span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 线程结束 end - 1</span><br><span class="line">            end.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中使用了CountDownLatch来确保ConnectionRunnerThread能够同时开始执行，并且在全部结束之后，才使main线程从等待状态中返回。</p>
<p>在资源一定的情况下（连接池中的10个连接），随着客户端线程的逐步增加，客户端出现超时无法获取连接的比率不断升高。</p>
<h4 id="✅线程池技术及其示例"><a href="#✅线程池技术及其示例" class="headerlink" title="✅线程池技术及其示例"></a>✅线程池技术及其示例</h4><p>如果服务端每次接受到一个任务，创建一个线程，然后进行执行，这会使操作系统频繁的进行线程上下文切换，无故增加系统的负载，而线程的创建和消亡都是需要耗费系统资源的，也无疑浪费了系统资源。</p>
<p>线程池技术能够很好地解决这个问题，它预先创建了若干数量的线程，并且不能由用户直接对线程的创建进行控制，在这个前提下重复使用固定或较为固定数目的线程来完成任务的执行。</p>
<p>线程池的好处：<br>1、消除了频繁创建和消亡线程的系统资源开销<br>2、面对过量任务的提交能够平缓的劣化。</p>
<p>线程池接口定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ThreadPool&lt;Job extends Runnable&gt; &#123;</span><br><span class="line">    // 执行一个Job，这个Job需要实现Runnable</span><br><span class="line">    void execute(Job job);</span><br><span class="line"></span><br><span class="line">    // 关闭线程池</span><br><span class="line">    void shutdown();</span><br><span class="line"></span><br><span class="line">    // 增加工作者线程</span><br><span class="line">    void addWorkers(int num);</span><br><span class="line"></span><br><span class="line">    // 减少工作者线程</span><br><span class="line">    void removeWorker(int num);</span><br><span class="line"></span><br><span class="line">    // 得到正在等待执行的任务数量</span><br><span class="line">    int getJobSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端可以通过execute(Job)方法将Job提交入线程池执行，而客户端自身不用等待Job的执行完成。<br>除了execute(Job)方法以外，线程池接口提供了增大&#x2F;减少工作者线程以及关闭线程池的方法。<br>这里工作者线程代表着一个重复执行Job的线程，而每个由客户端提交的Job都将进入到一个工作队列中等待工作者线程的处理。</p>
<p>手写一个线程池，不用Executor创建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultThreadPool&lt;Job extends Runnable&gt; implements ThreadPool&lt;Job&gt; &#123;</span><br><span class="line">    // 线程池最大限制数</span><br><span class="line">    private static final int MAX_WORKER_NUMBERS = 10;</span><br><span class="line">    // 线程池默认的数量</span><br><span class="line">    private static final int DEFAULT_WORKER_NUMBERS = 5;</span><br><span class="line">    // 线程池最小的数量</span><br><span class="line">    private static final int MIN_WORKER_NUMBERS = 1;</span><br><span class="line">    // 这是一个工作列表，将会向里面插入工作</span><br><span class="line">    private final LinkedList&lt;Job&gt; jobs = new LinkedList&lt;Job&gt;();</span><br><span class="line">    // 工作者列表</span><br><span class="line">    private final List&lt;Worker&gt; workers = Collections.synchronizedList(new ArrayList&lt;Worker&gt;());</span><br><span class="line">    // 工作者线程的数量</span><br><span class="line">    private int workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line">    // 线程编号生成</span><br><span class="line">    private AtomicLong threadNum = new AtomicLong();</span><br><span class="line">	</span><br><span class="line">    //构造函数</span><br><span class="line">    public DefaultThreadPool() &#123;</span><br><span class="line">        initializeWokers(DEFAULT_WORKER_NUMBERS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DefaultThreadPool(int num) &#123;</span><br><span class="line">    	// num &gt; max ， 取 max，num &lt; min 取 min。其他取 num</span><br><span class="line">        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS:(num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num);</span><br><span class="line">        initializeWokers(workerNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void execute(Job job) &#123;</span><br><span class="line">        if (job != null) &#123;</span><br><span class="line">            // 添加一个工作，然后进行通知</span><br><span class="line">            synchronized (jobs) &#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                jobs.notify();   //通知（这里jobs既是flag又是lock）</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutdown() &#123;</span><br><span class="line">        for (Worker worker : workers) &#123;</span><br><span class="line">            worker.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addWorkers(int num) &#123;</span><br><span class="line">        synchronized (jobs) &#123;</span><br><span class="line">            // 限制新增的Worker数量不能超过最大值</span><br><span class="line">            if (num + this.workerNum &gt; MAX_WORKER_NUMBERS) &#123;</span><br><span class="line">                num = MAX_WORKER_NUMBERS - this.workerNum;</span><br><span class="line">            &#125;</span><br><span class="line">            initializeWokers(num);</span><br><span class="line">            this.workerNum += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void removeWorker(int num) &#123;</span><br><span class="line">        synchronized (jobs) &#123;</span><br><span class="line">            if (num &gt;= this.workerNum) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;beyond workNum&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 按照给定的数量停止Worker</span><br><span class="line">            int count = 0;</span><br><span class="line">            while (count &lt; num) &#123;</span><br><span class="line">                Worker worker = workers.get(count);</span><br><span class="line">                if (workers.remove(worker)) &#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            this.workerNum -= count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getJobSize() &#123;</span><br><span class="line">        return jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化线程工作者</span><br><span class="line">    private void initializeWokers(int num) &#123;</span><br><span class="line">        for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = new Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread thread = new Thread(worker, &quot;ThreadPool-Worker-&quot; + threadNum.inrementAndGet());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 工作者，负责消费任务</span><br><span class="line">    class Worker implements Runnable &#123;</span><br><span class="line">        // 是否工作</span><br><span class="line">        private volatile boolean running = true;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (running) &#123;</span><br><span class="line">                Job job = null;</span><br><span class="line">                synchronized (jobs) &#123;</span><br><span class="line">                    // 如果工作者列表是空的，那么就wait</span><br><span class="line">                    while (jobs.isEmpty()) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            jobs.wait();  //等待</span><br><span class="line">                        &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">                            // 感知到外部对WorkerThread的中断操作，返回</span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 取出一个Job</span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                if (job != null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        job.run();</span><br><span class="line">                    &#125; catch (Exception ex) &#123;</span><br><span class="line">                        // 忽略Job执行中的Exception</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void shutdown() &#123;</span><br><span class="line">            running = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Job是要放入线程池的线程，Worker是线程池内执行Job线程的工作线程。里面用了等待通知模式，放入一个job会通知一下，jobs为空了就会等待。</p>
<p>当客户端调用execute(Job)方法时，会不断地向任务列表jobs中添加Job，而每个工作者线程会不断地从jobs上取出一个Job进行执行，当jobs为空时，工作者线程进入等待状态。</p>
<p>添加一个Job后，对工作队列jobs调用了其notify()方法，而不是notifyAll()方法，因为能够确定有工作者线程被唤醒，这时使用notify()方法将会比notifyAll()方法获得更小的开销（避免将等待队列中的线程全部移动到阻塞队列中）。</p>
<p>可以看到，线程池的本质就是使用了一个线程安全的工作队列连接工作者线程和客户端线程，客户端线程将任务放入工作队列后便返回，而工作者线程则不断地从工作队列上取出工作并执行。当工作队列为空时，所有的工作者线程均等待在工作队列上，当有客户端提交了一个任务之后会通知任意一个工作者线程，随着大量的任务被提交，更多的工作者线程会被唤醒。</p>
<h4 id="✅一个基于线程池技术的简单Web服务器"><a href="#✅一个基于线程池技术的简单Web服务器" class="headerlink" title="✅一个基于线程池技术的简单Web服务器"></a>✅一个基于线程池技术的简单Web服务器</h4><p>目前的浏览器都支持多线程访问，比如说在请求一个HTML页面的时候，页面中包含的图片资源、样式资源会被浏览器发起并发的获取。</p>
<p>大部分Web服务器也都是支持并发访问的。常用的Java Web服务器，如Tomcat、Jetty，在其处理请求的过程中都使用到了线程池技术。</p>
<p>使用前一节中的线程池来构造一个简单的Web服务器，这个Web服务器用来处理HTTP请求，目前只能处理简单的文本和JPG图片内容。这个Web服务器使用main线程不断地接受客户端Socket的连接，将连接以及请求提交给线程池处理，这样使得Web服务器能够同时处理多个客户端请求，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SimpleHttpServer &#123;</span><br><span class="line">    // 处理HttpRequest的线程池</span><br><span class="line">    static ThreadPool&lt;HttpRequestHandler&gt; threadPool = new DefaultThreadPool&lt;HttpRequestHandler&gt;(1);</span><br><span class="line">    // SimpleHttpServer的根路径</span><br><span class="line">    static String basePath;</span><br><span class="line">    static ServerSocket serverSocket;</span><br><span class="line">    // 服务监听端口</span><br><span class="line">    static int port = 8080;</span><br><span class="line"></span><br><span class="line">    public static void setPort(int port) &#123;</span><br><span class="line">        if (port &gt; 0) &#123;</span><br><span class="line">            SimpleHttpServer.port = port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setBasePath(String basePath) &#123;</span><br><span class="line">         if (basePath != null &amp;&amp; new File(basePath).exists() &amp;&amp; new File(basePath).isDirectory()) &#123;</span><br><span class="line">            SimpleHttpServer.basePath = basePath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 启动SimpleHttpServer，一个客户端请求</span><br><span class="line">    public static void start() throws Exception &#123;</span><br><span class="line">        serverSocket = new ServerSocket(port);</span><br><span class="line">        Socket socket = null;</span><br><span class="line">        //accept():3次握手结束，接受连接</span><br><span class="line">        while ((socket = serverSocket.accept()) != null) &#123;</span><br><span class="line">            // 接收一个客户端Socket，生成一个HttpRequestHandler，放入线程池执行</span><br><span class="line">            threadPool.execute(new HttpRequestHandler(socket));</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class HttpRequestHandler implements Runnable &#123;</span><br><span class="line">        private Socket socket;</span><br><span class="line"></span><br><span class="line">        public HttpRequestHandler(Socket socket) &#123;</span><br><span class="line">            this.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            String line = null;</span><br><span class="line">            BufferedReader br = null;</span><br><span class="line">            BufferedReader reader = null;</span><br><span class="line">            PrintWriter out = null;</span><br><span class="line">            InputStream in = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String header = reader.readLine();</span><br><span class="line">                // 由相对路径计算出绝对路径</span><br><span class="line">                String filePath = basePath + header.split(&quot; &quot;)[1];</span><br><span class="line">                out = new PrintWriter(socket.getOutputStream());</span><br><span class="line">                 // 如果请求资源的后缀为jpg或者ico，则读取资源并输出</span><br><span class="line">                if (filePath.endsWith(&quot;jpg&quot;) || filePath.endsWith(&quot;ico&quot;)) &#123;</span><br><span class="line">                    in = new FileInputStream(filePath);</span><br><span class="line">                    ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">                    int i = 0;</span><br><span class="line">                    while ((i = in.read()) != -1) &#123;</span><br><span class="line">                        baos.write(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    byte[] array = baos.toByteArray();</span><br><span class="line">                    out.println(&quot;HTTP/1.1 200 OK&quot;);</span><br><span class="line">                    out.println(&quot;Server: yjx23332&quot;);</span><br><span class="line">                    out.println(&quot;Content-Type: image/jpeg&quot;);</span><br><span class="line">                    out.println(&quot;Content-Length: &quot; + array.length);</span><br><span class="line">                    out.println(&quot;&quot;);</span><br><span class="line">                    System.out.println(&quot;传回！&quot;);</span><br><span class="line">                    socket.getOutputStream().write(array, 0, array.length);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    br = new BufferedReader(new InputStreamReader(new</span><br><span class="line">                            FileInputStream(filePath)));</span><br><span class="line">                    out = new PrintWriter(socket.getOutputStream());</span><br><span class="line">                    out.println(&quot;HTTP/1.1 200 OK&quot;);</span><br><span class="line">                    out.println(&quot;Server: yjx23332&quot;);</span><br><span class="line">                    out.println(&quot;Content-Type: text/html; charset=UTF-8&quot;);</span><br><span class="line">                    out.println(&quot;&quot;);</span><br><span class="line">                    while ((line = br.readLine()) != null) &#123;</span><br><span class="line">                        out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                out.println(&quot;HTTP/1.1 500&quot;);</span><br><span class="line">                out.println(&quot;&quot;);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                close(br, in, reader, out, socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 关闭流或者Socket</span><br><span class="line">    private static void close(Closeable... closeables) &#123;</span><br><span class="line">        if (closeables != null) &#123;</span><br><span class="line">            for (Closeable closeable : closeables) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    closeable.close();</span><br><span class="line">                &#125; catch (Exception ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SimpleHttpServer提供设置端口和跟路径的方法，SimpleHttpServer在建立了与客户端的连接之后，并不会处理客户端的请求，而是将其包装成HttpRequestHandler并交由线程池处理。</p>
<p>在线程池中的Worker处理客户端请求的同时，SimpleHttpServer能够继续完成后续客户端连接的建立，不会阻塞后续客户端的请求。Worker处理请求资源生成响应内容后，异步输出内容到客户端。</p>
<p>html页面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;测试页面&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">&lt;body &gt;</span><br><span class="line">	&lt;h1&gt;第一张图片&lt;/h1&gt;</span><br><span class="line">	&lt;img src=&quot;1.jpg&quot; /&gt;</span><br><span class="line">	&lt;h1&gt;第二张图片&lt;/h1&gt;</span><br><span class="line">	&lt;img src=&quot;2.jpg&quot; /&gt;</span><br><span class="line">	&lt;h1&gt;第三张图片&lt;/h1&gt;</span><br><span class="line">	&lt;img src=&quot;3.jpg&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>将SimpleHttpServer的根目录设定到该HTML页面所在目录，并启动SimpleHttpServer。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    SimpleHttpServer.setBasePath(&quot;C:\Users\Administrator\Desktop\server&quot;);</span><br><span class="line">    SimpleHttpServer.setPort(8080);</span><br><span class="line">    SimpleHttpServer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️线程池中的线程不是越多越好：<br>线程池中线程数量并不是越多越好，具体的数量需要评估每个任务的处理时间，以及当前计算机的处理器能力和数量。使用的线程过少，无法发挥处理器的性能；使用的线程过多，将会增加系统的无故开销，起到相反的作用。</p>
<p>原书笔记：<a href="https://blog.csdn.net/weixin_46949627/article/details/127009251">https://blog.csdn.net/weixin_46949627/article/details/127009251</a></p>
<h2 id="第五章-java中的锁"><a href="#第五章-java中的锁" class="headerlink" title="第五章 java中的锁"></a>第五章 java中的锁</h2><p>介绍java并发包中与锁相关的API和组件，以及这些API和组件的使用方式和实现细节。</p>
<h3 id="1-Lock接口"><a href="#1-Lock接口" class="headerlink" title="1.Lock接口"></a>1.Lock接口</h3><p>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。</p>
<h4 id="✅Lock接口和synchronized关键字的对比"><a href="#✅Lock接口和synchronized关键字的对比" class="headerlink" title="✅Lock接口和synchronized关键字的对比"></a>✅Lock接口和synchronized关键字的对比</h4><p>在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。</p>
<p>虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。</p>
<p>使用synchronized关键字将会隐式地获取锁，但是它将锁的获取和释放固化了，也就是先获取再释放。当然，这种方式简化了同步的管理，可是扩展性没有显示的锁获取和释放来的好。例如：先获得锁A，然后再获取锁B。</p>
<p>Lock的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。</p>
<p>Lock具备的sychronized关键字不具备的特点：<br>1、非阻塞地获取锁<br>2、能被中断地获取锁（获取到锁的线程能响应中断，中断异常被抛出，同时锁释放）<br>3、超时获取锁（截止时间无法获取锁，则返回）</p>
<h4 id="✅Lock接口中的API"><a href="#✅Lock接口中的API" class="headerlink" title="✅Lock接口中的API"></a>✅Lock接口中的API</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void lock()</span><br><span class="line">获取锁，调用该方法当前线程将会获取锁，当锁获得后，从该方法返回</span><br><span class="line"></span><br><span class="line">void lockInterruptibly() throws InterruptedException	</span><br><span class="line">可中断地获取锁，和 lock()方法的不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程</span><br><span class="line"></span><br><span class="line">boolean tryLock()	</span><br><span class="line">尝试非阻塞的获取锁，调用该方法后立刻返回，如果能够获取则返回true，否则返回false</span><br><span class="line"></span><br><span class="line">boolean tryLock(1ong time,TimeUnit unit) throws InterruptedException	</span><br><span class="line">超时的获取锁，当前线程在以下3种情况下会返回：①当前线程在超时时间内获得了锁 ②当前线程在超时时间内被中断 ③超时时间结束，返回false</span><br><span class="line"></span><br><span class="line">void unlock() </span><br><span class="line">释放锁</span><br><span class="line"></span><br><span class="line">Condition newCondition()	</span><br><span class="line">获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的 wait()方法，而调用后，当前线程将释放锁</span><br></pre></td></tr></table></figure>

<p>随后会详细介绍同步器AbstractQueuedSynchronizer以及常用Lock接口的实现ReentrantLock。Lock接口的实现基本都是通过聚合了一个同步器的子类来完成线程访问控制的。</p>
<h3 id="2-队列同步器"><a href="#2-队列同步器" class="headerlink" title="2.队列同步器"></a>2.队列同步器</h3><p>队列同步器 AbstractQueuedSynchronizer（AQS，以下简称同步器），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p>
<p>同步器提供的3个方法来对同步状态进行更改，它们能够保证状态的改变是安全的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getState()  获取当前同步状态。</span><br><span class="line">setState(int newState)  设置当前同步状态。</span><br><span class="line">compareAndSetState(int expect,int update)） 使用CAS设置当前状态，该方法能够保证状态</span><br></pre></td></tr></table></figure>

<p>子类通过继承同步器并实现它的抽象方法来管理同步状态，子类推荐被定义为自定义同步组件的静态内部类。同步器自身没有实现任何同步接口，它仅仅是定义了上面同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件：<br>ReentrantLock<br>ReentrantReadWriteLock<br>CountDownLatch</p>
<p>队列同步器与锁的关系：</p>
<p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。</p>
<p>1、锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节<br>2、同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p>
<h4 id="✅队列同步器的接口与示例"><a href="#✅队列同步器的接口与示例" class="headerlink" title="✅队列同步器的接口与示例"></a>✅队列同步器的接口与示例</h4><p>同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的方法，随后将同步器作为静态内部类组合在自定义同步组件的实现中，并调用同步器提供的模板方法。</p>
<p><strong>同步器可重写的方法</strong>，包含两种，一种是获取独占锁，一种是获取共享锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态，实现该方法需要查询当前状态，并判断同步状态是否符合预期，然后通过CAS设置同步状态（非阻塞的？）</span><br><span class="line"> */</span><br><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式释放同步状态，此时等待获取同步状态的线程将有机会获取同步状态</span><br><span class="line"> */</span><br><span class="line">protected boolean tryRelease(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态，返回结果大于等于0，表示获取成功，否则获取失败</span><br><span class="line"> */</span><br><span class="line">protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式释放同步状态</span><br><span class="line"> */</span><br><span class="line">protected boolean tryReleaseShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 是否被当前线程所独占</span><br><span class="line"> */</span><br><span class="line">protected boolean isHeldExclusively() &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现自定义的同步器组件时，将会调用<strong>同步器提供的模板方法</strong>，同步器提供的模板方法分为三类：一是独占式获取与释放同步状态、二是共享式获取与释放同步状态、三是查询同步队列中等待线程的情况。自定义的同步器将使用这些提供的模板方法来实现自己的同步语义。同步器提供的模板方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态</span><br><span class="line"> * 如果当前线程获取同步状态成功，则该方法执行完毕，否则，当前线程将会进入</span><br><span class="line"> * 同步队列等待，该方法将会调用重写的tryAcquire方法（区别：一个有返回，一个没有，输入没什么用？）</span><br><span class="line"> */</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态</span><br><span class="line"> * 与acquire 相同，但是该方法响应中断，当前线程未获取到同步状态则进入同步队列；如果当前线程被中断，则该方法会抛出异常并返回</span><br><span class="line"> */</span><br><span class="line">public final void acquireInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态</span><br><span class="line"> * 该方法在 acquireInterruptibly(int arg) 基础上增加了超时限制，如果当前线程在超时时间内没有获取同步状态，那么将返回false，否则返回true</span><br><span class="line"> */</span><br><span class="line">public final boolean tryAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    return tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式释放同步状态</span><br><span class="line"> * 该方法会在释放同步状态后，将同步队列中第一个节点中的线程唤醒</span><br><span class="line"> */</span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态</span><br><span class="line"> * 与独占式的区别在于，同一时刻可以有多个线程获得同步状态</span><br><span class="line"> */</span><br><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态</span><br><span class="line"> * 与方法acquireShared(int arg) 一样，只是该方法响应中断</span><br><span class="line"> */</span><br><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态</span><br><span class="line"> * 在方法 acquireSharedInterruptibly(int arg) 基础上，增加了超时限制</span><br><span class="line"> */</span><br><span class="line">public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    return tryAcquireShared(arg) &gt;= 0 ||</span><br><span class="line">        doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式释放同步状态</span><br><span class="line"> */</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取在同步队列上等待的线程的集合</span><br><span class="line"> */</span><br><span class="line">public final Collection&lt;Thread&gt; getQueuedThreads() &#123;</span><br><span class="line">    ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;();</span><br><span class="line">    for (Node p = tail; p != null; p = p.prev) &#123;</span><br><span class="line">        Thread t = p.thread;</span><br><span class="line">        if (t != null)</span><br><span class="line">            list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显而易见，独占锁是在同一时刻只能有一个线程获得锁，而其他获取锁的线程只能在同步队列中等待，只有持有锁的线程释放了，其他线程才能获得锁。<strong>独占锁的示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Mutex implements Lock &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态内部类自定义同步器</span><br><span class="line">     */</span><br><span class="line">    private static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 是否处于独占状态</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean isHeldExclusively() &#123;</span><br><span class="line">            return getState() == 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 独占式获取锁，状态为0时获取锁</span><br><span class="line">         * 如果经过CAS设置成功（同步状态设置为1）</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            if (compareAndSetState(0, 1)) &#123;  //0是期望，1是更新</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 独占式释放锁，只是将状态置为0</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryRelease(int releases) &#123;</span><br><span class="line">            if (getState() == 0) &#123;</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            setExclusiveOwnerThread(null);</span><br><span class="line">            setState(0);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 实例化一个 Condition，每个 Condition 都包含一个队列</span><br><span class="line">         */</span><br><span class="line">        Condition newCondition() &#123;</span><br><span class="line">            return new ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final Sync sync = new Sync();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        sync.acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return sync.tryAcquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isLocked() &#123;</span><br><span class="line">        return sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasQueuedThreads() &#123;</span><br><span class="line">        return sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireNanos(1, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：<br>1、自定义定义独占锁实现Lock，所以需要实现Lock接口中的API<br>2、自定义同步器作为静态内部类继承自同步器，重写同步器方法，实现独占式获取和释放同步状态<br>3、Lock的API中使用同步器的重写方法&#x2F;模版方法</p>
<p>在使用自定义同步器Mutex 时，不会直接与内部同步器交互，而是通过Mutex 提供的方法。</p>
<p>lock和tryLock的区别：<br>lock是非阻塞的，会一直尝试或锁，用acquire方法（内部用tryAcquire方法）线程调用该方法获取同步状态失败后会被加入到同步队列中等待；tryLock是阻塞的，获取一次，所以直接用tryAcquire方法。</p>
<p>Condition是什么？<br>ConditionObject 是AQS的内部类，用来维护等待队列<br>AQS内部实际上有两个队列<br>同步队列：公平&#x2F;非公平，共享&#x2F;非共享<br>等待队列：条件等待队列，也就是Condition<br>等待队列中就是用await方法时任务进入的队列（类似之前使用的wait，该队列中的任务只有唤醒才会尝试获取锁，以此减少CPU频繁的获取锁），通过signal唤醒。</p>
<h4 id="✅队列同步器的实现分析"><a href="#✅队列同步器的实现分析" class="headerlink" title="✅队列同步器的实现分析"></a>✅队列同步器的实现分析</h4><p>接下来将从实现角度分析同步器是如何完成线程同步的。<br>主要包括：同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放以及超时获取同步状态等同步器的核心数据结构与模板方法。</p>
<h5 id="一、同步队列"><a href="#一、同步队列" class="headerlink" title="一、同步队列"></a>一、同步队列</h5><p>同步器依赖内部的同步队列（一个FIFO双向队列,FIFO先进先出）来完成同步状态的管理。</p>
<p>当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node，它也是AQS的内部类）并将其加入同步队列的尾部，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点。</p>
<p>当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：<code>compareAndSetTail(Node expect,Node update)</code>，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</p>
<p>同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。（只有一个线程获取到同步状态，所以设置头节点的方法并不需要使用CAS来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。）</p>
<h5 id="二、独占式同步状态获取和释放"><a href="#二、独占式同步状态获取和释放" class="headerlink" title="二、独占式同步状态获取和释放"></a>二、独占式同步状态获取和释放</h5><p>同步器的 <code>acquire(int arg)</code> 方法可以获取同步状态（阻塞型的，相当于是获锁），该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，<strong>线程不会从同步队列中移出</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">	if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">		selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作。首先tryAcquire非阻塞型地获取，如果获取到直接返回了，获取不到，就构造节点加入同步队列，在同步队列中会一直自旋尝试获取同步状态。</p>
<p>步骤：<br>1、调用自定义同步器实现的 tryAcquire(int arg) 方法，该方法保证线程安全的获取同步状态</p>
<p>2、如果同步状态获取失败，则构造同步节点（独占式Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过 addWaiter(Node node) 方法将该节点加入到同步队列的尾部。</p>
<blockquote>
<p>enq(final Node node) 方法中，同步器通过 “死循环” 来保证节点的正确添加，在 “死循环” 中只有通过CAS将节点设置成为尾节点之后，当前线程才能从该方法返回，否则，当前线程不断地尝试设置。<br>可以看出，enq(final Node node) 方法将并发添加节点的请求通过CAS变得 “串行化” 了。</p>
</blockquote>
<p>3、节点进入同步队列之后，就进入了一个自旋的过程（acquireQueued(Node node,int arg) 方法），每个节点（或者说每个线程）都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，代表获取了锁，否则依旧留在这个自旋过程中（并会阻塞节点的线程，阻塞线程也就是进入等待，自旋不停？）</p>
<blockquote>
<p>虽然同步队列中每个线程都会自旋，但是只有前驱节点是头节点才能够尝试获取同步状态：<br>头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。<br>维护同步队列的FIFO原则。</p>
</blockquote>
<p>4、如果获取不到则阻塞节点中的线程，而<strong>被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现</strong>。</p>
<blockquote>
<p>节点自旋，发现前驱不是头节点，就进入等待状态，只有线程被中断或前驱节点被释放才会再判断是不是前驱是头节点。前驱是头节点后，获取同步状态，如果获取失败，则进入等待状态。（几个等待状态应该不一样？）</p>
</blockquote>
<p>独占式同步状态获取流程，见P128</p>
<p>5、线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，使得后续节点能够继续获取同步状态。调用同步器的 release(int arg) 模版方法（内部用tryRelease重写方法）可以释放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点（进而使后继节点重新尝试获取同步状态）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    // 尝试释放锁</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        //头节点不为空或者状态不是0</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            // 唤醒后继节点</span><br><span class="line">            unparkSuccessor(h);  //用来唤醒处于等待状态的线程</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>独占式同步状态获取和释放过程总结：<br>1、在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被自旋地加入到队列中并在队列中进行自旋<br>2、移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。<br>3、如果线程被中断，只是会唤醒被阻塞线程，是不会立刻被移出队列的，而是FIFO到该节点才移出。<br>4、不管是获取还是释放，都是模版方法里调用了重写的try方法。acquire是阻塞的，tryAcquire是非阻塞的，试一次，会返回是否成功。</p>
<p>疑问❓：<br>同步队列中节点的自旋和线程被阻塞的关系是什么？自旋发现前驱节点不是头节点或者获取不到同步状态的话，会阻塞线程，阻塞后是依靠前驱节点释放同步状态后唤醒或是中断唤醒还是一直自旋？</p>
<h5 id="三、共享式同步状态获取与释放"><a href="#三、共享式同步状态获取与释放" class="headerlink" title="三、共享式同步状态获取与释放"></a>三、共享式同步状态获取与释放</h5><p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。以文件的读写为例，读可以是共享锁，可以同时读，写是独占锁，一个在写，其他既不能读也不能写。</p>
<p>在 acquireShared(int arg) 方法中，同步器调用 tryAcquireShared(int arg) 方法尝试获取同步状态，tryAcquireShared(int arg)方法返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。在doAcquireShared(int arg)方法的自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示该次获取同步状态成功并从自旋过程中退出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    // 小于零获取锁失败</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    // 共享模式加入同步队列</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (; ; ) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            // 如果前一个线程为头结点</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                // 尝试获取锁</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                // 成功</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    // 将自己设置为头节点同时，传播状态，r就是之前返回的值</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null;</span><br><span class="line">                    // 如果过被当前线程状态为true，就设置当前线程的中断状态</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 逻辑同前</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 逻辑同前</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用releaseShared(int arg)方法可以释放同步状态:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    // 尝试释放锁</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        // 成功就修改自己节点状态</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。因为可能多个线程获取锁，所以，它和独占式主要区别在于tryReleaseShared(int arg)方法必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证的，因为释放同步状态的操作会同时来自多个线程。</p>
<h5 id="四、独占式超时获取同步状态"><a href="#四、独占式超时获取同步状态" class="headerlink" title="四、独占式超时获取同步状态"></a>四、独占式超时获取同步状态</h5><p>通过调用同步器的 doAcquireNanos(int arg,long nanosTimeout) 【模版方法】方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。该方法提供了传统Java同步操作（比如synchronized关键字）所不具备的特性。</p>
<p>在Java 5之前，当一个线程获取不到锁而被阻塞在synchronized之外时，对该线程进行中断操作，此时该线程的中断标志位会被修改，但线程依旧会阻塞在synchronized上，等待着获取锁。</p>
<p>在Java 5中，同步器提供了acquireInterruptibly(int arg)方法，这个方法在等待获取同步状态时，如果当前线程被中断，会立刻返回，并抛出InterruptedException。</p>
<p>超时获取同步状态过程可以被视作响应中断获取同步状态过程的“增强版”，doAcquireNanos(int arg,long nanosTimeout)方法在支持响应中断的基础上，增加了超时获取的特性。</p>
<p>该方法在自旋过程中，当节点的前驱节点为头节点时尝试获取同步状态，如果获取成功则从该方法返回，这个过程和独占式同步获取的过程类似，但是在同步状态获取失败的处理上有所不同。</p>
<p>如果当前线程获取同步状态失败，则判断是否超时（nanosTimeout小于等于0表示已经超时），如果没有超时，重新计算超时间隔nanosTimeout，然后使当前线程等待 nanosTimeout 纳秒（当已到设置的超时时间，该线程会从LockSupport.parkNanos(Object<br>blocker,long nanos)方法返回）。</p>
<p><strong>总结：</strong><br>独占式超时获取同步状态doAcquireNanos(int arg,long nanosTimeout)和独占式获取同步状态acquire(int args)在流程上非常相似，其主要区别在于未获取到同步状态时的处理逻辑：<br>1、acquire(int args)在未获取到同步状态时，将会使当前线程一直处于等待状态<br>2、doAcquireNanos(int arg,long nanosTimeout)会使当前线程等待nanosTimeout纳秒，如果当前线程在nanosTimeout纳秒内没有获取到同步状态，将会从等待逻辑中自动返回。</p>
<h5 id="五、自定义同步组件——TwinsLock"><a href="#五、自定义同步组件——TwinsLock" class="headerlink" title="五、自定义同步组件——TwinsLock"></a>五、自定义同步组件——TwinsLock</h5><p>设计一个同步工具：该工具在同一时刻，只允许至多两个线程同时访问，超过两个线程的访问将被阻塞。</p>
<p>TwinsLock在同一时刻允许至多两个线程的同时访问，表明同步资源数为2，这样可以设置初始状态status为2，当一个线程进行获取，status减1，该线程释放，则status加1，状态的合法范围为0、1和2，其中0表示当前已经有两个线程获取了同步资源，此时再有其他线程对同步状态进行获取，该线程只能被阻塞。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TwinsLock implements Lock &#123;</span><br><span class="line">    private final Sync sync = new Sync(2);</span><br><span class="line"></span><br><span class="line">    private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        Sync(int count) &#123;</span><br><span class="line">            if (count &lt;= 0) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;count must large than zero.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 在本方法中，用状态去代指资源数目</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int tryAcquireShared(int reduceCount) &#123;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                int current = getState();</span><br><span class="line">                int newCount = current - reduceCount;</span><br><span class="line">                if (newCount &lt; 0 || compareAndSetState(current,newCount)) &#123;</span><br><span class="line">                	// 返回当前剩余资源</span><br><span class="line">                    return newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean tryReleaseShared(int returnCount) &#123;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                int current = getState();</span><br><span class="line">                // 当前数目 + 释放数目</span><br><span class="line">                int newCount = current + returnCount;</span><br><span class="line">                if (compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">    	// 获取共享锁，state + 1</span><br><span class="line">    	// 使用的是node节点的方法</span><br><span class="line">        sync.acquireShared(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 释放共享锁 -1</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.releaseShared(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 其他接口方法略</span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long time, @NotNull TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    @NotNull</span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：<br>1、TwinsLock实现Lock接口，提供面向使用者的接口，使用者调用lock()<br>方法获取锁，随后调用unlock()方法释放锁，而同一时刻只能有两个线程同时获取到锁。<br>2、自定义同步器Sync作为静态内部类，该同步器面向线程访问和同步状态控制。共享式获取同步状态。<br>3、重写tryAcquireShared(int reduceCount)等方法，内部用过CAS确保状态的正确设置。acquireShared方法里是判断tryAcquireShared方法返回值大于等于0时，当前线程才获取同步状态。</p>
<p>总结：<br>1、acquireShared方法里输入的int，都是1呢。啥意思？<br>2、同步器作为一个桥梁，连接线程访问以及同步状态控制等底层技术与不同并发组件（比如Lock、CountDownLatch等）的接口语义。</p>
<p>测试类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line">public class TwinsLockTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test() throws InterruptedException &#123;</span><br><span class="line">        final Lock lock = new TwinsLock();</span><br><span class="line">        class Worker extends Thread &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName());</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        throw new RuntimeException(e);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 启动10个线程</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Worker w = new Worker();</span><br><span class="line">            w.setDaemon(true);</span><br><span class="line">            w.start();</span><br><span class="line">        &#125;</span><br><span class="line">        // 每隔1秒换行</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程名称成对输出，在同一时刻只有两个线程能够获取到锁。</p>
<p>原书笔记：<a href="https://blog.csdn.net/weixin_46949627/article/details/127078972">https://blog.csdn.net/weixin_46949627/article/details/127078972</a><br><a href="http://t.zoukankan.com/liukaifeng-p-10052596.html">http://t.zoukankan.com/liukaifeng-p-10052596.html</a><br>Lock和sychronized区别：<a href="https://blog.csdn.net/weixin_41010294/article/details/123528508">https://blog.csdn.net/weixin_41010294/article/details/123528508</a></p>
<h3 id="3-重入锁"><a href="#3-重入锁" class="headerlink" title="3.重入锁"></a>3.重入锁</h3><p>重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。</p>
<p>上一节的独占锁示例中，调用Mutex的lock()方法获取锁之后，如果再次调用lock()方法，则该线程将会被自己所阻塞，原因是Mutex在实现tryAcquire(int acquires)方法时没有考虑占有锁的线程再次获取锁的场景，而在调用tryAcquire(int acquires)方法时返回了false，导致该线程被阻塞。</p>
<p>所以说，Mutex是一个不支持重进入的锁。而synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁，而不像Mutex由于获取了锁，而在下一次获取锁时出现阻塞自己的情况。</p>
<p>重入锁：在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</p>
<p>公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。</p>
<h4 id="✅实现重进入"><a href="#✅实现重进入" class="headerlink" title="✅实现重进入"></a>✅实现重进入</h4><p>重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题。</p>
<p>1、线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</p>
<p>2、锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。</p>
<p>非公平锁获取的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 非公平锁获取</span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    // 当前线程</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    // 获取锁状态</span><br><span class="line">    int c = getState();</span><br><span class="line">    // 0 代表无锁</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        // 设置状态</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            // 设置独享锁的拥有者</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    // 如果当前线程是独有线程的线程ID</span><br><span class="line">    &#125; else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        // 是则增加次数</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        //设置</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。成功获取锁的线程再次获取锁，只是增加了同步状态值.</p>
<p>非公平锁释放的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    // 减去释放的值</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    // 如果当前线程不是拥有者</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    // 是否完全释放</span><br><span class="line">    boolean free = false;</span><br><span class="line">    // 如果是 0 则完全释放</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        // 抹去拥有者</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该锁被获取了n次，那么前(n-1)次tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true。可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。</p>
<h4 id="✅公平与非公平获取锁的区别"><a href="#✅公平与非公平获取锁的区别" class="headerlink" title="✅公平与非公平获取锁的区别"></a>✅公平与非公平获取锁的区别</h4><p>公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。</p>
<p>对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同。判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。<br>【因此，上面的独占锁和共享锁也都是公平的】</p>
<p>测试公平和非公平锁在获取锁时的区别，五个线程循环获取锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class FairAndUnfairTest &#123;</span><br><span class="line">    private static Lock fairLock = new ReentrantLock2(true);</span><br><span class="line">    private static Lock unfairLock = new ReentrantLock2(false);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void fair() &#123;</span><br><span class="line">        testLock(fairLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void unfair() &#123;</span><br><span class="line">        testLock(unfairLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void testLock(Lock lock)&#123;</span><br><span class="line">        // 启动5个Job</span><br><span class="line">        for(int i = 0; i &lt; 5;i++)&#123;</span><br><span class="line">            new Job(lock).start();</span><br><span class="line">        &#125;</span><br><span class="line">        while (true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Job extends Thread &#123;</span><br><span class="line">        private Lock lock;</span><br><span class="line"></span><br><span class="line">        public Job(Lock lock) &#123;</span><br><span class="line">            this.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                // 连续2次打印当前的Thread和等待队列中的Thread</span><br><span class="line">                lock.lock();</span><br><span class="line">                ReentrantLock2 reentrantLock2 = (ReentrantLock2) lock;</span><br><span class="line">                System.out.println(&quot;Fair:&quot; + reentrantLock2.isFair() + &quot;,Lock By 【&quot; + Thread.currentThread().getName() + &quot;】，waitting by  &quot; + reentrantLock2.getQueuedThreads().toString());</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ReentrantLock2 extends ReentrantLock &#123;</span><br><span class="line">        public ReentrantLock2(boolean fair) &#123;</span><br><span class="line">            super(fair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Collection&lt;Thread&gt; getQueuedThreads() &#123;</span><br><span class="line">            List&lt;Thread&gt; arrayList = new ArrayList&lt;Thread&gt;(super.getQueuedThreads());</span><br><span class="line">            Collections.reverse(arrayList);</span><br><span class="line">            return arrayList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、公平性锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁出现了一个线程连续获取锁的情况。（刚释放锁的线程再次获取同步状态的几率会非常大，使得其他线程只能在同步队列中等待。）</p>
<p>2、公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平锁虽然可能造成线程饥饿，但是极少的线程切换，保证了其更大的吞吐量。</p>
<h3 id="4-读写锁"><a href="#4-读写锁" class="headerlink" title="4.读写锁"></a>4.读写锁</h3><p>之前提到锁（如Mutex和ReentrantLock）基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升，提供写操作对读操作的可见性以及并发性的提升。</p>
<p>适用场景：在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。</p>
<p>在没有读写锁支持的（Java 5之前）时候，如果需要完成上述工作就要使用Java的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并进行通知之后，所有等待的读操作才能继续执行（写操作之间依靠synchronized关键进行同步），这样做的目的是使读操作能读取到正确的数据，不会出现脏读。</p>
<h4 id="✅读写锁的接口和示例"><a href="#✅读写锁的接口和示例" class="headerlink" title="✅读写锁的接口和示例"></a>✅读写锁的接口和示例</h4><p>ReadWriteLock仅定义了获取读锁和写锁的两个方法，即readLock()方法和writeLock()方法，而其实现——ReentrantReadWriteLock，除了接口方法之外，还提供了一些便于外界监控其内部工作状态的方法。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Cache &#123;</span><br><span class="line">    static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line">    static Lock r = rwl.readLock();</span><br><span class="line">    static Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    // 获取一个key对应的value</span><br><span class="line">    public static final Object get(String key) &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.get(key);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置key对应的value，并返回旧的value</span><br><span class="line">    public static final Object put(String key, Object value) &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.put(key, value);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清空所有的内容</span><br><span class="line">    public static final void clear() &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个非线程安全的HashMap作为缓存,使用读写锁的读锁和写锁来保证Cache是线程安全的.Cache使用读写锁提升读操作的并发性，也保证每次写操作对所有的读写操作的可见性，同时简化了编程方式。</p>
<h4 id="✅读写锁的实现分析"><a href="#✅读写锁的实现分析" class="headerlink" title="✅读写锁的实现分析"></a>✅读写锁的实现分析</h4><h5 id="一、读写状态的设计"><a href="#一、读写状态的设计" class="headerlink" title="一、读写状态的设计"></a>一、读写状态的设计</h5><p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。</p>
<p>回想ReentrantLock中自定义同步器的实现，同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态，如果在一个整型变量上维护多种状态，就一定需要 “按位切割使用” 这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。</p>
<p>通过位运算可以迅速确定读和写各自的状态，假设当前同步状态值为 S ，写状态等于 S&amp;0x0000FFFF （将高16位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号补0右移16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。</p>
<h5 id="二、写锁的获取与释放"><a href="#二、写锁的获取与释放" class="headerlink" title="二、写锁的获取与释放"></a>二、写锁的获取与释放</h5><p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    // 锁状态</span><br><span class="line">    int c = getState();</span><br><span class="line">    // 通过状态计算写锁数量</span><br><span class="line">    int w = exclusiveCount(c);</span><br><span class="line">    // 锁不为0，说明有读或者写</span><br><span class="line">    if (c != 0) &#123;</span><br><span class="line">        // 写锁不存在（说明现在是读锁）或者当前获取线程不是已经获取写锁的线程</span><br><span class="line">        if (w == 0 || current != getExclusiveOwnerThread())</span><br><span class="line">            return false;</span><br><span class="line">        // 如果重入次数大于最大冲入数目</span><br><span class="line">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 尝试获取写锁</span><br><span class="line">    // writerShouldBlock：公平锁会调用 hasQueuedPredecessors判断轮得到自己吗，非公平直接返回false去竞争锁</span><br><span class="line">    //  compareAndSetState 失败就会返回false</span><br><span class="line">    if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置当前线程拥有锁</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。</p>
<p>如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p>
<p>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</p>
<h5 id="三、读锁的获取与释放"><a href="#三、读锁的获取与释放" class="headerlink" title="三、读锁的获取与释放"></a>三、读锁的获取与释放</h5><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在 没有其他写线程访问（或者写状态为0） 时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。</p>
<p>获取读锁的实现从Java 5到Java 6变得复杂许多，主要原因是新增了一些功能，例如getReadHoldCount() 方法，作用是返回当前线程获取读锁的次数。由于读状态是 所有线程获取读锁次数的总和 ，所以每个线程 各自获取读锁的次数只能选择保存在ThreadLocal中 ，由线程自身维护，于是使获取读锁的实现变得复杂。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">        // 获取锁状态</span><br><span class="line">        int c = getState();</span><br><span class="line">        // 读数目+1</span><br><span class="line">        int nextc = c + (1 &lt;&lt; 16);</span><br><span class="line">        // 溢出</span><br><span class="line">        if (nextc &lt; c)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        // 现在是写状态 且 拥有者不是自己</span><br><span class="line">        if (exclusiveCount(c) != 0 &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">            return -1;</span><br><span class="line">        // 修改状态</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。</p>
<p>读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是（1&lt;&lt;16）。</p>
<h5 id="四、锁降级"><a href="#四、锁降级" class="headerlink" title="四、锁降级"></a>四、锁降级</h5><p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void processData() &#123;</span><br><span class="line">		//锁住读锁</span><br><span class="line">        readLock.lock();</span><br><span class="line">        // 数据在更新吗</span><br><span class="line">        if (!update) &#123;</span><br><span class="line">			// 必须先释放读锁</span><br><span class="line">            readLock.unlock();</span><br><span class="line">			// 锁降级从写锁获取到开始</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!update) &#123;</span><br><span class="line">					// 准备数据的流程（略）</span><br><span class="line">                    update = true;</span><br><span class="line">                &#125;</span><br><span class="line">                //开始降级</span><br><span class="line">                readLock.lock();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">            	// 锁降级完成，写锁降级为读锁</span><br><span class="line">                writeLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">			// 使用数据的流程（略）</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>锁降级：先获取写锁，变更数据，再获取读锁，再释放写锁。此时还有读锁，还可以读数据，其他线程也可以获取读锁读数据。<br>这样变更完数据之后，可以多个读线程一起读取数据。</p>
<p>不支持锁升级：有线程获取读锁的时候，不能获取写锁，数据更新对其他线程的可见性。</p>
<h3 id="5-LockSupport工具"><a href="#5-LockSupport工具" class="headerlink" title="5.LockSupport工具"></a>5.LockSupport工具</h3><p>队列同步器中，当需要阻塞或唤醒一个线程的时候，都会使用LockSupport工具类来完成相应工作。LockSupport定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为构建同步组件的基础工具。LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程。</p>
<p>在Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，其中参数blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和系统监控。</p>
<p>比如说，线程dump结果结果中，有阻塞对象的parkNanos方法能够传递给开发人员阻塞对象的信息。</p>
<p>为什么要加阻塞对象信息？<br>由于在Java 5之前，当线程阻塞（使用synchronized关键字）在一个对象上时，通过线程dump能够查看到该线程的阻塞对象，方便问题定位，而Java 5推出的Lock等并发工具时却遗漏了这一点，致使在线程dump时无法提供阻塞对象的信息。因此，在Java 6中，LockSupport新增了上述3个含有阻塞对象的park方法，用以替代原有的park方法。</p>
<h3 id="6-Condition接口"><a href="#6-Condition接口" class="headerlink" title="6.Condition接口"></a>6.Condition接口</h3><p>任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待&#x2F;通知模式。</p>
<p>Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待&#x2F;通知模式，但是这两者在使用方式以及功能特性上还是有差别的：<br>1、前置条件不但要获取锁，还要调用<code>Lock.newCondition()</code>获取Condition对象<br>2、等待队列支持多个<br>3、支持超时等待状态<br>4、支持在等待状态中不响应中断（可以对中断不敏感）</p>
<p>总结一下：<br>synchronized + Object监视器方法 - 实现等待通知 - 案例线程池<br>Lock(队列同步器) + Condition接口 - 实现等待通知 - 案例有界队列<br>可以直接使用synchronized实现同步<br>可以直接使用Lock实现锁，只不过只有同步队列，里面线程是阻塞状态，没有等待队列</p>
<h4 id="✅Condition接口与示例"><a href="#✅Condition接口与示例" class="headerlink" title="✅Condition接口与示例"></a>✅Condition接口与示例</h4><p>Condition定义了等待&#x2F;通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。</p>
<p>Condition对象是由Lock对象（调用Lock对象的newCondition()方法）创建出来的，换句话说，Condition是依赖Lock对象的。</p>
<p>等待通知模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">public void conditionWait() throws InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void conditionSignal() throws InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将Condition对象作为成员变量。通过Lock的newCondition()方法</p>
<p>当调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p>
<p>Condition接口方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">await() ：造成当前线程在接到信号或被中断之前一直处于等待状态，对中断敏感。</span><br><span class="line">await(long time, TimeUnit unit) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。</span><br><span class="line">awaitNanos(long nanosTimeout) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。返回值表示剩余时间，如果在nanosTimesout之前唤醒，那么返回值 = nanosTimeout - 消耗时间，如果返回值 &lt;= 0 ,则可以认定它已经超时了。</span><br><span class="line">awaitUninterruptibly() ：造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。</span><br><span class="line">awaitUntil(Date deadline) ：造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。如果没有到指定时间就被通知，则返回true，否则表示到了指定时间，返回返回false。</span><br><span class="line">signal() ：唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。</span><br><span class="line">signalAll() ：唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的锁。</span><br></pre></td></tr></table></figure>

<p>有界队列是一种特殊的队列，当队列为空时，队列的获取操作将会阻塞获取线程（进入等待队列），直到队列中有新增元素，当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现“空位”。有点像线程池。</p>
<p>线程池：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BoundedQueue&lt;T&gt; &#123;</span><br><span class="line">    private Object[] items;</span><br><span class="line">    // 添加的下标，删除的下标和数组当前数量</span><br><span class="line">    private int addIndex, removeIndex, count;</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line">    private Condition notEmpty = lock.newCondition();</span><br><span class="line">    private Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public BoundedQueue(int size) &#123;</span><br><span class="line">        items = new Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加一个元素，如果数组满，则添加线程进入等待状态，直到有&quot;空位&quot;</span><br><span class="line">    public void add(T t) throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            items[addIndex] = t;</span><br><span class="line">            if (++addIndex == items.length)</span><br><span class="line">                addIndex = 0;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public T remove() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == 0)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Object x = items[removeIndex];</span><br><span class="line">            if (++removeIndex == items.length)</span><br><span class="line">                removeIndex = 0;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            return (T) x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以添加方法为例：首先需要获得锁，目的是确保数组修改的可见性和排他性。当数组数量等于数组长度时，表示数组已满，则调用notFull.await()，当前线程随之释放锁并进入等待状态。如果数组数量不等于数组长度，表示数组未满，则添加元素到数组中，同时通知等待在notEmpty上的线程，数组中已经有新元素可以获取。</p>
<p>在添加和删除方法中使用while循环而非if判断，目的是防止过早或意外的通知，只有条件符合才能够退出循环。回想之前提到的等待&#x2F;通知的经典范式，二者是非常类似的。</p>
<p>⚠️线程的阻塞、等待的区别：<br>在java中，线程阻塞状态是线程本身不可计划的，而线程等待状态是线程本身计划之内的。<br>相同点：<br>（1）都会暂停线程的执行。<br>区别点：<br>（1）线程进入阻塞状态是被动的, 而线程进入等待状态是主动的。<br>阻塞状态的被动：线程在同步代码外，获取对象锁失败时，线程进入阻塞状态；何时获取对象锁失败不可知，即线程阻塞状态是线程本身不可计划的。<br>等待状态的主动：线程在同步代码内await，等待其他线程唤醒时，线程接入等待状态；何时等待其他线程操作可知，即线程等待状态是线程本身计划之内的。</p>
<h4 id="✅Condition的实现分析"><a href="#✅Condition的实现分析" class="headerlink" title="✅Condition的实现分析"></a>✅Condition的实现分析</h4><p>ConditionObject是同步器AbstractQueuedSynchronizer的内部类，因为Condition的操作需要获取相关联的锁，所以作为同步器的内部类也较为合理。</p>
<p>每个Condition对象都包含着一个队列（以下称为等待队列），该队列是Condition对象实现等待&#x2F;通知功能的关键。</p>
<h5 id="一、等待队列"><a href="#一、等待队列" class="headerlink" title="一、等待队列"></a>一、等待队列</h5><p>等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node。</p>
<p>等待队列：当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</p>
<p>在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，而并发包中的Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列（每个Condition对象一个）。</p>
<h5 id="二、等待"><a href="#二、等待" class="headerlink" title="二、等待"></a>二、等待</h5><p>调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</p>
<p>如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。</p>
<p>ConditionObject的await方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    // 当前线程加入等待队列</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    // 释放同步状态，也就是释放锁</span><br><span class="line">    int savedState = fullyRelease(node);</span><br><span class="line">    int interruptMode = 0;</span><br><span class="line">    // 节点是否在同步队列中</span><br><span class="line">    // Returns true if a node, always one that was initially placed on a condition queue, is now waiting to reacquire on sync queue.</span><br><span class="line">    // 如果节点在同步队列中，现在等待重新去获取锁，返回true</span><br><span class="line">    // 一般总是在条件队列</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        // 暂停自己，等待被唤醒或者被中断</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        // 是否被中断了</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取锁成功且异常模式不为THROW_IE，就修改interruptMode</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    // 该方法是内部类Condition中的，设置下一个在首位的等待者</span><br><span class="line">    if (node.nextWaiter != null)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    // 如果interruptMode 不是0，唤醒后报告中断</span><br><span class="line">    if (interruptMode != 0)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。（同步队列的首节点并不会直接加入等待队列，而是通过addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列中。）</p>
<p>（2）当等待队列中的节点被唤醒，则唤醒节点的线程进入同步队列，开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。</p>
<h5 id="三、通知"><a href="#三、通知" class="headerlink" title="三、通知"></a>三、通知</h5><p>调用Condition的signal()方法的前置条件是当前线程必须获取了锁，将在等待队列中等待时间最长的节点（首节点），线程安全地移动到同步队列，并使用LockSupport唤醒节点中的线程，然后就竞争锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">    // 锁是否处于占用状态</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    // 获取第一个线程</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    if (first != null)</span><br><span class="line">        // 唤醒</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。</p>
<p>成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。如果未获取到锁，将在同步队列中阻塞。</p>
<p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p>
<h2 id="第六章-java并发容器和框架"><a href="#第六章-java并发容器和框架" class="headerlink" title="第六章 java并发容器和框架"></a>第六章 java并发容器和框架</h2><h3 id="1-ConcurrentHashMap的实现原理与使用"><a href="#1-ConcurrentHashMap的实现原理与使用" class="headerlink" title="1.ConcurrentHashMap的实现原理与使用"></a>1.ConcurrentHashMap的实现原理与使用</h3><p>ConcurrentHashMap是线程安全且高效的HashMap。</p>
<h4 id="✅为什么使用ConcurrentHashMap"><a href="#✅为什么使用ConcurrentHashMap" class="headerlink" title="✅为什么使用ConcurrentHashMap"></a>✅为什么使用ConcurrentHashMap</h4><p>（1）<strong>HashMap线程不安全会死循环</strong></p>
<p>HashMap 在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(2); // 容量为2的Map</span><br><span class="line">Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i=0;i&lt;10000;i++)&#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    map.put(UUID.randomUUID().toString(),&quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,&quot;ftf&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,&quot;ftf&quot;);</span><br><span class="line">thread.start();</span><br><span class="line">thread.join();</span><br></pre></td></tr></table></figure>

<p>HashMap的实现原理：<br>HashMap的主干是一个Entry数组（Entry是以链表的形式存储的）。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。(其实所谓Map其实就是保存了两个对象之间的映射关系的一种集合)。</p>
<p>Entry结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next; // 存储指向下一个Entry的引用，单链表结构。</span><br><span class="line"> </span><br><span class="line">    int hash;	   // 对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以：HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p>
<p>HashMap在put的时候，插入的元素超过了容量(由负载因子决定)的范围就会触发扩容操作，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在其他的元素也在put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的。</p>
<p>HashMap的线程不安全主要体现在会造成死循环，数据丢失，数据覆盖这些问题。其中死循环和数据丢失是在JDK1.7中出现的问题，在Jdk1.8中已经得到解决，然而JDK1.8仍会有数据覆盖这样的问题。</p>
<p>（2）<strong>效率低下的HashTable</strong></p>
<p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其它线程也访问HashTable的同步方法时，会进入阻塞或轮询状态，所以竞争越激烈效率越低。</p>
<p>（3）ConcurrentHashMap的锁分段技术可有效提升并发访问率。</p>
<p>HashTable的线程都必须竞争同一把锁，假如容器里有多把锁每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其它段的数据也能被其他线程访问。</p>
<h4 id="✅ConcurrentHashMap的结构"><a href="#✅ConcurrentHashMap的结构" class="headerlink" title="✅ConcurrentHashMap的结构"></a>✅ConcurrentHashMap的结构</h4><p>类图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements ConcurrentMap&lt;K,V&gt;, Serializable</span><br></pre></td></tr></table></figure>

<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁(ReentrantLock),在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构。<strong>一个Segment里包含一个HashEntry数组</strong>，<strong>每个HashEntry是一个链表结构的元素（一个包含数据的链表）</strong>，每个Segment里守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p>
<h4 id="✅ConcurrentHashMap的初始化与定位"><a href="#✅ConcurrentHashMap的初始化与定位" class="headerlink" title="✅ConcurrentHashMap的初始化与定位"></a>✅ConcurrentHashMap的初始化与定位</h4><p>ConcurrentHashMap初始化方法是通过initialCapacity, loadFactor和concurrencyLevel等几个参数来初始化segment数组，段偏移量segmentShift，段掩码segmentMask和每个segment里的HashEntry数组来实现。</p>
<p>ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过散列算法定位到Segment。而且，会使用再散裂算法对元素的hashCode进行一次再散列。</p>
<p>再散列的目的：减少散列冲突，使元素均匀地分布在不同的segmrnt上，提高容器的存取效率。</p>
<h4 id="✅ConcurrentHashMap的操作"><a href="#✅ConcurrentHashMap的操作" class="headerlink" title="✅ConcurrentHashMap的操作"></a>✅ConcurrentHashMap的操作</h4><p>（1）get(key)</p>
<p>经过一次再散列，先定位到segment，然后再通过散列运算定位到元素。<br>不需要加锁，除非读到的值是空的才会加锁重读。原因是：将共享变量（segment大小、HashEntry里的value）定义为volatile。利用volatile在多线程中的可见性，可以被多线程读，保证不会读到过期的值。</p>
<p>（2）put(key, value)</p>
<p>先定位到segment，然后在segment里进行插入操作。分两步：<br>1.是否需要扩容？<br>先判断HashEntry数组是否超过阈值，如果超过了就扩容，扩容之后再插入数据。而HashMap是先插入再扩容，这样不好，因为下次可能就没有数据进来了，那就白扩容了。<br>2.如何扩容？<br>先创建一个容量是原来2倍的数组，然后通过对原数组元素进行再散列后插入到新数组。扩容只会对某个segment进行。</p>
<p>（3）size()</p>
<p>Segment中有一个全局变量count是一个volatile变量，可以累加各个segment的count来计算大小。但是可能累加前count发生了变化，统计结果不准。但是锁住所有的segment再计算也不合适。</p>
<p>在每个segment中有一个volatile修饰的count属性，表示这个segment中的元素个数，先通过2次不加锁的方法统计所有count的总和，如果两次结果不相等，或者容器被修改过了，就将Segment加锁，再进行第三次统计。</p>
<p>ConcurrentHashMap中有一个modCount变量，每次put\remove\clean操作，都会对这个值加一，通过比较这个值，就知道是否容器是否被修改了。</p>
<h3 id="2-ConcurrentLinkedQueue"><a href="#2-ConcurrentLinkedQueue" class="headerlink" title="2.ConcurrentLinkedQueue"></a>2.ConcurrentLinkedQueue</h3><p>无界线程安全队列。</p>
<p>在并发编程中，有时候需要使用线程安全的对列。如果要实现一个线程安全的对列有2种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的对列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。非阻塞的实现方式则可以使用循环CAS的方式来实现。【锁也是基于CAS和volatile来实现的吧】</p>
<p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全对列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到对列的尾部；当我们获取一个元素时，它会返回对列头部的元素。它采用了”wait-free”算法(即CAS算法)来实现。</p>
<h4 id="✅ConcurrentLinkedQueue的结构"><a href="#✅ConcurrentLinkedQueue的结构" class="headerlink" title="✅ConcurrentLinkedQueue的结构"></a>✅ConcurrentLinkedQueue的结构</h4><p>ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素(item)和指向下一个节点(next)的引用组成，节点和节点之间就是通过这个next关联起来，从而组成一张链表结构的对列。默认情况下head节点存储的元素为空，tail节点等于head节点。</p>
<p>继承了AbstractQueue，不是阻塞队列。</p>
<p>ConcurrentLinkedQueue由head节点和tail节点组成。head、tail、next、item均使用volatile修饰，保证其内存可见性。</p>
<h4 id="✅入队列-offer-E-e"><a href="#✅入队列-offer-E-e" class="headerlink" title="✅入队列:offer(E e)"></a>✅入队列:offer(E e)</h4><p>入队列就是将入队节点添加到对列的尾部。入队主要做两件事情：<br>第一：是将入队节点设置成当前队列尾节点的下一个节点；<br>第二：是更新tail节点，如果tail节点的next不为空，则将入队节点设置为tial节点，成为队尾节点的next节点，如果tail节点的next为空，则将入队节点的设置为tail的next节点。所以tail节点不总是尾节点。【效果是两格两格得跳】</p>
<p>1.定位尾节点<br>tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点。尾节点可能是tail节点，也可能是tail节点的next节点。</p>
<p>2.设置入队节点为尾节点<br>p.casNext(null,n)方法用于将入队节点设置为当前对尾节点的next节点，如果p是null，表示p是当前节点的尾节点，如果不为null，表示有其它线程更新了尾节点，则需要重新获取当前对列的尾节点。</p>
<p>⚠️不是每次入队都更新tail节点：<br>如果将tail节点永远作为尾节点，这样每次都需要循环CAS更新tail节点，而设置一个到尾节点的距离，当tail到尾节点的距离大于某个值（通常为1）的时候再更新tail，这样可以减少更新的次数，提高入队的效率。定位尾节点时就需要增加对volatile变量读操作，但是对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。</p>
<p><strong>入队方法永远返回true，所以不要通过返回值判断入队是否成功。</strong></p>
<h4 id="✅出队列：poll"><a href="#✅出队列：poll" class="headerlink" title="✅出队列：poll()"></a>✅出队列：poll()</h4><p>不是每次出队都更新head节点，当head中有元素，就直接弹出head的元素，如果没有元素，就弹出head的next，然后更新head节点，head节点变为弹出节点的next节点。【一次走两格】<br>也是通过控制距离的方式，减少CAS更新节点的消耗。</p>
<h3 id="3-阻塞队列"><a href="#3-阻塞队列" class="headerlink" title="3.阻塞队列"></a>3.阻塞队列</h3><p>阻塞对列(BlockingQueue)是一个支持两个附加操作的对列。这两个附加操作支持阻塞的插入和移除方法。</p>
<p>1）支持阻塞的插入方法：意思是当对列满时，对列会阻塞插入元素的线程，直到对列不满。<br>2）支持阻塞的移除方法：意思是当对列为空时，获取元素的线程会等待对列不为空。</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是向对列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素，消费者用来获取元素的容器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--------------------插入和移除操作的4种处理方式--------------</span><br><span class="line"></span><br><span class="line">方法/处理方式    抛出异常    返回特殊值    一直阻塞    超时退出</span><br><span class="line">插入方法        add(e)     offer(e)     put(e)      offer(e,time,unit)</span><br><span class="line">移除方法       remove()    poll()       take()     poll(time,unit)</span><br><span class="line">检查方法      element()    peek()       不可用      不可用</span><br><span class="line"></span><br><span class="line">1）抛出异常：当队列满时，如果再往对列里插入元素，会抛出IllegalStateException(&quot;Queue full&quot;)异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</span><br><span class="line">2）返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有返回null。</span><br><span class="line">3）一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到对列可用或者响应中断退出。当队列为空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</span><br><span class="line">4）超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</span><br></pre></td></tr></table></figure>

<p>如果是无界阻塞队列，队列不可能出现满的情况，岁月使用put和offer永远不会被阻塞，而且使用offer方法时，总返回true。</p>
<h4 id="✅java提供的几种阻塞队列"><a href="#✅java提供的几种阻塞队列" class="headerlink" title="✅java提供的几种阻塞队列"></a>✅java提供的几种阻塞队列</h4><p>ArrayBlockingQueue:    一个由数组结构组成的有界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue是一个用数组实现的有界阻塞队列。</span><br><span class="line">此队列按照先进先出(FIFO)的原则对元素进行排序。</span><br><span class="line">默认情况下不保证线程公平的访问队，即不保证先阻塞线程先访问队列。</span><br><span class="line"></span><br><span class="line">如果想保证公平性，可以用可重入锁来实现</span><br><span class="line">ArrayBlockingQueue fairQueue = new ArrayBlockingQueue&lt;&gt;(1000, true);</span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">    if (capacity &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    this.items = new Object[capacity];</span><br><span class="line">    lock = new ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedBlockingQueue:    一个由链表结构组成的有界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LinkedBlockingQueue是一个用链表实现的有界阻塞队列。</span><br><span class="line">此队列的默认和最大长度为Inter.MAX_VALUE。</span><br><span class="line">此队列按照先进先出的原则对元素进行排序。</span><br></pre></td></tr></table></figure>

<p>PriorityBlockingQueue:    一个支持优先级排序的无界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PriorityBlockingQueue是一个支持优先级的无界阻塞队列。</span><br><span class="line">默认情况下元素采取自然顺序升序排列。</span><br><span class="line">也可以自定义实现compareTo()方法来指定元素排序规则，</span><br><span class="line">或者初始化PriorityBlockingQueue时，指定构造参数(Comparator)来对元素进行排序。</span><br><span class="line">需要注意的是不能保证同优先级元素的排序。</span><br></pre></td></tr></table></figure>

<p>DelayQueue:    一个使用优先级队列实现的无界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DelayQueue是一个支持延时获取元素的无界阻塞队列.</span><br><span class="line">队列使用PriorityQueue来实现。</span><br><span class="line">队列中的元素必须实现Delayed接口，在创建元素时可以指定多久（元素存在了多久）才能从队列中获取当前元素。</span><br><span class="line">只有在延迟期满时才能从队列里提取元素。</span><br><span class="line"></span><br><span class="line">应用场景：</span><br><span class="line">1）缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue获取元素时，表示缓存有效期到了。</span><br><span class="line">2）定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimeQueue就是使用DelayQueue实现的。</span><br><span class="line"></span><br><span class="line">a.如何实现Delayed接口</span><br><span class="line">DelayQueue队列的元素必须实现Delayed接口。我们可以参考ScheduledThreadPoolExecutor里ScheduledFutureTask类的实现，一共有三步。</span><br><span class="line"></span><br><span class="line">第一步：在对象创建的时候，初始化基本数据。使用time记录当前对象延迟到什么时候可以使用，使用sequenceNumber来标识元素在队列中的先后顺序。</span><br><span class="line"></span><br><span class="line">private static final AtomicLong sequencer = new AtomicLong(0);</span><br><span class="line">private class ScheduledFutureTask&lt;V&gt; extends FutureTask&lt;V&gt; implements RunnableScheduledFuture&lt;V&gt; &#123;</span><br><span class="line">ScheduledFutureTask(Runnable r, V result, long ns) &#123;</span><br><span class="line">    super(r, result);</span><br><span class="line">    this.time = ns;</span><br><span class="line">    this.period = 0;</span><br><span class="line">    this.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二步：实现getDelay方法，该方法返回当前元素还需要延时多长时间，单位是纳秒</span><br><span class="line"></span><br><span class="line">public long getDelay(TimeUnit unit) &#123;</span><br><span class="line">    return unit.convert(time - now(), TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第三步：实现compareTo()方法来指定元素的顺序。例如，让延时时间最长的放在队列的末尾。</span><br><span class="line"></span><br><span class="line">public int compareTo(Delayed other) &#123;</span><br><span class="line">    if (other == this) // compare zero ONLY if same object</span><br><span class="line">        return 0;</span><br><span class="line">    if (other instanceof ScheduledFutureTask) &#123;</span><br><span class="line">        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span><br><span class="line">        long diff = time - x.time;</span><br><span class="line">        if (diff &lt; 0)</span><br><span class="line">            return -1;</span><br><span class="line">        else if (diff &gt; 0)</span><br><span class="line">            return 1;</span><br><span class="line">        else if (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            return -1;</span><br><span class="line">        else</span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    long d = (getDelay(TimeUnit.NANOSECONDS) -</span><br><span class="line">            other.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">    return (d == 0) ? 0 : ((d &lt; 0) ? -1 : 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b. 如何实现延时阻塞队列</span><br><span class="line">延时阻塞队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。</span><br><span class="line"></span><br><span class="line">public RunnableScheduledFuture take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            RunnableScheduledFuture first = queue[0];</span><br><span class="line">            if (first == null)</span><br><span class="line">                available.await();</span><br><span class="line">            else &#123;</span><br><span class="line">                long delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">                if (delay &lt;= 0)</span><br><span class="line">                    return finishPoll(first);</span><br><span class="line">                else if (leader != null)</span><br><span class="line">                    available.await();</span><br><span class="line">                else &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        if (leader == thisThread)</span><br><span class="line">                            leader = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (leader == null &amp;&amp; queue[0] != null)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码中的变量leader是一个等待获取队列头部元素的线程。</span><br><span class="line">如果leader不等于空，表示已经有线程在等待获取队列的头元素。</span><br><span class="line">所以，使用await()方法让当前线程等待信号。</span><br><span class="line">如果leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间。</span><br></pre></td></tr></table></figure>

<p>SynchronousQueue:    一个不存储元素的阻塞队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。</span><br><span class="line">它支持公平访问队列.</span><br><span class="line">默认情况下线程采用非公平性策略访问队列。创建公平性访问的SynchronousQueue，如果设置true，则等待的线程会采用先进先出的顺序访问队列。</span><br><span class="line">负责把生产者线程处理的数据直接传递给消费者线程。</span><br><span class="line">队列本身并不存储任何元素，非常适合传递性场景。</span><br><span class="line">SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。</span><br><span class="line">有点像go的channel</span><br></pre></td></tr></table></figure>

<p>LinkedTransferQueue:    一个由链表结构组成的无界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。</span><br><span class="line">相对于其它阻塞队列，linkedTransferQueue多了tryTransfer和transfer方法。</span><br><span class="line"></span><br><span class="line">（1）transfer方法</span><br><span class="line">如果当前有消费者正在等待接收元素(消费者使用take()方法或带有时间限制的poll()方法时)，</span><br><span class="line">transfer方法可以把生产者传入的元素立刻transfer(传输)给消费者。</span><br><span class="line">如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</span><br><span class="line">会让CPU自旋等待消费者消费元素。</span><br><span class="line">因为自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线程，并执行其它线程。</span><br><span class="line"></span><br><span class="line">（2）tryTransfer方法</span><br><span class="line">tryTransfer方法是用来试探生产者传入的元素是否能直接传递给消费者。</span><br><span class="line">如果没有消费者等待接收元素，则返回false。</span><br><span class="line">和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，</span><br><span class="line">而transfer方法是必须等到消费者消费了才返回。</span><br><span class="line"></span><br><span class="line">对于带有时间限制的tryTransfer(E e,long timeout,TimeUnit unit)方法，</span><br><span class="line">试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回。</span><br><span class="line">如果超时还没有消费元素，则返回false，如果在超时时间内消费了元素，则返回true.</span><br></pre></td></tr></table></figure>

<p>LinkedBlockingDeque:    一个由链表结构组成的双向阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。</span><br><span class="line">所谓双向队列指的是可以从队列的两端插入和移出元素。</span><br><span class="line">双向队列因为多了个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。</span><br><span class="line">相比其它的阻塞队列，LinkedBlockingDeque多了addFirst,addLast,offerFirst,offerLast,peekFirst和peekLast等方法，</span><br><span class="line">以First单词结尾的方法，表示插入，获取(peek)或移除双端队列的第一个元素。</span><br><span class="line">以Last单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。</span><br><span class="line">另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst.</span><br><span class="line"></span><br><span class="line">在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外双向阻塞队列可以运用在&quot;工作窃取&quot;模式中。</span><br></pre></td></tr></table></figure>

<h4 id="✅阻塞队列的实现原理"><a href="#✅阻塞队列的实现原理" class="headerlink" title="✅阻塞队列的实现原理"></a>✅阻塞队列的实现原理</h4><p>使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。通过查看JDK源代码发现ArrayBlockingQueue使用了Condition来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">notEmpty = lock.newCondition();</span><br><span class="line">notFull = lock.newChonditon();</span><br></pre></td></tr></table></figure>

<ul>
<li>如果队列满：添加元素的时候，通过调用notFull.await()阻塞当前线程；移除元素额时候，用notFull.signal()唤醒在notFull上等待的线程。</li>
<li>如果队列空：读取元素的时候，通过notEmpty.await()阻塞当前线程；当添加元素时，调用notEmpty.signal()唤醒在notEmpty上等待的线程。</li>
</ul>
<p>阻塞生产者await()主要通过LockSupport.park(this)来实现。其中，首先调用setBlocker先保存一下将要阻塞的线程，然后调用unsafe.park阻塞当前线程。</p>
<h3 id="4-Fork-Join框架"><a href="#4-Fork-Join框架" class="headerlink" title="4.Fork&#x2F;Join框架"></a>4.Fork&#x2F;Join框架</h3><p>Fork&#x2F;Join框架是Java 7 提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<h4 id="✅工作窃取-work-stealing-算法"><a href="#✅工作窃取-work-stealing-算法" class="headerlink" title="✅工作窃取(work-stealing)算法"></a>✅工作窃取(work-stealing)算法</h4><p>工作窃取(work-stealing)算法是指某个线程从其他队列里窃取任务来执行。</p>
<p>做一个比较大的任务，可以把这个任务分割成若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。<br>比如A线程负责处理A队列里的任务。但是，有的线程会把自己队列里的任务干完，而其它线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常使用双端队列，被窃取任务线程永远从双端队列头部拿任务执行，而窃取任务的线程永远从双队列的尾部拿任务执行。</p>
<p>工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。</p>
<p>工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>
<h4 id="✅Fork-Join框架的设计"><a href="#✅Fork-Join框架的设计" class="headerlink" title="✅Fork&#x2F;Join框架的设计"></a>✅Fork&#x2F;Join框架的设计</h4><p>步骤1：分割任务。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。</p>
<p>步骤2：执行任务并合并结果。分割的子任务分别放在双端队列，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</p>
<p>Fork&#x2F;Join使用两个类来完成以上两个事情：</p>
<p>1)ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制。<br>通常情况下，我们不需要直接继承ForkJoinTask类，只需要继承它的子类，Fork&#x2F;Join框架提供了以下两个子类。<br>a.RecursiveAction: 用于没有返回结果的任务。<br>b.RecursiveTask:用于有返回结果的任务。</p>
<p>2）ForkJoinPool：ForkJoinTask需要通过ForkJoinPool来执行。</p>
<p>任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程队列的尾部获取一个任务。</p>
<h4 id="✅使用Fork-Join的例子"><a href="#✅使用Fork-Join的例子" class="headerlink" title="✅使用Fork&#x2F;Join的例子"></a>✅使用Fork&#x2F;Join的例子</h4><p>计算1+2+3+4的结果：</p>
<p>1.如何fork：设置分割的阈值是2，由于是4个数字相加，所以Fork&#x2F;Join框架会把这个任务fork成两个子任务</p>
<p>2.如何join：join两个子任务的结果。因为是有结果的任务，因此必须继承RecursiveTask</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CountTask extends RecursiveTask&lt;Integer&gt;&#123;</span><br><span class="line"> </span><br><span class="line">    private static final int THRESHOLD = 2;//阈值</span><br><span class="line"> </span><br><span class="line">    private int start;</span><br><span class="line"> </span><br><span class="line">    private int end;</span><br><span class="line"> </span><br><span class="line">    public CountTask(int start,int end)&#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    protected Integer compute() &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        // 如果任务足够小就计算任务</span><br><span class="line">        boolean canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        if (canCompute)&#123;</span><br><span class="line">            for (int i=start;i&lt;=end;i++)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // 如果任务大于阈值，就分裂成两个子任务计算</span><br><span class="line">            int middle = (start + end)/2;</span><br><span class="line">            CountTask leftTask = new CountTask(start,middle);</span><br><span class="line">            CountTask rightTask = new CountTask(middle+1,end);</span><br><span class="line"> </span><br><span class="line">            // 执行子任务</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"> </span><br><span class="line">            // 等待子任务执行完，并得到结果</span><br><span class="line">            int leftResult = leftTask.join();</span><br><span class="line">            int rightResult = rightTask.join();</span><br><span class="line"> </span><br><span class="line">            // 合并子任务</span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = new ForkJoinPool();</span><br><span class="line">        // 生成一个计算任务，负责计算 1+2+3+4</span><br><span class="line">        CountTask task = new CountTask(1,4);</span><br><span class="line">        // 执行一个任务</span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;魔法革的日志信息：----&gt;&quot;+ result.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fork方法是执行，join方法是等待执行完获取运行结果。需要实现computer方法，在这个方法里看怎么拆分任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完成并得到结果。</p>
<h4 id="✅Fork-Join框架的异常处理"><a href="#✅Fork-Join框架的异常处理" class="headerlink" title="✅Fork&#x2F;Join框架的异常处理"></a>✅Fork&#x2F;Join框架的异常处理</h4><p>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (task.isCompletedAbnormally())&#123;</span><br><span class="line">    System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回 null。</p>
<h4 id="✅Fork-Join框架的实现原理"><a href="#✅Fork-Join框架的实现原理" class="headerlink" title="✅Fork&#x2F;Join框架的实现原理"></a>✅Fork&#x2F;Join框架的实现原理</h4><p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成的，ForkJoinTask数组负责将存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务。</p>
<p>（1）fork方法实现原理：</p>
<p>调用ForkJoinTask的fork()方法时，程序会调用ForkJoinWorkerThread的pushTask方法异步地执行这个任务，然后立即返回结果。</p>
<p>pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。</p>
<p>（2）join方法实现原理</p>
<p>Join方法的主要作用是阻塞当前线程并等待获取结果。</p>
<p>它调用了doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有4种：<br>已完成(NORMAL)，被取消(CANCELLED)，信号(SIGNAL)和出现异常(EXCEPTION)。</p>
<p>a. 如果任务状态已完成，则直接返回任务结果。<br>b. 如果任务状态是被取消，则直接抛出CancellationException。<br>c. 如果任务状态是抛出异常，则直接抛出对应的异常。</p>
<p>在doJoin()方法里，首先通过任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；如果没有执行完，则从任务数组里取出任务并执行。<br>如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。</p>
<h2 id="第七章-java中的13个原子操作类"><a href="#第七章-java中的13个原子操作类" class="headerlink" title="第七章 java中的13个原子操作类"></a>第七章 java中的13个原子操作类</h2><p>多线程同时更新一个变量，通常我们会使用synchronized来解决这个问题，synchronized会保证多线程不会同时更新变量i。</p>
<p>Java从JDK 1.5开始提供了java.util.concurrent.atomic包（以下简称Atomic包），这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。</p>
<p>Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。Atomic包里的类基本都是使用Unsafe实现的包装类。</p>
<blockquote>
<p>Unsafe类位于sun.misc包下，它是java实现高并发的基础，通过它可以执行一些不安全的操作，如像C语言一样直接操作内存资源，<br>它提供的这些方法增强了java对底层资源的操作能力，但同时也增加了程序出错的风险.<br>Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障相关、数组相关等。</p>
</blockquote>
<blockquote>
<p>CAS(compareAndSwap)即比较并替换，是实现并发算法时常用到的一种技术。CAS底层为一条原子指令cmpxchg，可以保证原子性，Unsafe提供的CAS方法如compareAndSwapInt底层就是CPU指令cmpxchg。<br>CAS在java并发包中的原子类如AtomicInteger，AQS(AbstractQueuedSynchronizer)，ConcurrentHashMap等实现中都有广泛的使用。<br>因此，不管是Atomic还是什么锁里的CAS都依托于Unsafe包里的方法。</p>
</blockquote>
<p>Unsafe类：<a href="https://www.cnblogs.com/strongmore/p/15468423.html">https://www.cnblogs.com/strongmore/p/15468423.html</a></p>
<h3 id="1-原子更新基本类型类"><a href="#1-原子更新基本类型类" class="headerlink" title="1.原子更新基本类型类"></a>1.原子更新基本类型类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">三个类：</span><br><span class="line">· AtomicBoolean：原子更新布尔类型。</span><br><span class="line">· AtomicInteger：原子更新整型。</span><br><span class="line">· AtomicLong：原子更新长整型。</span><br><span class="line"></span><br><span class="line">AtomicInteger为例：</span><br><span class="line">· int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。</span><br><span class="line"></span><br><span class="line">· boolean compareAndSet（int expect，int update）：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。</span><br><span class="line"></span><br><span class="line">· int getAndIncrement()：以原子方式将当前值加1，注意，这里返回的是自增前的值。</span><br><span class="line"></span><br><span class="line">· void lazySet（int newValue）：最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span><br><span class="line"></span><br><span class="line">·int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。</span><br></pre></td></tr></table></figure>

<p>源码分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">  for (;;) &#123;</span><br><span class="line">    int current = get(); </span><br><span class="line">    int next = current + 1;</span><br><span class="line">    if (compareAndSet(current, next)) </span><br><span class="line">        return current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Atomic包里的类基本都是使用Unsafe实现的.<br>Unsafe只提供了3种CAS方法：compareAndSwapObject、compare- AndSwapInt和compareAndSwapLong.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final native boolean compareAndSwapObject(Object o,  long offset, Object expected, Object x);  </span><br><span class="line">  </span><br><span class="line">public final native boolean compareAndSwapInt(Object o, long offset,  int expected, int x);  </span><br><span class="line">  </span><br><span class="line">public final native boolean compareAndSwapLong(Object o, long offset,  long expected, long x);  </span><br></pre></td></tr></table></figure>

<h3 id="2-原子更新数组"><a href="#2-原子更新数组" class="headerlink" title="2.原子更新数组"></a>2.原子更新数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">三个类：</span><br><span class="line">· AtomicIntegerArray：原子更新整型数组里的元素。</span><br><span class="line">· AtomicLongArray：原子更新长整型数组里的元素。</span><br><span class="line">· AtomicReferenceArray：原子更新引用类型数组里的元素。</span><br><span class="line"></span><br><span class="line">AtomicIntegerArray为例：</span><br><span class="line">· int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。</span><br><span class="line"></span><br><span class="line">· boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。</span><br><span class="line"></span><br><span class="line">static int[] value = new int[] &#123; 1， 2 &#125;;  </span><br><span class="line">static AtomicIntegerArray ai = new AtomicIntegerArray(value); </span><br><span class="line">ai.getAndSet(0， 3);</span><br><span class="line">System.out.println(ai.get(0)); //3</span><br><span class="line">System.out.println(value[0]);  //1</span><br></pre></td></tr></table></figure>

<p>需要注意的是，数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组。</p>
<h3 id="3-原子更新引用类型"><a href="#3-原子更新引用类型" class="headerlink" title="3.原子更新引用类型"></a>3.原子更新引用类型</h3><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">· AtomicReference：原子更新引用类型。</span><br><span class="line">· AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</span><br><span class="line">· AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，boolean initialMark）。</span><br><span class="line"></span><br><span class="line">AtomicReference为例：</span><br><span class="line"></span><br><span class="line">public class AtomicReferenceTest &#123;</span><br><span class="line"></span><br><span class="line">    public static AtomicReference&lt;user&gt; atomicUserRef = new AtomicReference&lt;user&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User user = new User(&quot;conan&quot;， 15); atomicUserRef.set(user);</span><br><span class="line">        User updateUser = new User(&quot;Shinichi&quot;， 17); atomicUserRef.compareAndSet(user， updateUser);</span><br><span class="line">        System.out.println(atomicUserRef.get().getName());</span><br><span class="line">        System.out.println(atomicUserRef.get().getOld());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-原子更新字段类"><a href="#4-原子更新字段类" class="headerlink" title="4.原子更新字段类"></a>4.原子更新字段类</h3><p>更新静态类里的成员变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">· AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</span><br><span class="line">· AtomicLongFieldUpdater：原子更新长整型字段的更新器。</span><br><span class="line">· AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。</span><br></pre></td></tr></table></figure>

<p>要想原子地更新字段类需要两步。第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新类的字段（属性）必须使用public volatile修饰符。</p>
<p>AstomicIntegerFieldUpdater例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AtomicIntegerFieldUpdaterTest &#123;</span><br><span class="line"></span><br><span class="line">   // 创建原子更新器，并设置需要更新的对象类和对象的属性</span><br><span class="line">    private static AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class， &quot;old&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User conan = new User(&quot;conan&quot;， 10);</span><br><span class="line">        System.out.println(a.getAndIncrement(conan)); //10</span><br><span class="line">        System.out.println(a.get(conan));  //11</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class User &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        public volatile int old;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">静态变量和成员变量：</span><br><span class="line">由static修饰的变量称为静态变量，其实质上就是一个全局变量。</span><br><span class="line">如果某个内容是被所有对象所共享，那么该内容就应该用静态修饰；</span><br><span class="line">没有被静态修饰的内容，其实是属于对象的特殊描述。</span><br><span class="line"></span><br><span class="line">成员变量和静态变量的区别：</span><br><span class="line">1.生命周期不同</span><br><span class="line">成员变量随着对象的创建而存在，随着对象被回收而释放。</span><br><span class="line">静态变量随着类的加载而存在，随着类的消失而消失。</span><br><span class="line">2.调用方式不同</span><br><span class="line">成员变量只能被对象调用。</span><br><span class="line">静态变量可以被对象调用，还可以被类名调用。</span><br><span class="line">3.别名不同</span><br><span class="line">成员变量也称为实例变量。</span><br><span class="line">静态变量也称为类变量。</span><br><span class="line">4.数据存储位置不同</span><br><span class="line">成员变量存储在堆内存的对象中，所以也叫对象的特有数据。</span><br><span class="line">静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。 </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">静态方法和非静态方法：</span><br><span class="line">静态方法:是使用static关键字修饰的方法，又叫类方法.属于类的，</span><br><span class="line">不属于对象， 在实例化对象之前就可以通过类名.方法名调用静态方法。</span><br><span class="line">非静态方法：又称为实例方法，成员方法。属于对象的，不属于类的。</span><br><span class="line"></span><br><span class="line">静态方法和非静态方法的区别：</span><br><span class="line">1.调用方法</span><br><span class="line">静态方法中，可以调用静态方法，不能调用非静态方法。在静态方法中，不能使用super和this关键字。不能引用成员变量。</span><br><span class="line">普通方法中，可以调用普通方法，也可以调用静态方法。</span><br><span class="line">2.使用方法</span><br><span class="line">静态方法可以直接调用，类名调用和对象调用。</span><br><span class="line">但是非静态方法只能通过对象调用。（对象名.方法名）</span><br><span class="line">3.生命周期不同</span><br><span class="line">静态方法的生命周期跟相应的类一样长，静态方法和静态变量会随着类的定义而被分配和装载入内存中。一直到线程结束，静态属性和方法才会被销毁。</span><br><span class="line">非静态方法的生命周期和类的实例化对象一样长，只有当类实例化了一个对象，非静态方法才会被创建，而当这个对象被销毁时，非静态方法也马上被销毁。</span><br><span class="line"></span><br><span class="line">静态方法优点：常住在内存中，调用快捷方便，全剧唯一，用类调用就行。</span><br><span class="line">应用场景：</span><br><span class="line">1. 静态方法最适合工具类中方法的定义；比如文件操作，日期处理方法等.</span><br><span class="line">2. 静态方法适合入口方法的定义；如单例模式，因为从外部拿不到构造函数，所有定义一个静态的方法获取对象非常有必要.</span><br><span class="line">3. 静态变量适合全局变量的定义.（如布尔型静态成员变量做控制符）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">静态类：</span><br><span class="line">java允许我们在一个类里面定义静态类。比如内部类（nested class）。</span><br><span class="line">把nested class封闭起来的类叫外部类。</span><br><span class="line">在java中，我们不能用static修饰顶级类（top level class）。只有内部类可以为static。</span><br><span class="line">（一般工具类也不是static的，方法是static的）</span><br><span class="line">（一般在一个类里再定义一个类用于包装数据，用public static class）</span><br><span class="line"></span><br><span class="line">静态内部类和非静态内部类的区别：</span><br><span class="line">1.内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。（此话怎样，意思是非静态内部类需要对象.类名，静态内部类需要外部类名.类名）</span><br><span class="line">2.非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。</span><br><span class="line">3.一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。</span><br><span class="line"></span><br><span class="line">class OuterClass&#123;</span><br><span class="line">  private static String msg = &quot;GeeksForGeeks&quot;;</span><br><span class="line">  // 静态内部类</span><br><span class="line">  public static class NestedStaticClass&#123;</span><br><span class="line">    // 静态内部类只能访问外部类的静态成员</span><br><span class="line">    public void printMessage() &#123;</span><br><span class="line">     // 试着将msg改成非静态的，这将导致编译错误 </span><br><span class="line">     System.out.println(&quot;Message from nested static class: &quot; + msg); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 非静态内部类</span><br><span class="line">  public class InnerClass&#123;</span><br><span class="line">    // 不管是静态方法还是非静态方法都可以在非静态内部类中访问</span><br><span class="line">    public void display()&#123;</span><br><span class="line">     System.out.println(&quot;Message from non-static nested class: &quot;+ msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">class Main</span><br><span class="line">&#123;</span><br><span class="line">  // 怎么创建静态内部类和非静态内部类的实例</span><br><span class="line">  public static void main(String args[])&#123;</span><br><span class="line">    // 创建静态内部类的实例</span><br><span class="line">    OuterClass.NestedStaticClass printer = new OuterClass.NestedStaticClass();</span><br><span class="line">    // 创建静态内部类的非静态方法</span><br><span class="line">    printer.printMessage();  </span><br><span class="line">    // 为了创建非静态内部类，我们需要外部类的实例</span><br><span class="line">    OuterClass outer = new OuterClass();    </span><br><span class="line">    OuterClass.InnerClass inner = outer.new InnerClass();</span><br><span class="line">    // 调用非静态内部类的非静态方法</span><br><span class="line">    inner.display();</span><br><span class="line">    // 我们也可以结合以上步骤，一步创建的内部类实例</span><br><span class="line">    OuterClass.InnerClass innerObject = new OuterClass().new InnerClass();</span><br><span class="line">    // 同样我们现在可以调用内部类方法</span><br><span class="line">    innerObject.display();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Inner class &#x27;Person&#x27; may be &#x27;static&#x27; </span><br><span class="line">ide提示内部类最好是静态的. 不然不能在所在外部类里直接new一个对象。</span><br><span class="line"></span><br><span class="line">一个类包在另一个外部类里面，叫做内部类，可以和其他内部类重名。</span><br><span class="line">但是和一个类并列在一个类文件里，不是内部类，不能重名。不同于内部类，是可以直接使用的，相当于一个单独的文件，不建议这么做。</span><br></pre></td></tr></table></figure>

<p>静态内部类和非静态内部类：<a href="https://www.jb51.net/article/74838.htm">https://www.jb51.net/article/74838.htm</a></p>
<h2 id="第八章-java中的并发工具类"><a href="#第八章-java中的并发工具类" class="headerlink" title="第八章 java中的并发工具类"></a>第八章 java中的并发工具类</h2><p>JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore工具类提供了一种并发流程控制的手段，Exchanger工具类提供了在线程间交换数据的一种方法。</p>
<h3 id="1-等待多线程完成的CountDownLatch"><a href="#1-等待多线程完成的CountDownLatch" class="headerlink" title="1.等待多线程完成的CountDownLatch"></a>1.等待多线程完成的CountDownLatch</h3><p>应用场景：等待其他多个线程执行完了，再执行当前线程。</p>
<p>在JDK1.5之后的并发包中提供的CountDownLatch可以实现join的功能，一个countDownLatch的await()方法相当于多个线程的join方法。join线程终止后，其实是调用了<code>this.notifyAll()方法</code>，在JVM里实现的，在JDK里看不到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    CountDownLatch countDownLatch = new CountDownLatch(2);</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(1);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            System.out.println(2);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用CountDownLatch的countDown方法时，CountDownLatch的await方法会阻塞当前线程，直到N变为0。可以是N个线程，也可以是1个线程的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可。</p>
<p>超时机制：<code>await(long time, TimeUnit unit)</code>，这个方法等待特定时间后，就会不再阻挡当前线程。</p>
<p>⚠️CountDownLatch不可能重新初始化或者修改其内部计数器的值。</p>
<h3 id="2-同步屏障CyclicBarrier"><a href="#2-同步屏障CyclicBarrier" class="headerlink" title="2.同步屏障CyclicBarrier"></a>2.同步屏障CyclicBarrier</h3><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p>
<p>应用场景：一辆车装10个人，上够10个人才开车。</p>
<p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier = new CyclicBarrier(2);</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(1);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    try &#123;</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程和子线程的调度是有CPU决定的，两个线程都有可能先执行。可能是1，2，也可能是2，1.</p>
<p>CyclicBarrier还提供了一个高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在所有线程都到达屏障时，优先执行barrierAction。注意，这个barrierAction不一定是要用cyclicBarrier.await()的线程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-18 22:50</span><br><span class="line"> **/</span><br><span class="line">public class CyclicTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier c = new CyclicBarrier(2, new A());</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                c.await();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(2);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class A implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出3-1-2 或者3-2-1.</p>
<h4 id="✅线程的阻塞状态和中断状态"><a href="#✅线程的阻塞状态和中断状态" class="headerlink" title="✅线程的阻塞状态和中断状态"></a>✅线程的阻塞状态和中断状态</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程的阻塞状态和中断状态</span><br><span class="line"></span><br><span class="line">已知：</span><br><span class="line">wait和notify：</span><br><span class="line">执行了监视器的wait()方法后，放弃锁进入等待状态。</span><br><span class="line">执行了监视器的notify()方法后，让一个线程从等待队列到同步队列，进入阻塞状态。</span><br><span class="line">wait()和notify()方法使用的前提是要获取对象的锁的，也就是在synchronized(obj)&#123;&#125;内。</span><br><span class="line">sleep方法进入定时等待状态，不会释放锁(如果写在synchronized内)。</span><br><span class="line"></span><br><span class="line">sleep和wait区别：</span><br><span class="line">1.sleep是Thread类的方法，是「静态方法」。wait是Object类的方法，调用需要具体的对象。</span><br><span class="line">2.sleep是不释放锁的，解除方法要么是timeout，或者interrupt一下让它抛出InterruptedException。wait是释放锁的，可以被notify/notifyAll恢复，同样也可以timeout或者interrupt。</span><br><span class="line">3.sleep在哪里都可以调用，wait必须在同步方法或同步块里调用，并且同步的对象要跟wait的对象一样。</span><br><span class="line">4.sleep作用只是线程的操作，用于短时间暂停线程，wait/notify可以用作线程间通信，达到资源调度的功能。</span><br><span class="line"></span><br><span class="line">Thread.yield():</span><br><span class="line">yield方法也是Thread类的静态方法，重新分配。</span><br><span class="line">会把当前线程从可运行状态变成就绪状态。</span><br><span class="line">之后会cpu会从众多就绪状态的线程中选择一个来执行。</span><br><span class="line"></span><br><span class="line">thread.join():</span><br><span class="line">join是Thread类方法，非静态，表示等待该线程结束，当前线程才继续执行</span><br><span class="line">join进入等待状态。</span><br><span class="line"></span><br><span class="line">线程中断：</span><br><span class="line">suspend()暂停和resume()继续容易造成死锁，stop()具有固有的不安全性。已废弃。</span><br><span class="line">终止线程的几种方式：</span><br><span class="line">1.设计标记位法：volatile的boolean类型变量来控制</span><br><span class="line">缺点：如果代码并没有这种循环语句，或者线程被其他语句阻塞了，线程可能一直不会去检查标记位。</span><br><span class="line">2.thread.interrupt()方法中断</span><br><span class="line">线程里有一个boolean类型的中断状态，是一个标记位，是存在Native层的。</span><br><span class="line">当使用Thread的interrupt()方法时，线程的中断状态会被设置为true。</span><br><span class="line">一些阻塞方法就会抛出一个异常InterruptedException。如果没有这种阻塞方法，那就什么都不会做。</span><br><span class="line">interrupt()方法是实例方法</span><br><span class="line">还有两个方法：isInterrupted() 和 interrupted() </span><br><span class="line">相同点是这两个都是返回一个boolean值，true表示中断，false表示未被中断。</span><br><span class="line">不同点是interrupted()是静态方法，只能在当前线程调用，判断是true后会清除标记，也就是重置为false。isInterrupted()是实例方法，不会清除标记，所以可以多次判断。</span><br><span class="line"></span><br><span class="line">*在Thread.sleep这些方法，抛出InterruptedException异常后会清除标记位状态。</span><br><span class="line">一个关于中断的例子见下面代码</span><br><span class="line"></span><br><span class="line">*所谓的interrupt线程中断，只是修改了一个标记位，需要我们判断标记位做后续的处理。</span><br><span class="line">如果catch代码块什么都不处理，会继续跑完剩下的代码。所以应该理解为『并不是中断，而是通知你应该自行中断了』</span><br><span class="line">线程不应该交给别的线程中断，应该由自己中断自己，过程中保证资源和变量已合理的处理了（该关的关，该释放的释放）。</span><br><span class="line"></span><br><span class="line">线程阻塞：</span><br><span class="line">阻塞和非阻塞是形容多个线程之间的相互影响的，一个线程占用了临界区资源，那么其他线程必须在临界区外等待。</span><br><span class="line">如果一个线程一直占用不释放资源，那么其他需要该临界区资源的线程都必须一直等待。</span><br><span class="line">非阻塞就是运行多个线程同时进入临界区，只要保证不把数据修改坏就行。</span><br><span class="line"></span><br><span class="line">线程阻塞的场景：</span><br><span class="line">运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</span><br><span class="line">发出I/O请求时，JVM会把该线程置为阻塞状态，I/O处理完毕时，线程重新转入就绪状态。</span><br><span class="line"></span><br><span class="line">线程阻塞和等待的区别：</span><br><span class="line">在java中，线程阻塞状态是线程本身不可计划的，而线程等待状态是线程本身计划之内的。</span><br><span class="line">相同点：</span><br><span class="line">（1）都会暂停线程的执行。</span><br><span class="line">区别点：</span><br><span class="line">（1）线程进入阻塞状态是被动的, 而线程进入等待状态是主动的。</span><br><span class="line">阻塞状态的被动：线程在同步代码外，获取对象锁失败时，线程进入阻塞状态；何时获取对象锁失败不可知，即线程阻塞状态是线程本身不可计划的。</span><br><span class="line">等待状态的主动：线程在同步代码内，等待其他线程操作时，线程接入等待状态；何时等待其他线程操作可知，即线程等待状态是线程本身计划之内的。</span><br><span class="line"></span><br><span class="line">countDownLatch/cyclicBarrier的await方法进入阻塞状态，会不会释放锁？</span><br><span class="line">经测试，测试代码如下，不会释放锁。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">wait进入等待状态，释放锁。</span><br><span class="line">sleep进入定时等待状态，不释放锁。</span><br><span class="line">await进入阻塞状态，不释放锁。</span><br></pre></td></tr></table></figure>

<p>线程中断的讲解：<a href="https://blog.csdn.net/alcoholdi/article/details/79475029">https://blog.csdn.net/alcoholdi/article/details/79475029</a></p>
<p>关于线程中断的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line"> </span><br><span class="line">    // 中断目标线程</span><br><span class="line">    public void interrupt() &#123;</span><br><span class="line">        if (this != Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"> </span><br><span class="line">        synchronized (blockerLock) &#123;</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            if (b != null) &#123;</span><br><span class="line">                interrupt0();           // Just to set the interrupt flag</span><br><span class="line">                b.interrupt(this);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 返回目标线程的中断状态	static在这里理解为：只供当前线程使用这个方法</span><br><span class="line">    public static boolean interrupted() &#123;</span><br><span class="line">        return currentThread().isInterrupted(true);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 判断目标线程是否中断</span><br><span class="line">    public boolean isInterrupted() &#123;</span><br><span class="line">        return isInterrupted(false);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private native boolean isInterrupted(boolean ClearInterrupted);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个关于中断的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-18 09:06</span><br><span class="line"> **/</span><br><span class="line">public class InterruptDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss:SSS&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        InterruptThread t = new InterruptThread();</span><br><span class="line">        Interrupt2Thread t = new Interrupt2Thread();</span><br><span class="line">//        Interrupt3Thread t = new Interrupt3Thread();</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3500);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class InterruptThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // 抛出InterruptedException后中断标志被清除</span><br><span class="line">                    // 在catch中直接return结束线程</span><br><span class="line">                    System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; catch &quot; + isInterrupted() + &quot; &quot; + interrupted()); //false false</span><br><span class="line">                    System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot; + interrupted()); //false false</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot; + interrupted()); //不输出</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Interrupt2Thread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (!isInterrupted()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // 抛出InterruptedException后中断标志被清除</span><br><span class="line">                    // 可以再次调用interrupt恢复中断</span><br><span class="line">                    // catch中再次调用interrupt恢复中断状态，while中下次判断isInterrupted()中结束线程</span><br><span class="line">                    System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; catch &quot; + isInterrupted()+ &quot; &quot; + interrupted()); //false false</span><br><span class="line">                    //interrupt();</span><br><span class="line">                    //如果不在catch里再中断，会一直执行</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot;);</span><br><span class="line">//                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot; + interrupted());</span><br><span class="line">                //如果用了上面的那个，中断标识为会输出true后被重置为false，继续循环，不会停</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Interrupt3Thread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @SneakyThrows</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (!isInterrupted()) &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                // 抛出InterruptedException后中断标志被清除</span><br><span class="line">                // 可以再次调用interrupt恢复中断</span><br><span class="line">                // catch中再次调用interrupt恢复中断状态，while中下次判断isInterrupted()中结束线程</span><br><span class="line">                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; catch &quot; + isInterrupted()+ &quot; &quot; + interrupted()); //false false</span><br><span class="line">                interrupt();</span><br><span class="line">                //System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot;);</span><br><span class="line">                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot; + interrupted());</span><br><span class="line">                //如果用了上面的那个，中断标识为会输出true后被重置为false，继续循环，直到在主线程内中断，抛出InterruptedException</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试await方法会不会释放锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-18 22:33</span><br><span class="line"> **/</span><br><span class="line">public class AwaitTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object lock = 1;</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line">        Thread thread1 = new Thread()&#123;</span><br><span class="line">            @SneakyThrows</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    System.out.println(&quot;thread1 get lock&quot;);</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread2 = new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.println(&quot;thread2 get lock&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CyclicBarrier的使用场景：多用于多线程计算数据，最后合并计算结果的场景。<br>一个合并计算结果的例子，用了barrierAction参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-18 23:02</span><br><span class="line"> **/</span><br><span class="line">public class CyclicDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss:SSS&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BankWaterService bankWaterService = new BankWaterService();</span><br><span class="line">        bankWaterService.count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class BankWaterService implements Runnable &#123;</span><br><span class="line">        private final CyclicBarrier c = new CyclicBarrier(4, this);  //这里屏障解除后执行本线程。</span><br><span class="line">        private final ExecutorService executor = Executors.newFixedThreadPool(4);</span><br><span class="line">        private final ConcurrentHashMap&lt;String, Integer&gt; sheetBankWaterCount = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        private void count() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                executor.execute(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        sheetBankWaterCount.put(Thread.currentThread().getName(), 3);</span><br><span class="line">                        try &#123;</span><br><span class="line">                            c.await();</span><br><span class="line">                            System.out.println(sdf.format(new Date()) + &quot; &quot; + Thread.currentThread().getName());</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int result = 0;</span><br><span class="line">            for (Map.Entry&lt;String, Integer&gt; sheet : sheetBankWaterCount.entrySet()) &#123;</span><br><span class="line">                result += sheet.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sdf.format(new Date()) + &quot; &quot; + &quot;result:&quot; + result);</span><br><span class="line">            executor.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-CyclicBarrier和CountDownLatch的区别"><a href="#3-CyclicBarrier和CountDownLatch的区别" class="headerlink" title="3.CyclicBarrier和CountDownLatch的区别"></a>3.CyclicBarrier和CountDownLatch的区别</h3><p>1、使用的场景不一样，CyclicBarrier阻塞每个线程（每个线程都等待最后一个线程到达屏障），像分布式问题，屏障清除了，每个线程可以继续做自己的事情；CountDownLatch阻塞等待线程（等待线程等待其他线程完成）向集中式的，最后由等待线程统一处理。</p>
<p>2、CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重弄下执行一次。</p>
<p>3、CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。</p>
<p>cyclicBarrier线程中断示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-19 18:37</span><br><span class="line"> **/</span><br><span class="line">public class CyclicInterruptTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier c = new CyclicBarrier(3);</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                c.await();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                //e.printStackTrace();</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(2);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        try &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(c.isBroken());</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">2</span><br><span class="line">true</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>说明：尽管屏障数是3，但是其中一个中断了的话，其他的await也会跑出异常。被中断的抛出InterruptedException，其他的抛出BrokenBarrierException。</p>
<h3 id="4-控制并发线程数的Semaphore"><a href="#4-控制并发线程数的Semaphore" class="headerlink" title="4.控制并发线程数的Semaphore"></a>4.控制并发线程数的Semaphore</h3><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p>
<p>应用场景：Semaphore可以做流量控制，特别是公用资源有限的应用场景，比如数据库连接。<br>假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库连接数只有10个，这是我们必须控制只有10个线程同时获取数据库连接保持数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final int THREAD_COUNT = 30;</span><br><span class="line">private static final ExecutorService executorService = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">private static final Semaphore s = new Semaphore(10);</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    for (int i = 0; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                s.acquire();</span><br><span class="line">                System.out.println(&quot;save data&quot;);</span><br><span class="line">                s.release();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然有30个线程在执行，但是只允许10个线程并发执行。<br>为什么不开始创建10个线程的线程池呢？因为前面需要30个，只是在代码某部分限制10个。<br>构造方法Semaphore(int permits)接收一个整型的数组，表示可用的许可证数量。<br>Semaphore的acquire()方法获取一个许可证，获取不到就阻塞，使用完之后调用release()方法归还许可证。还可以使用tryAcquire()方法尝试获取许可证。</p>
<p>其他方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">intavailablePermits():返回信号量中当前可用的许可证数目。</span><br><span class="line">ingetQueueLength():返回正在等待获取许可证的线程数。</span><br><span class="line">booleanhasQueueThreads():是否有线程正在等待获取许可证</span><br><span class="line">void reducePermits(int reduction):减少reduction个许可证，是个protected方法。</span><br><span class="line">Collection getQueuedThreads():返回所有等待获取许可证的线程集合，是个protected方法。</span><br></pre></td></tr></table></figure>

<h3 id="5-线程间交互数据的Exchanger"><a href="#5-线程间交互数据的Exchanger" class="headerlink" title="5.线程间交互数据的Exchanger"></a>5.线程间交互数据的Exchanger</h3><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exhange()方法交换数据，如果第一个线程先执行exhange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都达到同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p>
<p>应用场景：可用于遗传算法，将两个人作为交配对象，交换两个人的数据。还可以用于校对工作，比如我们需要将纸质银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入之后比对。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Exchanger;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-19 19:23</span><br><span class="line"> **/</span><br><span class="line">public class ExchangerTest &#123;</span><br><span class="line">    private static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;&gt;();</span><br><span class="line">    private static final ExecutorService threadPool = Executors.newFixedThreadPool(2);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            String a = &quot;银行流水A&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                String exchange = exgr.exchange(a);</span><br><span class="line">                System.out.println(&quot;B 录入的是:&quot; + exchange + &quot; A录入的是：&quot; + a);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            String b = &quot;银行流水B&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                String exchange = exgr.exchange(b);</span><br><span class="line">                System.out.println(&quot;A 录入的是:&quot; + exchange + &quot; B录入的是：&quot; + b);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果两个线程一个没有执行exchange()方法，则会一直等待，如果单向特殊情况发生，避免一直等待，可以使用<code>exchange(V x, long timeout, TimeUnit unit)</code>设置最大等待时间。</p>
<p>原书笔记：<a href="https://blog.csdn.net/tianzhonghaoqing/article/details/123976376">https://blog.csdn.net/tianzhonghaoqing/article/details/123976376</a></p>
<h2 id="第九章-java中的线程池"><a href="#第九章-java中的线程池" class="headerlink" title="第九章 java中的线程池"></a>第九章 java中的线程池</h2><p>合理地使用线程池能够带来3个好处：<br>降低资源消耗(通过重复利用已创建的线程降低线程创建和销毁造成的消耗)<br>提高响应速度(当任务到达时，任务可以不需要等到线程创建就能立即执行)<br>提高线程的可管理性(线程池可以进行统一分配、调优和监控线程)</p>
<h3 id="1-线程池的实现原理"><a href="#1-线程池的实现原理" class="headerlink" title="1.线程池的实现原理"></a>1.线程池的实现原理</h3><p>ThreadPoolExecutor执行execute方法分下面4种情况：</p>
<p>1、如果当前运行的线程少于corePoolSize，则创建新线程来执行任务，不管已有线程是不是空闲(需要获取全局锁)</p>
<p>2、如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue</p>
<p>3、如果BlockingQueue队列已满，则创建新的线程(非核心线程)来处理任务(需要获取全局锁）</p>
<p>4、如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法</p>
<p>工作线程：线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行。</p>
<h3 id="2-线程池的创建"><a href="#2-线程池的创建" class="headerlink" title="2.线程池的创建"></a>2.线程池的创建</h3><p><code>new ThreadPoolExecutor(xxx)</code>，其中参数具体含义如下：</p>
<p>1、corePoolSize(线程池的基本大小)：当提交一个任务到线程池时，线程池会创建一个线程来执行任务(即使其他空闲的基本线程能够执行新任务也会创建，满了不再创建。）如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p>
<p>2、runnableTaskQueue(任务队列)：用于保存等待执行的任务的阻塞队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue:基于数组结构的有界阻塞队列，按FIFO原则对元素排序。</span><br><span class="line"></span><br><span class="line">LinkedBlockingQueue:基于链表结构的有界阻塞队列，FIFO原则，吞吐量高于ArrayBlockingQueue，</span><br><span class="line">静态工厂方法Executors.newFixedThreadPool()使用该队列。</span><br><span class="line"></span><br><span class="line">SynchronousQueue:一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直阻塞。吞吐量高于LinkedBlockingQueue。</span><br><span class="line">静态工厂方法Executors.newCachedThreadPool使用该队列。</span><br><span class="line"></span><br><span class="line">PriorityBlockingQueue:一个具有优先级的无限阻塞队列。</span><br></pre></td></tr></table></figure>

<p>3、maximumPoolSize(线程池最大数量)：线程池允许创建的最大线程数，如果队列满了且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果使用的是无界队列，改参数没效果。</p>
<p>4、ThreadFactory：设置创建线程的工厂，可以给线程命名。</p>
<p>5、RejectedExecutionHandler(饱和策略)：当队列和线程池都满了，则采取一种策略处理提交的新任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AbortPolicy(默认)：直接抛出异常。</span><br><span class="line">CallerRunsPolicy：用调用者所在线程来运行任务。</span><br><span class="line">DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务</span><br><span class="line">DiscardPolicy：不处理，丢弃掉且不抛出异常</span><br></pre></td></tr></table></figure>

<p>6、keepAliveTime(线程活动保持时间)：线程池的工作线程空闲后保持存活的时间(超过该时长，非核心线程就会被回收)</p>
<p>7、TimeUnit(线程活动保持时间的单位)</p>
<h3 id="3-向线程池提交任务"><a href="#3-向线程池提交任务" class="headerlink" title="3.向线程池提交任务"></a>3.向线程池提交任务</h3><ul>
<li>execute()：用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">threadsPool.execute(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>submit()：用于提交需要返回值的任务(返回future类型的对象，该对象可以判断任务是否执行成功且可以通过对象的get()来获取返回值).<br>get()方法会阻塞当前线程直到任务完成。<code>get(long timeout, TimeUnit unit)</code>可阻塞一段时间后立即返回。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);</span><br><span class="line">    try &#123;</span><br><span class="line">    	Object s = future.get();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">    	// 处理中断异常</span><br><span class="line">    &#125; catch (ExecutionException e) &#123;</span><br><span class="line">    	// 处理无法执行任务异常</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    	// 关闭线程池</span><br><span class="line">    	executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-关闭线程池"><a href="#4-关闭线程池" class="headerlink" title="4.关闭线程池"></a>4.关闭线程池</h3><p>线程池的shutdown或shutdownNow方法关闭线程池，原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程。</p>
<p>无法响应中断的线程可能永远无法终止。</p>
<p>shutdown &#x3D;&gt; 平缓关闭，等待所有已添加到线程池中的任务执行完再关闭<br>shutdownNow &#x3D;&gt; 立刻关闭，停止正在执行的任务，并返回队列中未执行的任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shutdown和shutdownNow：</span><br><span class="line">1、shutdown()</span><br><span class="line">阻止新来的任务提交，对已经提交了的任务不会产生任何影响。</span><br><span class="line">当已经提交的任务执行完后，它会将那些闲置的线程（idleWorks）进行中断，这个过程是异步的。</span><br><span class="line">将线程池的状态改成SHUTDOWN，当再将执行execute提交任务时，如果测试到状态不为RUNNING，则抛出rejectedExecution，从而达到阻止新任务提交的目的。</span><br><span class="line"></span><br><span class="line">2、shutdownNow()</span><br><span class="line">阻止新来的任务提交，同时会中断当前正在运行的线程，即workers中的线程。</span><br><span class="line">它还将workQueue中的任务给移除，并将这些任务添加到列表中进行返回。</span><br><span class="line">通过将线程池的状态改成STOP，当再将执行execute提交任务时，如果测试到状态不为RUNNING，则抛出rejectedExecution，从而达到阻止新任务提交的目的.</span><br><span class="line">一个特例：</span><br><span class="line">一个线程正在sleep状态中，此时执行shutdownNow()，</span><br><span class="line">它向该线程发起interrupt()请求，而sleep()方法遇到有interrupt()请求时，会抛出InterruptedException，并清除中断标志</span><br><span class="line">如果catch了，并没有在catch中再interrupt()，会继续往下执行。</span><br><span class="line">如果向外抛出异常，会中断</span><br></pre></td></tr></table></figure>

<h3 id="5-合理配置线程池"><a href="#5-合理配置线程池" class="headerlink" title="5.合理配置线程池"></a>5.合理配置线程池</h3><p>1、任务的性质：</p>
<p>CPU密集型任务：配置尽可能小的线程(Ncpu+1)，因为CPU密集型任务使得CPU使用率很高，若开过多的线程数能增加上下文切换的次数，带来额外的开销。</p>
<p>IO密集型任务：配置尽可能多的线程(2*Ncpu)，因为CPU使用率并不高，可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间。</p>
<p>混合型任务：可将任务分成IO密集型和CPU密集型任务(两个任务执行时间相差不大时)，然后分别用不同的线程池去处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU密集型和IO密集型：</span><br><span class="line">CPU密集型：需非常多CPU计算资源，让每个CPU核心都参与计算，CPU性能充分利用，应避免过多线程上下文切换。</span><br><span class="line">IO密集型：网络、磁盘 IO （与DB、缓存），一旦IO，线程就等待，结束才执行。多设线程数，等待时去做其它事，提高效率。</span><br></pre></td></tr></table></figure>

<p>2、任务的优先级：优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理</p>
<p>3、任务的执行时间：可以交给不同规模的线程池来处理，或者优先级队列。执行时间短的先执行</p>
<p>4、任务的依赖性：比如依赖数据库连接池的任务，线程提交SQL后需要等待数据库返回结果，等待的时间越长，CPU空闲时间就越长(相当于IO密集型任务，应设置较大线程数)</p>
<p>5、建议使用有界队列，可以增加系统稳定性和预警能力，再抛弃任务的时候加监控，无界队列会撑满内存，导致整个系统不能用。</p>
<h3 id="6-线程池的监控"><a href="#6-线程池的监控" class="headerlink" title="6.线程池的监控"></a>6.线程池的监控</h3><p>如果在系统中大量使用线程池，则需要对线程池进行监控，在出现问题时，可根据线程池的使用状况快速定位问题。可使用以下属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">taskCount：线程池需要执行的任务数量</span><br><span class="line">completedTaskCount：线程池在运行过程中已完成的任务数量</span><br><span class="line">largestPoolSize：线程池里曾经创建过的最大线程数量</span><br><span class="line">getPoolSize：线程池的线程数量(线线程池不销毁的话，线程池里的线程不会自动销毁)</span><br><span class="line">getActiveCount：获取活动的线程数</span><br></pre></td></tr></table></figure>

<p>可以继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminated方法进行监控。在执行前、执行后、线程池关闭前监控，比如：任务平均执行时间，最大执行时间，最小执行时间。</p>
<h3 id="7-Executors的线程池："><a href="#7-Executors的线程池：" class="headerlink" title="7.Executors的线程池："></a>7.Executors的线程池：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定长线程池(FixedThreadPool)：用于控制线程最大并发数</span><br><span class="line">只有核心线程</span><br><span class="line">线程数量固定</span><br><span class="line">执行完立即回收</span><br><span class="line">任务队列为链表结构的有界队列(消耗内存)</span><br><span class="line"></span><br><span class="line">定时线程池(ScheduledThreadPool)：用于执行定时或周期性的任务</span><br><span class="line">核心线程数量固定</span><br><span class="line">非核心线程数量无限(线程过多导致内存溢出)</span><br><span class="line">执行完闲置10ms后回收</span><br><span class="line">任务队列为延时阻塞队列</span><br><span class="line"></span><br><span class="line">可缓存线程池(CachedThreadPool)：执行大量且耗时少的任务</span><br><span class="line">无核心线程</span><br><span class="line">非核心线程数量无限(线程过多导致内存溢出)</span><br><span class="line">执行完闲置60s后回收</span><br><span class="line">任务队列为不存储元素的阻塞队列</span><br><span class="line"></span><br><span class="line">单线程化线程池(SingleThreadExecutor)：应用于不适合并发但可能引起IO阻塞性及影响UI线程响应的操作，如数据库操作</span><br><span class="line">只有1个核心线程</span><br><span class="line">无非核心线程</span><br><span class="line">执行完立即回收</span><br><span class="line">任务队列为链表结构的有界队列(消耗内存)</span><br></pre></td></tr></table></figure>

<p>原书笔记：<a href="https://blog.csdn.net/qq_41398418/article/details/126279652">https://blog.csdn.net/qq_41398418/article/details/126279652</a></p>
<h2 id="第十章-Executor框架"><a href="#第十章-Executor框架" class="headerlink" title="第十章 Executor框架"></a>第十章 Executor框架</h2><p>在Java中，使用线程来异步执行任务。Java线程的创建与销毁需要一定的开销，如果我们为每一个任务创建一个新线程来执行，这些线程的创建与销毁将消耗大量的计算资源。同时， 为每一个任务创建一个新线程来执行，这种策略可能会使处于高负荷状态的应用最终崩溃。</p>
<p>Java的线程既是工作单元，也是执行机制。从JDK 5开始，把工作单元与执行机制分离开来。工作单元包括Runnable和Callable，而执行机制由Executor框架提供。</p>
<h3 id="1-Executor框架"><a href="#1-Executor框架" class="headerlink" title="1.Executor框架"></a>1.Executor框架</h3><h4 id="✅Executor框架的两级调度模型"><a href="#✅Executor框架的两级调度模型" class="headerlink" title="✅Executor框架的两级调度模型"></a>✅Executor框架的两级调度模型</h4><p>在HotSpot VM的线程模型中，Java线程（java.lang.Thread）被一对一映射为本地操作系统线程。操作系统会调度所有线程并将它们分配给可用的CPU。</p>
<p><strong>两级调度模型</strong>：<br>在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。<br><em>应用程序通过Executor框架控制上层的调度；而下层的调度由操作系统内核控制，下层的调度不受应用程序的控制。</em></p>
<h4 id="✅Executor框架的结构"><a href="#✅Executor框架的结构" class="headerlink" title="✅Executor框架的结构"></a>✅Executor框架的结构</h4><p>Executor框架主要由3大部分组成：</p>
<p>1、任务。包括被执行任务需要实现的接口：Runnable接口或Callable接口。</p>
<p>2、任务的执行。包括任务执行机制的核心接口Executor，以及实现自Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口（ThreadPoolExecutor和<br>ScheduledThreadPoolExecutor）。</p>
<p>3、异步计算的结果。包括接口Future和实现Future接口的FutureTask类。</p>
<hr>
<p>Executor框架的类与接口：</p>
<p>1、Executor是一个接口，它是Executor框架的基础，它将任务的提交与任务的执行分离开来。</p>
<p>2、ExecutorService接口，实现自Executor接口。</p>
<p>3、ThreadPoolExecutor类是线程池的核心实现类，用来执行被提交的任务。</p>
<p>4、ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。<br>ScheduledThreadPoolExecutor比Timer更灵活，功能更强大。</p>
<p>5、Future接口和实现Future接口的FutureTask类，代表异步计算的结果。</p>
<p>6、Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或Scheduled- ThreadPoolExecutor执行。</p>
<hr>
<p>使用步骤：</p>
<p>1.创建任务对象：主线程创建实现Runnable或者Callable接口的任务对象。<code>工具类Executors可以把一个Runnable对象封装为一个Callable对象（Executors.callable（Runnable task）或Executors.callable（Runnable task，Object resule））</code></p>
<p>2.任务提交给线程池执行：把Runnable对象直接交给ExecutorService执行<code>（ExecutorService.execute（Runnable command））</code>；或者也可以把Runnable对象或Callable对象提交给ExecutorService执行<code>（ExecutorService.submit（Runnable task）或ExecutorService.submit（Callabletask））</code><br>如果执行ExecutorService.submit（…），ExecutorService将返回一个实现Future接口的对象（到目前为止的JDK中，返回的是FutureTask对象）。由于FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService执行。</p>
<p>3.submit的获取结果：主线程可以执行<code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行<code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</p>
<h4 id="✅-Executor框架的成员"><a href="#✅-Executor框架的成员" class="headerlink" title="✅ Executor框架的成员"></a>✅ Executor框架的成员</h4><p>Executor框架的主要成员：ThreadPoolExecutor、<br>ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口和Executors。</p>
<hr>
<p>（1） ThreadPoolExecutor</p>
<p>ThreadPoolExecutor可以使用工厂类Executors来创建。Executors可以创建3种类型的ThreadPoolExecutor：SingleThreadExecutor、FixedThreadPool和CachedThreadPool。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">固定线程数的FixedThreadPool的 API。</span><br><span class="line">适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器。</span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">        0L, TimeUnit.MILLISECONDS,</span><br><span class="line">        new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单个线程的SingleThreadExecutor的API.</span><br><span class="line">适用于需要保证顺序地执行各个任务；只要一个线程的应用场景。</span><br><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1,</span><br><span class="line">        0L, TimeUnit.MILLISECONDS,</span><br><span class="line">        new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">        threadFactory));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CachedThreadPool是大小无界的线程池，</span><br><span class="line">适用于执行很多的短期异步任务的小程序，或者 是负载较轻的服务器。</span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">        60L, TimeUnit.SECONDS,</span><br><span class="line">        new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>（2） ScheduledThreadPoolExecutor<br>ScheduledThreadPoolExecutor可以使用工厂类Executors来创建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ScheduledThreadPoolExecutor。</span><br><span class="line">包含若干个线程的ScheduledThreadPoolExecutor。</span><br><span class="line">适用于需要多个后台线程执行周期任务</span><br><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SingleThreadScheduledExecutor。</span><br><span class="line">只包含一个线程的ScheduledThreadPoolExecutor。</span><br><span class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123;</span><br><span class="line">    return new DelegatedScheduledExecutorService</span><br><span class="line">        (new ScheduledThreadPoolExecutor(1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>（3） Future接口</p>
<p>Future接口和实现Future接口的FutureTask类用来表示异步计算的结果。当我们把Runnable 接口或Callable接口的实现类提交（submit）给ThreadPoolExecutor或<br>ScheduledThreadPoolExecutor时，会向我们返回一个FutureTask对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">api:</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p>到目前最新的JDK 8为止，Java通过上述API返回的是一个FutureTask对象。但从API可以看到，Java仅仅保证返回的是一个实现了Future接口的对象。</p>
<hr>
<p>（4） Runnable接口和Callable接口</p>
<p>Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或Scheduled- ThreadPoolExecutor执行。它们之间的区别是Runnable不会返回结果，而Callable可以返回结果。</p>
<p>工厂类Executors可以把一个Runnable包装成一个Callable。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Callable&lt;Object&gt; callable(Runnable task) //结果是null</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result)  //结果是result</span><br></pre></td></tr></table></figure>

<h3 id="2-ThreadPoolExecutor详解"><a href="#2-ThreadPoolExecutor详解" class="headerlink" title="2.ThreadPoolExecutor详解"></a>2.ThreadPoolExecutor详解</h3><p>介绍一下Executors创建的三种用的是什么参数</p>
<p>1.FixThreadPool内部使用无界队列LinkedBlockingQueue作为任务队列，队列的容量为Integer.MAX_VALUE，由于是无界队列，所以不会拒绝任务，maximumPool没有意义，可能会造成任务无限堆积，从而导致系统资源耗尽的情况。</p>
<p>2.SingleThreadExecutor：与FixThreadPool类似，只是SingleThreadExecutor的线程数固定为1</p>
<p>3.CachedThreadPool的corePool为空，maximumPoolSize为Integer.MAX_VALUE，keepAliveTime为60L，这意味着线程空闲超过60秒则会进行回收。CachedThreadPool内部使用不存储元素的阻塞队列SynchronousQueue作为任务队列，每个插入操作必须等待另一个线程的移除操作。这意味着如果任务的提交速度高于线程的处理速度，那么CachedThreadPool则会不断的创建新的线程，在极端的情况下，会耗尽CPU和内存资源。</p>
<h3 id="3-ScheduledThreadPoolExecutor"><a href="#3-ScheduledThreadPoolExecutor" class="headerlink" title="3.ScheduledThreadPoolExecutor"></a>3.ScheduledThreadPoolExecutor</h3><p>ScheduledThreadPoolExecutor主要用来执行需要延迟或者定时执行的任务，功能与Timer类似，不同的是Timer只能单线程允许，ScheduledThreadPoolExecutor可以指定多个线程。</p>
<p>ScheduledThreadPoolExecutor执行<code>scheduleAtFixedRate()方法或者scheduleWithFixedDelay()</code>方法时，会把要执行的任务放在一个无界队列DelayQueue中，<code>ScheduledThreadPoolExecutor会把Runable对象封装成ScheduledFutureTask（实现了RunnableScheduledFuture接口）</code>。线程池中的线程从DelayQueue中获取ScheduledFutureTask。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private class ScheduledFutureTask&lt;V&gt;</span><br><span class="line">    extends FutureTask&lt;V&gt; implements RunnableScheduledFuture&lt;V&gt;</span><br></pre></td></tr></table></figure>

<p>ScheduledFutureTask内部包含三个成员变量。<br>time：任务要被执行的具体时间<br>sequenceNumber：任务排序编号，如果两个任务的time相同，那么则sequenceNumber较小的会先执行<br>period：任务执行的周期</p>
<hr>
<p>ScheduledThreadPoolExecutor执行任务的流程大体是：<br>1.从DelayQueue中获取ScheduledFutureTask（time大于当前时间的任务）<br>2.执行ScheduledFutureTask<br>3.修改ScheduledFutureTask的time为下次要执行的时间<br>4.将ScheduledFutureTask再次放入DelayQueue中</p>
<h3 id="3-FutureTask"><a href="#3-FutureTask" class="headerlink" title="3.FutureTask"></a>3.FutureTask</h3><p>Future接口和FutureTask实现类代表线程异步执行的结果，可以通过FutureTask.get()方法获取异步返回的结果。</p>
<p>FutureTask类还实现了Runnable接口，因此可以交给Executor执行，也可以直接在当前线程中执行：<code>FutureTask.run()</code>。</p>
<hr>
<p>根据FutureTask.run被执行的时机，FutureTask可处于下面3种状态：<br>未启动：方法还没有被执行之前，FutureTask处于未启动状态<br>已启动：方法被执行的过程中，FutureTask处于已启动状态<br>已完成：方法执行完后正常结束或、取消(即执行FutureTask.cancel)或抛异常，FutureTask处于已完成状态</p>
<hr>
<p>FutureTask状态决定get和cancel方法执行结果：</p>
<p>1.gei方法：如果未启动或已启动状态，get方法将导致调用线程阻塞，如果已完成状态，get方法将导致调用线程立即返回结果或抛出异常。</p>
<p>2.cancel方法：当处于未启动状态，该任务将不会执行，当处于已启动状态，<code>Future.cancel(true)</code>将中断此任务线程来停止任务，<code>Future.cancel(false)</code>将不会对正在执行此任务的线程产生影响，当处于已完成状态时，cancel方法将返回false。</p>
<p>当一个线程需要等待另一个线程把某个任务执行完后并获取结果它才能继续执行，可使用FutureTask。</p>
<hr>
<p>FutureTask的实现：</p>
<p>FutureTask的实现基于AbstractQueuedSynchronizer(AQS是同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程，以及维护被阻塞线程的队列)。java.util.concurrent里的很多阻塞类：ReetrantLock、Semaphore、ReetrantReadWriteLock、CountDownLatch都是基于AQS实现。</p>
<hr>
<p>AQS遗忘的知识：<br>AQS实现的同步器都会包含两种类型的操作：<br>1.acquuire操作，获取同步状态，用来阻塞调用线程。FutureTask中为get方法。<br>2.release操作，释放同步状态，用来解除阻塞线程的阻塞，FutureTask中为run方法和cancel方法。</p>
<hr>
<p>基于复合优先于基础原则，FutureTask的内部私有类Sync继承自AQS。实现了AQS的<code>tryAcquireShared(int) 和 tryReleaseShared(int)</code>.</p>
<p>🤔因为FutureTask涉及到线程的阻塞唤醒也就是同步，所以用AQS。</p>
<h2 id="第十一章-java并发编程实践"><a href="#第十一章-java并发编程实践" class="headerlink" title="第十一章 java并发编程实践"></a>第十一章 java并发编程实践</h2><h3 id="1-生产者和消费者模式"><a href="#1-生产者和消费者模式" class="headerlink" title="1.生产者和消费者模式"></a>1.生产者和消费者模式</h3><p>什么是生产者和消费者模式？</p>
<p>生产者和消费者模式是<strong>通过一个容器来解决生产者和消费者的强耦合问题</strong>。生产者和消费者彼此之间不直接通信，而是<strong>通过阻塞队列来进行通信</strong>，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，<strong>阻塞队列就相当于一个缓冲区</strong>，平衡了生产者和消费者的处理能力。</p>
<p>这个阻塞队列就是用来给生产者和消费者解耦的。纵观大多数设计模式，都会<strong>找一个第三者出来进行解耦</strong>，如工厂模式的第三者是工厂类，模板模式的第三者是模板类。在学习一些设计模式的过程中，先找到这个模式的第三者，能帮助我们快速熟悉一个设计模式。</p>
<p>获取机器有多少个CPU，来决定线程池大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int corePoolSize = Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure>


<h3 id="2-多生产者和多消费者场景"><a href="#2-多生产者和多消费者场景" class="headerlink" title="2.多生产者和多消费者场景"></a>2.多生产者和多消费者场景</h3><p>在多核时代，多线程并发处理速度比单线程处理速度更快，所以可以使用多个线程来生产数据，同样可以使用多个消费线程来消费数据。而更复杂的情况是，消费者消费的数据，有可能需要继续处理，于是消费者处理完数据之后，它又要作为生产者把数据放在新的队列里，交给其他消费者继续处理.</p>
<h3 id="3-线程池就是生产者消费者模式"><a href="#3-线程池就是生产者消费者模式" class="headerlink" title="3.线程池就是生产者消费者模式"></a>3.线程池就是生产者消费者模式</h3><p>Java 中的线程池类其实就是一种生产者和消费者模式的实现方式，但是更加高明。生产者把任务丢给线程池，线程池创建线程并处理任务，如果将要运行的任务数大于线程池的基本线程数就把任务扔到阻塞队列里，这种做法比只使用一个阻塞队列来实现生产者和消费者模式显然要高明很多，因为消费者能够处理直接就处理掉了（不用中转队列），这样速度更快，而生产者先存，消费者再取这种方式显然慢一些。</p>
<p>生产者消费者例子：</p>
<p>调用一个远程接口查询数据，如果远程服务接口查询时需要几十秒的时间，那么它可以提供一个申请查询的接口，这个接口把要申请查询任务放数据库中，然后该接口立刻返回。然后服务器端用线程轮询并获取申请任务进行处理，处理完之后发消息给调用方，让调用方再来调用另外一个接口取数据。</p>
<p>再比如：</p>
<p>1.有一些任务，这些任务放在db里，表示完成进程，同时将表的id放入redis队列中。</p>
<p>2.任务处理端，从redis队列中取出id，再用id从数据库读出一个任务进行处理，并更新db中任务完成的进程。</p>
<p>3.因为redis缓存稳定性考虑，定时任务搂db中长时间未完成的任务，将id放入redis队列中。</p>
<h3 id="4-线上问题定位"><a href="#4-线上问题定位" class="headerlink" title="4.线上问题定位"></a>4.线上问题定位</h3><p>看日志、系统状态和 dump 线程。</p>
<p>在 Java 进程这一行里可以看到 CPU 利用率是 300%，不用担心，这个是当前机器所有核加在一起的 CPU 利用率。</p>
<p>jstack命令可以把线程 dump 下来，看看究竟是哪个线程、执行什么代码造成的 CPU 利用率高。</p>
<p>dump 出来的线程 ID（nid）是十六进制的，而我们用 TOP 命令看到的线程 ID 是十进制的，所以要用 printf 命令转换一下进制。然后用十六进制的 ID 去 dump 里找到对应的线程。</p>
<p>十进制转十六进制：<br><code>printf &quot;%x\n&quot; 31558</code></p>
<p><code>netstat -nat | grep 8080 -c</code> 多少台机器连接到本机8080端口</p>
<p><code>ps -eLf|grep java -c</code> 看java线程数</p>
<h3 id="5-异步任务池"><a href="#5-异步任务池" class="headerlink" title="5.异步任务池"></a>5.异步任务池</h3><p>如果一个任务仍进线程池之后，运行线程池的程序重启了，那么线程池里的任务就会丢失。另外，线程池只能处理本机的任务，在集群环境下不能有效地调度所有机器的任务。所以，结合线程池开发一个异步任务处理池。</p>
<p>任务池的主要处理流程是，每台机器会启动一个任务池，每个任务池里有多个线程池，当某台机器将一个任务交给任务池后，任务池会先将这个任务保存到数据中，然后某台机器上的任务池会从数据库中获取待执行的任务，再执行这个任务。</p>
<p>每个任务有几种状态，分别是创建（NEW）、执行中（EXECUTING）、RETRY（重试）、挂起（SUSPEND）、中止（TEMINER）和执行完成（FINISH）。</p>
<p>创建：提交给任务池之后的状态。<br>执行中：任务池从数据库中拿到任务执行时的状态。<br>重试：当执行任务时出现错误，程序显式地告诉任务池这个任务需要重试，并设置下一次执行时间。<br>挂起：当一个任务的执行依赖于其他任务完成时，可以将这个任务挂起，当收到消息后，再开始执行。<br>中止：任务执行失败，让任务池停止执行这个任务，并设置错误消息告诉调用端。<br>执行完成：任务执行结束。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>maven与nexus</title>
    <url>/2022/06/01/myblog/java/maven%E5%92%8Cnuxus/</url>
    <content><![CDATA[<h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><ol>
<li><p>优秀的构建工具<br>通过简单的命令，能够完成清理、编译、测试、打包、部署等一系列过程。同时，不得不提的是，Maven是跨平台的，无论是在Windows、还是在Linux或Mac上，都可以使用同样的命令。</p>
</li>
<li><p>依赖管理工具<br>项目依赖的第三方的开源类库，都可以通过依赖的方式引入到项目中来。代替了原来需要首先下载第三方jar，再加入到项目中的方式。从而更好的解决了合作开发中依赖增多、版本不一致、版本冲突、依赖臃肿等问题。<br>具体是怎么实现的呢？Maven通过坐标系统准确的定位每一个构件，即通过坐标找到对应的java类库。</p>
</li>
<li><p>项目信息管理工具<br>能够管理项目描述、开发者列表、版本控制系统地址、许可证等一些比较零散的项目信息。除了直接的项目信息，通过Maven自动生成的站点，以及一些已有的插件，还能够轻松获得项目文档、测试报告、静态分析报告、源码版本、日志报告等非常具有价值的项目信息。</p>
</li>
</ol>
<h3 id="maven命令"><a href="#maven命令" class="headerlink" title="maven命令"></a>maven命令</h3><p>✅常见打包命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true		-- 跳过单测打包</span><br><span class="line">mvn clean install -Dmaven.test.skip=true		-- 跳过单测打包，并把打好的包上传到本地仓库</span><br><span class="line">mvn clean deploy -Dmaven.test.skip=true			-- 跳过单测打包，并把打好的包上传到远程仓库</span><br></pre></td></tr></table></figure>

<p>✅mvn命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn -v //查看版本 </span><br><span class="line">mvn archetype:create //创建 Maven 项目 </span><br><span class="line">mvn compile //编译源代码 </span><br><span class="line">mvn test-compile //编译测试代码 </span><br><span class="line">mvn test //运行应用程序中的单元测试 </span><br><span class="line">mvn site //生成项目相关信息的网站 </span><br><span class="line">mvn package //依据项目生成 jar 文件 </span><br><span class="line">mvn install //在本地 Repository 中安装 jar </span><br><span class="line">mvn -Dmaven.test.skip=true //忽略测试文档编译 </span><br><span class="line">mvn clean //清除目标目录中的生成结果 </span><br><span class="line">mvn clean compile //将.java类编译为.class文件 </span><br><span class="line">mvn clean package //进行打包 </span><br><span class="line">mvn clean test //执行单元测试 </span><br><span class="line">mvn clean deploy //部署到版本仓库 </span><br><span class="line">mvn clean install //使其他项目使用这个jar,会安装到maven本地仓库中 </span><br><span class="line">mvn archetype:generate //创建项目架构 </span><br><span class="line">mvn dependency:list //查看已解析依赖 </span><br><span class="line">mvn dependency:tree com.xx.xxx //看到依赖树 </span><br><span class="line">mvn dependency:analyze //查看依赖的工具 </span><br><span class="line">mvn help:system //从中央仓库下载文件至本地仓库 </span><br><span class="line">mvn help:active-profiles //查看当前激活的profiles </span><br><span class="line">mvn help:all-profiles //查看所有profiles </span><br><span class="line">mvn help:effective -pom //查看完整的pom信息</span><br></pre></td></tr></table></figure>



<h3 id="maven仓库"><a href="#maven仓库" class="headerlink" title="maven仓库"></a>maven仓库</h3><p>maven的依赖管理功能，通过在Pom中指定坐标的形式将jar引入到项目中。jar包就存放在仓库中。</p>
<p>Maven的仓库分为本地仓库和远程仓库。远程仓库分为：中央仓库、私服、其他远程仓库。</p>
<p>当Maven根据坐标寻找构件时，它首先会查看本地仓库，如果本地仓库存在此构件，则直接使用；如果本地仓库不存在此构件，或者需要查看是否有更新的构件版本，Maven会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。</p>
<p>为什么需要私服？</p>
<p>1.一些无法从外部仓库下载的构件，例如内部的项目，可以部署到私服上，以便供其他依赖项目使用。</p>
<p>2.为了节省带宽和时间，在局域网内架设一个私有的仓库服务器，用其代理所有外部的远程仓库。当本地Maven项目需要下载构件时，先去私服请求，如果私服没有，则再去远程仓库请求，从远程仓库下载构件后，把构件缓存在私服上。这样，即使暂时没有Internet链接，由于私服已经缓存了大量构件，整个项目还是可以正常使用的。同时，也降低了中央仓库的负荷。</p>
<p>如果没有私服，我们所需的所有构件都需要通过maven的中央仓库和第三方的Maven仓库下载到本地，而一个团队中的所有人都重复的从maven仓库下载构件无疑加大了仓库的负载和浪费了外网带宽，如果网速慢的话，还会影响项目的进程。很多情况下项目的开发都是在内网进行的，连接不到maven仓库怎么办呢？开发的公共构件怎么让其它项目使用？这个时候我们不得不为自己的团队搭建属于自己的maven私服，这样既节省了网络带宽也会加速项目搭建的进程，当然前提条件就是你的私服中拥有项目所需的所有构件。<br>————————————————</p>
<p>总而言之：私服在用户局域网内的特殊远程仓库，私服起到了maven用户与中央仓库的中间作用，私服从中央仓库缓存构件，maven用户从私服下载构件。</p>
<h3 id="nexus"><a href="#nexus" class="headerlink" title="nexus"></a>nexus</h3><p>nexus就是私服的一种。</p>
<p>nexus是一个强大的maven仓库管理器,它极大的简化了本地内部仓库的维护和外部仓库的访问.</p>
<p>nexus提供了强大的仓库管理功能,构件搜索功能,它基于REST,友好的UI是一个extjs的REST客户端,占用较少的内存,基于简单文件系统而非数据库.</p>
<p>节省外网带宽；加速Maven构建；部署第三方构件；提高稳定性，增强控制；降低中央仓库的负荷；控制和审计；建立本地内部公用仓库。</p>
<p>转载自：<a href="https://www.cnblogs.com/youngdeng/p/15098442.html">https://www.cnblogs.com/youngdeng/p/15098442.html</a></p>
<p>如何配置：<a href="https://www.jianshu.com/p/5b06b2541336">https://www.jianshu.com/p/5b06b2541336</a></p>
<h3 id="配置项目遇到的几个问题"><a href="#配置项目遇到的几个问题" class="headerlink" title="配置项目遇到的几个问题"></a>配置项目遇到的几个问题</h3><p>背景：把之前的包想移动到新创建的一个子包里。</p>
<p>✅父子工程引用的问题</p>
<p>1、Parent怎么能找到childA和childB呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">   &lt;module&gt;childA&lt;/module&gt;</span><br><span class="line">   &lt;module&gt;childB&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>

<p>2、pom”继承”的概念</p>
<p>如果分别去在各自的pom里引用包，就会导致pom文件引入的包重复。<br>父pom写好了，子pom就通过<code>&lt;parent&gt;</code>标签继承父pom的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">   &lt;groupId&gt;com.sang.main&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;Parent-Moduel&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.0.2&lt;/version&gt;</span><br><span class="line">   &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt;  &lt;!--本例中此处是可选的，不是在外层包下的话用--&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>

<p>子pom中引入<code>&lt;parent&gt;</code>标签后，就会从父pom继承<code>&lt;version&gt;</code>等属性了,主pom中把依赖通过<code>&lt;dependecyManagement&gt;</code>引起来，表示子pom可能会用到的jar包依赖，子包引用的话，可以不加version属性，便于统一管理，加了的话表示子包单独用这个版本。</p>
<p>摘自：<a href="https://blog.csdn.net/SunFlowerXT/article/details/105531109">https://blog.csdn.net/SunFlowerXT/article/details/105531109</a></p>
<p>✅Junit找不到的问题，test放在main里，结构限定scope为test</p>
<p>✅class notFound 以及 找不到或无法加载主类</p>
<p>项目结构没有安排明白的原因，点project structure，父包下面的main包和test包下的java包啥的都不作为source和test，resource也不作为reesource。子包下面的模块选好。就可以了。</p>
<p>✅打包时注意</p>
<p>打包时注意：</p>
<p>当mvn仓库里缺少jar包，同时又从中央仓库自动下载不下来的时候，就需要自己下载jar包然后放仓库里了，<br>但是有时候只是简单的把jar和source放仓库的文件夹下，并不管用，这个时候你可以用命令把jar把打进去：<br><code>mvn install:install-file -Dfile=D:\xxx.jar -DgroupId=commons-dbcp -DartifactId= commons-dbcp -Dversion= 1.4 -Dpackaging=jar</code><br>-Dfile 是存在本地磁盘里jar 的路径</p>
<p>✅jar包冲突</p>
<p>mvn dependency:tree命令解决jar包冲突<br>当项目出现jar包冲突时,用命令mvn dependency:tree 查看依赖情况<br>mvn dependency:tree 查看依赖树,查看包结构间的依赖<br>mvn dependency:tree &gt;d:&#x2F;tmp 把结果输出到文件，<br>然后再pom.xml文件里排除掉冲突的jar包</p>
<p>————————————————<br>原文链接：<a href="https://blog.csdn.net/good_good_xiu/article/details/116740333">https://blog.csdn.net/good_good_xiu/article/details/116740333</a></p>
<p>⚠️本地启动项目，有包显红，在maven - root - compile一下。<br>maven中的compile命令是用来将源代码编译成可执行的class文件，或者把它打包成jar文件，以便他人使用。</p>
<p>✅为什么包没有在pom中引入，但是compile编译之后在target文件中却出现了呢。<br>maven会自动寻找依赖并自动加载它们，在某些情况下，即使它们没有在pom文件中显式引入，也会被自动加载到项目中。也有可能其他依赖引入了该包。这些jar包会被编译成class文件，maven把它们放在target目录下，以便正常使用。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>java诊断</title>
    <url>/2022/09/10/myblog/java/java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="java诊断工具arthas"><a href="#java诊断工具arthas" class="headerlink" title="java诊断工具arthas"></a>java诊断工具arthas</h2><h3 id="✅简介"><a href="#✅简介" class="headerlink" title="✅简介"></a>✅简介</h3><p>Arthas 是Alibaba开源的Java诊断工具。安装在系统所在服务器。可以帮助开发人员或者运维人员查找问题，分析性能，bug追踪。</p>
<p>解决问题：<br>1、以全局视角来查看系统的运行状况、健康状况。<br>2、反编译源码，查看jvm加载的是否为预期的文件内容。<br>3、查看某个方法的返回值，参数等等。<br>4、方法内调用路径及各方法调用耗时。<br>5、查看jvm运行状况。<br>6、外部.class文件重新加载到jvm里。<br>等等…..</p>
<p>场景：<br>1）调用接口时，接口返回异常信息，如果该异常信息没有清晰的定位到代码，那么我们通常只能依靠大脑回忆代码，来估计错误发生地了，如果无法估计，一般情况下就会进入测试环境，模拟复现，如果无法复现。<br>2）这个查询，耗时20s，我们想要分析一下到底是哪些代码导致的。但是该方法内部又穿插调用了其它业务功能方法，难道手写System.currentTimeMillis()自己做减运算，还是guava的StopWatch亦或是commons的StopWatch？这几种方式需要我们手动嵌入代码，容易遗漏、费力还费时。<br>等等<br>arthas可以为我们解决上述问题，帮助程序员尽早下班，尽早交代。</p>
<h3 id="✅安装启动"><a href="#✅安装启动" class="headerlink" title="✅安装启动"></a>✅安装启动</h3><p>下载: wget <a href="https://alibaba.github.io/arthas/arthas-boot.jar">https://alibaba.github.io/arthas/arthas-boot.jar</a><br>启动: java -jar arthas-boot.jar</p>
<p>退出arthas<br>quit —— 退出当前 Arthas 客户端，其他 Arthas 客户端不受影响<br>shutdown —— 关闭 Arthas 服务端，所有 Arthas 客户端全部退出 &amp; 重置所有增强过的类，就不用单独调用reset</p>
<h3 id="✅应用"><a href="#✅应用" class="headerlink" title="✅应用"></a>✅应用</h3><p>1、查看某方法耗时</p>
<p><code>trace cn.asae.e.contract.web.ContractController getContract</code></p>
<p>2、显示进程相关信息，仪表盘</p>
<p><code>dashboard</code></p>
<p>3、查看类里某个方法的返回值和入参</p>
<p>命令+类完全限定名+监测方法+表达式<br><code>watch cn.asae.e.contract.web.ContractSubjectController getContractSubjectLogs &quot;&#123;params,returnObj&#125;&quot;</code></p>
<p>4、时空隧道</p>
<p>方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</p>
<p><code>tt -t cn.asae.e.contract.web.ContractSubjectController getContractSubjectLogs</code><br>-t 代表记录下每次方法执行情况</p>
<p>5、查看JVM已加载的类信息</p>
<p><code>sc -d cn.asae.e.contract.web.ContractSubjectController</code></p>
<p>-d 输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的ClassLoader等详细信息。<br>如果一个类被多个ClassLoader所加载，则会出现多次</p>
<p>转自：<a href="https://www.cnblogs.com/jiawen010/p/15513454.html">https://www.cnblogs.com/jiawen010/p/15513454.html</a></p>
<p>其他：<a href="https://blog.csdn.net/weixin_37650458/article/details/123561000">https://blog.csdn.net/weixin_37650458/article/details/123561000</a></p>
<h2 id="fullGC"><a href="#fullGC" class="headerlink" title="fullGC"></a>fullGC</h2><h3 id="✅什么是GC-heap分区"><a href="#✅什么是GC-heap分区" class="headerlink" title="✅什么是GC &amp; heap分区"></a>✅什么是GC &amp; heap分区</h3><p>Java垃圾回收机制，Java通过可达性分析一个对象的引用是否存在，当不存在的时候，将回收堆中的对象。回收无用内存空间</p>
<p>一般而言，GC主要是针对运行的数据区的。作为程序员要关注的区域主要有5块，分别是方法区(Method Area)，Java栈(Java stack)，本地方法栈(Native Method Stack)，堆(Heap)，程序计数器(Program Counter Register)。实际jvm在管理内存的时候，比这个分的更细致，只不过做应用程序开发，我们只需要关注这5块就可以了。</p>
<p>“堆”，也就是Heap了，它是Jvm管理的内存中最大的一块。程序的主要数据也都是存放在堆内存中的，也就是说程序所创建的对象基本上都在该区域进行内存分配，这一块区域被所有的线程所共享，通常出现线程安全问题的一般都是这个区域的数据出现的问题。通常我们所说的gc主要是针对java heap这块区域的。</p>
<p>Heap区在设计上是分代设计的，其划分为了Eden、Survivor 和 Tenured&#x2F;Old ，其中Eden区、Survivor(存活)属于年轻代，Tenured&#x2F;Old区属于老年代或者持久代。</p>
<p>一般我们将年轻代发生的GC称为Minor GC，对老年代进行GC称为Major GC。</p>
<p>而FullGC是对整个堆来说的，在最近几个版本的JDK里默认包括了对永生带即方法区的回收(JDK8中无永生带了)，出现Full GC的时候经常伴随至少一次的Minor GC,但非绝对的。Major GC的速度一般会比Minor GC慢10倍以上。</p>
<hr>
<p>JVM的堆区对象分配的一般规则：</p>
<ol>
<li><p>对象优先在Eden区分配，当eden不够分配时，进行一次minor gc。（java对象大多很快没掉，所以minor gc很频繁）</p>
</li>
<li><p>大对象直接进入老年代(-XX:PretenureSizeThreshold&#x3D;3145728 这个参数来定义多大的对象直接进入老年代)</p>
</li>
<li><p>长期存活的对象将进入老年代(-XX:MaxTenuringThreshold&#x3D;1设置晋升老年代的年龄阈值)</p>
</li>
<li><p>动态对象年龄判定：虚拟机并不会永远地要求对象的年龄都必须达到MaxTenuringThreshold才能晋升老年代，如果Survivor空间中相同年龄的所有对象的大小总和大于Survivor的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</p>
</li>
<li><p>空间分配担保：计算新生代minor gc后剩下的对象若survivor无法容纳，是否能通过老年代来担保分配空间，如果不能，需要触发一次full gc。HandlePromotionFailure&#x3D;false设置是否允许老年代担保。</p>
</li>
<li><p>只要老年代的连续空间大于(新生代所有对象的总大小或者历次晋升的平均大小)就会进行minor GC，否则会进行full GC。</p>
</li>
</ol>
<h3 id="✅FullGC的触发条件"><a href="#✅FullGC的触发条件" class="headerlink" title="✅FullGC的触发条件"></a>✅FullGC的触发条件</h3><p>FullGC是针对整个Heap区而言的，它将在以下几种情况被触发：</p>
<p>1、在程序中调用了System.gc()方法。此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定，但很多情况下它会触发 Full GC,从而增加Full GC的频率，也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过<code>-XX:+ DisableExplicitGC</code>来禁止RMI(Java远程方法调用)调用System.gc。</p>
<p>2、老年代空间不足。老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误【java.lang.OutOfMemoryError: Java heap space】，而为避免以上两种状况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p>
<p>3、Permanet Generation空间满了。也就是以前所说的方法区，Permanet Generation中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC（concurrent mark sweep 标记清除算法）的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出错误信息：java.lang.OutOfMemoryError: PermGen space 。为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p>
<p>4、通过Minor GC后进入老年代的平均大小大于老年代的可用内存。如果发现统计数据说之前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC。由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。分配很大的对象。所谓大对象，是指需要大量连续内存空间的java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC。为了解决这个问题，CMS垃圾收集器提供了一个可配置的参数，即<code>-XX:+UseCMSCompactAtFullCollection</code>开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程，内存整理的过程无法并发的，空间碎片问题没有了，但停顿时间不得不变长了，JVM设计者们还提供了另外一个参数 <code>-XX:CMSFullGCsBeforeCompaction</code>，这个参数用于设置在执行多少次不压缩的Full GC后，跟着来一次带压缩的。</p>
<h3 id="✅分代收集算法"><a href="#✅分代收集算法" class="headerlink" title="✅分代收集算法"></a>✅分代收集算法</h3><p>针对年轻代和老年代，JVM将使用不同的垃圾收集算法进行收集，达到高效的垃圾回收。</p>
<p>1、年轻代采用的是标记-复制算法，将需要回收的对象标记，将不需要的对象移动到Survivor空间，然后将标记对象回收，该算法可以实现对大多数会失效的对象进行回收，对少部分不需要回收的对象进行转移，保证eden区拥有连续的内存空间，而且复制的效率高。</p>
<p>因为在年轻代不需要回收的对象一般是很少的，每次垃圾收集时都有大批对象死去，只有少量存活，选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>2、老年代采用的是标记-整理算法，将需要回收的对象标记，将不需要的对象进行移动整理，使不需要回收的对象占用连续的内存空间，再清除回收对象，保证老年代拥有连续的内存空间，而且整理效率高。</p>
<p>因为在老年代需要回收的对象一般是很少的，其存活率较高、没有额外空间对它进行分配担保。</p>
<p>3、CMS GC（concurrent mark sweep 标记清除算法）老年代中使用：标记所有需要回收的对象，在标记完后统一回收。缺点：标记清除效率不高，产生碎片多。但是并发收集，低停顿。</p>
<p>转自：<a href="https://blog.csdn.net/weixin_35291771/article/details/114075710">https://blog.csdn.net/weixin_35291771/article/details/114075710</a></p>
<p>探秘Java虚拟机——内存管理与垃圾回收：<br><a href="http://www.blogjava.net/chhbjh/archive/2012/01/28/368936.html">http://www.blogjava.net/chhbjh/archive/2012/01/28/368936.html</a></p>
<h3 id="✅什么是fullgc"><a href="#✅什么是fullgc" class="headerlink" title="✅什么是fullgc"></a>✅什么是fullgc</h3><p>一些概念：</p>
<p>GC<br>GC 全称为garbage collection,中文含义为垃圾回收，在jvm中的含义为回收无用内存空间</p>
<p>Young space<br>中文名为年轻代或者新生代，为JVM 堆的一部分，由分代GC概念划分而来，保存生命周期较短的对象</p>
<p>Tenured space<br>中文名为老年代或年老代，为JVM 堆的一部分，由分代GC概念划分而来，保存生命周期较长的对象</p>
<p>Minor GC<br>minor gc指的是发生在年轻代或者说新生代（Young space）中的gc，也有人称其为young gc或者ygc,在下文中我们统一使用minor gc表示</p>
<p>Major GC<br>major gc指的是发生在老年代（Tenured space）中的gc，也有人称为old gc,o gc,cms gc等，在下文我们统一使用major gc表示</p>
<p>stop the world<br>指的是用户线程在运行至安全点（safe point）或安全区域（safe region）之后，就自行挂起，进入暂停状态，对外的表现看起来就像是全世界都停止运转了一样,而不论何种gc算法，不论是minor gc还是major gc都会stop the world，区别只在于stop the world的时间长短。</p>
<p><strong>什么是Full GC</strong></p>
<p>先说一下结论，Full GC这个概念是没有官方定义的，而且含义还特别混乱，在不同地方表达的含义是不同的，需要就不同的场景分别进行讨论。</p>
<p>大众认知上：<br>在通常意义上人们口中说的Full GC为一次特殊GC行为的描述，这次GC会回收整个堆的内存，包含老年代，新生代，metaspace等，这个是最常见的一种认知，很多人也就了解到这个程度，因此在遇到一些特殊场景的时候就会发现实际情况和自己的认知会发生冲突</p>
<p>从GC日志上：<br>在gc.log中会发现在部分gc日志头中也有Full GC这样的字眼，这里表示的含义是在这次GC的全过程中，都是Stop The world的状态，也就是说在这次GC的全过程中所有用户线程都是处于暂停的状态</p>
<p>阿里老哥总结的：<a href="https://blog.csdn.net/kep159/article/details/103088438">https://blog.csdn.net/kep159/article/details/103088438</a></p>
<h3 id="✅jstat查看GC"><a href="#✅jstat查看GC" class="headerlink" title="✅jstat查看GC"></a>✅jstat查看GC</h3><p><strong>使用jstat 查出来的FGC 次数和时间，实际上指的是老年代的收集器发生Stop the world 的次数和持续时间</strong></p>
<p>1、查询GC使用情况：<br><code>jstat -gcutil 23484 1000 5</code></p>
<p>1000是间隔时间，5是总共打印5次，可缺省。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">68.75   0.00  62.73   0.17  96.39  90.54      2    0.010     0    0.000    0.010</span><br><span class="line"></span><br><span class="line">S0: 新生代中Survivor space 0区已使用空间的百分比</span><br><span class="line">S1: 新生代中Survivor space 1区已使用空间的百分比</span><br><span class="line">E: 新生代已使用空间的百分比</span><br><span class="line">O: 老年代已使用空间的百分比</span><br><span class="line">M：元数据区使用比例</span><br><span class="line">CCS：压缩使用比例</span><br><span class="line">YGC: 从应用程序启动到当前，发生Yang GC 的次数</span><br><span class="line">YGCT: 从应用程序启动到当前，Yang GC所用的时间【单位秒】</span><br><span class="line">FGC: 从应用程序启动到当前，发生Full GC的次数</span><br><span class="line">FGCT: 从应用程序启动到当前，Full GC所用的时间</span><br><span class="line">GCT: 从应用程序启动到当前，用于垃圾回收的总时间【单位秒】</span><br></pre></td></tr></table></figure>

<p>2、垃圾总体回收统计<br><code>jstat -gc 91185 1000 5</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"> 68.75   0.00  62.73   0.17  96.39  90.54      2    0.010     0    0.000    0.010</span><br><span class="line"></span><br><span class="line">S0C：第一个幸存区的大小</span><br><span class="line">S1C：第二个幸存区的大小</span><br><span class="line">S0U：第一个幸存区的使用大小</span><br><span class="line">S1U：第二个幸存区的使用大小</span><br><span class="line">EC：伊甸园区的大小</span><br><span class="line">EU：伊甸园区的使用大小</span><br><span class="line">OC：老年代大小</span><br><span class="line">OU：老年代使用大小</span><br><span class="line">MC：方法区大小</span><br><span class="line">MU：方法区使用大小</span><br><span class="line">CCSC:压缩类空间大小</span><br><span class="line">CCSU:压缩类空间使用大小</span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line">YGCT：年轻代垃圾回收消耗时间</span><br><span class="line">FGC：老年代垃圾回收次数</span><br><span class="line">FGCT：老年代垃圾回收消耗时间</span><br><span class="line">GCT：垃圾回收消耗总时间</span><br></pre></td></tr></table></figure>

<p>3、新生代垃圾回收统计<br><code>jstat -gcnew 91185 1000 5</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</span><br><span class="line">5120.0 5120.0 3520.2    0.0  7  15 5120.0  33280.0  20877.8      2    0.010</span><br><span class="line"></span><br><span class="line">S0C：第一个幸存区大小</span><br><span class="line">S1C：第二个幸存区的大小</span><br><span class="line">S0U：第一个幸存区的使用大小</span><br><span class="line">S1U：第二个幸存区的使用大小</span><br><span class="line">TT:对象在新生代存活的次数</span><br><span class="line">MTT:对象在新生代存活的最大次数</span><br><span class="line">DSS:期望的幸存区大小</span><br><span class="line">EC：伊甸园区的大小</span><br><span class="line">EU：伊甸园区的使用大小</span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line">YGCT：年轻代垃圾回收消耗时间</span><br></pre></td></tr></table></figure>

<p>4、堆内存统计<br><code>jstat -gccapacity 18528 1000 5 //整体统计</code><br><code>jstat -gcnewcapacity 18528 1000 5 //新生代统计</code><br><code>jstat -gcoldcapacity 18528 1000 5 //老年代统计</code></p>
<h2 id="java堆栈"><a href="#java堆栈" class="headerlink" title="java堆栈"></a>java堆栈</h2><h3 id="✅java内存空间"><a href="#✅java内存空间" class="headerlink" title="✅java内存空间"></a>✅java内存空间</h3><p>JAVA在程序运行时，在内存中划分5片空间进行数据的存储。分别是：1：程序计数器。2：本地方法栈。3：方法区。4：栈。5：堆。<br>堆和栈都是Java用来在RAM中存放数据的地方</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">程序计数器：线程私有，存储当前线程所执行的字节码行号指示器。</span><br><span class="line">循环、跳转、异常处理、线程恢复等基础功能都依赖该计数器。溢出概率极低。</span><br><span class="line"></span><br><span class="line">java虚拟机栈：线程私有。局部变量表的大小在编译器确定。</span><br><span class="line">方法的相关调用信息、变量信息，对象的引用。</span><br><span class="line">会抛出：StackOverflowError和OutOfMemoryError</span><br><span class="line"></span><br><span class="line">本地方法栈：为本地方法所服务</span><br><span class="line"></span><br><span class="line">java堆：线程共享区域，存储对象实例及数组。有可能抛出OutOfMemoryError</span><br><span class="line"></span><br><span class="line">方法区：线程共享区域，存储已被虚拟机加载的类信息、常量、静态变量，即时变异后的代码。</span><br><span class="line">又叫永久代，java8中逐步取消，被metaspace元数据区取代。有可能抛出OutOfMemoryError</span><br><span class="line"></span><br><span class="line">直接内存：NIO机制，使用Native函数库直接分配堆外内存。</span><br></pre></td></tr></table></figure>

<p>1、堆</p>
<p>可以把堆理解为一家餐厅，里面有200张桌子，也就是最多能同时容纳200桌客人就餐，来一批客人就为他们安排一些桌子，如果某天来的客人特别多，超过200桌了，那就不能再接待超出的客人了。</p>
<p>当然，进来吃饭的客人不可能是同时的，有的早，有的晚，先吃好的客人，老板会安排给他们结账走人，然后空出来的桌子又能接待新的客人。</p>
<p>这里，堆就是餐厅，最大容量200桌就是堆内存的大小，老板就相当于GC(垃圾回收)，给客人安排桌子就相当于java创建对象的时候分配堆内存，结账就相当于GC回收对象占用的空间。</p>
<p>2、栈</p>
<p>接着把栈比作一口废井，这口井多年不用已经没水了，主人现在把它作为贮存自酿酒的地方，存酒的时候就用绳子勾着酒坛子慢慢放下去，后面再存就一坛一坛堆着放上去，取酒的时候就先取最上面的坛子。</p>
<h3 id="✅什么时候存到堆Heap里"><a href="#✅什么时候存到堆Heap里" class="headerlink" title="✅什么时候存到堆Heap里"></a>✅什么时候存到堆Heap里</h3><p>存放：存放由new创建的对象和数组。</p>
<p>在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，会在栈中定义一个引用变量，这个变量的取值等于数组或者对象在堆内存中的首地址，引用变量相当于为数组或者对象起的一个别名，或者代号。</p>
<p>数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针!</p>
<p>堆内存的特点是什么？<br>第一点：堆其实可以类似的看做是管道，或者说是平时去排队买票的情况差不多，所以堆内存的特点就是：先进先出，后进后出，也就是你先排队好，你先买票。<br>第二点：堆可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，但缺点是，由于要在运行时动态分配内存，存取速度较慢。<br>new对象在堆中如何分配？<br>由Java虚拟机的自动垃圾回收器来管理。</p>
<h3 id="✅什么时候存到栈Stack里"><a href="#✅什么时候存到栈Stack里" class="headerlink" title="✅什么时候存到栈Stack里"></a>✅什么时候存到栈Stack里</h3><p>存放：在函数中定义的一些基本类型的变量(8种，int, short, long, byte, float, double, boolean, char，不包含String)和对象的引用变量、main方法、方法函数</p>
<p>当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。</p>
<p>栈内存的特点<br>第一点：栈内存就好像一个矿泉水瓶，往里面放入东西，那么先放入的沉入底部，所以它的特点是：先进后出，后进先出<br>第二点：存取速度比堆要快，仅次于寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。</p>
<p>栈中主要存放一些基本类型的变量（int, short, long, byte, float, double, boolean, char）和对象句柄。<br>栈内存分配机制<br>栈内存可以称为一级缓存，由垃圾回收器自动回收<br>例子：<br>int a &#x3D; 3;<br>int b &#x3D; 3;</p>
<h3 id="✅堆栈的区别"><a href="#✅堆栈的区别" class="headerlink" title="✅堆栈的区别"></a>✅堆栈的区别</h3><p>JVM是基于堆栈的虚拟机，JVM为新创建的线程都分配一个堆栈，也就是说，对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作：以帧为单位的压栈和出栈操作。</p>
<p>差异：<br>1). 堆内存用来存放由new创建的对象和数组<br>2). 栈内存用来存放方法或者局部变量等<br>3). 堆是先进先出，后进后出<br>4). 栈是先进后出，后进先出<br>5). 共享性的不同：栈内存是线程私有的，<strong>堆内存是所有线程共有的</strong><br>6). 生存空间不同：栈中数据的生存空间一般在当前scopes内(就是由{…}括起来的区域).</p>
<p>栈：</p>
<p>函数中定义的基本类型变量，对象的引用变量都在函数的栈内存中分配。<br>栈内存特点，数数据一执行完毕，变量会立即释放，节约内存空间。<br>栈内存中的数据，没有默认初始化值，需要手动设置。</p>
<p>堆：</p>
<p>堆内存用来存放new创建的对象和数组。<br>堆内存中所有的实体都有内存地址值。<br>堆内存中的实体是用来封装数据的，这些数据都有默认初始化值。<br>堆内存中的实体不再被指向时，JVM启动垃圾回收机制，自动清除，这也是JAVA优于C++的表现之一（C++中需要程序员手动清除）</p>
<h3 id="✅String-str-“abc”的内部工作"><a href="#✅String-str-“abc”的内部工作" class="headerlink" title="✅String str &#x3D; “abc”的内部工作"></a>✅String str &#x3D; “abc”的内部工作</h3><p>(1)先定义一个名为str的对String类的对象引用变量：String str；</p>
<p>(2)在栈中查找有没有存放值为”abc”的地址（引用），如果没有，则在栈中开辟一个存放字面值为”abc”的地址，接着在堆中创建一个新的String类的对象“abc”，并将该字符串指向这个地址，而且在栈中这个地址旁边记下这个引用的对象“abc”。如果已经有了值为”abc”的地址，则查找对象“abc”，并返回“abc”的地址。</p>
<p>(3)将str指向对象“abc”的地址。</p>
<p>值得注意的是，一般String类中字符串值都是直接存值的。但像String str &#x3D; “abc”；这种场合下，其字符串值却是保存了一个指向存在栈中数据的引用！<br><strong>（有点问题，指向的是堆中的字符串常量池里的字符串吧？？）</strong></p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str1 = “abc”;  </span><br><span class="line">String str2 = “abc”;  </span><br><span class="line">System.out.println(str1==str2); //true</span><br></pre></td></tr></table></figure>

<p>str1.equals(str2)；的方式是将比较两个字符串的值是否相等。&#x3D;&#x3D;号，根据JDK的说明，只有在两个引用都指向了同一个对象时才返回真值。而我们在这里要看的是，str1与str2是否都指向了同一个对象。<br>结果说明，JVM创建了两个引用str1和str2，但只创建了一个对象，而且两个引用都指向了这个对象。实现堆中数据的共享。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str1 = “abc”;  </span><br><span class="line">String str2 = “abc”;  //没创建新对象，创建了一个新引用变量</span><br><span class="line">str1 = “bcd”;   //改变值，只能创建一个新对象，引用变量指向新的对象</span><br><span class="line">System.out.println(str1 + “,” + str2); //bcd, abc  </span><br><span class="line">System.out.println(str1==str2); //false</span><br></pre></td></tr></table></figure>

<p>赋值的变化导致了类对象引用的变化，str1指向了另外一个新对象！而str2仍旧指向原来的对象。上例中，当我们将str1的值改为”bcd”时，JVM发现在栈中没有存放该值的地址，便开辟了这个地址，并创建了一个新的对象，其字符串的值指向这个地址。</p>
<p>💡原因：事实上，String类被设计成为不可改变(immutable)的类。如果你要改变其值，可以，但JVM在运行时根据新值悄悄创建了一个新对象，然后将这个对象的地址返回给原来类的引用。这个创建过程虽说是完全自动进行的，但它毕竟占用了更多的时间。在对时间要求比较敏感的环境中，会带有一定的不良影响。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str1 = new String(“abc”);</span><br><span class="line">String str2 = “abc”;</span><br><span class="line">System.out.println(str1==str2); //false</span><br></pre></td></tr></table></figure>

<p>💡原因：只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享。<br><strong>（与字符串常量池共享吧？）</strong></p>
<p><strong>意思是：String str &#x3D; “abc” 的创建对象方式，会在栈中保存“abc”。（字符串常量池中吧？）如果多次这样创建一个值的String对象，会先去栈里看有没有，如果有，堆里就不新建对象了，栈里新建一个引用变量指向那个对象，如果没有就新建，但是new方式不会看，都是新建。</strong></p>
<p>结论：</p>
<p>(1)我们在使用诸如String str &#x3D; “abc”; 的格式定义类时，总是想当然地认为，我们创建了String类的对象str。担心陷阱！对象可能并没有被创建！唯一可以肯定的是，指向String类的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑，除非你通过new()方法来显要地创建一个新的对象。因此，更为准确的说法是，我们创建了一个指向String类的对象的引用变量str，这个对象引用变量指向了某个值为”abc”的String对象。</p>
<p>(2)使用String str &#x3D; “abc”; 的方式，可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str &#x3D; new String(“abc”); 的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。这个思想应该是享元模式的思想，但JDK的内部在这里实现是否应用了这个模式，不得而知。</p>
<p>(3)当比较包装类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用&#x3D;&#x3D;。</p>
<p>(4)由于String类的不可改变immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。</p>
<p>参考：<br>程序中堆栈空间加载过程：<a href="https://www.jb51.net/article/229958.htm">https://www.jb51.net/article/229958.htm</a><br>堆栈区别、String创建过程：<a href="https://zhuanlan.zhihu.com/p/529280783">https://zhuanlan.zhihu.com/p/529280783</a></p>
<h3 id="String不可变怎么理解"><a href="#String不可变怎么理解" class="headerlink" title="String不可变怎么理解"></a>String不可变怎么理解</h3><p>看了一圈优点模糊，主要几个疑问：<br>1、<code>String s = &quot;abc&quot;;</code>，到底怎么个流程，已有的字符串怎么找到的。<br>2、字符串常量池在哪里存的。初步结论是java8在堆中。<br>3、运行时常量池和字符串常量池？</p>
<p><strong>看看jvm虚拟机再解惑吧</strong></p>
<p>string类为什么是不可变的：<br><a href="https://blog.csdn.net/liuqinhou/article/details/126160186">https://blog.csdn.net/liuqinhou/article/details/126160186</a></p>
<p>String源码角度分析为什么不可变，通过反射的方法改变：<br><a href="https://blog.csdn.net/zhangjg_blog/article/details/18319521">https://blog.csdn.net/zhangjg_blog/article/details/18319521</a></p>
<p>浅谈为什么Java里面String类是不可变的：<br><a href="https://www.jb51.net/article/157814.htm">https://www.jb51.net/article/157814.htm</a></p>
<p>String是如何实现其对象不可变：<br><a href="https://zhuanlan.zhihu.com/p/498718374">https://zhuanlan.zhihu.com/p/498718374</a></p>
<p>Java 常量池详解（一）字符串常量池：<br><a href="https://blog.csdn.net/Prior_SX/article/details/123463430">https://blog.csdn.net/Prior_SX/article/details/123463430</a></p>
<p>字符串常量池和运行时常量池是在堆还是在方法区？<br><a href="https://www.cnblogs.com/cosmos-wong/p/12925299.html">https://www.cnblogs.com/cosmos-wong/p/12925299.html</a></p>
<p>Java8中字符串常量池到底是在哪里：<br><a href="https://blog.51cto.com/u_14234228/2489846">https://blog.51cto.com/u_14234228/2489846</a></p>
<h3 id="✅堆内存共享性问题"><a href="#✅堆内存共享性问题" class="headerlink" title="✅堆内存共享性问题"></a>✅堆内存共享性问题</h3><p>问题来源：既然各个java进程共享堆内存，那么看fullgc的情况跟哪个进程线程有什么关系呢？</p>
<p>没错，堆是全局共享的，但是会存在一些问题</p>
<p>就是多个线程在堆上同时申请空间，如果在并发的场景中，两个线程先后把对象引用指向了同一个堆的内存区域，那可能就会出现问题；为了解决这个问题呢，就得进行同步控制，说到同步控制，就会影响到效率。</p>
<p>为了解决这个并发问题，对象的内存分配过程就必须进行同步控制。<br>HotSpot虚拟机（HotSpot虚拟机是目前最流行的虚拟机）的方案：<br>每个线程在Java堆中预先分配一小块内存，然后在给对象分配内存的时候，直接在自己这块”私有”内存中分配，当这部分区域用完之后，再分配新的”私有”内存。<br>这种方案被称之为TLAB分配，即Thread Local Allocation Buffer。这部分Buffer是从堆中划分出来的，但是是本地线程独享的。</p>
<p><strong>TLAB</strong></p>
<p>TLAB是虚拟机在堆内存的eden划分出来的一块专用空间，是<strong>线程专属</strong>的。在虚拟机的TLAB功能启动的情况下，在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，<strong>只给当前线程使用</strong>，这样<strong>每个线程都单独拥有一个空间</strong>，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。</p>
<p><strong>所以说，因为有了TLAB技术，堆内存并不是完完全全的线程共享，其eden区域中还是有一部分空间是分配给线程独享的。</strong></p>
<p>⚠️TLAB是线程独享的，但是只是在“分配”这个动作上是线程独享的，至于在读取、垃圾回收等动作上都是线程共享的。而且在使用上也没有什么区别。也就是说，虽然每个线程在初始化时都会去堆内存中申请一块TLAB，并不是说这个TLAB区域的内存其他线程就完全无法访问了，其他线程的读取还是可以的，只不过无法在这个区域中分配内存而已。并且，在TLAB分配之后，并不影响对象的移动和回收，也就是说，虽然对象刚开始可能通过TLAB分配内存，存放在Eden区，但是还是会被垃圾回收或者被移到Survivor Space、Old Gen等。</p>
<p>⚠️TLAB带来的问题：<br>TLAB是在eden区分配的，因为eden区域本身就不太大，而且TLAB空间的内存也非常小，默认情况下仅占有整个Eden空间的1%。所以，必然存在一些大对象是无法在TLAB直接分配。<br>遇到TLAB中无法分配的大对象，对象还是可能在eden区或者老年代等进行分配的，但是这种分配就需要进行同步控制，这也是为什么我们经常说：小的对象比大的对象分配起来更加高效。<br>————————————————<br>为了解决这两个方案存在的问题，虚拟机定义了一个refill_waste的值，这个值可以翻译为“最大浪费空间”。</p>
<p>当请求分配的内存大于refill_waste的时候，会选择在堆内存中分配。若小于refill_waste值，则会废弃当前TLAB，重新创建TLAB进行对象内存分配。</p>
<p>总结：<br>为了保证对象的内存分配过程中的线程安全性，HotSpot虚拟机提供了一种叫做TLAB(Thread Local Allocation Buffer)的技术。</p>
<p>在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，只给当前线程使用，当需要分配内存时，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。</p>
<p>所以，“堆是线程共享的内存区域”这句话并不完全正确，因为TLAB是堆内存的一部分，他在读取上确实是线程共享的，但是在内存分配上，是线程独享的。</p>
<p>TLAB的空间其实并不大，所以大对象还是可能需要在堆内存中直接分配。那么，对象的内存分配步骤就是先尝试TLAB分配，空间不足之后，再判断是否应该直接进入老年代，然后再确定是再eden分配还是在老年代分配。<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/jiey0407/article/details/125190629">https://blog.csdn.net/jiey0407/article/details/125190629</a></p>
<h2 id="jvm性能监控工具"><a href="#jvm性能监控工具" class="headerlink" title="jvm性能监控工具"></a>jvm性能监控工具</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>java virtual machine process status tool<br>jps 主要用来输出 JVM 中运行的进程状态信息</p>
<p>语法格式：<code>jps [options] [hostid]</code><br>如果不指定 hostid 就默认为当前主机或服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-q 不输出类名、Jar名和传入main方法的参数</span><br><span class="line">-m 输出传入main方法的参数</span><br><span class="line">-l 输出main类或Jar的全限名</span><br><span class="line">-v 输出传入JVM的参数</span><br></pre></td></tr></table></figure>

<p>jps命令获取实际的进程id，是去用户的临时目录下去拿进程id的。<br>文件路径：&#x2F;tmp&#x2F;hsperfdata_{userName}&#x2F;，存储了当前用户的进程信息。</p>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>stack trace for java 显示虚拟机的线程快照。<br>jstack 主要用来查看某个 Java 进程内的线程堆栈信息。</p>
<p>语法格式：<code>jstack [option] pid</code><br>如果是在64位机器上，需要指定选项”-J-d64”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-l long listings，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况</span><br><span class="line">-m mixed mode，不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）</span><br></pre></td></tr></table></figure>

<p>jstack 可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在 JVM 性能调优中使用得非常多。例如：找出某个 Java 进程中最耗费 CPU 的 Java 线程并定位堆栈信息。</p>
<p>第一步先找出 Java 进程 ID<br><code>ps -ef | grep 应用 | grep -v grep</code></p>
<p>第二步找出该进程内最耗费 CPU 的线程<br>可以使用 <code>ps -Lfp pid </code>或者 <code>ps -mp pid -o THREAD, tid, time</code> 或者 <code>top -Hp pid</code> .【有没有可以输出按时间排序的，且区分daemon的】</p>
<p>使用<code>printf &quot;%x\n&quot; 线程id</code> 将线程id转换为16进制值。</p>
<p><code>jstack 进程id | grep 16进制线程id</code><br>从而定位代码，可能是哪里wait时间长了。</p>
<p><code>jstack -l 进程id 查看进程下所有线程</code></p>
<hr>
<p>jstack打印的信息怎么看：<br>dump 文件里，值得关注的线程状态有：<br>死锁，Deadlock（重点关注）<br>执行中，Runnable<br>等待资源，Waiting on condition（重点关注）<br>等待获取监视器，Waiting on monitor entry（重点关注）<br>暂停，Suspended<br>对象等待中，Object.wait() 或 TIMED_WAITING<br>阻塞，Blocked（重点关注）<br>停止，Parked</p>
<hr>
<p><strong>实例一：Waiting to lock 和 Blocked</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;RMI TCP Connection(267865)-172.16.5.25&quot; daemon prio=10 tid=0x00007fd508371000 nid=0x55ae waiting for monitor entry [0x00007fd4f8684000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at org.apache.log4j.Category.callAppenders(Category.java:201)</span><br><span class="line">- waiting to lock &lt;0x00000000acf4d0c0&gt; (a org.apache.log4j.Logger)</span><br><span class="line">at org.apache.log4j.Category.forcedLog(Category.java:388)</span><br><span class="line">at org.apache.log4j.Category.log(Category.java:853)</span><br><span class="line">at org.apache.commons.logging.impl.Log4JLogger.warn(Log4JLogger.java:234)</span><br><span class="line">at com.tuan.core.common.lang.cache.remote.SpyMemcachedClient.get(SpyMemcachedClient.java:110)</span><br></pre></td></tr></table></figure>

<p>说明：<br>1）线程状态是 Blocked，阻塞状态。说明线程等待资源超时！<br>2）“ waiting to lock &lt;0x00000000acf4d0c0&gt;”指，线程在等待给这个 0x00000000acf4d0c0 地址上锁（英文可描述为：trying to obtain  0x00000000acf4d0c0 lock）。<br>3）在 dump 日志里查找字符串 0x00000000acf4d0c0，发现有大量线程都在等待给这个地址上锁。如果能在日志里找到谁获得了这个锁（如locked &lt; 0x00000000acf4d0c0 &gt;），就可以顺藤摸瓜了。<br>4）“waiting for monitor entry”说明此线程通过 synchronized(obj) {……} 申请进入了临界区，从而进入了下图1中的“Entry Set”队列，但该 obj 对应的 monitor 被其他线程拥有，所以本线程在 Entry Set 队列中等待。<br>5）第一行里，”RMI TCP Connection(267865)-172.16.5.25”是 Thread Name 。tid指Java Thread id。nid指native线程的id。prio是线程优先级。[0x00007fd4f8684000]是线程栈起始地址。</p>
<hr>
<p><strong>实例二：Waiting on condition 和 TIMED_WAITING</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;RMI TCP Connection(idle)&quot; daemon prio=10 tid=0x00007fd50834e800 nid=0x56b2 waiting on condition [0x00007fd4f1a59000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x00000000acd84de8&gt; (a java.util.concurrent.SynchronousQueue$TransferStack)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198)</span><br><span class="line">at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:424)</span><br><span class="line">at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:323)</span><br><span class="line">at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:874)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:945)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)</span><br><span class="line">at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>1）“TIMED_WAITING (parking)”中的 timed_waiting 指等待状态，但这里指定了时间，到达指定的时间后自动退出等待状态；parking指线程处于挂起中。</p>
<p>2）“waiting on condition”需要与堆栈中的“parking to wait for  &lt;0x00000000acd84de8&gt; (a java.util.concurrent.SynchronousQueue$TransferStack)”结合来看。首先，本线程肯定是在等待某个条件的发生，来把自己唤醒。其次，SynchronousQueue 并不是一个队列，只是线程之间移交信息的机制，当我们把一个元素放入到 SynchronousQueue 中时必须有另一个线程正在等待接受移交的任务，因此这就是本线程在等待的条件。<br>3）别的就看不出来了。</p>
<hr>
<p><strong>实例三：in Obejct.wait() 和 TIMED_WAITING</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;RMI RenewClean-[172.16.5.19:28475]&quot; daemon prio=10 tid=0x0000000041428800 nid=0xb09 in Object.wait() [0x00007f34f4bd0000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;0x00000000aa672478&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:118)</span><br><span class="line">- locked &lt;0x00000000aa672478&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at sun.rmi.transport.DGCClient$EndpointEntry$RenewCleanThread.run(DGCClient.java:516)</span><br><span class="line">at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>1）“TIMED_WAITING (on object monitor)”，对于本例而言，是因为本线程调用了 java.lang.Object.wait(long timeout) 而进入等待状态。</p>
<p>2）“Wait Set”中等待的线程状态就是“ in Object.wait() ”。当线程获得了 Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被 synchronized 的对象）的 wait() 方法，放弃了 Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify() 或者 notifyAll() ，“ Wait Set”队列中线程才得到机会去竞争，但是只有一个线程获得对象的 Monitor，恢复到运行态。</p>
<p>3）RMI RenewClean 是 DGCClient 的一部分。DGC 指的是 Distributed GC，即分布式垃圾回收。</p>
<p>4）请注意，是先 locked &lt;0x00000000aa672478&gt;，后 waiting on &lt;0x00000000aa672478&gt;，之所以先锁再等同一个对象，请看下面它的代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static private class  Lock &#123; &#125;;</span><br><span class="line">private Lock lock = new Lock();</span><br><span class="line">public Reference&lt;? extends T&gt; remove(long timeout)</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        Reference&lt;? extends T&gt; r = reallyPoll();</span><br><span class="line">        if (r != null) return r;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            lock.wait(timeout);</span><br><span class="line">            r = reallyPoll();</span><br><span class="line">            ……</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即，线程的执行中，先用 synchronized 获得了这个对象的 Monitor（对应于  locked &lt;0x00000000aa672478&gt; ）；当执行到 lock.wait(timeout);，线程就放弃了 Monitor 的所有权，进入“Wait Set”队列（对应于  waiting on &lt;0x00000000aa672478&gt; ）。<br>5）从堆栈信息看，是正在清理 remote references to remote objects ，引用的租约到了，分布式垃圾回收在逐一清理呢。</p>
<p>转自：<a href="https://www.cnblogs.com/nexiyi/p/java_thread_jstack.html">https://www.cnblogs.com/nexiyi/p/java_thread_jstack.html</a></p>
<h3 id="jmap和jhat"><a href="#jmap和jhat" class="headerlink" title="jmap和jhat"></a>jmap和jhat</h3><p>jmap（Memory Map）和jhat（Java Heap Analysis Tool）</p>
<p>jmap用来查看<strong>堆内存</strong>使用状况，一般结合jhat使用。<br>jmap语法格式：<code>jmap [option] pid</code>  pid为进程id</p>
<p>打印进程的类加载器和类加载器加载的持久代对象信息，输出：类加载器名称、对象是否存活（不可靠）、对象地址、父类加载器、已加载的类大小等信息</p>
<p>使用<strong>jmap -heap pid</strong>查看进程堆内存使用情况，包括使用的GC算法、堆配置参数和各代中堆内存使用情况。</p>
<p>使用<code>jmap -histo pid</code> &#x2F; <code>jmap -histo:live pid</code>查看堆内存中的对象数目、大小统计直方图，如果带上live则只统计活对象.<br>加上<code>| more</code> 按类别统计</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmap -histo:live 21711 | more </span><br><span class="line">num     #instances         #bytes  class name------------</span><br><span class="line">   1:         38445        5597736  &lt;constMethodKlass&gt;</span><br><span class="line">   2:         38445        5237288  &lt;methodKlass&gt;</span><br><span class="line"></span><br><span class="line">class name是对象类型</span><br></pre></td></tr></table></figure>

<p>还有一个很常用的情况是：用jmap把进程内存使用情况dump到文件中，再用jhat分析查看。jmap进行dump命令格式如下：<code>jmap -dump:format=b,file=dumpFileName pid</code></p>
<p>例如：<code>jmap -dump:format=b,file=/tmp/dump.dat 进程id</code></p>
<p>dump.dat文件很大。<br>dump出来的文件可以用MAT、VisualVM等工具查看，这里用jhat查看：<code>jhat -port 9998 /tmp/dump.dat</code><br>然后就可以在浏览器中输入主机地址：9998 查看了。##### ###</p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>JVM统计监测工具<br>jvm statistics monitoring tool：用于收集虚拟机各方面的运行数据。</p>
<p>语法格式：<code>jstat [ generalOption | outputOptions vmid [interval[s|ms] [count]] ]</code></p>
<p>vmid是Java虚拟机ID，在Linux&#x2F;Unix系统上一般就是进程ID。interval是采样时间间隔。count是采样数目。 例如：<code>jstat -gc 进程id 250 4</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jstat -gc 21711 250 4 </span><br><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">192.0  192.0   64.0   0.0    6144.0   1854.9   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</span><br><span class="line">192.0  192.0   64.0   0.0    6144.0   1972.2   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</span><br><span class="line"></span><br><span class="line">S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）</span><br><span class="line">运行以来，总耗时，单位s</span><br><span class="line">EC、EU：Eden区容量和使用量</span><br><span class="line">OC、OU：年老代容量和使用量</span><br><span class="line">PC、PU：永久代容量和使用量</span><br><span class="line">YGC、YGT：年轻代GC次数和GC耗时</span><br><span class="line">FGC、FGCT：Full GC次数和Full GC耗时</span><br><span class="line">GCT：GC总耗时</span><br></pre></td></tr></table></figure>

<p>JVM堆内存布局：<br>堆内存 &#x3D; 年轻代 + 年老代 + 永久代<br>年轻代 &#x3D; Eden区 + 两个Survivor区（From和To）</p>
<p><code>jstat -gcutil 23484 1000 5</code> 监视内容基本与gc相同，但输出的主要是已占用的总空间的百分比。</p>
<p><code>jstat -gccause 23484 1000 5</code> 查询gc的原因。</p>
<h3 id="hprof"><a href="#hprof" class="headerlink" title="hprof"></a>hprof</h3><p>（Heap&#x2F;CPU Profiling Tool）<br>hprof能够展现CPU使用率，统计堆内存使用情况。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -agentlib:hprof[=options] ToBeProfiledClass</span><br><span class="line">java -Xrunprof[:options] ToBeProfiledClass</span><br><span class="line">javac -J-agentlib:hprof[=options] ToBeProfiledClass</span><br></pre></td></tr></table></figure>

<p>例如：<code>java -agentlib:hprof=cpu=samples,interval=20,depth=3 主类</code><br>每隔20毫秒采样CPU消耗信息，堆栈深度为3，生成的profile文件名称是java.hprof.txt，在当前目录。</p>
<p>例如：<code>javac -J-agentlib:hprof=cpu=times Hello.java</code><br>能够获得更加细粒度的CPU消耗信息，能够细到每个方法调用的开始和结束，它的实现使用了字节码注入技术（BCI）。</p>
<p>JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解：<a href="https://zhuanlan.zhihu.com/p/294950372?utm_medium=social&utm_oi=690843302169178112">https://zhuanlan.zhihu.com/p/294950372?utm_medium=social&amp;utm_oi=690843302169178112</a></p>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>虚拟机配置信息，<code>jinfo 进程id</code></p>
<h3 id="图像化界面分析工具"><a href="#图像化界面分析工具" class="headerlink" title="图像化界面分析工具"></a>图像化界面分析工具</h3><p>VisualVM、JProfile、MAT</p>
<h2 id="几种排查思路"><a href="#几种排查思路" class="headerlink" title="几种排查思路"></a>几种排查思路</h2><h3 id="线程cpu占用高"><a href="#线程cpu占用高" class="headerlink" title="线程cpu占用高"></a>线程cpu占用高</h3><p>1.<code>ps -ef|grep java</code> 或者 jps 查找出进程id<br>2.<code>top -Hp 进程id</code> 查找出最耗cpu的线程id <code>top -c</code>看进程的<br>3.<code>printf &quot;%x\n&quot;</code> 线程id  转换为16进制的id<br>4.使用<code>jstack 进程id | grep 16进制线程id</code>  查找出堆栈信息，分析</p>
<p>另外，arthas也可以打印出前多少个线程及占有cpu情况<br><code>thread -n 5</code></p>
<h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><p>除了程序计数器，其他内存存储都可能OOM。<br>有可能：数据量大、JVM内存容量参数分配不合理、代码bug死循环无限分配容量<br>1、内存泄露，对象已经死了，无法通过垃圾收集器进行自动回收，通过找出泄露的代码位置和原因，才好确定解决方案；<br>2、内存溢出，内存中的对象都还必须存活着，这说明Java堆分配空间不足，检查堆设置大小（-Xmx与-Xms），检查代码是否存在对象生命周期太长、持有状态时间过长的情况。</p>
<p>1.先使用jmap看一下堆内存使用情况<br>2.<code>jmap -dump:format=b,file=/tmp/dump.dat 进程id</code> dump文件<br>3.使用MAT工具分析<br>mat工具的使用：<a href="https://developer.aliyun.com/article/44641">https://developer.aliyun.com/article/44641</a></p>
<h3 id="full-gc"><a href="#full-gc" class="headerlink" title="full gc"></a>full gc</h3><p>1.<code>jstat -gcutil 进程id 1000 40</code>查看gc情况，1s一次，40次动态看gc增长<br>2.找到gc.log<br>里面有gc前堆使用空间&gt;gc后堆已使用空间，还有用户态消耗的cpu时间、内核态消耗的cpu时间、操作从开始到结束经过的时间。</p>
<p>模拟gc看日志：<br><a href="https://javastack.blog.csdn.net/article/details/109006521">https://javastack.blog.csdn.net/article/details/109006521</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis实战</title>
    <url>/2022/06/02/myblog/java/mybatis%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>1、mybatis <code>&lt;if&gt;</code> 标签不是必须在<code>&lt;where&gt;</code>标签下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table</span><br><span class="line">&lt;where&gt;</span><br><span class="line">    &lt;if test=&quot;uis != null&quot;&gt;</span><br><span class="line">        uid = #&#123;uid&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">where status = 0</span><br><span class="line">&lt;if test=&quot;uis != null&quot;&gt;</span><br><span class="line">    and uid = #&#123;uid&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">&lt;if test=&quot;uis != null&quot;&gt;</span><br><span class="line">    where uid = #&#123;uid&#125;</span><br><span class="line">&lt;/if&gt;</span><br></pre></td></tr></table></figure>

<p>2、mybatis中，<code>select * from in &lt;foreach&gt; #&#123;list&#125;</code>，中的list不能是空，不能为null，会报错。</p>
<p>3、mybatis查出的结果是list，如果结果是一条都没有，那么返回的是空list，而不是null。</p>
<p>4、mybatis sum 如果没有记录，返回的是null，所以要注意mybatis返回结果都用包装类型来接。</p>
<p>5.mybatis查出的Date类型，是毫秒时间戳，可以用String接Date类型，只不过是：2023-01-01 11:11:11.1，所以得用.substring(0,19)，注意该方法string是null不行，位数不够也会报错。</p>
<p>6.mybatis来select，in一个list，如果传入的list是null或者空会报错。<br>null会报错：org.mybatis.spring.MybatisSystemException<br>空list会error sql<br>如果加了<code>&lt;where&gt;</code>标签和<code>&lt;if&gt;</code>标签，会导出所有的。<br><code>&lt;if test=&quot;list != null and list.size() &gt; 0&quot;&gt;</code></p>
<h3 id="mybatis-error"><a href="#mybatis-error" class="headerlink" title="mybatis error"></a>mybatis error</h3><h4 id="✅Mybatis-Exception-Translator-translateExceptionIfPossible"><a href="#✅Mybatis-Exception-Translator-translateExceptionIfPossible" class="headerlink" title="✅Mybatis Exception Translator.translateExceptionIfPossible"></a>✅Mybatis Exception Translator.translateExceptionIfPossible</h4><p>原因：插入时找不到参数，批量插入时传的list为空也会报此问题。</p>
<h3 id="resultMap和resultType"><a href="#resultMap和resultType" class="headerlink" title="resultMap和resultType"></a>resultMap和resultType</h3><p>ResultType和ResultMap都是执行查询语句时返回的结果集。<br>ResultType相对与ResultMap而言更简单一点。只有满足ORM（Object Relational Mapping，对象关系映射）时，即数据库表中的字段名和实体类中的属性完全一致时，才能使用，否则会出现数据不显示的情况。<br>ResultMap和ResultType的功能类似，但是ResultMap更强大一点，ResultMap可以实现将查询结果映射为复杂类型的pojo。</p>
<h4 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h4><p>1.java的基础类型及其包装类int,double和java.lang.Integer,java.lang.Double等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回值为int，resultType为int ,java.lang.Integer也可以--&gt;</span><br><span class="line">&lt;select id=&quot;countUser&quot; resultType=&quot;int&quot;&gt;</span><br><span class="line">    select count(*) from user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>2.自己定义的实体类,实体类和数据库字段需要一致，如果不一致需要使用resulMap自定义map，也可以直接使用map。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回值为实体类，resultType为User--&gt;</span><br><span class="line">&lt;select id=&quot;getUser&quot; resultType=&quot;com.entity.User&quot;&gt;</span><br><span class="line">   select * from User where id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>3.map类型，Dao层的返回类型为<code>Map&lt;String, Object&gt;</code>，key是对应的column值，value是数据中的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 返回值为Map&lt;String,Object&gt;，resultType为map--&gt;</span><br><span class="line">&lt;select id=&quot;getUserSelective&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">    select name,address,salary from User where id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>4.List集合，其中该集合的类型可以为1,2,3中提到的类型。Dao层的返回类型为<code>List&lt;User&gt;</code>，这里只展示了实体类集合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回值为List&lt;User&gt;，resultType为User--&gt;</span><br><span class="line">&lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h4 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h4><p>结果集的映射是 MyBatis 最强大的特性,通过使用resultMap或resultType可以解决复杂映射问题。基础简单的使用resultType就可以了，但是如果出现table中列和实体类中的属性不一致或者多表级联。那么这时resultMap就可以发挥作用了。</p>
<p>TestDao.xml:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;com.repository.TestDao&quot;&gt;</span><br><span class="line">    //定义映射</span><br><span class="line">    &lt;resultMap id=&quot;TestResultMap&quot; type=&quot;com.entity.TestDO&quot;&gt;</span><br><span class="line">        &lt;result column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt;</span><br><span class="line">        &lt;result column=&quot;name&quot; property=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; /&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    //定义返回栏目</span><br><span class="line">    &lt;sql id=&quot;all_colum_without_id&quot;&gt;</span><br><span class="line">        name</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    &lt;sql id=&quot;all_colum&quot;&gt;</span><br><span class="line">        name,&lt;include refid=&quot;all_colum_without_id&quot;/&gt;</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    //插入语句</span><br><span class="line">    &lt;insert id=&quot;insertOne&quot; parameterType=&quot;com.entity.TestDO&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span><br><span class="line">        insert into table (&lt;include refid=&quot;all_colum_without_id&quot;/&gt;)</span><br><span class="line">        values (#&#123;name&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    //批量插入</span><br><span class="line">    &lt;insert id=&quot;insertBatch&quot; parameterType=&quot;com.entity.TestDO&quot;&gt;</span><br><span class="line">        insert into table (&lt;include refid=&quot;all_colum_without_id&quot;/&gt;)</span><br><span class="line">        values</span><br><span class="line">        &lt;foreach collection=&quot;testDOList&quot; separator=&quot;,&quot; item=&quot;item&quot; index=&quot;index&quot;&gt;</span><br><span class="line">            (#&#123;item.name&#125;,</span><br><span class="line">            #&#123;item.age&#125;)</span><br><span class="line">            &lt;/foreach&gt;</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    //查询</span><br><span class="line">    &lt;select id=&quot;findById&quot; resultMap=&quot;TestResultMap&quot;&gt;</span><br><span class="line">        select &lt;include refid=&quot;all_colum&quot;/&gt; from table where id=#&#123;id&#125;</span><br><span class="line">        &lt;if test=&quot;age != null&quot;&gt;</span><br><span class="line">            and age=#&#123;age&#125;</span><br><span class="line">        &lt;if&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>TestDao.java接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface TestDao &#123;</span><br><span class="line">    //插入</span><br><span class="line">    Integer insertOne(TestDO testDO);</span><br><span class="line">    //批量插入</span><br><span class="line">    Integer insertBatch(List&lt;TestDO&gt; testDOList);</span><br><span class="line">    //查询</span><br><span class="line">    TestDO findById(Long id, Integer age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdbcType告诉框架如何解析这个属性（对应数据库中的类型），column是数据库中table的列名，property是实体类中对应的属性名字，type是对应的实体类，id&#x3D;”TestResultMap”是这个resultMap的一个引用标志。</p>
<p>这样使用resultMap就像用resultType对应实体类，在select出来的语句中直接对字段就行as，as为实体类属性名，或驼峰形式就行。</p>
<p>resultMap更复杂的用法：<a href="https://blog.csdn.net/wobuaizhi/article/details/83104464">https://blog.csdn.net/wobuaizhi/article/details/83104464</a></p>
<h3 id="返回映射下划线转驼峰"><a href="#返回映射下划线转驼峰" class="headerlink" title="返回映射下划线转驼峰"></a>返回映射下划线转驼峰</h3><p>意思是返回值对应到对象，mysql返回的字段名（app_id），直接映射到对象属性名（appId）。</p>
<p>第一种 Spring Boot</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis.configuration.map-underscore-to-camel-case=true</span><br></pre></td></tr></table></figure>

<p>第二种 mybatis-config.xml配置中加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- 全局配置 --&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">    </span><br><span class="line">       &lt;!-- 是否开启自动驼峰命名规则映射</span><br><span class="line">        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt; </span><br></pre></td></tr></table></figure>

<h3 id="mybatis-useGeneratedKeys-keyProperty"><a href="#mybatis-useGeneratedKeys-keyProperty" class="headerlink" title="mybatis useGeneratedKeys keyProperty"></a>mybatis useGeneratedKeys keyProperty</h3><p>useGeneratedKeys （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</p>
<p>首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys&#x3D;”true”，然后再把 keyProperty 设置为目标属性就 OK 了。</p>
<p>作用：在inset时，可以不用管主键插入多少，而且插入后，还能直接用对象里的值，因为自动返回了。建表时必须设置主键自增。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot;</span><br><span class="line">    keyProperty=&quot;id&quot;&gt;</span><br><span class="line">  insert into Author (username,password,email,bio)</span><br><span class="line">  values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<h3 id="DUPLICATE"><a href="#DUPLICATE" class="headerlink" title="DUPLICATE"></a>DUPLICATE</h3><p>duplicate在mybatis中的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;insert id=&quot;insertOne&quot; parameterType=&quot;com.entity.TestDO&quot;&gt;</span><br><span class="line">    insert into table (id, &lt;include refid=&quot;all_colum_without_id&quot;/&gt;)</span><br><span class="line">    values (0, #&#123;name&#125;)</span><br><span class="line">    ON DUPLICATE KEY UPDATE name=values(name), age=values(age)</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">values后面就是插入要查哪些。</span><br><span class="line">update后面是更新要更新哪些</span><br><span class="line">什么时候更新要看表的主键索引和唯一索引</span><br><span class="line">id可选，加了id，就传0</span><br></pre></td></tr></table></figure>

<p>因为更新的时候是不会返回id的，所以要去掉：<code>useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;</code><br>如果不去掉，会报<code>executorexception: error getting generated key or setting result to parameter object</code></p>
<h3 id="xml里面foreach标签里面的属性separator"><a href="#xml里面foreach标签里面的属性separator" class="headerlink" title="xml里面foreach标签里面的属性separator"></a>xml里面foreach标签里面的属性separator</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;if test=&quot;myList != null&quot;&gt;</span><br><span class="line">    AND dm in</span><br><span class="line">    &lt;foreach collection=&quot;myList &quot; item=&quot;item&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">        #&#123;item , jdbcType=VARCHAR &#125;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/if&gt;</span><br></pre></td></tr></table></figure>
<p>渲染为sql：<code>AND dm in ( &#39;03&#39; , &#39;04&#39;)</code></p>
<p>如果separator属性为or，渲染为：<code>AND ( dm  = &#39;01&#39;or dm   = &#39;02&#39; or dm   = &#39;03&#39;) </code></p>
<h3 id="where标签的作用"><a href="#where标签的作用" class="headerlink" title="where标签的作用"></a>where标签的作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;select&quot; resultType=&quot;DO&quot;&gt;</span><br><span class="line"> SELECT * FROM hdc</span><br><span class="line"> WHERE</span><br><span class="line"> &lt;if test=&quot;state != null&quot;&gt;</span><br><span class="line"> state = #&#123;state&#125;</span><br><span class="line"> &lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>如果state参数为空时，最终生成SQL语句为<br>SELECT * FROM hdc WHERE<br>执行会出错，可以在where 后加一个1&#x3D;1，但是累赘</p>
<p>用<code>&lt;where&gt;...&lt;/where&gt;</code>标签就好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectOne&quot; resultType=&quot;DO&quot;&gt;</span><br><span class="line"> SELECT * FROM hdc</span><br><span class="line"> &lt;where&gt;</span><br><span class="line">  &lt;if test=&quot;state != null&quot;&gt;</span><br><span class="line">    state = #&#123;state&#125;</span><br><span class="line">  &lt;/if&gt;</span><br><span class="line"> &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>总结：<code>&lt;where&gt;</code>标签，1、在后面if null都是空时，可以自动删除where。2、在后面多个if null，第一个为null时，会自动删掉后面有的and。</p>
<h3 id="trim实现动态sql"><a href="#trim实现动态sql" class="headerlink" title="trim实现动态sql"></a>trim实现动态sql</h3><p>场景：想使用having，having后面用if null标签，如果后面的if null都是null，having会留着，导致出错。</p>
<p>trim 在英语中有“点缀物”，修剪的意思。可以把‘’标签为一个装饰sql的标签。trim标签常用于动态生成sql的场景下。</p>
<p>基本格式：<br><code>&lt;trim prefix=&quot;&quot; suffix=&quot;&quot; suffixOverrides=&quot;&quot; prefixOverrides=&quot;&quot;&gt;&lt;/trim&gt;</code><br>prefix：<br>表示在trim包裹的SQL语句前面添加的指定内容。<br>suffix：<br>表示在trim包裹的SQL末尾添加指定内容<br>prefixOverrides：<br>表示去掉（覆盖）trim包裹的SQL的指定首部内容<br>suffixOverrides：<br>表示去掉（覆盖）trim包裹的SQL的指定尾部内容</p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/425922768">https://zhuanlan.zhihu.com/p/425922768</a></p>
<p>例子(查输入的list的元素是不是在查处的一个list字段里有)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">group by id</span><br><span class="line">&lt;trim prefix=&quot;having&quot; prefixOverrides=&quot;and&quot;&gt;</span><br><span class="line">    &lt;if test=&quot;nameList != null and nameList.size() &gt; 0&quot;&gt;</span><br><span class="line">        &lt;foreach collection=&quot;nameList&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;name&quot; index=&quot;index&quot; separator=&quot;or&quot;&gt;</span><br><span class="line">            find_in_set(#&#123;name&#125;, names) &gt; 0</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line"></span><br><span class="line">    &lt;if test=&quot;nameList != null and nameList.size() &gt; 0&quot;&gt;</span><br><span class="line">        and</span><br><span class="line">        &lt;foreach collection=&quot;nameList&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;name&quot; index=&quot;index&quot; separator=&quot;or&quot;&gt;</span><br><span class="line">            find_in_set(#&#123;name&#125;, names) &gt; 0</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/trim&gt;</span><br></pre></td></tr></table></figure>


<h3 id="条件构造器QueryWrapper"><a href="#条件构造器QueryWrapper" class="headerlink" title="条件构造器QueryWrapper"></a>条件构造器QueryWrapper</h3><p>QueryWrapper是在使用Mybatis-plus中用到的一种技术，也叫作构造器，能简化sql的操作。MyBatisPlus 依赖：mybatis-plus-boot-starter</p>
<p>首先，Mapper接口需要继承<code>BaseMapper&lt;T&gt;</code>抽象类，加@Mapper注解。</p>
<p>LambdaQueryWrapper和QueryWrapper查询是一样的，但是使用Lambda语法更加方便，更容易理解。</p>
<p>LambdaQueryWrapper和QueryWrapper的区别：<br>首先它们都是Mybatis-plus提供的查询构造器，用于构建查询条件。<br>1、LambdaQueryWrapper支持Lambda表达式作为查询条件，而QuerryWrapper不支持。<br>2、LambdaQueryWrapper可以避免手写错误的字段名，因为它会在编译期间进行类型检查。而QueryWrapper只能在运行时才发现错误。<br>3、LambdaQueryWrapper可以链式调用，更加优雅简洁。而QueryWrapper需要每次重新创建一个实例来添加新的查询条件。</p>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/list&quot;)</span><br><span class="line">public List&lt;Student&gt; list(Student student)&#123;</span><br><span class="line">    LambdaQueryWrapper&lt;Student&gt; lqw = new LambdaQueryWrapper&lt;Student&gt;();</span><br><span class="line">    lqw.eq(Student::getName, student.getName()); </span><br><span class="line">    //也可以：lqw.eq(&quot;name&quot;, student.getName());</span><br><span class="line">    lqw.like(Student::getClass,student.getClass());</span><br><span class="line">    lqw.between(&quot;age&quot;,student.getAge1(),student.getAge2());</span><br><span class="line">    lqw.orderByAsc(&quot;age&quot;);</span><br><span class="line">    List&lt;Student&gt; list = studentDao.list(lqw);</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码对应sql：<code>select * from student where name = &#39;?&#39; and class like &#39;%?%&#39; and age between &#39;?&#39; and &#39;?&#39; order by &#39;?&#39; asc</code></p>
<p>QueryWrapper其实可以理解成一个放查询条件的盒子，我们把查询条件放在里面，他就会自动按照对应的条件进行查询数据。</p>
<p>根据不同的查询要求，有不同的用法，常用到的比如：eq（相等）、like、and、or、isNull、isNotNull、ne（不相等）、likeRight、between、gt（大于）、lt（小于）等</p>
<hr>
<p>使用QueryWrapper来更新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QueryWrapper&lt;user&gt; qw = new QueryWrapper&lt;&gt;();</span><br><span class="line">qw.eq(&quot;id&quot;, 1);</span><br><span class="line">User user = new User();</span><br><span class="line">user.setName(&quot;liu&quot;);</span><br><span class="line">int rows = userMapper.update(user, qw);</span><br></pre></td></tr></table></figure>


<h3 id="使用Map接收mybatis结果"><a href="#使用Map接收mybatis结果" class="headerlink" title="使用Map接收mybatis结果"></a>使用Map接收mybatis结果</h3><p>ResultSet是一个表示数据库结果集的接口，在java中用于表示从数据库查询的结果，允许通过行和列的方式访问数据，从而从数据库中检索和操作数据。</p>
<p>但是Mybatis不支持直接用ResultSet接收查询结果。因为Mybatis采用的是物理映射技术，而ResultSet只能获取行列数据，得不到物理映射的结果。</p>
<p>那么除了定义DO，还可以用什么接收mybatis返回的数据呢？ 用Map。</p>
<p>dao接口怎么写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@MapKey(&quot;某字段名&quot;)</span><br><span class="line">Map&lt;String, Object&gt; selectAll();</span><br></pre></td></tr></table></figure>

<p>xml怎么写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;select&quot; resultType=&quot;java.util.Map&quot;&gt;</span><br><span class="line"> SELECT * FROM hdc</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>@MapKey 是MyBatis框架的注解，作用是将List结果集转换成key-value形式的Map结果集，方便快速从结果集中查询指定结果。</p>
<p>@MapKey(value&#x3D;””) 是mybatis的注解，用来映射Map类型的联合查询结果。作用是指定从查询结果的某个字段映射到Map的Key，这个注解是必须的，必须指定一个字段为key。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserMapper()&#123;</span><br><span class="line"> </span><br><span class="line">    //使用list接收</span><br><span class="line">    //[&#123;id:1111,name:&quot;foo&quot;&#125;,&#123;id:2222,name:&quot;bar&quot;&#125;]</span><br><span class="line">    public List&lt;User&gt; useList();</span><br><span class="line"> </span><br><span class="line">    //使用带有@Mapkey(&quot;id&quot;)的Map&lt;Integer,User&gt;接收</span><br><span class="line">    //&#123;1111:&#123;id:1111,name:&quot;foo&quot;&#125;,2222:&#123;id:2222,name:&quot;bar&quot;&#125;&#125;</span><br><span class="line">    @Mapkey(&quot;id&quot;)</span><br><span class="line">    public Map&lt;Integer,User&gt; useMap();</span><br><span class="line"></span><br><span class="line">    //不想定义DO，直接用List&lt;Map&lt;String, Object&gt;&gt;接收</span><br><span class="line">    //返回的结果Map是字段名：值，跟@MapKey里的value没啥关系</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是不能用<code>List&lt;Object&gt;</code>接结果。<br>如果@MapKey中的value是null，会展示一个key为null的map。</p>
<hr>
<p>MyBatis中的动态SQL以及@ResultMap,@MapKey和@Options的使用：<br><a href="https://www.freesion.com/article/2930425356/">https://www.freesion.com/article/2930425356/</a></p>
<h3 id="ResultHandler"><a href="#ResultHandler" class="headerlink" title="ResultHandler"></a>ResultHandler</h3><p>ResultHandler，顾名思义，对返回的结果进行处理，最终得到自己想要的数据格式或类型。也就是说，可以自定义返回类型。可以迭代查询结果集，将其存储在集合中，或执行自定义处理。它是mybatis的一个接口，用来处理结果集，从而获取特定的数据或者操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ResultHandler&lt;T&gt; &#123;</span><br><span class="line">    void handleResult(ResultContext&lt;? extends T&gt; var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mapper接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface GoodsDao &#123;</span><br><span class="line">    public void selectGoods(ResultHandler resultHandler); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>映射文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;   </span><br><span class="line">&lt;!DOCTYPE mapper   </span><br><span class="line">PUBLIC &quot;-//ibatis.apache.org//DTD Mapper 3.0//EN&quot;  </span><br><span class="line">&quot;http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.yht.mybatisTest.dao.GoodsDao&quot;&gt;</span><br><span class="line">   </span><br><span class="line">    &lt;select id=&quot;selectGoods&quot; resultType=&quot;map&quot;&gt;  </span><br><span class="line">        select price,name from goods</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">                                                        </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>selectGoods方法的查询结果是<code>List&lt;Map&gt;</code>，假如现在有这么一个需求：想统计价格低于50的书籍有哪些，价格高于50的书籍有哪些，该怎么处理呢？这个时候就用到了ResultHandler，我们创建一个SelectGoodsResultHandler。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SelectGoodsResultHandler implements ResultHandler&#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, List&lt;String&gt;&gt; resultMap = new HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public void handleResult(ResultContext context) &#123;</span><br><span class="line">        if(resultMap.get(&quot;lowPrice&quot;) == null &amp;&amp; resultMap.get(&quot;highPrice&quot;) == null)&#123;</span><br><span class="line">            List&lt;String&gt; lowList = new ArrayList&lt;String&gt;();</span><br><span class="line">            List&lt;String&gt; highList = new ArrayList&lt;String&gt;();</span><br><span class="line">            resultMap.put(&quot;lowPrice&quot;, lowList);</span><br><span class="line">            resultMap.put(&quot;highPrice&quot;, highList);</span><br><span class="line">        &#125;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        Map&lt;String,Object&gt; resultObject = (Map&lt;String, Object&gt;)context.getResultObject();</span><br><span class="line">        BigDecimal price = (BigDecimal) resultObject.get(&quot;price&quot;);</span><br><span class="line">        String name = (String) resultObject.get(&quot;name&quot;);</span><br><span class="line">        if(price.intValue() &lt; 50)&#123;</span><br><span class="line">            ((List&lt;String&gt;)resultMap.get(&quot;lowPrice&quot;)).add(name);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ((List&lt;String&gt;)resultMap.get(&quot;highPrice&quot;)).add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Map&lt;String, List&lt;String&gt;&gt; getResults()&#123;</span><br><span class="line">        return resultMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GoodsDaoTest &#123;</span><br><span class="line">    </span><br><span class="line">    private static SqlSessionFactory sqlSessionFactory = null;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void selectGoodsTest()&#123;</span><br><span class="line">        </span><br><span class="line">        SqlSession sqlSession = getSqlSessionFactory().openSession(true);</span><br><span class="line">        GoodsDao goodsMapper = sqlSession.getMapper(GoodsDao.class);</span><br><span class="line">        SelectGoodsResultHandler resultHandler = new SelectGoodsResultHandler();</span><br><span class="line">        goodsMapper.selectGoods(resultHandler);</span><br><span class="line">        System.out.println(resultHandler.getResults().toString());;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static SqlSessionFactory getSqlSessionFactory() &#123;</span><br><span class="line">        String resource = &quot;spring-ibatis.xml&quot;;</span><br><span class="line">        if(sqlSessionFactory == null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources</span><br><span class="line">                        .getResourceAsReader(resource));</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                // TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转载自：<a href="https://www.cnblogs.com/51life/p/9633002.html">https://www.cnblogs.com/51life/p/9633002.html</a></p>
<p>mybatis之ResultHandler如何使用：<br><a href="https://www.jianshu.com/p/8773d0e786d8">https://www.jianshu.com/p/8773d0e786d8</a></p>
<h3 id="mybatis传表名"><a href="#mybatis传表名" class="headerlink" title="mybatis传表名"></a>mybatis传表名</h3><p>mybatis 怎么传入表名来控制插入哪个表？<br>在 MyBatis 中，我们可以通过动态 SQL 的方式来传入表名，从而控制插入哪个表。</p>
<p>貝体操作如下：<br>1.在Mapperxml 文件中，使用 parameterType 指定一个参数类型为 string，用于接收要插入的表名。</p>
<p>2.在插入语句中，使用 ＄{} 操作待将该参数传递到 SQL中。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void insertIntoTable(@Param(&quot;tableName&quot;) String tableName, ...)</span><br><span class="line"></span><br><span class="line">&lt;insert id=&quot;insertIntoTable&quot;&gt;</span><br><span class="line">    INSERT INTO $&#123;tableName&#125; (column, column2) VALUES (#&#123;value1&#125;, #&#123;value2&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<p>如果除了表名参数，另一个参数是对象，在xml文件中加对象名.字段名来调用。</p>
<p>3.在调用该方法时，传递要插入的表名即可。<br>String tableName &#x3D; user;<br>mapper.insertIntoTable (tableName, value1, value2);<br>注意：使用＄{}操作符传递参数，需要注意 SQL 注入的问题，因此需要进行必要的安全措施，如输入参数的参数校验等。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>log日志与maven打包</title>
    <url>/2022/04/03/myblog/java/log%E6%97%A5%E5%BF%97%E4%B8%8Emaven%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p>工作中需要将应用部署在本地，想来之前用go的时候貌似是直接编译运行就在本地部署了，但是java需要用到maven打包，还没打包过，学习一下。顺便工作中查看日志对log4j、sjf4j、logback、lomback这几个东西有点迷糊，所以先学一下日志相关的，然后建工程打包部署在本地看下效果。</p>
<h3 id="1-lombok"><a href="#1-lombok" class="headerlink" title="1.lombok"></a>1.lombok</h3><p>自然不必多说，lombok可以通过简单的注解的形式来帮助我们简化和消除一些必须有但显得很臃肿的Java代码，比如常见的Getter&amp;Setter、toString()、构造函数等等。lombok不仅方便编写，同时也让我们的代码更简洁。</p>
<p>lombok提供了一个功能完整的jar包，可以很方便的与我们的项目进行集成。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>第一步：加入lombok依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>scop&#x3D;provided，表示它只在编译阶段生效，不需要打入包中，lombok在编译期将带lombok注解的java文件正确编译为完整的class文件。</p>
<p>第二步：idea中添加lombok插件</p>
<p>否则会报缺少方法和没有设置属性的异常。</p>
<p>第三步：设置启用注释处理</p>
<p>设置中 Annotation processors，enable annotation processing。</p>
<h4 id="lombok原理"><a href="#lombok原理" class="headerlink" title="lombok原理"></a>lombok原理</h4><ol>
<li>javac对源代码进行分析，生成了一棵抽象语法树（AST）</li>
<li>编译过程中调用实现了“JSR 269 API”的Lombok程序</li>
<li>此时Lombok就对第一步骤得到的AST进行处理，找到@Data注解所在类对应的语法树（AST），然后修改该语法树（AST），增加getter和setter方法定义的相应树节点</li>
<li>javac使用修改后的抽象语法树（AST）生成字节码文件，即给class增加新的节点（代码块）</li>
</ol>
<h3 id="2-SLF4J"><a href="#2-SLF4J" class="headerlink" title="2.SLF4J"></a>2.SLF4J</h3><h4 id="接口与包关系"><a href="#接口与包关系" class="headerlink" title="接口与包关系"></a>接口与包关系</h4><p>Simple logging Facade for Java，意思为简单日志门面，它是把不同的日志系统的实现进行了具体的抽象化，只提供了统一的日志使用接口，使用时只需要按照其提供的接口方法进行调用即可，由于<strong>它只是一个接口</strong>，并不是一个具体的可以直接单独使用的日志框架，所以最终日志的格式、记录级别、输出方式等都要<strong>通过接口绑定的具体的日志系统来实现</strong>，这些具体的日志系统就有log4j、logback、java.util.logging等，它们才实现了具体的日志系统的功能。</p>
<p>SLF4J只是一个接口，实际使用时必须要结合具体的日志系统来使用，我们首先来看SLF4J和各个具体的日志系统进行绑定时的框架原理图：</p>
<p><img src="/images/logback.png"></p>
<p>slf4j原理很简单，他只提供一个核心slf4j api(就是slf4j-api.jar包)，这个包只有日志的接口，并没有实现，所以如果要使用就得<strong>再给它提供一个实现了些接口的日志包</strong>，比 如：log4j、common logging、jdk log日志实现包等，但是<strong>这些日志实现又不能通过接口直接调用</strong>，实现上他们根本就和slf4j-api不一致，因此slf4j又增加了一层来<strong>转换各日志实现包的使用</strong>，当然slf4j-simple除外。其结构如下： </p>
<blockquote>
<p>slf4j-api(接口层)<br> | |<br>各日志实现包的连接层( slf4j-jdk14, slf4j-log4j)<br> | |<br>各日志实现包 	</p>
</blockquote>
<p><strong>所以，结合各日志实现包使用时提供的jar包情况为：</strong></p>
<p>SLF4J和logback结合使用时需要提供的jar：slf4j-api.jar、logback-classic.jar、logback-core.jar</p>
<p>SLF4J和log4j结合使用时需要提供的jar：slf4j-api.jar、slf4j-log4j12.jar、log4j.jar</p>
<p>和log4j2配合需要导入log4j2的<strong>log4j-api.jar</strong>、<strong>log4j-core.jar</strong>和桥接包<strong>log4j-slf4j-impl.jar</strong>。</p>
<p>SLF4J和JDK中java.util.logging结合使用时需要提供的jar：slf4j-api.jar、slf4j-jdk14.jar</p>
<p>SLF4J和simple(SLF4J本身提供的一个接口的简单实现)结合使用时需要提供的jar：slf4j-api.jar、slf4j-simple.jar</p>
<p>当然还有其他的日志实现包，以上是经常会使用到的一些。</p>
<p>*<strong>注意，以上slf4j和各日志实现包结合使用时最好只使用一种结合，不然的话会提示重复绑定日志，并且会导致日志无法输出。*</strong></p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>*<strong>slf4j-api.jar:对外提供统一的日志调用接口，该接口具体提供的调用方式和方法举例说明：*</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">　　<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Tester.class);  </span><br><span class="line">　　<span class="comment">//通过LoggerFactory获取Logger实例</span></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//接口里的统一的调用方法，各具体的日志系统都有实现这些方法</span></span><br><span class="line">　　		logger.info(<span class="string">&quot;testlog: &#123;&#125;&quot;</span>, <span class="string">&quot;test&quot;</span>); </span><br><span class="line">       logger.debug(<span class="string">&quot;testlog: &#123;&#125;&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">       logger.error(<span class="string">&quot;testlog: &#123;&#125;&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">       logger.trace(<span class="string">&quot;testlog: &#123;&#125;&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">       logger.warn(<span class="string">&quot;testlog: &#123;&#125;&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Lombok提供的@Slf4j注解，可以省去获取Logger对象的步骤，直接使用log.info()…</p>
<p><strong>如果系统中之前已经使用了log4j做日志输出，想使用slf4j作为统一的日志输出，该怎么办呢？</strong></p>
<p>如果之前系统中是单独使用log4j做为日志输出的，这时再想使用slf4j做为日志输出时，如果系统中日志比较多，此时更改日志输出方法肯定是不太现实的，这个时候就可以使用log4j-over-slf4j.jar将使用log4j日志框架输出的日志路由到slf4j上来统一采用slf4j来输出日志。</p>
<h4 id="为什么使用？"><a href="#为什么使用？" class="headerlink" title="为什么使用？"></a>为什么使用？</h4><p><strong>为什么要使用SLF4J?</strong></p>
<ul>
<li>slf4j是一个<strong>日志接口，自己没有具体实现日志系统</strong>，只提供了一组标准的调用api,这样<strong>将调用和具体的日志实现分离</strong>，<strong>使用slf4j后有利于根据自己实际的需求更换具体的日志系统</strong>，比如，之前使用的具体的日志系统为log4j，想更换为logback时，只需要删除log4j相关的jar，然后加入logback相关的jar和日志配置文件即可，而不需要改动具体的日志输出方法，试想如果没有采用这种方式，当你的系统中日志输出有成千上万条时，你要更换日志系统将是多么庞大的一项工程。如果你开发的是一个面向公众使用的组件或公共服务模块，那么一定要使用slf4的这种形式，这有利于别人在调用你的模块时保持和他系统中使用统一的日志输出。</li>
<li><strong>slf4j日志输出时可以使用{}占位符</strong>，如，logger.info(“testlog: {}”, “test”)，而如果只使用log4j做日志输出时，只能以logger.info(“testlog:”+”test”)这种形式，前者要比后者在性能上更好，后者采用+连接字符串时就是new 一个String 字符串，在性能上就不如前者。</li>
</ul>
<h3 id="3-log4j-log-for-java"><a href="#3-log4j-log-for-java" class="headerlink" title="3.log4j(log for java)"></a>3.<strong>log4j(log for java)</strong></h3><p>Log4j是Apache的一个开源项目，通过使用Log4j，我们可以<strong>控制日志信息输送的目的地</strong>是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以<strong>控制每一条日志的输出格式</strong>；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以<strong>通过一个配置文件来灵活地进行配置</strong>，而不需要修改应用的代码。</p>
<p><strong>如何使用？</strong></p>
<ul>
<li>引入jar,使用log4j时需要的jar为：log4j.jar。</li>
<li>定义配置文件log4j.properties或log4j.xml</li>
<li>在具体的类中进行使用：<ul>
<li>在需要日志输出的类中加入：private static final Logger logger &#x3D; Logger.getLogger(Tester.class);  &#x2F;&#x2F;通过Logger获取Logger实例</li>
<li>在需要输出日志的地方调用相应方法即可：logger.debug(“System …..”)</li>
</ul>
</li>
</ul>
<h3 id="4-logback"><a href="#4-logback" class="headerlink" title="4.logback"></a>4.logback</h3><p>logback同样是由log4j的作者设计完成的，拥有更好的特性，用来取代log4j的一个日志框架，是slf4j的原生实现(即直接实现了slf4j的接口，而log4j并没有直接实现，所以就需要一个适配器slf4j-log4j12.jar)，logback一共有以下几个模块：</p>
<ul>
<li>logback-core：其它两个模块的基础模块</li>
<li>logback-classic：它是log4j的一个改良版本，同时它完整实现了slf4j API使你可以很方便地更换成其它日志系统如log4j或JDK14 Logging</li>
<li>logback-access：访问模块与Servlet容器集成提供通过Http来访问日志的功能</li>
</ul>
<p>同样，单独使用它时，需要引入以上jar，然后进行配置文件的配置，最后就是在相关类中进行使用，使用时加入以下语句:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">　　<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Test.class);</span><br><span class="line"> 　logger.info(<span class="string">&quot;打印日志&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果要改代码的日志级别：改logback-spring.xml里的<code>&lt;root level=&quot;INFO&quot;&gt;</code></p>
<h3 id="5-log发展史"><a href="#5-log发展史" class="headerlink" title="5.log发展史"></a>5.log发展史</h3><p>从JDK1.4开始提供java.until.logging日志框架来打印日志，但是大佬觉得JUL太难用了，就自己手撸了个log4j，后来log4j发现安全漏洞，加上代码结构问题难以维护，于是从1.2就停止更新log4j，并又重新手撸了个log4j2，再后来，这个大佬又双手撸了一个性能更高、功能更全的logback。</p>
<p>从此，这个大佬构建了log的世界，也创造了最常见的日志框架：log4j、log4j2、logback。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用log4j，需要log4j.jar</span></span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger_log4j</span> <span class="operator">=</span> Logger.getLogger(Test.class);</span><br><span class="line">logger_log4j.info(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用log4j2，需要log4j-api.jar、log4j-core.jar</span></span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger_log4j2</span> <span class="operator">=</span> LogManager.getLogger(Test.class);</span><br><span class="line">logger_log4j2.info(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// logback，需要logback-classic.jar、logback-core.jar</span></span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.Logger;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.LoggerContext;</span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger_logback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggerContext</span>().getLogger(Test.class);</span><br><span class="line">logger_logback.info(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.until.logging，简称jul</span></span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger_jul</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;java.Test&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>从上面不难看出，使用不同的日志框架，就要引入不同的jar包，使用不同的代码获取Logger。</p>
<p>于是Apache Commons Logging出现了。</p>
<p>Common-logging提供了一个日志入口，称作”门面日志”，即它不负责写日志，而是<strong>提供用一个统一的接口，通过jar来决定使用的日志框架</strong>，这样就不要再更换框架的时候再修改代码了。后来开发了log4j的大佬又因为嫌弃Common-logging难用，开发了门面日志框架<strong>slf4j</strong>，今天就拿slf4j讲述门面日志。</p>
<p>门面日志和设计模式中的<strong>外观模式</strong>如出一辙，本身不提供服务，为子系统提供统一的入口，封装子系统的复杂性，便于客户端调用。slf4j就像是菜鸟驿站，本身没有快递服务，但是提供顺丰、中通等快递服务，至于你想用顺丰还是用中通，完全取决于你的想法。</p>
<p>使用slf4j：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Test.class);</span><br><span class="line">logger.info(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用slf4j需要首先导入<strong>slf4j-api.jar</strong>，和log4j配合，需要导入<strong>log4j.jar</strong>，以及桥接包<strong>slf4j-log412.jar</strong>。</p>
<p>logback只需要导入<strong>logback-classic.jar</strong>和<strong>logback-core.jar</strong>即可，不需要桥接包。</p>
<h4 id="为什么使用桥接包？"><a href="#为什么使用桥接包？" class="headerlink" title="为什么使用桥接包？"></a>为什么使用桥接包？</h4><p>slf4j从LoggerFactory.getLogger()开始，原理就是就是让ClassLoader从classpath(依赖的jar)中找到<strong>StaticLoggerBinder</strong>这个类，然后利用他来返回log4j、logback中的Logger，然后打印日志。</p>
<p>所谓的桥接包，就是实现StaticLoggerBinder类，用来连接slf4j和日志框架。因为log4j和log4j2刚开始没有StaticLoggerBinder这个类，为了不改变程序结构，只能重新写一个新的jar来实现StaticLoggerBinder。而logback出现slf4j之后，于是在logback本身的jar中实现了StaticLoggerBinder，所以就不需要桥接包。</p>
<p>StaticLoggerBinder实现了使用底层日志框架创建Logger的功能，各自的StaticLoggerBinder为slf4j提供的Logger，再提供给用户打印日志。</p>
<p>log4j和log4j2桥接包及logback依赖里，都有StaticLoggerBinder类。</p>
<p>“Class path contains multiple SLF4J bindings.”在使用slf4j的时候会遇到以上的报告信息。究其根本是因为logback-classic、log4j-slf4j-impl、slf4j-log412、slf4j-jdk这些jar不能同时存在。他们都实现了StaticLoggerBinder类而导致冲突，slf4j无法确定到底用哪个日志框架。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>lombok是一个可以简化代码的jar包，需要导入依赖，添加插件，可以说是开发必备。跟日志没啥关系，只不过@Slf4j注解是lombok提供的，用来在方法中直接使用log。</p>
</li>
<li><p>slf4j是日志门面，一个日志接口，而不提供日志系统实现，方便日志系统与调用的分离，可以方便更换日志系统。相当于是提供了一种日志输出的规范，下面的日志系统都需要实现这些方法，统一了日志输出规范。它实现了日志框架一些通用的api，log4j和logback是具体的日志框架。</p>
</li>
<li><p>log4j就是一个日志实现系统，具体的配置文件log4j.properties怎么写，还得再看看。log4j在结合slf4j时需要使用一个适配类桥接包。使用Logger.getLogger。</p>
</li>
<li><p>logback时比log4j新的日志实现系统，直接实现了slf4j接口，使用LoggerFactory.getLogger。</p>
<p>他们可以单独的使用，也可以绑定slf4j一起使用。</p>
<p>单独使用，分别调用框架自己的方法来输出日志信息。绑定slf4j一起使用。调用slf4j的api来输入日志信息，具体使用与底层日志框架无关（需要底层框架的配置文件）。显然不推荐单独使用日志框架。假设项目中已经使用了log4j，而我们此时加载了一个类库，而这个类库依赖另一个日志框架。这个时候我们就需要维护两个日志框架，这是一个非常麻烦的事情。而使用了slf4j就不同了，由于应用调用的抽象层的api，与底层日志框架是无关的，因此可以任意更换日志框架。</p>
</li>
</ol>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="1-maven项目"><a href="#1-maven项目" class="headerlink" title="1.maven项目"></a>1.maven项目</h4><p>很久没在这个电脑上新建maven项目，结果问题来了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.m2 ❯ mvn -v      </span><br><span class="line">zsh: command not found: mvn</span><br></pre></td></tr></table></figure>

<p>之前出现的问题又出现了，之前重新配置了一下就可以了，可是brew info maven 也找不到之前maven安装的路径，难道之前我不是通过brew安装的吗？</p>
<p>另外在资源库中也没找到，好吧，重新 brew install maven 😅。可是brew安装报错。</p>
<p>官网<a href="https://maven.apache.org/download.cgi%E4%B8%8B%E8%BD%BDapache-maven-3.8.5-bin.tar.gz%E3%80%82%E8%A7%A3%E5%8E%8B%E5%88%B0%E8%B5%84%E6%BA%90%E5%BA%93%E4%B8%AD%E3%80%82%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E4%BD%BF%E5%BE%97%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E8%BE%93%E5%85%A5mvn%E8%83%BD%E5%A4%9F%E6%89%BE%E5%88%B0maven%E5%8C%85%EF%BC%9F%E5%B0%B1%E9%9C%80%E8%A6%81%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%BA%86%E3%80%82">https://maven.apache.org/download.cgi下载apache-maven-3.8.5-bin.tar.gz。解压到资源库中。那么如何使得在命令行中输入mvn能够找到maven包？就需要配置环境变量了。</a></p>
<p>下载之后，需要配置环境变量，不经想起之前的疑问：jdk环境变量在&#x2F;etc&#x2F;profile中配置，而maven中的环境变量在~&#x2F;.bash_profile，这是为什么？</p>
<p>我们常说的环境变量修改主要包含两类文件，分别是 profile 和 bashrc 文件。profile 文件又分为：”&#x2F;etc&#x2F;profile”，”<del>&#x2F;.bash_profile”；bashrc 文件则又分为 “&#x2F;etc&#x2F;bashrc”，和 “</del>&#x2F;.bashrc” 文件。</p>
<p>说到这儿，可能迷惑了，我在我电脑里没看到.bash_profile和.bashrc啊，但是看到.zshrc了，这是为啥？</p>
<blockquote>
<p>iterm2以及mac自带的terminal都是终端模拟器。最开始时候就用起了iterm2.</p>
<p>bash，zsh是shell，zsh兼容bash</p>
<p>shell：壳，用它表示“为使用者提供的操作界面”，Shell泛指所有为用户提供操作界面的程序，分为两类：命令行（CLI）与图形界面（GUI）。通常情况下，我们在聊shell的时候，其实都是聊的Linux的命令行界面。</p>
</blockquote>
<blockquote>
<p>sh和bash和zsh :</p>
<p>sh全称为Bourne Shell，来自于1977年底的Unix v7版。二进制文件位置为<code>/bin/sh</code>。 </p>
<p>bash全称为Bourne-Again Shell，是在1989年对sh的重写版，替代了sh。二进制文件位置为<code>/bin/bash</code>。 </p>
<p>现在的Linux系统以及macOS系统的shell都默认使用bash。</p>
<p>Zsh即Z shell，是一款可用作交互式登录的shell及脚本编写的命令解释器。Zsh对Bourne shell做出了大量改进，同时加入了Bash、ksh及tcsh的某些功能。 </p>
<p>所以说Zsh也是一个Shell，就是会比bash能好用很多。所以这也是2019年起，macOS的默认Shell从Bash改为Zsh的原因？</p>
<p>zsh拥有完善的插件机制以及丰富的生态，和oh my zsh一起食用更佳</p>
</blockquote>
<h5 id="查看本地Shell的命令"><a href="#查看本地Shell的命令" class="headerlink" title="查看本地Shell的命令"></a>查看本地Shell的命令</h5><ul>
<li><p>查看当前Linux的全部Shell：<code>cat /etc/shells</code></p>
</li>
<li><p>查看当前使用的Shell：<code>echo $SHELL</code>或者<code>echo $0</code></p>
</li>
<li><p>切换默认的Shell：<code>chsh -s [shell的二进制文件路径]</code>，之后要重新登陆Shell才能生效哈。例如：</p>
</li>
<li><ul>
<li>切换为Bash： <code>chsh -s /bin/bash</code></li>
<li>切换为Zsh：<code>chsh -s /bin/zsh</code></li>
</ul>
</li>
</ul>
<h5 id="Shell的各种配置文件"><a href="#Shell的各种配置文件" class="headerlink" title="Shell的各种配置文件"></a>Shell的各种配置文件</h5><p>无论是Bash还是Zsh，都是有各自的配置文件来完成自己的工作的。这些配置文件都是隐藏文件，也就是说，用户不需要知道这些配置。但是在这里也要给大家总结一下都有哪些配置文件，也许以后用的上呢。 </p>
<h5 id="Bash的配置文件"><a href="#Bash的配置文件" class="headerlink" title="Bash的配置文件"></a>Bash的配置文件</h5><ul>
<li>&#x2F;etc&#x2F;profile：为系统的<strong>每个用户</strong>设置环境信息，当用户第一次<strong>登录</strong>时会执行该文件里的命令。默认会直接调用&#x2F;etc&#x2F;bashrc。该文件的改动需要重启才能生效。用于设置系统级别的环境变量和启动程序，在这个文件下配置会对所有的用户生效。</li>
<li>&#x2F;etc&#x2F;bashrc：为每一个运行bash shell的用户执行此文件。当bash shell被打开时，会读取并执行该文件中的命令。所以修改该文件后，重新打开Shell即可生效。</li>
<li>~&#x2F;.bash_profile：和&#x2F;etc&#x2F;profile类似，但是只对当前用户生效。只对单一用户生效，该文件是一个用户级别的设置，可以理解为某一用户下的profile</li>
<li>~&#x2F;.bashrc：和&#x2F;etc&#x2F;bashrc类似，但是只对当前用户生效。</li>
<li>~&#x2F;.bash_logout：当每次退出bash shell时，执行该文件。</li>
<li>~&#x2F;.bash_history：保存了历史命令。在Shell为Bash时，每次敲击命令时，都会保存在这个文件里</li>
</ul>
<h5 id="Zsh的配置文件"><a href="#Zsh的配置文件" class="headerlink" title="Zsh的配置文件"></a>Zsh的配置文件</h5><ul>
<li>&#x2F;etc&#x2F;bashrc 对应 &#x2F;etc&#x2F;zshrc</li>
<li>~&#x2F;.bash_profile 对应 ~&#x2F;.zprofile</li>
</ul>
<p>加载顺序：zshenv、zprofile、zshrc、zlogin</p>
<hr>
<p>所以说，各种教程里说的配置都是默认bash的，bash的配置文件对标到zsh中就可以。</p>
<p><strong>&#x2F;etc&#x2F;profile 和 &#x2F;etc&#x2F;bashrc 这种在 &#x2F;etc 目录下的配置则都属于全局配置，所有用户的shell都有权使用这些环境变量，～&#x2F; 则属于用户级别的</strong></p>
<h5 id="总结一下：各种配置文件可以按两种方式分类："><a href="#总结一下：各种配置文件可以按两种方式分类：" class="headerlink" title="总结一下：各种配置文件可以按两种方式分类："></a>总结一下：各种配置文件可以按两种方式分类：</h5><table>
<thead>
<tr>
<th></th>
<th>profile</th>
<th align="center">bashrc&#x2F;zshrc</th>
</tr>
</thead>
<tbody><tr>
<td>全局</td>
<td>&#x2F;etc&#x2F;profile（无关哪个shell）</td>
<td align="center">&#x2F;etc&#x2F;bashrc</td>
</tr>
<tr>
<td>用户</td>
<td>~&#x2F;.bash_profile （专用于哪个shell）</td>
<td align="center">~&#x2F;.bashrc</td>
</tr>
</tbody></table>
<p>profile的bashrc区别?</p>
<p>要搞清bashrc与profile的区别，首先要弄明白什么是交互式shell和非交互式shell，即login shell 和non-login shell。</p>
<p>交互式模式就是shell等待你的输入，并且执行你提交的命令。这种模式被称作交互式是因为shell与用户进行交互。这种模式也是大多数用户非常熟悉的：登录、执行一些命令、签退。当你签退后，shell也终止了。 shell也可以运行在另外一种模式：非交互式模式。在这种模式下，shell不与你进行交互，而是读取存放在文件中的命令,并且执行它们。当它读到文件的结尾，shell也就终止了。</p>
<p>bashrc 与 profile 都用于保存用户的环境信息，bashrc用于交互式non-loginshell，而profile用于交互式login shell。</p>
<ol>
<li><p>&#x2F;etc&#x2F;profile: 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从&#x2F;etc&#x2F;profile.d目录的配置文件中搜集shell的设置.</p>
</li>
<li><p>&#x2F;etc&#x2F;bashrc: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.</p>
</li>
<li><p>~&#x2F;.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.</p>
</li>
<li><p>~&#x2F;.bashrc: 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.</p>
</li>
<li><p>~&#x2F;.bash_logout: 当每次退出系统(退出bash shell)时,执行该文件.</p>
</li>
</ol>
<p>另外,&#x2F;etc&#x2F;profile中设定的变量(全局)的可以作用于任何用户,而~&#x2F;.bashrc等中设定的变量(局部)只能继承&#x2F;etc&#x2F;profile中的变量,他们是”父子”关系.</p>
<hr>
<p>当登入系统时候获得一个shell进程时，其读取环境设定档有三步</p>
<p>1、首先读入的是全局环境变量设定档&#x2F;etc&#x2F;profile，然后根据其内容读取额外的设定的文档，如<br>&#x2F;etc&#x2F;profile.d和&#x2F;etc&#x2F;inputrc</p>
<p>2、然后根据不同使用者帐号，去其家目录读取<del>&#x2F;.bash_profile，如果这读取不了就读取</del>&#x2F;.bash_login，这个也读取不了才会读取<br>~&#x2F;.profile，这三个文档设定基本上是一样的，读取有优先关系</p>
<p>3、然后在根据用户帐号读取~&#x2F;.bashrc</p>
<hr>
<p>总结：配置文件全局&#x2F;用户—交互的&#x2F;非交互的，jdk的配置就是在&#x2F;etc&#x2F;profile中，maven的配置在～&#x2F;.bash_profile既然用的是zsh，就在 ~&#x2F;.zprofile里面配置。</p>
<hr>
<p>在～&#x2F;.zprofile文件中，添加配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export M=&quot;/usr/local/ApacheMaven&quot;</span><br><span class="line">export PATH=&quot;$M/bin:$PATH&quot;</span><br></pre></td></tr></table></figure>

<p>source ～&#x2F;.zprofile 即可。</p>
<p>然后配置一下阿里云仓库。在setting.xml文件中，要关注两个地方，<em><strong>localRepository</strong></em>和<em><strong>mirrors</strong></em>。第一个localRepository是你本地仓库所在的位置，你的包都会下载到这里，默认在你用户目录的.m2目录下，这里可以换成你想存放的地址。第二个mirror是你的包下载地址，因为有墙，所以建议增加阿里云仓库配置，来加速下载。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-创建maven-web项目"><a href="#2-创建maven-web项目" class="headerlink" title="2.创建maven web项目"></a>2.创建maven web项目</h4><p>新建maven项目时选中create from archetype，选择org.apache.maven.archetypes:maven-archetype-webapp。</p>
<p>选择自己maven的setting.xml。</p>
<p>配置tomcat服务器，选择tomcat-local，给服务器取名字，选版本端口号之类的。</p>
<p>deployment中artifact选择要部署的jar包，选exploded的。</p>
<p>选择热部署，在实际开发中是很管用的web开发，你后台，改了啥他就热部署，不用你重启tomcat，前台的也是，你修改jsp,css,js什么的都可以直接进行热部署，你只要自己刷新一下你的页面就行了。</p>
<h4 id="3-使用log4j集合slf4j"><a href="#3-使用log4j集合slf4j" class="headerlink" title="3.使用log4j集合slf4j"></a>3.使用log4j集合slf4j</h4><p>Apache Log4j是一个基于Java的日志记录工具，它的日志级别按下面顺序递减：</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>OFF</td>
<td>最高级别，用于关闭日志记录。</td>
</tr>
<tr>
<td>FATAL</td>
<td>将导致应用程序提前终止的严重错误的信息将立即呈现在日志上。</td>
</tr>
<tr>
<td>ERROR</td>
<td>将其他运行时错误或意外情况的信息呈现在日志上。</td>
</tr>
<tr>
<td>WARN</td>
<td>使用已过时的API，API的滥用，潜在错误，其他不良的或意外的运行时的状况（但不一定是错误的）</td>
</tr>
<tr>
<td>INFO</td>
<td>一些感兴趣的运行时事件（启动&#x2F;关闭</td>
</tr>
<tr>
<td>DEBUG</td>
<td>一些详细信息，查看程序的运行状态</td>
</tr>
<tr>
<td>TRACE</td>
<td>最详细的信息。一般这些信息只记录到日志文件中。</td>
</tr>
</tbody></table>
<h5 id="第一步：引入依赖"><a href="#第一步：引入依赖" class="headerlink" title="第一步：引入依赖"></a>第一步：引入依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0-alpha7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="第二步：配置log4j的配置文件"><a href="#第二步：配置log4j的配置文件" class="headerlink" title="第二步：配置log4j的配置文件"></a>第二步：配置log4j的配置文件</h5><p>其配置文件名为log4j.properties，<strong>需要手动在java&#x2F;resources下创建</strong>，如果建在其他位置，idea这个工具将无法识别。该配置文件用来设置记录器的级别、存放器和布局的，它可接key&#x3D;value格式的设置或xml格式的设置信息。通过配置，可以创建出Log4J的运行环境。</p>
<p>Log4J配置文件的基本格式如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### set log levels 配置根Logger###</span></span><br><span class="line"><span class="comment">### log4j.rootLogger  = [ level ] , appenderName1 , appenderName2 ,  … ###</span></span><br><span class="line"><span class="comment">###  level : 是日志记录的优先级 优先级从高到低分别是ERROR、WARN、INFO、DEBUG</span></span><br><span class="line"><span class="comment">###  比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来</span></span><br><span class="line"><span class="comment">### Appender 为日志输出目的地 这里 将debug层级及以上的信息输出到console和file，自己定义的名字  ###</span></span><br><span class="line"><span class="attr">log4j.rootLogger</span> = <span class="string">DEBUG,Console,File</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">###  输出到控制台  ###</span></span><br><span class="line"><span class="attr">log4j.appender.Console</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="attr">log4j.appender.Console.Target</span>=<span class="string">System.out</span></span><br><span class="line"><span class="attr">log4j.appender.Console.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.Console.layout.ConversionPattern</span>=<span class="string">[%d&#123;yy/MM/dd HH:mm:ss:SSS&#125;]-%l:%m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### 输出到日志文件 ###</span></span><br><span class="line"><span class="attr">log4j.appender.File</span>=<span class="string">org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="attr">log4j.appender.File.File</span>=<span class="string">$&#123;project&#125;src/main/resources/log/app.log</span></span><br><span class="line"><span class="attr">log4j.appender.File.MaxFileSize</span>=<span class="string">10MB</span></span><br><span class="line"><span class="attr">log4j.appender.File.Threshold</span>=<span class="string">ALL</span></span><br><span class="line"><span class="attr">log4j.appender.File.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.File.layout.ConversionPattern</span>=<span class="string">[%p][%d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125;][%c]%m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#   %m   输出代码中指定的消息</span></span><br><span class="line"><span class="comment">#　　%p   输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL</span></span><br><span class="line"><span class="comment">#　　%r   输出自应用启动到输出该log信息耗费的毫秒数</span></span><br><span class="line"><span class="comment">#　　%c   输出所属的类目，通常就是所在类的全名</span></span><br><span class="line"><span class="comment">#　　%t   输出产生该日志事件的线程名</span></span><br><span class="line"><span class="comment">#　　%n   输出一个回车换行符，Windows平台为“\r\n”，Unix平台为“\n”</span></span><br><span class="line"><span class="comment">#　　%d   输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss , SSS&#125;，输出类似：2002年10月18日  22 ： 10 ： 28 ， 921</span></span><br><span class="line"><span class="comment">#　　%l   输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: 10 )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Appender 为日志输出目的地，Log4j提供的appender有以下几种：</span></span><br><span class="line"><span class="comment">#org.apache.log4j.ConsoleAppender（控制台），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.FileAppender（文件），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Layout：日志输出格式，Log4j提供的layout有以下几种</span></span><br><span class="line"><span class="comment">#org.apache.log4j.HTMLLayout（以HTML表格形式布局），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.PatternLayout（可以灵活地指定布局模式），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</span></span><br></pre></td></tr></table></figure>

<p>当然，通过Threshold设置，可以把异常日志单独输出到一个文件中。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### set log levels ###</span></span><br><span class="line"><span class="attr">log4j.rootLogger</span> = <span class="string">debug ,  stdout ,  D ,  E</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### 输出到控制台 ###</span></span><br><span class="line"><span class="attr">log4j.appender.stdout</span> = <span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.Target</span> = <span class="string">System.out</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.layout.ConversionPattern</span> =  <span class="string">[%p][%d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125;][%c]%m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### 输出到日志文件 ###</span></span><br><span class="line"><span class="attr">log4j.appender.D</span> = <span class="string">org.apache.log4j.DailyRollingFileAppender</span></span><br><span class="line"><span class="attr">log4j.appender.D.File</span> = <span class="string">$&#123;project&#125;src/main/resources/log/app.log</span></span><br><span class="line"><span class="attr">log4j.appender.D.Append</span> = <span class="string">true</span></span><br><span class="line"><span class="attr">log4j.appender.D.Threshold</span> = <span class="string">DEBUG</span></span><br><span class="line"><span class="attr">log4j.appender.D.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.D.layout.ConversionPattern</span> = <span class="string">[%p][%d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125;][%c]%m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### 保存异常信息到单独文件 ###</span></span><br><span class="line"><span class="attr">log4j.appender.E</span> = <span class="string">org.apache.log4j.DailyRollingFileAppender</span></span><br><span class="line"><span class="attr">log4j.appender.E.File</span> = <span class="string">$&#123;project&#125;src/main/resources/log/error.log</span></span><br><span class="line"><span class="attr">log4j.appender.E.Append</span> = <span class="string">true</span></span><br><span class="line"><span class="attr">log4j.appender.E.Threshold</span> = <span class="string">ERROR</span></span><br><span class="line"><span class="attr">log4j.appender.E.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.E.layout.ConversionPattern</span> = <span class="string">[%p][%d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125;][%c]%m%n</span></span><br></pre></td></tr></table></figure>

<h5 id="第三步：编写测试类"><a href="#第三步：编写测试类" class="headerlink" title="第三步：编写测试类"></a>第三步：编写测试类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.PropertyConfigurator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Log4jDemo</span> &#123;</span><br><span class="line">    <span class="comment">//private static Logger logger = LoggerFactory.getLogger(Log4jTestDemo.class);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前项目的根目录</span></span><br><span class="line">        String relativelyPath=System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定properties文件位置</span></span><br><span class="line">        PropertyConfigurator.configure(relativelyPath+ <span class="string">&quot;/src/main/resources/conf/log4j.properties&quot;</span>);</span><br><span class="line">        <span class="comment">// 记录debug级别的信息</span></span><br><span class="line">        log.debug(<span class="string">&quot;This is debug message.&quot;</span>);</span><br><span class="line">        <span class="comment">// 记录info级别的信息</span></span><br><span class="line">        log.info(<span class="string">&quot;This is info message.&quot;</span>);</span><br><span class="line">        <span class="comment">// 记录error级别的信息</span></span><br><span class="line">        log.error(<span class="string">&quot;This is error message.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除非配置文件在resources目录下，否则不能自己找到配置文件的位置，还需要在代码中指定位置，低效！</p>
<p>这个问题貌似在spring中得到解决，在web.xml中增加配置：</p>
<p><a href="https://blog.csdn.net/HenryMrZ/article/details/79258057">https://blog.csdn.net/HenryMrZ/article/details/79258057</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>log4jConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:/conf/log4j.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="4-maven项目打包"><a href="#4-maven项目打包" class="headerlink" title="4.maven项目打包"></a>4.maven项目打包</h4><p>有个问题：web项目进行部署前，必须要将项目进行打包吗？</p>
<p>直接部署在tomcat，并没有在target文件夹下找到war包。</p>
<p>maven-web项目要使用servlet，就要导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>导入之后reimport一下pom.xml。</p>
<p>发现部署之后，原本的System.getProperty输出的项目目录变成了tomcat的bin目录。</p>
<h5 id="介绍一下System-getProperty"><a href="#介绍一下System-getProperty" class="headerlink" title="介绍一下System.getProperty()"></a>介绍一下System.getProperty()</h5><p>Java中给我们提供了System.getProperty()这个函数，这个函数可以获取到Java JVM以及操作系统的一些参数，可以供程序判断等。</p>
<p>System.getProperty()方法中需要传递一个字符串的参数，表示需要获取那个环境配置，获得结果为String。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.getProperty(<span class="string">&quot;java.vm.version&quot;</span>);<span class="comment">//java虚拟机版本  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;java.vendor.url&quot;</span>); <span class="comment">//java官方网站  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;java.vm.nam&quot;</span>); <span class="comment">//java虚拟机名称  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;user.country&quot;</span>); <span class="comment">//国家或地区  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;user.dir&quot;</span>); <span class="comment">//工程的路径  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;java.runtime.version&quot;</span>);<span class="comment">//java运行环境版本  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;os.arch&quot;</span>); <span class="comment">//操作系统位数（32或64）  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;os.name&quot;</span>); <span class="comment">//操作系统名称  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;sun.jnu.encoding&quot;</span>); <span class="comment">//编码格式  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;os.version&quot;</span>); <span class="comment">//操纵系统版本  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;java.version&quot;</span>); <span class="comment">//java版本版本</span></span><br></pre></td></tr></table></figure>

<p>那么如何找到路径下的log4j.properties配置文件呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> req.getServletContext().getRealPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">System.out.println(filePath); <span class="comment">// 文件存放的路径</span></span><br><span class="line"><span class="comment">// 指定properties文件位置</span></span><br><span class="line">PropertyConfigurator.configure(filePath + <span class="string">&quot;WEB-INF/classes/conf/log4j.properties&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="项目中target目录是什么？"><a href="#项目中target目录是什么？" class="headerlink" title="项目中target目录是什么？"></a>项目中target目录是什么？</h5><p>target是用来存放项目构建后的文件和目录、jar包、war包、编译的class文件，所有都是Maven构建时生成的。</p>
<p><a href="https://blog.51cto.com/zhangzhixi/5102490?b=totalstatistic">https://blog.51cto.com/zhangzhixi/5102490?b=totalstatistic</a></p>
<p>还有一个问题：tomcat运行之后，日志不保存在文件中了，难道是识别不了project目录了吗？</p>
<p>确实，log输出到了tomcat中的bin目录中。改成绝对目录。</p>
<h5 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h5><p>由于web项目没有写java文件没有main函数, 是无法直接运行的, 因此web项目需要放在一个容器里才能运行</p>
<p>这里就将web项目放在Tomcat这个web服务器里运行</p>
<p>基于maven的web项目 “ 打包、部署、使用” 操作步骤如下:</p>
<ol>
<li>打包：在IDEA主界面的右边找到maven, 在maven的生命周期Lifecycle下面找到package, 双击package命令进行运行。底下的控制台提示 BUILD SUCCESS 代表构建成功。构建成功之后, 根据控制台里提示的war包路径找到war的位置。</li>
<li>部署：”部署“ 操作      (部署就是手动把打包好的war包复制到tomcat-webapps下边)</li>
</ol>
<blockquote>
<p>不打jar包运行，tomcat文件夹下没有应用的痕迹啊。【todo】应该是把war包放在tomcat目录下和idea中启动不太一样。idea中需要idea一直在运行状态。但是idea中运行的也是tomcat？</p>
</blockquote>
<ol start="3">
<li><p>运行，首先将Tomcat加载到系统环境变量</p>
<blockquote>
<p>配置tomcat环境变量：</p>
<p>如果不配置的话，需要每次都进到tomcat的bin目录下运行startup.sh启动。</p>
<p>在 ～&#x2F;.zprofile 文件中增加  export PATH&#x3D;${PATH}:tomcat bin目录</p>
<p>​    语法：</p>
<p>​    ${}为占位符，${PATH} 和 $PATH等效</p>
<p>​    &#x3D;前后不能有空格</p>
<p>​    : 为分隔符（等同于windows环境变量中的 ; ）</p>
<p>​    PATH&#x3D;$PATH:xxx 可以理解为 “ PATH+&#x3D;xxx “（当然不能这么写）<br>​    PATH&#x3D;xxx:$PATH这种写法亦可，只是前后顺序的问题；</p>
<p>export -p 查看所有环境变量</p>
<ol>
<li>sudo su 申请权限</li>
<li>startup.sh            &#x2F;&#x2F;启动tomacat</li>
<li>shutdown.sh          &#x2F;&#x2F;关闭tomcat</li>
</ol>
</blockquote>
</li>
</ol>
<p>启动之后，好奇时一直在运行还是怎么的，应该是一直在运行。起个定时线程试一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">service.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">    log.info(<span class="string">&quot;Thread &#123;&#125;, now &#123;&#125;.&quot;</span>, Thread.currentThread(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>报不能用lambada表达式的错误，我改了level等级为8，打包时还报错。不用试了，只要tomcat开的，应用就一直是起的。每访问一次，log文件中就记录日志。</p>
<h3 id="maven打包"><a href="#maven打包" class="headerlink" title="maven打包"></a>maven打包</h3><h4 id="1-idea中使用maven插件打包"><a href="#1-idea中使用maven插件打包" class="headerlink" title="1.idea中使用maven插件打包"></a>1.idea中使用maven插件打包</h4><p>上面就是用此操作，应该先clean，再compile编译，再打包的。</p>
<p>mvn clean 清空class文件<br>mvn compile 编译<br>mvn package 打包<br>mvn test 测试<br>mvn install 打包并上传到本地仓库<br>mvn deploy 上传到远程仓库<br>mvn -Dmaven.test.skip&#x3D;true 跳过测试</p>
<p>pom中的插件应该是自动给我加的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>log-maven-package<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span><span class="comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-install-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  这种打包方式会有外部依赖包。</p>
<h4 id="2-直接使用mvn-package打包"><a href="#2-直接使用mvn-package打包" class="headerlink" title="2.直接使用mvn package打包"></a>2.直接使用mvn package打包</h4><p>不在 POM 中配置任何插件，直接使用 <code>mvn package</code> 进行项目打包，这对于没有使用外部依赖包的项目是可行的。但如果项目中使用了第三方 JAR 包，就会出现问题，因为 <code>mvn package</code> 打的 JAR 包中是不含有依赖包，会导致作业运行时出现找不到第三方依赖的异常。这种方式局限性比较大，因为实际的项目往往很复杂，通常都会依赖第三方 JAR。</p>
<p>大数据框架的开发者也考虑到这个问题，所以基本所有的框架都支持在提交作业时使用 <code>--jars</code> 指定第三方依赖包，但是这种方式的问题同样很明显，就是你必须保持生产环境与开发环境中的所有 JAR 包版本一致，这是有维护成本的。</p>
<p>基于上面这些原因，最简单的是采用 <code>All In One</code> 的打包方式，把所有依赖都打包到一个 JAR 文件中，此时对环境的依赖性最小。要实现这个目的，可以使用 Maven 提供的 <code>maven-assembly-plugin</code> 或 <code>maven-shade-plugin</code> 插件。</p>
<blockquote>
<p>我直接使用mvn package 报错误</p>
<p>[ERROR] No compiler is provided in this environment. Perhaps you are running on a JRE rather than a JDK?</p>
<p>未解决</p>
</blockquote>
<h4 id="3-maven-assembly-plugin插件"><a href="#3-maven-assembly-plugin插件" class="headerlink" title="3.maven-assembly-plugin插件"></a>3.maven-assembly-plugin插件</h4><p><code>Assembly</code> 插件支持将项目的所有依赖、文件都打包到同一个输出文件中。目前支持输出以下文件类型：</p>
<ul>
<li>zip</li>
<li>tar</li>
<li>tar.gz (or tgz)</li>
<li>tar.bz2 (or tbz2)</li>
<li>tar.snappy</li>
<li>tar.xz (or txz)</li>
<li>jar</li>
<li>dir</li>
<li>war</li>
</ul>
<p><strong>基本使用</strong></p>
<p>在 POM.xml 中引入插件，指定打包格式的配置文件 <code>assembly.xml</code>(名称可自定义)，并指定作业的主入口类：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目最终打包成的名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>community<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptors</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptor</span>&gt;</span>src/main/resources/assembly.xml<span class="tag">&lt;/<span class="name">descriptor</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptors</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 指定启动类 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.liuxuan.Log4jDemo<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>assembly.xml 文件内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">assembly</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/ASSEMBLY/2.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/ASSEMBLY/2.0.0 </span></span></span><br><span class="line"><span class="string"><span class="tag">                              http://maven.apache.org/xsd/assembly-2.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指明打包方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">formats</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">format</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">formats</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">includeBaseDirectory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">includeBaseDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencySets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencySet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>/<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">useProjectArtifact</span>&gt;</span>true<span class="tag">&lt;/<span class="name">useProjectArtifact</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">unpack</span>&gt;</span>true<span class="tag">&lt;/<span class="name">unpack</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这里以排除 storm 环境中已经提供的 storm-core 为例，演示排除 Jar 包--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.apache.storm:storm-core<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencySet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencySets</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>采用 maven-assembly-plugin 进行打包时命令如下：</p>
<p>mvn assembly:assembly </p>
<blockquote>
<p>问题：使用命令mvn compile 时，会报错 no compiler，但是idea中点击时没问题。所以得先点compile编译，再执行assembly命令。</p>
</blockquote>
<p>打包后会同时生成两个 JAR 包，其中后缀为 <code>jar-with-dependencies</code> 是含有第三方依赖的 JAR 包，后缀是由 <code>assembly.xml</code> 中 <code>&lt;id&gt;</code> 标签指定的，可以自定义修改。</p>
<h4 id="4-maven-shade-plugin插件"><a href="#4-maven-shade-plugin插件" class="headerlink" title="4.maven-shade-plugin插件"></a>4.maven-shade-plugin插件</h4><p><code>maven-shade-plugin</code> 比 <code>maven-assembly-plugin</code> 功能更为强大，比如你的工程依赖很多的 JAR 包，而被依赖的 JAR 又会依赖其他的 JAR 包，这样,当工程中依赖到不同的版本的 JAR 时，并且 JAR 中具有相同名称的资源文件时，shade 插件会尝试将所有资源文件打包在一起时，而不是和 assembly 一样执行覆盖操作。</p>
<p><strong>通常使用 <code>maven-shade-plugin</code> 就能够完成大多数的打包需求，其配置简单且适用性最广，因此建议优先使用此方式。</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目最终打包成的名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>community<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 指定启动类 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformer</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.ronz.community.CommunityApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">&lt;!-- 下面的配置仅针对存在同名资源文件的情况，如没有则不用配置--&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 有些项目包可能会包含同文件名的资源文件（例如属性文件）--&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 为避免覆盖，可以将它们的内容合并到一个文件中 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformer</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">resource</span>&gt;</span>META-INF/spring.handlers<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformer</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">resource</span>&gt;</span>META-INF/spring.schemas<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 maven-shade-plugin 进行打包的时候，打包命令和普通打包一样</p>
<p>mvn package</p>
<h4 id="5-使用-maven-jar-plugin-和-maven-dependency-plugin-插件"><a href="#5-使用-maven-jar-plugin-和-maven-dependency-plugin-插件" class="headerlink" title="5.使用 maven-jar-plugin 和 maven-dependency-plugin 插件"></a>5.使用 maven-jar-plugin 和 maven-dependency-plugin 插件</h4><p>此种打包方式有一个比较明显的缺点：打包后会在 <code>target</code> 目录下生成 <code>lib</code> 目录（存放依赖 Jar）和项目 Jar。也就是说由于依赖都存在于 <code>lib</code> 目录中，所以要想运行 Jar 包，必须将 Jar 包和 <code>lib</code>目录放在同一个路径下。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目最终打包成的名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>community<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 会在 MANIFEST.MF 中生成 Class-Path 项 --&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 系统会根据 Class-Path 项配置的路径加载依赖 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 指定依赖包所在目录，相对于项目最终 Jar 包的路径 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>lib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 指定 MainClass --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.ronz.community.CommunityApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置依赖包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 相当于执行 mvn 命令，将依赖打包到指定目录 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--将依赖打包至 target 下的 lib 目录--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个思想也比较简单。</p>
<p>首先说 maven-jar-plugin 插件，它的思想就是：指定启动类、指定依赖包相对于项目最终 Jar 包所在的路径、给 MANIFEST.MF 文件添加 Class-Path 属性（运行项目 Jar 包时会根据 Class-Path 属性来找到具体依赖 Jar 包的路径）。</p>
<p>接着是 maven-dependency-plugin 插件，它的主要思想就是：指定所有依赖被打包为 Jar 包后的存放路径。</p>
<p>pom.xml 文件配置完毕之后，就可以运行打包命令了：<br><em># 跳过测试用例执行 package 命令</em> mvn package -Dmaven.test.skip&#x3D;true</p>
<p>这种方式打包出来的 Jar 包，在代码层面只包含了项目本身的代码。而项目的依赖都以 Jar 包的形式放在了项目 Jar 包同级别目录下的 <code>lib</code> 目录中，这些依赖 Jar 包的路径在 <code>MANIFEST.MF</code> 文件中都以路径的方式指明了。</p>
<h4 id="打包总结"><a href="#打包总结" class="headerlink" title="打包总结"></a>打包总结</h4><p>工作中用到的命令只是：mvn package -Dmaven.test.skip&#x3D;true，但是看项目中貌似使用的是assembly。</p>
<p>推荐使用maven-shade-plugin插件，可以避免前面的资源文件被后面的覆盖掉。</p>
<p>只是mvn compile 这个问题还没解决，为什么idea中点击compile能够编译，终端执行命令却不行。</p>
<h3 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h3><p><a href="https://github.com/jadeliuliu/log-maven-package/tree/master">https://github.com/jadeliuliu/log-maven-package/tree/master</a></p>
<p>摘自：</p>
<p>slf4j、log4j、logback：<a href="https://www.cnblogs.com/javalinux/p/15683735.html">https://www.cnblogs.com/javalinux/p/15683735.html</a></p>
<p>log发展史：<a href="https://juejin.cn/post/7033021644142542878">https://juejin.cn/post/7033021644142542878</a></p>
<p>idea中创建maven web项目：<a href="https://www.cnblogs.com/weiqingfeng/p/9494914.html">https://www.cnblogs.com/weiqingfeng/p/9494914.html</a></p>
<p>mac区分.bash_profile 和&#x2F;etc&#x2F;profile：<a href="https://blog.csdn.net/weixin_42214743/article/details/116133257">https://blog.csdn.net/weixin_42214743/article/details/116133257</a></p>
<p>bash和zsh：<a href="https://www.zhihu.com/question/20036548/answer/2345481001">https://www.zhihu.com/question/20036548/answer/2345481001</a></p>
<p>log4j配置文件：<a href="http://www.blogjava.net/zJun/archive/2006/06/28/55511.html">http://www.blogjava.net/zJun/archive/2006/06/28/55511.html</a></p>
<p>maven项目打包部署到tomcat：<a href="https://blog.csdn.net/asdx1020/article/details/104554811">https://blog.csdn.net/asdx1020/article/details/104554811</a>   &amp;&amp;   <a href="https://blog.csdn.net/Shangxingya/article/details/107295800">https://blog.csdn.net/Shangxingya/article/details/107295800</a></p>
<p>常用maven打包方式：<a href="https://juejin.cn/post/6844904067194437639#heading-1">https://juejin.cn/post/6844904067194437639#heading-1</a>   &amp;&amp; <a href="https://blog.csdn.net/zhuxian1277/article/details/119880760">https://blog.csdn.net/zhuxian1277/article/details/119880760</a></p>
<h3 id="log日志怎么传参"><a href="#log日志怎么传参" class="headerlink" title="log日志怎么传参"></a>log日志怎么传参</h3><p>不同于String.format和sout，log使用占位符传参，就是{}，前面用:还是&#x3D;还是其他无所谓：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log.info(&quot;remind：orderInfo:&#123;&#125;&quot;, JSON.toJSONString(orderInfo));</span><br></pre></td></tr></table></figure>
<p>如果是log.error里面还有Exception对象，那么该怎么打印:<br>对于异常，是不需要占位符的，而且也不需要 e.getMessage()，直接打印出来即可.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">&#125; catch (Exeception e) &#123;</span><br><span class="line">    log.error(&quot;error in order:&#123;&#125;&quot;, JSON.toJSONString(orderInfo), e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="log日志级别开关"><a href="#log日志级别开关" class="headerlink" title="log日志级别开关"></a>log日志级别开关</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>ssm是什么</title>
    <url>/2022/06/25/myblog/java/ssm/</url>
    <content><![CDATA[<p>SSM框架：Spring + SpringMVC + MyBatis</p>
<p>Spring和SpringMVC是当前企业开发必用框架之一，MyBatis则是与数据库交互的持久层框架之一，由于易用性和轻便性，则被大多互联网公司所选用。SSM基础框架的掌握是当前企业开发最基本的要求，也是其他技术学习和进阶的必要基础。</p>
<p>b站视频地址：<a href="https://www.bilibili.com/video/BV1WZ4y1P7Bp?p=42">https://www.bilibili.com/video/BV1WZ4y1P7Bp?p=42</a></p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h3><p>MVC模式是什么？</p>
<p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p>
<ul>
<li><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。</li>
<li><strong>View（视图）</strong> - 视图代表模型包含的数据的可视化。</li>
<li><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</li>
</ul>
<p>SpringMVC概述？</p>
<p>SpringMVC是一种基于Java实现的MVC设计模型的请求驱动类型的轻量级Web框架，属于SpringFrameWork的后续产品，已经融合在Spring Web Flow中。</p>
<p>SpringMVC已经成为目前最主流的MVC框架之一，并且随着Spring3.0的发布，全面超越Structs2，成为最优秀的MVC框架。它通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful编程风格的请求。web文件夹内servelet？</p>
<h3 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h3><p>持久层框架，方便数据库操作的。</p>
<p>原始比较繁琐的jdbc操作：注册驱动–获得连接–获得statement–执行查询–遍历结果集（封装实体，传递）–释放资源。</p>
<p>缺点：代码重复（比如获得连接资源），资源频繁连接关闭，消耗资源，sql语句比较死，得解耦合，用配置文件。</p>
<p>jdbc缺点：（1）数据库创建、释放资源造成系统资源浪费从而影响系统性能。（2）sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码，耦合性高。（3）查询操作时，需要手动将结果集中的数据手动封装到实体中，插入操作时，需要手动将实体的数据设置到sql语句的占位符位置。</p>
<p>应对上述问题给出的解决方案：（1）使用数据库连接池初始化连接资源。（2）将sql语句抽到xml配置文件中。（3）使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射。</p>
<p>MyBatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程，</p>
<p>MyBatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中的sql的动态参数进行映射生成最终执行的sql语句。</p>
<p>MyBatis框架执行sql并将结果集映射为java对象并返回，采用ORM（对象关系映射）思想解决了实体和数据库映射的问题，对jdbc进行封装，屏蔽jdbc api底层访问细节，不与jdbc打交道就可以完成对数据库的持久化操作。</p>
<h3 id="mvc和servlet的关系"><a href="#mvc和servlet的关系" class="headerlink" title="mvc和servlet的关系"></a>mvc和servlet的关系</h3><p>1、Servlet与JSP一起为Web应用开发带来了巨大的贡献，后来出现的众多Java Web应用开发框架都是基于这两种技术的，更确切的说，都是基于Servlet技术的。</p>
<p>2、Springmvc的核心是一个DispatcherServlet，并且DispatcherServlet继承自 FrameworkServlet继承自HttpServletBean 继承自HttpServlet（也就是你说的servelt） 本质上是一样的东西。其实就是基于tomcat等这些web容器对我们的CS请求能做更多的事情，如校验，拦截（AOP思想），后期渲染等等，好让我们专注于业务的开发。</p>
<p>总结</p>
<p>1、servlet就是一个Java接口，是JavaEE规范的一种<br>2、Servlet容器也叫做Servlet引擎：全称server applet，意为服务程序。主要作用是给上级容器(Tomcat)提供doGet()和doPost()等方法。其生命周期实例化、初始化、调用、销毁受控于 Tomcat容器。<br>3、而Tcomcat、webLogic等web容器包含servlet容器。<br>4、Tomcat容器属于web容器的一种，web容器还包括weblogic容器、JBoss容器等。<br>5、web容器：可以部署多个WEB应用程序的环境。<br>6、Spring MVC （SpringBoot）其实就是基于tomcat等这些web容器对我们的CS请求能做更多的事情</p>
<p>转自：<a href="https://zhuanlan.zhihu.com/p/295173834">https://zhuanlan.zhihu.com/p/295173834</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》面向对象</title>
    <url>/2021/11/08/myblog/java/%E3%80%8AJava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B/</url>
    <content><![CDATA[<h2 id="Java开发入门"><a href="#Java开发入门" class="headerlink" title="Java开发入门"></a>Java开发入门</h2><p>Java是由Sun公司于1995年开发的可编写跨平台应用软件、完全面向对象的程序设计语言。2009年被Oracle公司收购。</p>
<h3 id="Java三个技术平台"><a href="#Java三个技术平台" class="headerlink" title="Java三个技术平台"></a>Java三个技术平台</h3><p>针对不同的开发市场，Sun公司将Java划分为三个技术平台。</p>
<p>（1）Java SE：（standard edition）Java平台标准版，为开发普通桌面和商务应用程序提供的解决方案，是三个平台中最核心的部分，Java EE和Java ME都是从Java SE的基础上发展而来，Java SE包括Java最核心的类库，如集合、IO、数据库连接及网络编程。</p>
<p>（2）Java EE：（enterprise edition）平台企业版，为开发企业级应用程序提供的解决方案，包括Servlet、JSP、JavaBean、EJB、Web Service等。用来做web开发的java框架。</p>
<p>（3）Java ME：（micro edition）平台微型版，为开发电子消费产品和嵌入式设备提供的解决方案，用于微型数字电子设备上软件程序的开发，例如家用电器增加智能化控制和联网功能，未手机增加游戏和通讯录管理功能。此外，还提供HTTP等协议，为移动电话提供Client&#x2F;Server方式访问Internet，提供无线交流。</p>
<p>不管哪个版本，都是java语言实现的一个框架。之所以要分版本，是因为3个版本是针对不同问题，设计的解决方案。</p>
<p>J2SE是标准版本，J2ME是手机方向的，J2EE是网站开发方向的。</p>
<h3 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h3><ul>
<li>简单易用：丢弃了c++中的：操作符重载、多继承、自动强制类型转换、不使用指针而是引用，提供自动分配和回收内存空间。</li>
<li>安全可靠：Java通常被用在网络环境中，为此，Java 提供了一个安全机制以防恶意代码的攻击。除了Java 语言具有的许多安全特性以外，Java 对通过网络下载的类具有一个安全防范机制（类 ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类 SecurityManager）让 Java 应用设置安全哨兵。</li>
<li>跨平台：通过JVM虚拟机在不同的操作系统上允许Java程序。</li>
<li>面向对象：将一切事物都看成对象，类、接口、继承。只支持类之间的单继承，支持接口之间的多继承，支持类与接口之间的实现机制（implements）。java全面支持动态绑定，c++只对虚函数使用动态绑定。</li>
<li>支持多线程：内置了多线程控制，可使用户程序并发执行。</li>
</ul>
<h3 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK&gt;JRE&gt;JVM"></a><strong>JDK&gt;JRE&gt;JVM</strong></h3><p><strong>JVM</strong> ：（Java Virtual Machine）， Java 虚拟机。它只认识 xxx.class 类型的文件，能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。jvm 是 Java 能够跨平台的核心。</p>
<p><strong>JRE</strong> ：（Java Runtime Environment），Java 运行时环境。主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。普通用户只需要JRE进行运行已经编译好的java程序，而不需要开发。</p>
<p><strong>JDK</strong> ：（Java Development Kit），Java 开发工具包。jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。例如：javac.exe（编译 java 源码的编译器 javac），java.exe（java运行工具），jar.exe（java打包工具），java文档生成工具 等很多 java 程序调试和分析的工具。</p>
<p>1996年推出jdk1.0，随后到1.5改变命名方式，jdk1.5&#x3D;jdk5.2017年jdk9，2018年jdk10.但是并不稳定。目前最多运用jdk8.</p>
<p>安装jdk时，安装开发工具（包括javac.exe、java.exe等，以及一个专用JRE环境），源代码（Java所有核心类库的源代码），公共JRE相当于多装一个JRE在其他路径，所以不需要。</p>
<p>JDK&#x3D;JRE(JVM+JAVA基本类库)+开发工具</p>
<h3 id="JDK目录"><a href="#JDK目录" class="headerlink" title="JDK目录"></a>JDK目录</h3><ul>
<li>bin目录：存放一些可执行程序，如javac.exe（java编译器）、java.exe（java运行工具）、jar.exe（打包工具）、javadoc.exe（文档生成工具）等。</li>
<li>db目录：纯java实现的支持JDBC4.0所有规范的小型数据库。</li>
<li>include目录：由于JDK是通过C和C++实现的，因此在启动时引入一些C语言的头文件，该目录就是存放这些头文件的。</li>
<li>jre目录：Java运行时环境的根目录，，包括java虚拟机、运行时的类包、java应用启动器以及一个bin目录，不包括开发环境中的开发工具。</li>
<li>lib目录：java类库或库文件，是开发工具使用的归档包文件。</li>
</ul>
<blockquote>
<p>javac.exe：编译器工具，将java文件编译成可执行的java字节码文件.class</p>
<p>java.exe：java运行工具，会启动一个java虚拟机进程，专门负责运行字节码文件</p>
</blockquote>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>目的：在任何位置都能够编译和运行java程序。</p>
<p>配置：PATH：用于告知操作系统去指定路径寻找JDK，CLASSPATH：告知JDK去指定路径查找类文件(.class文件)</p>
<p>当在命令窗口中运行一个可执行文件时，操作系统首先会在当前目录下寻找是否存在该文件，如果不存在，会在PATH环境变量中定义的路径下寻找这个文件。</p>
<h3 id="java运行机制"><a href="#java运行机制" class="headerlink" title="java运行机制"></a>java运行机制</h3><p>.java文件，</p>
<p>使用javac.exe即java编译器进行编译，</p>
<p>.class文件，</p>
<p>使用java命令开启Java虚拟机运行程序，java虚拟机首先将编译好的字节码文件加载到内存（类加载，由类加载器完成），然后虚拟机通过java解析器对加载到内存中的java类进行解释执行，</p>
<p>机器码文件，</p>
<p>计算机运行机器码文件。</p>
<blockquote>
<p>java程序是由java虚拟机负责解释执行的，而不是操作系统，因此跨平台。</p>
</blockquote>
<h3 id="类包"><a href="#类包" class="headerlink" title="类包"></a>类包</h3><p>import导包：import 包名.类名  &#x2F;  import 包名.*</p>
<p>java的核心类主要放在java包及其子包下。java扩展的大部分类在javax包及其子包下。</p>
<p>java.util：java的大量工具类、集合类，如Arrays、List、Set等</p>
<p>java.net：java网络编程相关的类和接口</p>
<p>java.io：java输入输出相关类和接口</p>
<p>java.awt：构建图形界面GUI的类和接口</p>
<p>java.sql：数据库编程</p>
<h2 id="Java编程基础"><a href="#Java编程基础" class="headerlink" title="Java编程基础"></a>Java编程基础</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行&#x2F;&#x2F;  多行&#x2F;*  *&#x2F;</p>
<p>文档注释：对某个类或类中的方法进行系统性解释说明。开发人员可使用JDK提供的javadoc工具将文档注释提取出来生成一份API帮助文档。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*  content</span><br><span class="line">*  content</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>包名：一律小写<br>类名、接口名：首字母大写<br>常量名：都大写下划线连接<br>变量名和方法名：一个单词首字母小写，后面首字母大写</p>
<h3 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h3><p>八种基本数据类型：<br>byte：是8位、有符号的，以二进制补码表示的整数；-128~127；<br>short：16位<br>int：32位<br>long：64位，所赋的值超过int的取值范围，则需要加L，long num&#x3D;10000000L;<br>float：单精度32位，小数默认为double类型，因此定义float型需要在后面加f&#x2F;F<br>double：双精度64位<br>boolean：布尔<br>char：字符，2个字节</p>
<p>引用数据类型：<br>引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型。变量一旦声明后，类型就不能被改变了。对象、数组都是引用数据类型。<br>所有引用类型的默认值都是null，表示没有指向任何对象。</p>
<p><code>char c=&#39;a&#39;</code> 和 <code>char c=97</code>一样。因为可以将char变量赋值为0-65535范围内的整数，计算机将整数自动转化为对应的字符。</p>
<h3 id="变量的类型转换"><a href="#变量的类型转换" class="headerlink" title="变量的类型转换"></a>变量的类型转换</h3><p>（1）自动类型转换（隐式类型转换）：将一个类型取值范围小的数值直接赋值给另一个取值范围大的数据类型变量。大壶装小壶。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte b=3;</span><br><span class="line">int x=b;</span><br><span class="line">double y=x;</span><br></pre></td></tr></table></figure>

<p>（2）强制类型转换（显式类型转换）：目标类型取值范围小于源类型。小壶装大壶。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte a;</span><br><span class="line">int b=298;</span><br><span class="line">a=(byte)b;   //结果a会变成42</span><br></pre></td></tr></table></figure>

<p>强制类型转换中可能丢失精度，例如int占用4个字节，而byte占用1个字节，298变二进制后只留下最低的八位。</p>
<p>（3）表达式类型自动提升：byte、short、char类型的变量在运算期间类型会自动提示为int类型，然后进行运算，因此在最后获得结果时需要强制类型转换。</p>
<p>（4）在使用+&#x3D;、-&#x3D;、*&#x3D;等运算符时，强制类型转换会自动完成。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>整形常量：二进制0b&#x2F;0B开头，八进制0开头，十六进制0x&#x2F;0X开头。</p>
<p>null：表示对象的引用为空。</p>
<p>需要用final关键字定义常量：<br><code>final int a=0</code></p>
<p>转义符<br>\r  回车符<br>\n  换行符<br>\t  制表符<br>\b  退格符，backspace<br>\后加&#39;或&quot;或\表示本身</p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选，可以不break而继续执行。</span></span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="comment">//你可以有任意数量的case语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">//可选，最后才看</span></span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>定义的三种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] nums=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span>[] nums=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">剖析：<span class="type">int</span>[] nums;  nums变量的类型是<span class="type">int</span>[]。</span><br><span class="line">nums会占用一块内存单元，nums=<span class="keyword">new</span> <span class="title class_">int</span>[]; 表示创建数组，并将数组的内存地址赋值给变量nums。在程序运行期间可以用变量nums来引用数组.</span><br></pre></td></tr></table></figure>

<p>多维数组：<code>String[][] str = new String[3][4];</code></p>
<p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>对数组进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">Arrays.sort(arr,<span class="number">1</span>,<span class="number">4</span>);  左闭右开</span><br></pre></td></tr></table></figure>

<h2 id="面向对象（上）"><a href="#面向对象（上）" class="headerlink" title="面向对象（上）"></a>面向对象（上）</h2><p>面向对象是把构成问题的事物按照一定规则划分为多个独立的对象，然后通过调用对象的方法来解决问题。</p>
<p>封装：将对象的属性和行为封装起来。</p>
<p>继承：描述类与类之间的关系，使得无须重新编写原有类的情况下对原有类的功能进行扩展。</p>
<p>多态：一个类中定义的属性和功能被其他类继承后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一方法所呈现出的多种不同行为特征。</p>
<p>类是对象的抽象，共同特征作为属性（成员变量），共同行为作为类的方法（成员方法）。对象是类的实例。</p>
<p>创建对象：<code>Person p=new Person();</code></p>
<p>第一步：<code>Person p;</code> 声明一个Person类型的变量p</p>
<p>第二步：<code>=new Person();</code>创建Person对象，并将Person对象在内存中的地址赋值给变量p，这样变量p便持有了对象的引用。</p>
<p>内存中，p变量存对象的地址，在栈内存，p是一个引用，指向真正的对象。对象创建在堆内存。</p>
<blockquote>
<p>栈内存：存放基本类型的变量和对象的引用变量。</p>
<p>堆内存：存放new创建的对象和数组。</p>
</blockquote>
<p>创建好对象后，可以通过对象的引用来访问对象的所有成员。对象引用.对象成员</p>
<p>也可以使用创建的对象本身来引用对象成员：<code>new Person().成员</code>。由于没有对象引用的存在，在完成一个对象成员的访问后，该对象变成垃圾对象。<strong>当对象没有被任何变量所引用就会变成垃圾。</strong></p>
<h3 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h3><p>访问控制级别由小到大：private→default→protected→public</p>
<ul>
<li>private（当前类访问级别）：该成员只能被该类的其他成员访问，其他类无法直接访问。</li>
<li>default（包访问级别）：不使用任何访问控制修饰符的话，就是default，表示这个类或者类的成员只能被本包中的其他类访问。</li>
<li>protected（子类访问级别）：成员能被同一包内的其他类访问，也能被不同包下该类的子类访问。</li>
<li>public（公共访问级别）：该类或类的成员能被所有的类访问，不管是否在同一包中。</li>
</ul>
<blockquote>
<p>如果一个java源文件中定义的所有类都没有public修饰符，那么这个源文件的文件名可以是一切合法的文件名。</p>
<p>如果java源文件中定义了一个public修饰的类，则源文件名必须与public修饰的类的类名一致。</p>
</blockquote>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>类的封装，是指将对象的属性隐藏在对象内部，设为private级别，不允许外部程序直接访问对象的内部信息，而通过类内public的方法（setxxx，getxxx）实现对内部信息的操作及访问。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>在实例化对象的同时为这个对象的属性进行赋值，可以通过构造方法来实现。</p>
<p>构造方法需要满足的三个条件：方法名与类名相同、在方法名的前面没有返回值类型的声明、方法中不能使用return返回一个值但是可以单独return来结束方法。</p>
<p>构造方法的重载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line">    TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java中每个类都至少有一个构造方法，如果一个类中没有显示地定义构造方法，系统会自动为这个类创建一个无参构造方法。但是一旦自己定义了有参的构造方法，系统将不再提供无参的构造方法。</p>
<blockquote>
<p>疑问：构造方法用来在实例化对象的时候为对象的成员变量赋值，而在定义类的时候，可以声明变量（不赋值）也可以定义变量（赋值），那么定义了变量之后，实例化对象，是给对象的成员赋初值了吗？应该是吧</p>
</blockquote>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>关键字this用来指代当前对象，用来在方法中访问对象的其他成员。</p>
<ul>
<li>通过this关键字调用成员变量，解决与局部变量名称冲突的问题。</li>
<li>通过this关键字调用成员方法。</li>
<li>通过this关键字调用构造函方法，构造方法是在实例化对象时被java虚拟机自动调用的，但是可以<strong>在一个构造方法中</strong>用<code>this(参数);</code>的形式来调用其他的构造方法。注意：只能在构造方法中用，且必须是构造方法中的第一条语句，且只能出现一次，而且不能在两个构造方法中相互调用。</li>
</ul>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>（1）静态变量</p>
<p>类内的数据成员被一个类的所有实例对象所共享时使用，例如学校学生的学校名。不必要在每个对象占用的空间中都声明这个对象，而是在对象之外的空间中声明一个变量供所有对象来共享。</p>
<p>注意：static关键字只能用于修饰成员变量，不能用于修饰局部变量。</p>
<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String schoolName;</span><br><span class="line">&#125;</span><br><span class="line">main函数中：</span><br><span class="line">Student.schoolName=<span class="string">&quot;daxue&quot;</span>;</span><br><span class="line">Student stu1=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">使用： stu1.schoolName</span><br></pre></td></tr></table></figure>

<p>（2）静态方法</p>
<p>希望在不创建对象的情况下就可以调用某个方法时使用。</p>
<p>访问方式：<code>类名.方法</code>    或    <code>实例对象名.方法</code></p>
<p>注意：在一个静态方法中只能访问用static修饰的成员，原因在于没有没sttaic修饰的成员需要先创建对象才能访问，而静态方法在被调用时可以不创建任何对象。</p>
<blockquote>
<p>思考：一个文件中可以有多个类，文件名叫public的类的名字，类内可以有public static main函数，有main函数的类得是public的?</p>
<p>static 的成员函数，只能访问static的成员（函数或变量），public static main函数中可以创建其他类的对象，然后访问其他非static类的成员。</p>
</blockquote>
<p>（3）静态代码块</p>
<p>static{…}  在类被加载时，静态代码块会执行，由于类只加载一次，因此静态代码块也只执行一次。通常使用静态代码块对类的成员变量进行初始化。第一次实例化对象时会加载类。</p>
<h2 id="面向对象（下）"><a href="#面向对象（下）" class="headerlink" title="面向对象（下）"></a>面向对象（下）</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>is a的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类在继承父类的时候，会自动拥有父类所有公共的成员。</p>
<p>java中只支持单继承，不允许多继承，一个类只能有一个直接父类。</p>
<h3 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h3><p>不能使用比父类中重写的方法更严格的访问权限，如父类的访问权限是public，子类方法不能是private。</p>
<p>也可以重新定义父类的属性。</p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>子类重写父类方法或重新定义父类属性后，子类对象无法直接访问他们，因此，用super访问。<code>super.成员变量/成员方法</code></p>
<p>还可以用super关键字来调用父类的构造方法。<code>super([参数1,参数2]);</code>但是，只能出现在子类构造方法的第一行，且只能出现一次。</p>
<p>注意：子类的构造方法中一定会调用父类的某个构造方法，可以通过super指定。如果没有super，则会默认调用父类无参的构造方法。因此，如果父类只定义了有参的构造方法，系统不给默认无参构造方法，就会出错。因此需要在父类添加无参构造方法，或者子类指定调用父类有参构造方法。</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>java中的Object类是所有类的父类，每个类都直接或间接地继承自该类，称为超类、基类、或根类。Object类中有一些自定义的方法。</p>
<p><code>对象名.toString()  </code>返回对象的字符串表示。</p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>不可更改，最终的意思。</p>
<p>（1）修饰类：不能被继承。</p>
<p>（2）修饰方法：不能被子类重写</p>
<p>（3）修饰变量：常量，只能被赋值一次。</p>
<p>final修饰的成员变量，必须在声明的同时进行赋值。</p>
<p>final修饰的局部变量，可以先声明，再进行一次赋值。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>例如在定义Animal类时，shout()方法无法明确表示，java提供抽象方法来使得其无需提供方法的具体实现。</p>
<p>抽象方法：<code>public abstract void shout();</code>没有大括号</p>
<p>包含抽象方法的类一定是抽象类，class前加abstract，但是抽象类中可以不包含抽象方法。</p>
<p>抽象类不能被实例化，只能创建子类，并在子类中实现抽象类中的抽象方法。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是一种特殊的抽象类，它不包含普通方法，内部所有方法都是抽象方法。</p>
<p>JDK8中对接口进行了重新定义，接口中除了抽象方法外，可以有default修饰的默认方法，static修饰的静态方法，这两种方法都允许有方法体。</p>
<p>用interface修饰，可以extends多个接口。接口内部可以有final常量，定义常量时必须进行初始化赋值。</p>
<p>小提示：定义常量时<code>public static final</code>可省略，定义方法时<code>public abstract</code>可省略</p>
<p>调用静态方法：<code>接口名.方法名</code></p>
<p>调用抽象方法和默认方法需要通过接口实现类的实例对象来调用。默认方法不需要子类中实现。</p>
<p><code>public interface Hockey extends Sports, Event</code>   接口的多继承</p>
<p>一个类可以在继承一个类的同时实现多个接口：<code>public class 类名 extends 类名 implements 接口1，接口2</code>  ，extend需要在前面</p>
<blockquote>
<p>注意：如果一个类通过implement实现接口，如果该类是抽象类，则可以实现接口中的部分抽象方法，如果不是抽象类，则需要实现接口中的所有抽象方法。</p>
</blockquote>
<p>总结：类继承类（只能继承一个类，但同时可以实现多个接口），接口继承接口（可一次继承多个接口），类实现接口（可一次实现多个接口）</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指一个类中定义的属性和方法被其他类继承或重写后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一方法所呈现的多种不同形态。</p>
<p>把子类对象直接赋值给父类引用变量时，程序只有在运行时才知道该引用变量具体代表哪个子类对象。</p>
<h3 id="对象的类型转换"><a href="#对象的类型转换" class="headerlink" title="对象的类型转换"></a>对象的类型转换</h3><p>子类对象当作父类类型使用：向上转型</p>
<p><code>Animal an1=new Cat();</code>   不需要任何显示声明，但是不能通过父类变量去调用子类特有的方法。</p>
<p>要想使用子类特有的方法，需要将本质为Cat类型的an1对象由Animal类型向下转型为Cat类型。</p>
<p><code>Cat cat=(Cat)an1;</code> 就可以用cat变量来调用子类特有方法了。</p>
<p><code>instanceof</code>关键字，用来判断一个对象是否为某个类或接口的实例或子类实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Animal an1=new Cat();</span><br><span class="line">if(an1 instanceof Cat)&#123;</span><br><span class="line">    Cat cat=(Cat)an1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>java中允许一个类的内部定义类，这样的类叫内部类。内部类所在类叫外部类。根据内部类的位置、修饰符、定义方式的不同分为四种。</p>
<p>（1）成员内部类</p>
<p>像成员变量、成员方法一样的存在，在成员内部类中，可以访问外部类的所有成员。在外部类中，可以访问成员内部类的成员。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外部类访问内部类的成员：</span><br><span class="line">Inner inner = new Inner();</span><br><span class="line">inner.成员</span><br><span class="line">在与外部类平行的类中：</span><br><span class="line">Outer out = new Outer();  创建外部类对象</span><br><span class="line">Outer.Inner in = new Inner();   创建内部类对象</span><br></pre></td></tr></table></figure>

<p>（2）局部内部类</p>
<p>也叫方法内部类，是定义在某个方法内的，有效范围仅限于方法内部。</p>
<p>局部内部类可以访问外部类所有成员，而只有在包含局部内部类的方法中才可以访问内部类的成员。</p>
<p>（3）静态内部类</p>
<p>使用static关键字修饰的成员内部类，静态内部类只能访问外部类的静态成员.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在与外部类平行的类中：</span><br><span class="line">Outer.Inner inner = new Outer.Inner();</span><br><span class="line">inner.成员</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般在刷题时，定义Solution类，类内定义成员方法实现算法。测试时，定义另一个类，类内main函数中输入输出，然后定义对象<code>Solution s = new Solution();</code>通过对象访问算法方法。</p>
</blockquote>
<p>（4）匿名内部类</p>
<p>在java中调用某个方法时，如果该方法的参数是一个接口类型，除了可以传入一个参数接口实现类，还可以使用匿名内部类实现接口来作为该方法的参数。</p>
<p>匿名内部类就是没有名称的内部类，在调用包含有接口类型参数的方法时，通常为了简化代码，不会创建一个接口的实现类作为方法参数传入，而是直接通过匿名内部类的形式传入一个接口类型参数，在匿名内部类中直接完成方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义动物类接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		String name=<span class="string">&quot;maomao&quot;</span>;</span><br><span class="line">		<span class="comment">//定义匿名内部类作为参数传递给animalShout方法</span></span><br><span class="line">		animalShout(<span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">		    <span class="comment">//匿名内部类中实现shout方法</span></span><br><span class="line">		    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>&#123;</span><br><span class="line">		    	<span class="comment">//JDK8开始，局部内部类、匿名内部类可以访问非final的局部变量</span></span><br><span class="line">		    	System.out.println(name+“喵喵”)；</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;)；</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义静态方法animalShout(),接收接口类型参数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">animalShout</span><span class="params">(Animal an)</span>&#123;</span><br><span class="line">		an.shout(); <span class="comment">//调用传入对象的shout()方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分两步：</p>
<p>第一步 <code>animalShout(new Animal()&#123;&#125;)</code> 参数位置创建一个实例对象，表示创建的对象为Animal的子类实例，该子类是匿名的。</p>
<p>第二步<code>&#123;&#125;</code>中编写匿名子类的实现代码。</p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda 表达式，也可称为<strong>闭包</strong>，它是推动 Java 8 发布的最重要新特性。它使用一个清晰简洁的表达式来表达一个接口。</p>
<p>匿名内部类存在一个问题：如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然冗余。</p>
<p>Lambda表达式针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br><span class="line">可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</span><br><span class="line">可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</span><br><span class="line">可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</span><br><span class="line">可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，return可省略</span><br></pre></td></tr></table></figure>

<p>上面的例子，用lambda表达式来做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">animalShout(()-&gt;System.out.println(name+“喵喵”);)</span><br></pre></td></tr></table></figure>

<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>Lambda表达式可以实现匿名内部类的功能，但是局限在于接口中只有一个抽象方法时才能使用Lambda表达式代替匿名内部类。</p>
<p>因为Lambda表达式是基于函数式接口实现的，函数式接口就是只有一个抽象方法的接口。</p>
<p>JDK8中专门为函数式接口引入@FunctionalInterface注解，显示地标识接口是一个函数式接口，如果不是编译器就会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Calculate</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		showSum(<span class="number">10</span>, <span class="number">20</span>, (x,y)-&gt;x+y);  <span class="comment">//实现方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建参数为接口的方法</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showSum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, Calculate cu)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;和为：&quot;</span>+cu.sum(x, y));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda表达式的引用形式"><a href="#Lambda表达式的引用形式" class="headerlink" title="Lambda表达式的引用形式"></a>Lambda表达式的引用形式</h3><p>Lambda表达式的主体只有一条语句时，程序可通过<code>：：</code>的语法格式来引用方法和构造器。本质是对Lambda表达式的主体部分已存在的方法进行直接引用。</p>
<p>相当于calc方法需要实现，而又现成的abs方法可以用。</p>
<p>（1）类名引用普通方法&#x2F;静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Calculate</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含静态方法的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Math</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(num&lt;<span class="number">0</span>)  <span class="keyword">return</span> -num;</span><br><span class="line">		<span class="keyword">else</span>  <span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printAbs</span><span class="params">(<span class="type">int</span> num, Calculate cu)</span>&#123;</span><br><span class="line">		System.out.println(cu.calc(num));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//使用lambda表达式</span></span><br><span class="line">		printAbs(-<span class="number">10</span>, n-&gt;Math.abs(n));</span><br><span class="line">		<span class="comment">//使用方法引用</span></span><br><span class="line">		printAbs(-<span class="number">10</span>, Math::abs);  类名::类静态方法/普通方法名</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）对象名引用方法</p>
<p>也可以通过实例化对象的名称来对其方法进行引用。是普通方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math ma = new Math();</span><br><span class="line">printAbs(-10, n-&gt;ma.abs(n));</span><br><span class="line">printAbs(-10,ma::abs);</span><br></pre></td></tr></table></figure>

<p>（3）构造器引用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonBuilder</span>&#123;</span><br><span class="line">	Person <span class="title function_">buildPerson</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个Person类，并添加有参构造方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">(String name, PersonBuilder bu)</span>&#123;</span><br><span class="line">		System.out.println(bu.buildPerson(name).getName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//使用lambda表达式   ()-&gt;new 类名()</span></span><br><span class="line">		printAbs(<span class="string">&quot;张三&quot;</span>, name-&gt;<span class="keyword">new</span> <span class="title class_">Person</span>(name));</span><br><span class="line">		<span class="comment">//使用方法引用    类名::new</span></span><br><span class="line">		printAbs(<span class="string">&quot;张三&quot;</span>, Person::<span class="keyword">new</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>java语言引入了异常，以异常类的形式对正常情况进行封装。</p>
<p>异常类都继承自java.lang.Throwable类。</p>
<p>Throwable有两个直接子类Error和Exception。</p>
<p>其中Error称为错误类，代表Java运行时产生的系统内部错误或资源耗尽的错误，如系统崩溃、虚拟机错误。</p>
<p>Exception类称为异常类，标识程序本身可以处理的错误，异常处理都是针对该类及其子类。RuntimeException表示运行时异常，其他表示编译时异常。</p>
<p>Throwable类中常用的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String getMessage()</span><br><span class="line">返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</span><br><span class="line">public void printStackTrace()</span><br><span class="line">打印toString()结果和栈层次到System.err，即错误输出流。</span><br><span class="line">public Throwable getCause()</span><br><span class="line">返回一个Throwable 对象代表异常原因。</span><br></pre></td></tr></table></figure>

<p>运行时异常是在程序运行时由Java虚拟机自动进行捕获处理的。例如数组越界。</p>
<h3 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在除法方法中：</span><br><span class="line">try&#123;</span><br><span class="line">   可能发生异常的语句</span><br><span class="line">&#125;catch(Exception类或其子类 e1)&#123;</span><br><span class="line">   对捕获的异常进行相应的处理</span><br><span class="line">   System.out.println(&quot;异常：&quot;+e1.getMessage());</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	无论程序是否异常都会执行的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try{}中的代码块发生异常，系统会将这个异常的信息封装成一个异常对象，传递给catch(){}代码块，catch代码块需要一个参数指明它所能接收的异常类型，必须是Exception类或其子类。</p>
<p>finally{}中的代码不受return语句和程序异常的影响，可以用来完成必须要做的事，例如释放系统资源、关闭线程池等。但是在try…catch…代码块中执行了<code>System.exit(0)</code>语句的话，finally不会执行，因为<code>System.exit(0)</code>表示退出当前的java虚拟机。</p>
<h3 id="throws关键字"><a href="#throws关键字" class="headerlink" title="throws关键字"></a>throws关键字</h3><p>用于将异常从当前方法中抛出，throws写在方法声明的后面，后跟声明方法中发生异常的类型，这种做法叫做方法申明抛出一个异常。一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int divide(int x, int y) throws Exception&#123;</span><br><span class="line">	int res=x/y;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了throws后，还需要再出现异常的代码（main中）处使用try…catch…代码块进行捕获处理。</p>
<h3 id="throw关键字"><a href="#throw关键字" class="headerlink" title="throw关键字"></a>throw关键字</h3><p>throw用于方法体内，并且抛出的是一个异常类对象。</p>
<p>通过throw关键字抛出异常后，还需要try…catch…或throws关键字对异常进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void deposit(double amount) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">  if(判断)&#123;</span><br><span class="line">      throw new Exception(&quot;异常&quot;); //可以用来指示异常信息</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throw抛出异常对象，然后通过throws关键字抛出异常，最后通过try…catch…语句捕获异常。</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>java允许用户自定义异常，但自定义的异常类必须继承自Exception或其子类。在构造方法中使用super()语句调用Exception的构造方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 	<span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>();  <span class="comment">//调用无参构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(message);  <span class="comment">//调用有参构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>java提供垃圾回收机制（Java GC），虚拟机会自动回收垃圾对象所占用的内存空间。</p>
<p>当一个对象在堆内存中运行时，根据它被引用变量所引用的状态，可以把它所处的状态分为三种：</p>
<p>（1）可用状态：对象被创建后，有一个以上的引用变量引用它，那么这个对象在程序中将处于可用状态，程序可以通过引用变量来调用该对象的实例变量和方法。</p>
<p>（2）可恢复状态：程序中某个对象不再有任何引用变量引用它，它就进入了可恢复状态。系统准备回收，回收之前会调用可恢复状态对象的<code>finalize()</code>方法进行资源清理。如果在调用<code>finalize()</code>方法之前重新使一个引用变量引用该对象，则这个对象会再次变为可用对象。</p>
<p>（3）不可用状态：调用<code>finalize()</code>方法后，对象进入不可用状态，内存被清理。</p>
<blockquote>
<p>一个对象在失去引用成为垃圾后，会暂时保存在内存中，垃圾堆积到一定程度时，java虚拟机会启动垃圾回收器将这些垃圾对象从内存中释放，也就说回收的时机无法把握。</p>
</blockquote>
<p>强制系统进行垃圾回收的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.gc();</span><br><span class="line">或：</span><br><span class="line">Runtime.getRuntime().gc();</span><br></pre></td></tr></table></figure>

<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><p>当一个对象在内存中被释放时，它的<code>finalize()</code>方法会自动调用，<code>finalize()</code>方法是定义在Object类中的实例方法，方法原型：</p>
<p><code>protected void finalize() throws Throwable&#123;&#125;</code></p>
<p>任何java类都可以重写Object类的<code>finalize()</code>方法，在该方法中清理对象占用的资源。重写实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">	public void finalize()&#123;</span><br><span class="line">		System.out.println(&quot;d&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>servlet入门</title>
    <url>/2022/03/19/myblog/java/servlet/</url>
    <content><![CDATA[<h3 id="1-Http协议"><a href="#1-Http协议" class="headerlink" title="1.Http协议"></a>1.Http协议</h3><p>HTTP协议的特点<br>1.支持客户 &#x2F; 服务器模式 	<br>2.简单快速<br>3.灵活<br>4.无连接，HTTP1.1 版本后支持可持续连接<br>5.无状态</p>
<p>HTTP url:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//host[:port]/[abs_path]</span></span><br><span class="line">http:<span class="comment">//IP(主机名/域名):端口/访问的资源路径</span></span><br></pre></td></tr></table></figure>

<ul>
<li>http 表示通过HTTP协议来定位网络资源</li>
<li>host 表示合法的 Internet 主机名或者 ip 地址</li>
<li>port 指一个端口号，为空则为 80</li>
<li>abs_path 指定请求的 URL</li>
</ul>
<h4 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h4><ul>
<li>http请求由请求行、<strong>请求头</strong>、请求正文组成。<ul>
<li>请求体第一行就是请求行；请求行由请求方式，请求路径、请求协议版本三部分组成</li>
<li>请求头指一行一行的键值对</li>
<li>正文即是内容；GET请求没有正文，其内容直接跟在地址后面</li>
</ul>
</li>
</ul>
<h4 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h4><ul>
<li>在接收和解释请求消息后，服务器返回一个 HTTP 响应消息。HTTP 响应由状态行、消息报头、响应正文组成<ul>
<li>状态行由协议版本、状态码、请求结果组成</li>
<li>消息报头与请求头大致相同</li>
<li>响应正文就是浏览器呈现的内容</li>
</ul>
</li>
</ul>
<h4 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h4><p>  HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成，请求消息和响应消息都是由开始行（对于请求消息， 开始行就是请求行；响应消息则是状态行），消息报头，空行，消息正文（可选）组成</p>
<p>  每一个报头域都是由 名字+”:”+空格+值 组成，消息报头域的名字是大小写无关的</p>
<p>1.请求头：</p>
<p>  请求报头允许客户端向服务器传递请求的附加信息以及客户端自身的信息，无法通过参数来传递的用请求头。</p>
<ul>
<li><p>referer： 该请求头指明请求从哪里来</p>
<p> 此请求头后面接的值为上一个页面的URL地址，通常用来做统计、防盗链。如果是从浏览器地址栏直接输入进行访问的，都没有该请求头。例如百度的广告，搜一个东西，出现广告字样的连接，点击会记录是从百度搜索进来的。例如邀请好友，用来记录是谁邀请进来的。例如从a页面到d页面，必须要经过b页面和c页面，防盗链。</p>
</li>
</ul>
<p>2.响应头</p>
<p>  响应报头允许服务器传递不能放在状态行中的附加响应消息，以及关于服务器的信息和对Request-URL所标识的资源进行下一步访问的信息</p>
<ul>
<li>location（重定向）：location 响应报头域用于重定向接收者到一个新位置</li>
</ul>
<p>  location响应报头域，常用在服务器更换域名时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>refresh：第一种是定时自动跳转到 [url]指定的页面（单位为秒）（307重定向过来的），可以在html页面通过meta标签实现，也可以在后台实现；第二种是不带 [url] 是指每 [content] 秒刷新一次页面</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;refresh&quot;</span> content=<span class="string">&quot;3;url=http://www.baidu.com&quot;</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2-servlet概述"><a href="#2-servlet概述" class="headerlink" title="2.servlet概述"></a>2.servlet概述</h3><p>Servlet 是 Server 与 Applet 的缩写，是服务端小程序的意思。使用 Java 语言编写的服务器端程序，可以生成动态的 WEB 页，Servlet 主要运行在服务器端，并由服务器调用执行， 是一种按照 Servlet 标准来开发的类。 是 SUN 公司提供的一门用于开发动态 Web 资源的技术。（言外之意：要实现 web 开发，需要实现 Servlet 标准）</p>
<p>Servlet 本质上也是 Java 类，但要遵循 Servlet 规范进行编写，没有 main()方法，它的创建、使用、销毁都由 Servlet容器进行管理(如 Tomcat)。（言外之意：写自己的类，不用写 main 方法，别人自动调用）</p>
<p>Servlet 是和 HTTP 协议是紧密联系的，其可以处理 HTTP 协议相关的所有内容。这也是 Servlet 应用广泛的原因之一。<br>提供了 Servlet 功能的服务器，叫做 Servlet 容器，其常见容器有很多，如 Tomcat, Jetty, WebLogic Server, WebSphere, JBoss 等等。</p>
<p><strong>tomcat和servlet的关系</strong></p>
<p>Tomcat 是Web应用服务器,是一个Servlet&#x2F;JSP容器. Tomcat 作为Servlet容器,负责处理客户请求,把请求传送给Servlet,并将Servlet的响应传送回给客户.而Servlet是一种运行在支持Java语言的服务器上的组件。</p>
<h3 id="3-使用servlet"><a href="#3-使用servlet" class="headerlink" title="3.使用servlet"></a>3.使用servlet</h3><h4 id="3-1-新建web项目"><a href="#3-1-新建web项目" class="headerlink" title="3.1.新建web项目"></a>3.1.新建web项目</h4><p>创建web工程，java enterprise - web application，引入jdk、tomcat。</p>
<h4 id="3-2-实现servlet规范"><a href="#3-2-实现servlet规范" class="headerlink" title="3.2.实现servlet规范"></a>3.2.实现servlet规范</h4><p>实现 Servlet 规范，即继承 HttpServlet 类（tomcat里的jar包支持的），该类中已经完成了通信的规则，我们只需要进行业务的实现即可。</p>
<p><strong>重写 service 方法</strong><br>满足 Servlet 规范只是让我们的类能够满足接收请求的要求，接收到请求后需要对请求进行分析，以及进行业务逻辑处理，计算出结果，则需要添加代码，在规范中有一个叫做 service的方法，专门用来做请求处理的操作，业务代码则可以写在该方法中。</p>
<p><strong>通过注解设置路径</strong></p>
<p>在完成好了一切代码的编写后，还需要向服务器说明，特定请求对应特定资源。</p>
<p>开发servlet项目，使用@WebServlet将一个继承于javax.servlet.http.HttpServlet 的类定义为Servlet组件。在Servlet3.0 中 ， 可以使用@WebServlet注解将一个继承javax.servlet.http.HttpServlet的类标注为可以处理用户请求的Servlet。</p>
<blockquote>
<p>javax.servlet下面有两个servlet-api，一个是servlet-api，这个定义了servlet规范，一个是javax.servlet-api，这个是serlvet提供的api。<br>@WebServlet这个注解是在javax.servlet-api依赖包里</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name可写可不写，value过滤器会拦截，urlPatterns过滤器不会拦截</span><br><span class="line"><span class="meta">@WebServlet(name=&quot;Servlet01&quot;,value=&quot;/ser01&quot;)</span> </span><br><span class="line"><span class="meta">@WebServlet(name=&quot;Servlet01&quot;,urlPatterns = &quot;/ser01&quot;)</span></span><br><span class="line">也可以配置多个路径：</span><br><span class="line"><span class="meta">@WebServlet(name=&quot;Servlet01&quot;,value=&#123;&quot;/ser01&quot;,&#x27;/ser001&#x27;&#125;)</span> </span><br><span class="line"><span class="meta">@WebServlet(name=&quot;Servlet01&quot;,urlPatterns=&#123;&quot;/ser01&quot;,&#x27;/ser001&#x27;&#125;)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-19 17:00</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Servlet!&quot;</span>);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-发布项目并启动服务"><a href="#3-3-发布项目并启动服务" class="headerlink" title="3.3.发布项目并启动服务"></a>3.3.发布项目并启动服务</h4><p>到此，需要编写和配置的地方已经完成，项目已经完整了，但是如果需要外界能够访问， 还需要将项目发布到服务器上并运行服务器。</p>
<p>设置tomcat配置，设置项目的站点名（项目对外访问路径）</p>
<p>配置中选deployment更改站点名。</p>
<p>然后启动就可以访问页面。</p>
<p><a href="http://localhost:8080/servlet_demo/ser01">http://localhost:8080/servlet_demo/ser01</a></p>
<p>tomcat有个绿点表示正在运行。</p>
<h3 id="4-servlet工作流程"><a href="#4-servlet工作流程" class="headerlink" title="4.servlet工作流程"></a>4.servlet工作流程</h3><p>1.通过请求头获知浏览器访问的是哪个主机</p>
<p>2.再通过请求行获取访问的是哪个一个web应用</p>
<p>3.再通过请求行中的请求路径获知访问的是哪个资源</p>
<p>4.通过获取的资源路径在配置中匹配到真实的路径</p>
<p>5.服务器会创建servlet对象，（如果是第一次访问时，创建servlet实例，并调用init方法进行初始化操作）</p>
<p>6.调用service（request， response）方法来处理请求和响应的操作</p>
<p>7.调用service完毕后返回服务器，由服务器将response缓冲区的数据取出，以http响应的格式发送给浏览器</p>
<h3 id="5-servlet工作模式"><a href="#5-servlet工作模式" class="headerlink" title="5.servlet工作模式"></a>5.servlet工作模式</h3><ul>
<li>客户端发送请求至服务器</li>
<li>服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器</li>
<li>服务器将响应返回客户端</li>
</ul>
<h3 id="6-servlet生命周期"><a href="#6-servlet生命周期" class="headerlink" title="6.servlet生命周期"></a>6.servlet生命周期</h3><p>Servlet没有 main()方法，不能独立运行，它的运行完全由 Servlet 引擎来控制和调度。 所谓生命周期，指的是servlet 容器何时创建 servlet 实例、何时调用其方法进行请求的处理、 何时并销毁其实例的整个过程。</p>
<ol>
<li>实例和初始化时机（类加载和实力化）<br>当请求到达容器时，容器查找该 servlet 对象是否存在，如果不存在，则会创建实例并进行初始化。</li>
<li>就绪&#x2F;调用&#x2F;服务阶段<br>有请求到达容器，容器调用 servlet 对象的 service()方法,处理请求的方法在整个生命周期中可以被多次调用；<br>HttpServlet 的 service()方法，会依据请求方式来调用 doGet()或者 doPost()方法。但是， 这两个 do 方法默认情况下，会抛出异常，需要子类去 override。</li>
<li>销毁时机<br>当容器关闭时（应用程序停止时），会将程序中的 Servlet 实例进行销毁。</li>
</ol>
<p>上述的生命周期可以通过 Servlet 中的生命周期方法来观察。在 Servlet 中有三个生命周 期方法，不由用户手动调用，而是在特定的时机由容器自动调用，观察这三个生命周期方法 即可观察到 Servlet 的生命周期。</p>
<p>1⃣️ init 方法，在 Servlet 实例创建之后执行（证明该 Servlet 有实例创建了）</p>
<p>2⃣️service 方法，每次有请求到达某个 Servlet 方法时执行，用来处理请求（证明该Servlet 进行服务了）</p>
<p>3⃣️destroy 方法，Servlet 实例销毁时执行（证明该 Servlet 的实例被销毁了）</p>
<p>Servlet 的生命周期，简单的概括这就分为四步：servlet 类加载–&gt;实例化–&gt;服务–&gt;销毁。<br>下面描述一下 Tomcat 与 Servlet 是如何工作的,看看下面的时序图：</p>
<p><img src="/images/servlet%E6%97%B6%E5%BA%8F%E5%9B%BE.png"></p>
<ol>
<li>Web Client 向 Servlet 容器（Tomcat）发出 Http 请求</li>
<li>Servlet 容器接收 Web Client 的请求</li>
<li>Servlet 容器创建一个 HttpServletRequest 对象，将 Web Client 请求的信息封装到这个对象 中</li>
<li>Servlet 容器创建一个 HttpServletResponse 对象</li>
<li>Servlet 容器调HttpServlet 对象service 方法，把 Request 与 Response 作为参数，传给 HttpServlet</li>
<li>HttpServlet 调用 HttpServletRequest 对象的有关方法，获取 Http 请求信息</li>
<li>HttpServlet 调用 HttpServletResponse 对象的有关方法，生成响应数据</li>
<li>Servlet 容器把 HttpServlet 的响应结果传给 Web Client</li>
</ol>
<h3 id="7-形参：HttpServletRequest对象"><a href="#7-形参：HttpServletRequest对象" class="headerlink" title="7.形参：HttpServletRequest对象"></a>7.形参：HttpServletRequest对象</h3><p>HttpServletRequest 对象：主要作用是用来接收客户端发送过来的请求信息，例如：请求的参数，发送的头信息等都属于客户端发来的信息，service()方法中形参接收的HttpServletRequest 接口的实例化对象，表示该对象主要应用在 HTTP 协议上，该对象是由 Tomcat 封装好传递过来。</p>
<p>HttpServletRequest 是 ServletRequest 的子接口，ServletRequest 只有一个子接口，就是 HttpServletRequest。既然只有一个子接口为什么不将两个接口合并为一个？<br>从长远上讲：现在主要用的协议是 HTTP 协议，但以后可能出现更多新的协议。若以后想要支持这种新协议，只需要直接继承 ServletRequest 接口就行了。</p>
<p>在 HttpServletRequest 接口中，定义的方法很多，但都是围绕接收客户端参数的。但是怎么拿到该对象呢？不需要，直接在 Service 方法中由容器传入过来，而我们需要做的就是取出对象中的数据，进行分析、处理。</p>
<h4 id="接收请求"><a href="#接收请求" class="headerlink" title="接收请求"></a>接收请求</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-20 09:41</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser03&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet3</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 常用方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 获取请求时的完整路径（从http开始，到？前面结束）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestURL() +<span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;url:&quot;</span>+url);</span><br><span class="line">        <span class="comment">// 获取请求时的部分路径（从项目的站点名称开始，到？前面结束）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> req.getRequestURI();</span><br><span class="line">        System.out.println(<span class="string">&quot;uri:&quot;</span>+uri);</span><br><span class="line">        <span class="comment">// 获取请求时的参数字符串（从？开始）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queryString</span> <span class="operator">=</span> req.getQueryString();</span><br><span class="line">        System.out.println(<span class="string">&quot;queryString:&quot;</span>+queryString);</span><br><span class="line">        <span class="comment">// 获取请求方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;method:&quot;</span>+method);</span><br><span class="line">        <span class="comment">// 获取当前协议版本</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">protocol</span> <span class="operator">=</span> req.getProtocol();</span><br><span class="line">        System.out.println(<span class="string">&quot;protocol:&quot;</span>+protocol);</span><br><span class="line">        <span class="comment">// 获取项目的站点名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">webApp</span> <span class="operator">=</span> req.getContextPath();</span><br><span class="line">        System.out.println(<span class="string">&quot;webApp:&quot;</span>+webApp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取请求的参数</span></span><br><span class="line"><span class="comment">         * http://localhost:8080/servlet_demo/ser03?uname=lili&amp;upwd=lslsls&amp;input=111&amp;input=222&amp;input=333</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 获取指定名称的参数值,返回字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">upwd</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;upwd&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;uname:&quot;</span>+uname);</span><br><span class="line">        System.out.println(<span class="string">&quot;upwd:&quot;</span>+upwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定名称的参数的所有参数值,返回字符串数组（用于复选框传值）</span></span><br><span class="line">        String[] strings = req.getParameterValues(<span class="string">&quot;input&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(strings != <span class="literal">null</span> &amp;&amp; strings.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(String s : strings)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;strings:&quot;</span>+s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="请求乱码问题"><a href="#请求乱码问题" class="headerlink" title="请求乱码问题"></a>请求乱码问题</h4><p>由于现在的 request 属于接收客户端的参数，所以必然有其默认的语言编码，主要是由于在解析过程中默认使用的编码方式为 ISO-8859-1(此编码不支持中文)，所以解析时一定会出现乱码。要想解决这种乱码问题，需要设置request 中的编码方式，告诉服务器以何种方式来解析数据。或者在接收到乱码数据以后，再通过相应的编码格式还原。<br>方式一：</p>
<p><code>String nuname = new String(request.getParameter(name).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); </code></p>
<p>借助了String 对象的方法，该种方式对任何请求有效，是通用的。但是原本不是乱码的，使用的话会出现乱码。<br>Tomcat8起，以后的GET方式请求是不会出现乱码的。POST请求是会乱码的。</p>
<p>用JSP进行post请求表单提交：新建login.jsp</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;ser03&quot;</span>&gt;</span><br><span class="line">        姓名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;uname&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">        密码：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;upwd&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">        &lt;button&gt;登录&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>访问：<a href="http://localhost:8080/servlet_demo/login.jsp">http://localhost:8080/servlet_demo/login.jsp</a></p>
<p>方式二：通过设置服务器解析编码的格式（只针对post请求）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置编码格式</span></span><br><span class="line">req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);	</span><br></pre></td></tr></table></figure>

<h4 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h4><p>请求转发，是一种服务器的行为，当客户端请求到达后，服务器进行转发，此时会将请求对象进行保存，地址栏中的 URL 地址不会改变，得到响应后，服务器端再将响应发送给客户端，从始至终只有一个请求发出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-20 21:34</span></span><br><span class="line"><span class="comment"> * 请求转发跳转</span></span><br><span class="line"><span class="comment"> * 可以让请求从服务端跳转到客户端即jsp（或跳转到指定Servlet）服务器行为</span></span><br><span class="line"><span class="comment"> * 特点：1。服务端行为 2。地址栏不会发生改变</span></span><br><span class="line"><span class="comment"> * 3。从始至终只有一个请求 4。request数据可以共享</span></span><br><span class="line"><span class="comment"> * 只能跳一次</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser04&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet4</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 接收客户端请求的参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ser04 uname:&quot;</span>+uname);</span><br><span class="line">        <span class="comment">// 请求转发跳转到ser03</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;ser03&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="request作用域"><a href="#request作用域" class="headerlink" title="request作用域"></a><strong>request作用域</strong></h4><p>通过该对象可以在一个请求中传递数据，作用范围：在一次请求中有效，即服务器跳转有效。（请求转发跳转时有效，直接访问跳转的url无效）。作用域在一次请求中，在请求转发过程中通过request来传输&#x2F;共享数据。</p>
<p>Ser05，准备用来请求转发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-20 21:34</span></span><br><span class="line"><span class="comment"> * request作用域</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser05&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet5</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 设置域对象</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        req.setAttribute(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        req.setAttribute(<span class="string">&quot;list&quot;</span>, list);</span><br><span class="line">        <span class="comment">// 请求转发并跳转到Servlet6，共享同一个req对象</span></span><br><span class="line">        <span class="comment">//req.getRequestDispatcher(&quot;ser06&quot;).forward(req, resp);</span></span><br><span class="line">        <span class="comment">// 一般是从客户端获取数据，所以跳转到jsp客户端</span></span><br><span class="line">        <span class="comment">// 请求转发跳转到jsp，并通过域对象传递数据</span></span><br><span class="line">        <span class="comment">// html就不行，因为是静态页面，而jsp是动态页面</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;attribute.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跳转到ser06</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-20 21:34</span></span><br><span class="line"><span class="comment"> * request作用域</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser06&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet6</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取域对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) req.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name：&quot;</span> + name);</span><br><span class="line">        List&lt;String&gt; list = (List&lt;String&gt;) req.getAttribute(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跳转到jsp：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;attribute页面&lt;/h2&gt;</span><br><span class="line">&lt;%-- 如果要在jsp中写java代码，需要写在脚本段中 --%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 获取域对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) request.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name：&quot;</span> + name);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<h3 id="8-形参：HttpServletResponse对象"><a href="#8-形参：HttpServletResponse对象" class="headerlink" title="8.形参：HttpServletResponse对象"></a>8.形参：<strong>HttpServletResponse对象</strong></h3><p>Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的 request 对象和代表响应的 response 对象。<br>request 和 response 对象代表请求和响应：获取客户端数据，需要通过 request 对象；向客户端输出数据，需要通过 response 对象。</p>
<p>HttpServletResponse 的主要功能用于服务器对客户端的请求进行响应，将 Web 服务器处理后的结果返回给客户端。service()方法中形参接收的是 HttpServletResponse 接口的实例化对象，这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法。</p>
<h4 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h4><p>接收到客户端请求后，可以通过 HttpServletResponse 对象直接进行响应，响应时需要获取输出流。有两种形式：</p>
<p>getWriter() 获取字符流(只能响应字符) </p>
<p>getOutputStream() 获取字节流(能响应一切数据)</p>
<p>响应回的数据到客户端被浏览器解析。<br>注意：两者不能同时使用。一个文件里只能用一个，因为response只有一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-22 08:50</span></span><br><span class="line"><span class="comment"> * getWriter() 字符输出流(输出字符串)</span></span><br><span class="line"><span class="comment"> * getOutputStream() 字节输出流(输出一切数据)</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser07&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet7</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">//        // getWrite获取字符输出流</span></span><br><span class="line"><span class="comment">//        PrintWriter writer = resp.getWriter();</span></span><br><span class="line"><span class="comment">//        // 输出数据</span></span><br><span class="line"><span class="comment">//        writer.write(&quot;hello&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// getOutputStream字节输出流</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line">        <span class="comment">// 输出数据</span></span><br><span class="line">        out.write(<span class="string">&quot;hi&quot;</span>.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="响应乱码问题"><a href="#响应乱码问题" class="headerlink" title="响应乱码问题"></a>响应乱码问题</h4><p>在响应中，如果我们响应的内容中含有中文，则有可能出现乱码。这是因为服务器响应的数据也会经过网络传输，服务器端有一种编码方式，在客户端也存在一种编码方式，当两端使用的编码方式不同时则出现乱码。</p>
<p>getWriter()的字符乱码<br>对于 getWriter()获取到的字符流，响应中文必定出乱码，由于服务器端在进行编码时默认会使用 ISO-8859-1 格式的编码，该编码方式并不支持中文。</p>
<p>要解决该种乱码只能在服务器端告知服务器使用一种能够支持中文的编码格式，比如我们通常用的”UTF-8”。</p>
<p>客户端也要设置，字节输出流可以设置响应类型，默认是字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置服务端的编码格式</span></span><br><span class="line">resp.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// 设置客户端的编码格式和响应类型</span></span><br><span class="line">resp.setHeader(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;text/html;charset=UTF-8&quot;</span>);       </span><br></pre></td></tr></table></figure>

<p>字符输出流也一样。</p>
<p>也可以同时设置客户端和服务端的编码格式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同时设置服务端和客户端的编码格式</span></span><br><span class="line">resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>总结：要想解决响应的乱码，只需要保证使用支持中文的编码格式。并且保证服务器端 和客户端使用相同的编码方式即可。</p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>重定向是一种服务器指导，客户端的行为。客户端发出第一个请求，被服务器接收处理后，服务器会进行响应，在响应的同时，服务器会给客户端一个新的地址（下次请求的地址 response.sendRedirect(url);），当客户端接收到响应后，会立刻、马上、自动根据服务器给的新地址发起第二个请求，服务器接收请求并作出响应，重定向完成。<br>从描述中可以看出重定向当中有两个请求存在，并且属于客户端行为。</p>
<p>特点：<br>服务端指导，客户端行为<br>存在两次请求<br> request对象不共享</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-22 08:50</span></span><br><span class="line"><span class="comment"> * 重定向 302</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser08&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet8</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ser08&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ser08:&quot;</span>+uname);</span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;ser07&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过观察浏览器我们发现第一次请求获得的响应码为 302，并且含有一个 location 头信息。并且地址栏最终看到的地址是和第一次请求地址不同的，地址栏已经发生了变化。</p>
<h4 id="请求转发与重定向的区别"><a href="#请求转发与重定向的区别" class="headerlink" title="请求转发与重定向的区别"></a><strong>请求转发与重定向的区别</strong></h4><p><img src="/images/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91.png"></p>
<p>对于请求转发，举个例子，前端页面输入用户名和密码，req.getAttribute获取参数，或是req.setAttribute设置参数，使用请求转发可以将参数传递到jsp页面，jsp页面使用req.getAttribute进行获取。</p>
<p>而重定向是返回一个新的页面，两个页面之间没有参数传递。</p>
<p>请求转发的地址只能是当前站点下（字符串参数就是加载项目根目录后面的字符串），重定向地址可以是任意地址。跨域跳转只能用重定向。</p>
<h3 id="9-cookie"><a href="#9-cookie" class="headerlink" title="9.cookie"></a>9.cookie</h3><p>web程序使用http协议传输，http无状态，导致每一次连接传输的数据量增大。服务器从网络连接中无法获得客户端身份，cookie相当于是服务端颁发给客户端的通行证。不同的服务器应用给客户端的cookie也不一样，是隔离的。</p>
<p>cookie是浏览器提供的一种技术，通过服务器的程序能将一些只须保存在客户端，或者在客户端进行处理的数据，放在本地的计算机上，不需要通过网络传输，因而提高网页处理的效率，并且能够减少服务器的负载，但是由于cookie是服务器保存在客户端的信息，所以其安全性也是很差的。例如常见的记住密码则可以通过cookie来实现，还有通常的推荐显示。</p>
<p>有一个专门操作Cookie的类javax.servlet.http.Cookie。随着服务器端的响应发送给客户端，保存在浏览器。当下次再访问服务器时把Cookie再带回服务器。</p>
<p>Cookie的格式：键值对用&#x3D;连接，多个键值对间用;隔开。</p>
<h4 id="cookie的创建和发送"><a href="#cookie的创建和发送" class="headerlink" title="cookie的创建和发送"></a>cookie的创建和发送</h4><p>通过 new Cookie(“key”,“value”);来创建一个 Cookie 对象，要想将 Cookie 随响应发送到客户端，需要先添加到 response 对象中，response.addCookie(cookie);此时该 cookie 对象则随着响应发送至了客户端。在浏览器上可以看见。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.cookie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-26 11:04</span></span><br><span class="line"><span class="comment"> * cookie的创建和发送</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/coo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cookie01</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 创建cookie name唯一</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">        <span class="comment">// 发送（响应）cookie</span></span><br><span class="line">        resp.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mac浏览器检查cookie：右键检查元素–储存空间–点击cookie</p>
<h4 id="cookie的获取"><a href="#cookie的获取" class="headerlink" title="cookie的获取"></a>cookie的获取</h4><p>在服务器端只提供了一个 getCookies()的方法用来获取客户端回传的所有 cookie 组成的一个数组，如果需要获取单 个 cookie 则需要通过遍历，getName()获取 Cookie 的名称，getValue()获取 Cookie 的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.cookie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-26 11:04</span></span><br><span class="line"><span class="comment"> * cookie的返回，是数组</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/coo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cookie02</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取cookie数组</span></span><br><span class="line">        Cookie[] cookies = req.getCookies();</span><br><span class="line">        <span class="comment">// 非空判断</span></span><br><span class="line">        <span class="keyword">if</span>(cookies != <span class="literal">null</span> &amp;&amp; cookies.length &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 遍历cookie数组</span></span><br><span class="line">            <span class="keyword">for</span>(Cookie cookie : cookies)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cookie.getName();</span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cookie.getValue();</span><br><span class="line">                System.out.println(<span class="string">&quot;名称：&quot;</span>+name+<span class="string">&quot;--值：&quot;</span>+value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接运行就有上次传入浏览器的cookie。</p>
<h4 id="cookie设置到期时间"><a href="#cookie设置到期时间" class="headerlink" title="cookie设置到期时间"></a>cookie设置到期时间</h4><p>除了 Cookie 的名称和内容外，我们还需要关心一个信息，到期时间，到期时间用来指定该 cookie 何时失效。默认 为当前浏览器关闭即失效。我们可以手动设定 cookie 的有效时间（通过到期时间计算），通过 setMaxAge(int time);方法设定 cookie 的最大有效时间，以秒为单位。</p>
<p>到期时间的取值：</p>
<ul>
<li><p>负整数</p>
<p>若为负数，表示不在硬盘存储该 cookie。</p>
<p>cookie 的 maxAge 属性的默认值就是-1，表示只在浏览器内存中存活，一旦关闭浏览器窗口，那么 cookie 就会消失。</p>
</li>
<li><p>正整数</p>
<p>大于 0 的整数，表示存储的秒数。</p>
<p>表示 cookie 对象可存活指定的秒数。当生命大于 0 时，浏览器会把 Cookie 保存到硬盘上，就算关闭浏览器， 就算重启客户端电脑，cookie 也会存活相应的时间。</p>
</li>
<li><p>零(用于删除Cookie)</p>
<p>若为 0，表示删除该 cookie。</p>
<p>cookie 生命等于 0 是一个特殊的值，它表示 cookie 被作废！也就是说，如果原来浏览器已经保存了这个 Cookie，那么可以通过 Cookie 的 setMaxAge(0)来删除这个 Cookie。 无论是在浏览器内存中，还是在客户端 硬盘上都会删除这个 Cookie。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.cookie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-26 11:04</span></span><br><span class="line"><span class="comment"> * cookie的到期时间</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/coo3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cookie03</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 默认值-1，表示只在浏览器内存中</span></span><br><span class="line">        <span class="comment">// 创建Cookie对象</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置Cookie 3天后失效</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">3</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">        <span class="comment">// 发送Cookie对象 设置之后必需进行响应</span></span><br><span class="line">        resp.addCookie(cookie);</span><br><span class="line">        <span class="comment">// 删除之前的cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">oldCookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;kkk&quot;</span>);</span><br><span class="line">        oldCookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">        resp.addCookie(oldCookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="cookie的注意点"><a href="#cookie的注意点" class="headerlink" title="cookie的注意点"></a>cookie的注意点</h4><ul>
<li>Cookie保存在当前浏览器中。</li>
</ul>
<p>在一般的站点中常常有记住用户名这样一个操作，该操作只是将信息保存在本机上，换电脑以后这些信息就无 效了。而且 cookie 还不能跨浏览器。</p>
<ul>
<li>Cookie存中文问题 （一般不存中文）</li>
</ul>
<p>Cookie 中不能出现中文，如果有中文则通过 URLEncoder.encode()来进行编码，获取时通过 URLDecoder.decode()来进行解码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;姓名&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="comment">// 通过 URLEncoder.encode()来进行编码</span></span><br><span class="line">name = URLEncoder.encode(name);</span><br><span class="line">value = URLEncoder.encode(value);</span><br><span class="line"><span class="comment">// 创建Cookie对象</span></span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(name,value);</span><br><span class="line"><span class="comment">// 发送Cookie对象</span></span><br><span class="line">response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取时通过 URLDecoder.decode()来进行解码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> URLDecoder.decode(cookie.getName());</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> URLDecoder.decode(cookie.getValue());</span><br></pre></td></tr></table></figure>

<ul>
<li>同名Cookie问题</li>
</ul>
<p>如果服务器端发送重复的Cookie那么会覆盖原有的Cookie。</p>
<ul>
<li>浏览器存放Cookie的数量</li>
</ul>
<p>不同的浏览器对Cookie也有限定，Cookie的存储有是上限的。Cookie是存储在客户端（浏览器）的，而且一般 是由服务器端创建和设定。后期结合Session来实现回话跟踪。Cookie的大小也是有限制的，一般是4kb以下。</p>
<h4 id="cookie的路径"><a href="#cookie的路径" class="headerlink" title="cookie的路径"></a>cookie的路径</h4><p>Cookie的setPath设置cookie的路径，这个路径直接决定服务器的请求是否会从浏览器中加载某些cookie。</p>
<p><strong>情景一：当前服务器下任何项目的任意资源都可获取Cookie对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line"><span class="comment">// 设置路径为&quot;/&quot;，表示在当前服务器下任何项目都可访问到Cookie对象</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<p><strong>情景二：当前项目下的资源可获取Cookie对象 （默认不设置Cookie的path）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line"><span class="comment">// 设置路径为&quot;/s01&quot;，表示在当前项目下任何项目都可访问到Cookie对象</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/servlet_demo&quot;</span>); <span class="comment">// 默认情况，可不设置path的值</span></span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<p><strong>情景三：指定项目下的资源可获取Cookie对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 当前项目路径为：servlet_demo */</span></span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line"><span class="comment">// 设置路径为&quot;/servlet_1&quot;，表示在s02项目下才可访问到Cookie对象</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/servlet_1&quot;</span>); <span class="comment">// 只能在servlet_1项目下获取Cookie，就算cookie是servlet_demo产生的，servlet_demo也不能获取它</span></span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<p><strong>情景四：指定项目的指定目录下的资源可获取Cookie对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line"><span class="comment">// 设置路径为&quot;/servlet_demo/coo1&quot;，表示在servlet_demo/coo1目录下才可访问到Cookie对象</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/servlet_demo/cook&quot;</span>); </span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<p>如果我们设置path，如果当前访问的路径包含了cookie的路径（当前访问路径在cookie路径基础上要比cookie的范围小）cookie就会加载到request对象之中。</p>
<p>cookie的路径指的是可以访问该cookie的顶层目录，该路径的子路径也可以访问该cookie。</p>
<p>总结：当访问的路径包含了cookie的路径时，则该请求将带上该cookie；如果访问路径不包含cookie路径，则该请求不会携带该cookie。</p>
<h3 id="10-HttpSession对象"><a href="#10-HttpSession对象" class="headerlink" title="10.HttpSession对象"></a>10.HttpSession对象</h3><p>上面讲解了请求的概念，无状态，无法做到多个请求之间的数据共享。</p>
<p>HttpSession对象是javax.servlet.http.HttpSession的实例，该接口并不像HttpServletRequest或HttpServletResponse还存在一个父接口，该接口只是一个纯粹的接口。这因为Session本身就属于HTTP协议的范畴。</p>
<p>Session：在计算机中，尤其是在网络应用中，称为“会话控制”。Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。</p>
<p>对于服务器而言，每一个连接到它的客户端都是一个 session，servlet 容器使用此接口创建 HTTP 客户端和 HTTP 服务器之间的会话。会话将保留指定的时间段，跨多个连接或来自用户的页面请求。<strong>一 个会话通常对应于一个用户，该用户可能多次访问一个站点</strong>。可以通过此接口查看和操作有关某个会话 的信息，比如会话标识符、创建时间和最后一次访问时间。在整个 session 中，最重要的就是属性的操作。</p>
<p>session无论客户端还是服务器端都可以感知到，若重新打开一个新的浏览器，则无法取得之前设置的session，因为每一个session只保存在当前的浏览器当中，并在相关的页面取得。</p>
<p>session的作用是为了标识一次会话，或者说确认一个用户；并且在**一次会话（一个用户的多次请求）**期间共享数据。可以通过request.getSession()方法，来获取当前会话的session对象。当获取session对象时，会先判断session对象是否存在，如果存在，则获取session对象，如果不存在，则创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-26 22:54</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/sess01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Session1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// session对象的获取,</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        <span class="comment">// 获取session的唯一标识--会话标识符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> session.getId();</span><br><span class="line">        System.out.println(<span class="string">&quot;唯一标识符号：&quot;</span>+id);</span><br><span class="line">        System.out.println(<span class="string">&quot;创建时间：&quot;</span>+session.getCreationTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;最后一次访问时间(时间戳)：&quot;</span>+session.getLastAccessedTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否是新的session对象：&quot;</span>+session.isNew());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="标识会话-JSESSIONID"><a href="#标识会话-JSESSIONID" class="headerlink" title="标识会话 JSESSIONID"></a><strong>标识会话 JSESSIONID</strong></h4><p>Session 既然是为了标识一次会话，那么此次会话就应该有一个唯一的标志，这个标志就是 sessionId。</p>
<p>每当一次请求到达服务器，如果服务器开启了会话（访问了 session），服务器第一步会查看是否从客户端回传一个名为 JSESSION 的 cookie，如果没有则认为这是一次新的会话，会创建一个新的 session 对象，并用唯一的 sessionId 为此次会话做一个标志，<strong>并且还会传对应的cookie在浏览器</strong>。如果有 JESSIONID 这个 cookie 回传，服务器则会 根据 JSESSIONID 这个值去查看是否含有 id 为 JSESSION 值的 session 对象，如果没有则认为是一个新的会话，重新创建一个新的 session 对象，并标志此次会话，<strong>并会向浏览器响应一个新的cookie，浏览器更新这个cookie</strong>；如果找到了相应的 session 对象，则认为是之前标志过的一次会话，返回该 session 对象，数据达到共享。</p>
<blockquote>
<p>浏览器每一次访问服务器，都会将cookie传给后台，后台可以操作cookie再响应。</p>
<p>浏览器里可以将sessionid的cookie删掉。</p>
</blockquote>
<p>这里提到一个叫做 JSESSION 的 cookie，这是一个比较特殊的 cookie，当用户请求服务器时，如果访问了 session，则服务器会创建一个名为 JSESSION，值为获取到的 session（无论是获取到的还是 新创建的）的 sessionId 的 cookie 对象，并添加到 response 对象中，响应给客户端，有效时间为关闭浏览器。</p>
<p>sessionid以cookie的形式存储； Session 的底层依赖 Cookie 来实现。一个服务器应用可以对应多个cookie，但是只能有一个session。</p>
<p>cookie是为了方便减少数据传输的，让服务端记住客户端身份的；session是为了多次访问记住状态的，也就是形成会话的。</p>
<p>cookie是有路径的，session就看是不是一次会话了。</p>
<h4 id="session域对象"><a href="#session域对象" class="headerlink" title="session域对象"></a>session域对象</h4><p>Session 用来表示一次会话，在一次会话中数据是可以共享的，这时 session 作为域对象存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setAttribute(String name, Object o); <span class="comment">// 设置域对象内容 </span></span><br><span class="line">getAttribute(String name); <span class="comment">// 获取域对象内容 </span></span><br><span class="line">removeAttribute(String name); <span class="comment">//删除域对象内容</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-27 09:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/sess02&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Session2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        session.setAttribute(<span class="string">&quot;uname&quot;</span>, <span class="string">&quot;lili&quot;</span>);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        session.removeAttribute(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">        req.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lili&quot;</span>);</span><br><span class="line">        <span class="comment">// 请求转发跳转到jsp页面，请求转发，一次请求，request可以拿到，session也可以拿到</span></span><br><span class="line">        <span class="comment">//req.getRequestDispatcher(&quot;sess01.jsp&quot;).forward(req, resp);</span></span><br><span class="line">        <span class="comment">// 重定向跳转到jsp页面,两次请求，request失效，但是session可以拿到</span></span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;sess01.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: mac</span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">3</span>/<span class="number">27</span></span><br><span class="line">  Time: 上午<span class="number">10</span>:<span class="number">00</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;获取域对象&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 获取session域对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> (String) request.getSession().getAttribute(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> (String) request.getSession().getAttribute(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取request域对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) request.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;session uname:&quot;</span>+uname);</span><br><span class="line">    System.out.println(<span class="string">&quot;session pwd:&quot;</span>+ pwd);</span><br><span class="line">    System.out.println(<span class="string">&quot;request name:&quot;</span>+ name);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>数据存储在 session 域对象中，当 session 对象不存在了，数据也就不能共享了。不同的服务器应用之间，session对象也是隔离的，两个不同的session对象间数据不能共享。</p>
<h4 id="session的销毁"><a href="#session的销毁" class="headerlink" title="session的销毁"></a><strong>session的销毁</strong></h4><p>1.默认到期时间</p>
<p>当客户端第一次请求servlet并且操作session时，session对象生成，Tomcat中session默认的存活时间为30min，即你不操作界面的时间，一旦有操作，session会重新计时。</p>
<p>session的默认时间可以在tomcat安装目录下的conf目录下的web.xml文件中进行修改。单位为分。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.设置到期时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过session.setMaxInactionInterval()可以自行设定存活时间，单位为秒</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">session.setMaxInactiveInterval(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//10秒后销毁session</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看session最大不活动时间，即存活时间</span></span><br><span class="line">System.out.println(session.getMaxInactiveInterval());</span><br></pre></td></tr></table></figure>

<p>3.立即销毁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.invalidate();</span><br><span class="line"><span class="comment">//session立即作废</span></span><br></pre></td></tr></table></figure>

<p>浏览器每次访问都是一个新的。</p>
<p>4.关闭浏览器</p>
<p>session底层以来cookie，cookie对象默认只在浏览器内存中存活，关闭浏览器即失效。</p>
<p>这个默认的优先级高，如果不关浏览器30分钟失效，关了浏览器立马失效。</p>
<p>5.关闭服务器</p>
<p>非正常关闭服务器时才会失效。  	</p>
<p>如果是正常关闭服务器，session会被钝化到本地磁盘，下次访问时会从本地磁盘中活化出来。在 工作空间 work 目录下的 SESSION.ser 文件中。 </p>
<p>Session 失效则意味着此次会话结束，数据共享结束。</p>
<h3 id="11-ServletContext对象"><a href="#11-ServletContext对象" class="headerlink" title="11.ServletContext对象"></a>11.ServletContext对象</h3><h4 id="ServletContext对象的获取"><a href="#ServletContext对象的获取" class="headerlink" title="ServletContext对象的获取"></a>ServletContext对象的获取</h4><p>每一个web应用都有且仅有一个ServletContext对象，又称为Application对象，从名称中可知，该对象是与应用程序相关的。在web容器启动时，会为每一个web应用程序创建一个对应的ServletContext对象。</p>
<p>该对象有两大作用，第一、作为域对象来共享数据，此时数据在整个应用程序中共享；第二、该对象中保存了当前应用程序相关信息。例如可以通过getServerInfo()方法获取当前服务器信息，getRealPath(String path)获取资源的真实路径等。</p>
<p>ServletContext对象获取：</p>
<p>①.通过request对象获取</p>
<p>ServletContext servletContext &#x3D; req.getServletContext();<br>(不能用了？)</p>
<p>②.通过session对象获取</p>
<p>ServletContext servletContext &#x3D; request.getSession().getServletContext();</p>
<p>③.通过servletConfig对象获取，在Servlet标准中提供了ServletConfig方法</p>
<p>ServletContext servletContext &#x3D; getServletConfig().getServletContext();</p>
<p>④.直接获取 Servlet类中提供了直接获取ServletContext对象的方法</p>
<p>ServletContext servletContext &#x3D; getServletContext();</p>
<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> getServletContext();</span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="comment">//获取当前服务器的版本信息</span></span><br><span class="line"><span class="comment">//Apache Tomcat/9.0.59</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ServletInfo</span> <span class="operator">=</span> servletContext.getServerInfo();</span><br><span class="line">System.out.println(<span class="string">&quot;服务器当前的版本信息：&quot;</span> + ServletInfo);</span><br><span class="line"><span class="comment">//获取项目的真实路径</span></span><br><span class="line"><span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;/&quot;</span>);     <span class="comment">//表示获取根路径,项目的而不是应用的</span></span><br><span class="line"><span class="comment">///Users/liuxuan/MyProject/JavaProject/java/web/target/web/</span></span><br><span class="line">System.out.println(<span class="string">&quot;获取项目的真实路径：&quot;</span> + realPath);</span><br></pre></td></tr></table></figure>



<h4 id="ServletContext域对象"><a href="#ServletContext域对象" class="headerlink" title="ServletContext域对象"></a>ServletContext域对象</h4><p>ServletContext也可以当做域对象来使用，通过ServletContext中存取数据，可以使得整个应用程序共享某些数据。当然不建议存放过多数据，因为ServletContext中的数据一旦存储进去没有手动移除的话，将会一直保存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-29 09:19</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/con02&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        <span class="comment">// 设置域对象</span></span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取域对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) servletContext.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="comment">// 移除域对象</span></span><br><span class="line">        servletContext.removeAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Servlet三大作用域</strong>：</p>
<p>1.request域对象<br>在一次请求中有效。请求转发有效,重定向失败。</p>
<p>2.session域对象<br>在一次会话中有效。请求转发和重定向都有效，session销毁后失效。</p>
<p>3.servletContext域对象<br>在整个应用程序中有效。服务器关闭销毁。</p>
<h3 id="12-文件上传和下载"><a href="#12-文件上传和下载" class="headerlink" title="12.文件上传和下载"></a>12.文件上传和下载</h3><p>servlet中如何实现文件的上传和下载。</p>
<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>文件上传涉及到前台页面的编写和后台服务器端代码的编写，前台发送文件，后台接收并保存文件，这才是一个完整的文件上传。</p>
<h5 id="前台页面"><a href="#前台页面" class="headerlink" title="前台页面"></a>前台页面</h5><p>在做文件上传的时候，会有一个上传文件的界面，首先我们需要一个表单，并且表单的请求方式为 POST；其次我们的 form 表单的 enctype 必须设为”multipart&#x2F;form-data”即 enctype&#x3D;“multipart&#x2F;form-data” 意思是设置表单的 MIME 编码。默认情况下这个编码格式是 ”application&#x2F;x-www-form-urlencoded”，不能用于文件上传；只有使用了 multipart&#x2F;form-data 才能完整地传递文件数据。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: mac</span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">3</span>/<span class="number">29</span></span><br><span class="line">  Time: 下午<span class="number">9</span>:<span class="number">41</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;文件上传&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        <span class="number">1.</span>准备表单</span><br><span class="line">        <span class="number">2.</span>设置表单的提交类型 method=<span class="string">&quot;post&quot;</span></span><br><span class="line">        <span class="number">3.</span>设置表单类型为文件上传表单 enctype=<span class="string">&quot;multipart/form-data&quot;</span></span><br><span class="line">        <span class="number">4.</span>设置文件提交的地址 action=<span class="string">&quot;uploadServlet&quot;</span></span><br><span class="line">        <span class="number">5.</span>准备表单元素 <span class="number">1.</span>普通表单项 type=<span class="string">&quot;text&quot;</span> <span class="number">2.</span>文件项 type=<span class="string">&quot;file&quot;</span></span><br><span class="line">        <span class="number">6.</span>设置表单元素的name属性值，否则后台无法接收数据</span><br><span class="line">        --&gt;</span><br><span class="line">    &lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;uploadServlet&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">        姓名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;uname&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">        文件：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;myfile&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">        &lt;!-- button 默认的 type 属性是 submit，做提交按钮可以不设置 type --&gt;</span><br><span class="line">        &lt;button type=<span class="string">&quot;submit&quot;</span>&gt; 提交 &lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h5 id="后台实现"><a href="#后台实现" class="headerlink" title="后台实现"></a>后台实现</h5><p>使用注解 <code>@MultipartConfig</code>标识为支持文件上传， Servlet 将 <code>Multipart/form-data</code> 的post请求封装成 Part 通过part对上传文件进行操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.MultipartConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Part;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-29 21:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@MultipartConfig</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/uploadServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件上传......&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为保证数据正确性，首先设置编码</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取普通表单项参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;uname&quot;</span>); <span class="comment">// 表单元素中 uname 的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;uname：&quot;</span> + uname);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Part 对象，上传的文件</span></span><br><span class="line">        <span class="type">Part</span> <span class="variable">part</span> <span class="operator">=</span> req.getPart(<span class="string">&quot;myfile&quot;</span>); <span class="comment">// 表单中 file 文件域的 name 属性值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 part 对象得到上传的文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> part.getSubmittedFileName();</span><br><span class="line">        System.out.println(<span class="string">&quot;上传的文件名：&quot;</span> + fileName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到文件要存放的路径--项目路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> req.getServletContext().getRealPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        System.out.println(filePath); <span class="comment">// 文件存放的路径</span></span><br><span class="line">        <span class="comment">// /Users/liuxuan/MyProject/JavaProject/servletdemo/servlet-demo/out/artifacts/servlet_demo_war_exploded/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存文件到指定路径</span></span><br><span class="line">        part.write(filePath + <span class="string">&quot;/&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前端页面…&#x2F;upload.jsp选择文件提交后，自动跳转至…&#x2F;uploadServlet页面。</p>
<p>⚠️一个飘红问题</p>
<p>Servlet3.0新增了request.getParts()&#x2F;getPart(String filename) api，用于获取使用multipart&#x2F;form-data格式传递的http请求的请求体，通常用于获取上传文件。用于从请求中解析上传的文件。</p>
<p>request.getParts()  获取请求中全部文件<br>getPart(String filename)   获取请求中指定name的文件</p>
<p>所以getPart方法飘红的话，看一下用的servlet方法版本是不是3.0的。</p>
<p><code>InputStream is = part.getInputStream();</code> 获取输入流</p>
<p>需要注意的是，使用request.getParts()方法必须给servlet添加注解@MultipartConfig，否则虽然不会抛出异常，但是获取不到数据。</p>
<p>更多用法撒：<br><a href="https://blog.csdn.net/u012334071/article/details/50261063/">https://blog.csdn.net/u012334071/article/details/50261063/</a></p>
<p><a href="https://wenku.baidu.com/view/c66d20190a12a21614791711cc7931b765ce7b61.html">https://wenku.baidu.com/view/c66d20190a12a21614791711cc7931b765ce7b61.html</a></p>
<p><a href="https://www.cnblogs.com/sunyongxing/articles/2622891.html">https://www.cnblogs.com/sunyongxing/articles/2622891.html</a></p>
<h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><p>即将服务器上的资源下载（拷贝）到本地，可以通过两种方式下载：通过超链接下载、通过代码下载。</p>
<p>项目内的文本或图片资源文件夹需要通过 Tomcat -&gt; Deployment 进行上传才能通过项目发布，进行访问。</p>
<h5 id="超链接下载"><a href="#超链接下载" class="headerlink" title="超链接下载"></a>超链接下载</h5><p>当我们在HTML或JSP页面中使用a标签时，原意是希望能够进行跳转，但当超链接遇到浏览器不识别的资源时会自动下载；当遇到浏览器能够直接显示的资源，浏览器就会默认显示出来，比如txt、png、jpg等。当然我们也可以通过download属性规定浏览器进行下载。但有些浏览器并不支持。</p>
<p>在web文件夹下新建一个download文件夹，准备图片、文本放在这个文件夹下，文件存放地址需要配置一下，点右上角configuration，再点deployment，再点加号external source，选到download文件夹下，再改一下application context：&#x2F;servlet_demo&#x2F;download。这样文件夹下的资源才能被浏览器访问到。（这个download是文件夹名字）</p>
<p>访问：<a href="http://localhost:8080/servlet_demo/download.html">http://localhost:8080/servlet_demo/download.html</a> （这个download是html名字）</p>
<p>download.html：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>文件下载<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 浏览器能够识别的资源，点击展示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;download/TacoCloud.jpeg&quot;</span>&gt;</span>图片文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;download/Taco.java&quot;</span>&gt;</span>文本文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加download点击下载,可不写属性名，表示文件名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;download/TacoCloud.jpeg&quot;</span> <span class="attr">download</span>=<span class="string">&quot;百度.jpeg&quot;</span>&gt;</span>图片文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;download/Taco.java&quot;</span> <span class="attr">download</span>=<span class="string">&quot;&quot;</span>&gt;</span>文本文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 浏览器不能够识别的资源,自动下载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>压缩文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="后台实现下载"><a href="#后台实现下载" class="headerlink" title="后台实现下载"></a>后台实现下载</h5><p>实现步骤：</p>
<p>得知道要下载的资源文件名，文件名传到后台代码之后：</p>
<ol>
<li>需要通过response.setContentType方法设置Content-type头字段的值，为浏览器无法使用某种方式或激活某个程序来处理的MIME类型，例如“application&#x2F;octet-stream”或“application&#x2F;x-msdownload‘等。</li>
<li>需要通过response.setHeader方法设置Content-Disposition头的值为“attachment;filename&#x3D;文件名“</li>
<li>读取下载文件，调用response.getOutputStream方法向客户端写入附件内容。</li>
</ol>
<p>第一步：写html页面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;文件下载&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;downloadServlet&quot;</span>&gt;</span><br><span class="line">        文件名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;fileName&quot;</span> placeholder=<span class="string">&quot;请输入要下载的文件名&quot;</span>&gt;</span><br><span class="line">        &lt;button&gt;下载&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：写一个servlet页面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-31 21:59</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/downloadServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DownloadServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写钥匙的</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件下载===&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置请求的编码格式</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 乱码问题，设置编码格式</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取参数（得到要下载的文件名）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;fileName&quot;</span>);</span><br><span class="line">        <span class="comment">// 参数的非空判断  trim()去除字符串前后空格，中间的不管</span></span><br><span class="line">        <span class="keyword">if</span>(fileName == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(fileName.trim()))&#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;请输入要下载的文件名！&quot;</span>);</span><br><span class="line">            resp.getWriter().close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到图片存放的路径,文件放在配置好的download目录下的。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> req.getServletContext().getRealPath(<span class="string">&quot;/download/&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过路径得到file对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path + fileName);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件：&quot;</span>+ file);</span><br><span class="line">        <span class="comment">// 判断文件对象是否存在，并且是个标准文件</span></span><br><span class="line">        <span class="keyword">if</span>(file.exists() &amp;&amp; file.isFile())&#123;</span><br><span class="line">            <span class="comment">// 1.设置响应类型，设置为浏览器无法使用某种方式或激活某个程序来处理的MIME类型</span></span><br><span class="line">            resp.setContentType(<span class="string">&quot;application/x-msdownload&quot;</span>);</span><br><span class="line">            <span class="comment">// 2.设置响应头</span></span><br><span class="line">            resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName);</span><br><span class="line">            <span class="comment">// 3.得到file文件的输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            <span class="comment">// 4.得到字节输出流，字符输出流文件是不行的</span></span><br><span class="line">            <span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line">            <span class="comment">// 5.定义byte数组</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">// 6.定义长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 7.循环输出</span></span><br><span class="line">            <span class="keyword">while</span> ((len = in.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 8.关闭资源</span></span><br><span class="line">            out.close();</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;文件不存在，请重试！&quot;</span>);</span><br><span class="line">            resp.getWriter().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h3><p><a href="https://github.com/jadeliuliu/servletdemo/tree/master/servlet-demo">https://github.com/jadeliuliu/servletdemo/tree/master/servlet-demo</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>比较全的文章：<a href="https://blog.csdn.net/qq_19782019/article/details/80292110">https://blog.csdn.net/qq_19782019/article/details/80292110</a></p>
<p>实现：<a href="https://blog.csdn.net/Hello_zbs/article/details/108394660">https://blog.csdn.net/Hello_zbs/article/details/108394660</a></p>
<p>b站视频：<a href="https://www.bilibili.com/video/BV1Ta4y1H7Vc?p=26&spm_id_from=pageDriver">https://www.bilibili.com/video/BV1Ta4y1H7Vc?p=26&amp;spm_id_from=pageDriver</a></p>
<p>学习笔记：<a href="https://www.cnblogs.com/yuan-liu/p/15255326.html">https://www.cnblogs.com/yuan-liu/p/15255326.html</a></p>
<h3 id="servlet的get和post请求"><a href="#servlet的get和post请求" class="headerlink" title="servlet的get和post请求"></a>servlet的get和post请求</h3><p>get：将数据通过url附加数据现行的向服务器发送数据<br>post：将数据存放在请求体中隐性的向服务器发送数据</p>
<p>区别：<br>1.get常用于不包含敏感信息的查询功能 （不用输入密码）<br>2.post用于安全性较高的功能或者服务器的“写”操作 eg：用户登录、注册、更新账目</p>
<p>service()是请求处理的核心方法，无论是get或者是post都会被service()方法处理。<br>当采用无差别请求时，可以用service()方法。<br>request.getMethod()查看请求方式<br>doGet()方法处理get请求<br>doPost()方法处理post请求<br>response.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”);解决中文乱码</p>
<p>参考：<a href="https://juejin.cn/post/6869979139164602382">https://juejin.cn/post/6869979139164602382</a></p>
<h3 id="WebServlet和-RequestMapping"><a href="#WebServlet和-RequestMapping" class="headerlink" title="@WebServlet和@RequestMapping"></a>@WebServlet和@RequestMapping</h3><p>都是用在Controller类里，用于拦截特定请求的。</p>
<p>@WebServlet注解作用在类上，用于标注在一个继承了HttpServlet类之上，属于类级别的注解，一般用于需要有HttpServletRequest请求中带了参数，或者需要filter等场景，这个是Servlet实现的路径映射逻辑。</p>
<p>@RequestMapping 在controller类上加，具体的方法上再加， 可以在控制器类的级别和&#x2F;或其中的方法的级别上使用 处理普通的URI请求，或者http请求，这个是spring实现的DispatcherServlet的路径映射逻辑。</p>
<p>✅ 两种构造Controller的区别：</p>
<p>Controller是spring 的一个bean，由spring的IOC来管理的一个bean</p>
<p>Servlet是一个接口或者接口的实现（常见的是GenericServlet 和 HttpServlet）</p>
<p>Servlet实现方式：<br>有一个映射关系servlet-mapping，url的endpoint 对应的具体的servlet， 比如规定’&#x2F;demo’ 映射到ServletDemo（继承自HttpServlet，重写doGet，doPost等方法）.<br>在浏览器地址栏输入localhost:8088&#x2F;demo   , 这个请求就会执行到ServletDemo的doGet方法，经过一系列逻辑，最终将要返回给浏览器的数据写入HttpServletResponse，这样浏览器就能收到结果。</p>
<p>Controller实现方式：<br>只是一个bean，方法上可以加上注解GetMapping，PostMapping等，标注映射的url的endpoint。<br>Servlet容器（Tomcat等）接收到请求以后，将请求交给DispatcherServlet的service方法来处理，servlet会在doDispatch里面先找到mappedHandler ，然后找到HandlerAdapter。调用HandlerAdapter 的handle方法，其实应该是AbstractHandlerMethodAdapter，<br>然后调用到RequestMappingHandlerAdapter的handleInternal，最终调用到invokeAndHandle，反射调用controller的方法。找到endpoint对应的bean的方法，并调用。</p>
<p>总结：<br><em><strong>容器&#x3D;&#x3D;》DispatcherServlet (service方法) &#x3D;&#x3D;》 doDispatcher &#x3D;&#x3D;》HandlerAdapter （handle）&#x3D;》AbstractHandlerMethodAdapter&#x3D;&#x3D;》RequestMappingHandlerAdapter &#x3D;&#x3D;》invokeAndHandle&#x3D;&#x3D;》反射具体的controller方法</strong></em></p>
<p>转自：<a href="https://www.cnblogs.com/huainanyin/p/15936212.html">https://www.cnblogs.com/huainanyin/p/15936212.html</a></p>
<p>Spring提供的DispatcherServlet是怎么调用我们的Controller里的业务接口的：<a href="https://blog.csdn.net/caoyuanyenang/article/details/114401414">https://blog.csdn.net/caoyuanyenang/article/details/114401414</a></p>
<p>✅@RequestMaping参数<br>见java注解</p>
<h3 id="cookie-session-tocken的区别"><a href="#cookie-session-tocken的区别" class="headerlink" title="cookie session tocken的区别"></a>cookie session tocken的区别</h3><p>鉴权：鉴定权限</p>
<p>✅cookie</p>
<p>cookie是鉴权的方式之一，是客户端登录后，服务器端生成后发送给客户端的。cookie可以保存很多种数据，但是他只能保存字符串，且在安全性上有隐患。<br>在客户端发起请求后，服务器端生成一个cookie，并发送给客户端，保存在客户端本地，下次请求的时候带上cookie。</p>
<p>✅session</p>
<p>session是一种会话，比如我发起请求到关闭浏览器这个过程就是一个会话。session是鉴权的方式之二，在客户端发起请求后，服务器生成一个对应的session，并保存在服务器中，再把session id保存到cookie里面，通过cookie发送给客户端，客户端接收到cookie过后，下一次请求时就会把cookie带上，服务器收到请求中的session id后就会把它与之前保存的session做对比，如果是一样的，那就说明是已经登录过的，如果不一样，那就需要重新登录：服务器为客户端创造一个session，并且生成一个与session相关联的session id存放到cookie中，在本次响应中返回到客户端保存。</p>
<p>✅token</p>
<p>token是一个令牌，是鉴权方式之三，他是由一部分固定的header、以及body组成的，在body中可以放userid+电话号码，等用户的非隐秘信息，然后再通过某种加密方式，把这两部分加密形成一个秘钥。</p>
<p>在客户端发起请求后，服务器会生成一个token，可以通过cookie也可以直接发送给客户端，客户端接收到token后，会把它保存在本地，在下一次请求时，会带上，服务器端收到二次请求以及带上的token后，会再根据用户的信息去加密一个token，再把两次token进行比对，如果是相同的，那就不用再登录了，如果不一样就需要再重新登录。</p>
<p>第一次请求客户端发送的没有这个tocken，服务端生成tocken给客户端，客户端第二次发送带上tocken，就不用重新登陆了。服务端不保存tocken。</p>
<p>✅区别</p>
<p>cookie、session、token的区别<br>1.生成的位置相同：cookie、session、token都是在服务器端生成；<br>2.保存的位置不同：cookie、token保存在客户端本地，session保存在服务器；<br>3.鉴权过程不同：<br>cookie是将请求中携带的cookie与服务器记录的cookie做对比；<br>session是将请求中携带的session与服务器存储的session做对比；<br>token是将请求中携带的token与服务器通过请求中的信息（userid、签名）生成的token作对比。</p>
<p>摘自：<a href="https://blog.csdn.net/qq_43844012/article/details/124271258">https://blog.csdn.net/qq_43844012/article/details/124271258</a></p>
<p>cookie：用来保存一些信息在客户端的，比如记住密码和推荐显示。<br>session：是用来标识一次会话的，在一次会话期间共享数据。<br>token：用来作为密钥快捷登录的</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>jar、war、tomcat、servlet</title>
    <url>/2022/06/04/myblog/java/war%E5%8C%85jar%E5%8C%85%E6%89%93%E5%8C%85tomcat%E9%83%A8%E7%BD%B2servlet%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h3 id="tomcat与servlet"><a href="#tomcat与servlet" class="headerlink" title="tomcat与servlet"></a>tomcat与servlet</h3><p>1.tomcat就是一个web应用服务器，相当于市存放java程序的容器。以便服务被访问。<br>2.servlet实际上是java类，java语言编写的服务器端程序，它用来处理http协议相关的所有内容，没有main方法，需要在servlet容器中进行管理，可以是tomact。如何使用：继承HttpServlet（tomcat里的jar包支持），它帮助我们完成通信的规则。<br>3.tomcat与servlet关系：tomcat是servlet&#x2F;jsp容器，servlet时web应用开发的组件，tomcat负责处理客户请求，把请求传送给servlet，再将servlet的响应传送回给客户。<br>4.新建web工程时，如果不用maven，java enterprise - web application，再引入jdk、tomcat（tomcat的lib下有servlet包）。如果用maven，就选archetype-webapp。</p>
<h3 id="war包与jar包"><a href="#war包与jar包" class="headerlink" title="war包与jar包"></a>war包与jar包</h3><p>1.Jar文件（扩展名为. Jar，Java Application Archive）包含Java类的普通库、资源（resources）、辅助文件（auxiliary files）等。<br>2.jar包是java打的包，一般只是包括一些编译后class文件和一些部署文件，在声明了Main_class之后是可以用java命令运行的。<br>3.jar包通常是开发时要引用通用类，打成包便于存放管理。<br>————————————————<br>1.War文件（扩展名为.War,Web Application Archive）包含全部Web应用程序。在这种情形下，一个Web应用程序被定义为单独的一组文件、类和资源，用户可以对war文件进行封装，并把它作为小型服务程序（servlet）来访问。<br>2.war包可以理解为javaweb打的包，是一个web模块，包括写的代码编译成的class文件，依赖的包，配置文件，所有的网站页面，包括html，jsp等等。一个war包可以理解为是一个web项目，里面是项目的所有东西。<br>3.war包需要发布到一个容器里面，拿Tomcat来说,将war文件包放置它的\webapps\目录下，启动Tomcat,这个包可以自动进行解压，也就是你的web目录，相当于发布了。<br>4.WAR是Sun提出的一种Web应用程序格式，与JAR类似，也是许多文件的一个压缩包。这个包中的文件按一定目录结构来组织：通常其根目录下包含有Html和Jsp文件或者包含这两种文件的目录，另外还会有一个WEB-INF目录，这个目录很重要。通常在WEB-INF目录下有一个web.xml文件和一个classes目录，web.xml是这个应用的配置文件，而classes目录下则包含编译好的Servlet类和Jsp或Servlet所依赖的其它类（JavaBean）。另外还有META-INF目录，里面有MANIFEST.MF文件。存储了项目的元信息。其中文件manifest.mf仅此一份，描述了程序的基本信息、Main-Class的入口、jar依赖路径Class-Path。<br>————————————————</p>
<p>原文链接：<a href="https://blog.csdn.net/Sunny5319/article/details/90933532">https://blog.csdn.net/Sunny5319/article/details/90933532</a></p>
<p>jar包和war包都是为了项目的部署和发布，通常在打包部署的时候，会在里面加上部署的相关信息。这个打包实际上就是把代码和依赖的东西压缩在一起，变成后缀名为.jar和.war的文件</p>
<hr>
<p>什么时候用jar、war?<br>当你的项目在没有完全完成的时候，不适合使用war文件，因为你的类会由于调试之类的经常改，这样来回删除、创建war文件很不方便，来回修改，来回打包，最好是你的项目已经完成了，不做修改的时候，那就打个war包，这个时候一个war文件就相当于一个web应用程序；而jar文件就是把类和一些相关的资源封装到一个包中，便于程序中引用。</p>
<h3 id="jar包打包"><a href="#jar包打包" class="headerlink" title="jar包打包"></a>jar包打包</h3><p>安装好JDK之后,jar.exe就已经安装好了。在命令行中键入jar命令之后，会有详细的用法介绍。</p>
<h4 id="✅单个文件打包"><a href="#✅单个文件打包" class="headerlink" title="✅单个文件打包"></a>✅单个文件打包</h4><p>将一个单独的java文件打包：<br><code>jar cvf /Users/liuxuan/MyProject/java/test.jar /Users/liuxuan/MyProject/java/jartest/hello.java</code><br>使用<code>java -jar test.jar</code> 提示没有主清单属性。</p>
<p>所以增加清单配置文件：MANIFEST.MF</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Main-Class: hello</span><br><span class="line"></span><br><span class="line">//注意：1. 冒号后面加一个空格，2. 最后必须回车到新的空行</span><br></pre></td></tr></table></figure>
<p>再打包：<code>jar cvfm test.jar ./*</code><br>java -jar运行，找不到或无法加载主类 hello。</p>
<p>所以在打包前先编译：<code>javac hello.java</code>，生成class文件，然后再打包，运行，可以执行。</p>
<blockquote>
<p>META-INF文件夹相当于一个信息包，目录中的文件和目录获得Java 2平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务。这个文件夹和其中的 MANIFEST.MF文件，在用jar打包时自动生成。<br>执行jar文件的时候，这个jar里是需要具备 META-INF&#x2F;MANIFEST.MF的，否则java -jar就找不到main class。</p>
</blockquote>
<p>多个文件也可以如此打包，首先应该javac编译，然后增加主清单配置文件，其中可以指示默认入口函数（其中有main方法）。如果打的包中有其他类，java -jar jar包 是运行默认类，运行其他类方法：<code>java -cp test.jar com.test.sum 3 9</code>。<br>main函数可以有输入参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">public class sum&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        if(args.length &lt; 2)&#123;</span><br><span class="line">            System.out.println(&quot;Paras: num1 num2&quot;);</span><br><span class="line">            System.exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        final int num1 = Integer.valueOf(args[0]);</span><br><span class="line">        System.out.println(&quot;Num1: &quot; + num1);</span><br><span class="line">        final int num2 = Integer.valueOf(args[1]);</span><br><span class="line">        System.out.println(&quot;Num2: &quot; + num2);</span><br><span class="line"></span><br><span class="line">        final int sum = num1 + num2;</span><br><span class="line">        System.out.println(num1 + &quot; + &quot; + num2 + &quot; = &quot; + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/Xminyang/article/details/108059776">https://blog.csdn.net/Xminyang/article/details/108059776</a></p>
<h4 id="✅使用idea打包"><a href="#✅使用idea打包" class="headerlink" title="✅使用idea打包"></a>✅使用idea打包</h4><p>🤔不可以java -jar的打包：<br>1.点击intellij idea左上角的“File”菜单 -&gt; Project Structure<br>2.点击”Artifacts” -&gt; 绿色的”+” -&gt; “JAR” -&gt; Empty<br>3. Name栏填入自定义的名字，Output ditectory选择jar包目标目录，Available Elements里双击需要添加到jar包的文件（添加java工程编译文件）<br>4. OK之后，点击菜单中“Build” -&gt; “Build Artifacts”<br>5. 点击弹出框中待生成jar包下面的build即可</p>
<p>生成了jar包，直接java -jar执行，报<code>Error: Invalid or corrupt jarfile testjar.jar</code>.<br>需要用 -cp 指定类来执行，例如：<code>java -cp testjar.jar leecode.JianPanHang500</code></p>
<p>🤔可以直接java -jar的打包：<br>如果需要直接java -jar 执行的jar包：<br>1.点击”Artifacts” -&gt; 绿色的”+” -&gt; “JAR” -&gt; from modules…<br>2.选择主类，选择META-INF位置<br>3.OK之后，点击菜单中“Build” -&gt; “Build Artifacts”<br>4.点击弹出框中待生成jar包下面的build即可</p>
<p>注意：在选择主类时需要全路径，rebuild之后可以重新编译，<code>java -jar lee.jar</code>直接运行主类。</p>
<p>参考：<a href="https://blog.csdn.net/qq_42239765/article/details/123236019">https://blog.csdn.net/qq_42239765/article/details/123236019</a></p>
<h4 id="✅使用maven打包"><a href="#✅使用maven打包" class="headerlink" title="✅使用maven打包"></a>✅使用maven打包</h4><p>🤔不包含依赖包，也不指定入口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;!-- 项目最终打包成的名字 --&gt;</span><br><span class="line">    &lt;finalName&gt;mylogmavenpackage&lt;/finalName&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;!-- 指定项目编译时的java版本和编码方式 --&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>🤔指定入口，将依赖的jar包输出到指定目录<br>指定了入口类，可以直接使用java -jar project.jar执行，但是第三方依赖存在一个指定的外部目录下，迁移时需将jar和依赖目录一起迁移。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;!-- 指定项目编译时的java版本和编码方式 --&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;archive&gt;</span><br><span class="line">          &lt;manifest&gt;</span><br><span class="line">            &lt;mainClass&gt;com.netty.client.SignalClient&lt;/mainClass&gt; &lt;!-- 指定入口类 --&gt;</span><br><span class="line">            &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;!-- 在jar的MF文件中生成classpath属性 --&gt;</span><br><span class="line">            &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;!-- classpath前缀,即依赖jar包的路径 --&gt;</span><br><span class="line">          &lt;/manifest&gt;</span><br><span class="line">        &lt;/archive&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.1&lt;/version&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;id&gt;copy&lt;/id&gt;</span><br><span class="line">          &lt;phase&gt;install&lt;/phase&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;copy-dependencies&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">          &lt;configuration&gt;</span><br><span class="line">            &lt;!-- 指定依赖包的输出路径，需与上方的classpathPrefix保持一致 --&gt;</span><br><span class="line">            &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/lib&lt;/outputDirectory&gt;</span><br><span class="line">          &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>🤔将项目依赖和项目打成一个jar包（胖包）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;!-- 指定项目编译时的java版本和编码方式 --&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;archive&gt;</span><br><span class="line">          &lt;manifest&gt;</span><br><span class="line">            &lt;mainClass&gt;com.netty.client.SignalClient&lt;/mainClass&gt; &lt;!-- 指定入口类路径 --&gt;</span><br><span class="line">          &lt;/manifest&gt;</span><br><span class="line">        &lt;/archive&gt;</span><br><span class="line">        &lt;descriptorRefs&gt;</span><br><span class="line">          &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;!-- jar包后缀，生成的jar包形式为：project-1.0-SNAPSHOT-jar-with-dependencies.jar --&gt;</span><br><span class="line">        &lt;/descriptorRefs&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">      &lt;!-- 添加此项后，可直接使用mvn package | mvn install --&gt;</span><br><span class="line">      &lt;!-- 不添加此项，需直接使用mvn package assembly:single --&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;id&gt;make-assembly&lt;/id&gt;</span><br><span class="line">          &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;single&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<h3 id="打war包"><a href="#打war包" class="headerlink" title="打war包"></a>打war包</h3><p>上面打jar包，其实都有对应的打war包的方法：</p>
<p>✅手动打war包<br><code>jar cvf test.war ./*</code></p>
<p>✅idea打war包<br>artifact中选择web application，explode对于war explode，archive对应war。</p>
<p>✅maven打war包<br>pom.xml中指示<br><code>&lt;packaging&gt;war&lt;/packaging&gt;</code><br>maven有多种打包方式。</p>
<h3 id="war包和war-explode包"><a href="#war包和war-explode包" class="headerlink" title="war包和war explode包"></a>war包和war explode包</h3><p>1.war模式<br>这种可以称之为是发布模式，就是先将WEB工程打成war包，然后再将其上传到服务器进行发布 。</p>
<p>2.war exploded模式<br>是将WEB工程以当前文件夹的位置关系上传到服务器，即直接把文件夹、jsp页面 、classes等等移到Tomcat 部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。<br>在平时开发的时候，使用热部署的话，应该对Tomcat进行相应的设置，这样的话修改的jsp界面什么的东西才可以及时的显示出来。<br>（热部署，对于Java应用程序来说，热部署就是在运行时更新Java类文件。）</p>
<p>问题：<br>idea进行部署，会将war包移到tomcat webapp文件夹下吗？</p>
<h3 id="java-web工程目录结构"><a href="#java-web工程目录结构" class="headerlink" title="java web工程目录结构"></a>java web工程目录结构</h3><p>1.src文件夹：这是用来存放Java源文件。下面有main文件夹和test文件夹。<br>1.1.src&#x2F;main&#x2F;java：存放相应的Java代码，并根据对应的Java项目继续分层<br>1.2.src&#x2F;main&#x2F;resource：存放一些配置文件，例如application.properties、logback.xml<br>1.3.src&#x2F;main&#x2F;webapp：Web应用的网页，用来放静态资源比如HTML、CSS、图片等文件。WEB-INF目录所在。WEB-INF中存放网站配置文件目录，web.xml等配置信息。</p>
<p>2..idea文件夹：是存储IntelliJ IDEA项目的配置信息，主要内容有IntelliJ IDEA项目本身的一些编译配置、文件编码信息、jar包的数据源和相关的插件配置信息。一般用git做版本控制的时候会把.idea文件夹排除，因为这个文件下保存的都是个人本地Idea编译器的配置。</p>
<p>3.target文件夹：是用来存放项目构建后的文件和目录、jar包、war包、编译的class文件，都是maven构建时生成的。存放的是单个module的编译结果。</p>
<p>4.out文件夹：存放该项目下所有module的编译结果。</p>
<p>5.pom.xml：项目对象模型</p>
<h3 id="新建个web工程并部署"><a href="#新建个web工程并部署" class="headerlink" title="新建个web工程并部署"></a>新建个web工程并部署</h3><p>1.new project，选maven，选maven-archetype-webapp<br>2.选择maven setting，新建工程<br>3.简单写个index.jsp，在webapp目录下（主页）<br>4.通过idea部署，生成war_explode包，热部署<br>5.lsof -i:8080 查看端口占用<br>6.target文件夹下有war包了，但是在tomcat-webapp文件夹下并没有该项目。<br>7.关闭idea，web也无法访问了，所以要想一直运行，得打jar包放在webapp目录下？<br>8.并且发现，没用servlet，不用导入servlet包。</p>
<h3 id="pom-xml结构"><a href="#pom-xml结构" class="headerlink" title="pom.xml结构"></a>pom.xml结构</h3><p>pom.xml 就是 maven 的配置文件，用以描述项目的各种信息。</p>
<p><code>&lt;project </code>  是 pom.xml 中描述符的根。</p>
<p><code>&lt;modelVersion&gt;</code> 指定 pom.xml 符合哪个版本的描述符。maven 2 和 3 只能为 4.0.0。</p>
<p>在 maven 中，根据 groupId、artifactId、version 组合来唯一识别一个 jar 包。<br><code>&lt;groupId&gt;</code> - 团体、组织的标识符。团体标识的约定是，它以创建这个项目的组织名称的逆向域名(reverse domain name)开头。一般对应着 java 的包结构。<br><code>&lt;artifactId&gt;</code> - 单独项目的唯一标识符。例如junit。不要在 artifactId 中包含点号(.)。<br><code>&lt;version&gt;</code> - 一个项目的特定版本。</p>
<blockquote>
<p>maven 在版本管理时候可以使用几个特殊的字符串 SNAPSHOT、LATEST、RELEASE。比如 1.0-SNAPSHOT。各个部分的含义和处理逻辑如下说明：<br>SNAPSHOT - 这个版本一般用于开发过程中，表示不稳定的版本。<br>LATEST - 指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个 snapshot 版，具体看哪个时间最后。<br>RELEASE ：指最后一个发布版。</p>
</blockquote>
<p><code>&lt;packaging&gt;</code> - 项目的类型，描述了项目打包后的输出，默认是 jar。常见的输出类型为：pom, jar, maven-plugin, ejb, war, ear, rar, par。</p>
<p><code>&lt;name&gt;</code> - 项目名字</p>
<p><code>&lt;url&gt;</code> - 项目网站</p>
<p><code>&lt;description&gt;</code> - 项目描述</p>
<p><code>&lt;parent&gt;</code> - maven 支持继承功能。子 POM 可以使用 parent 指定父 POM ，然后继承其配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;my-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0&lt;/version&gt;</span><br><span class="line">    &lt;relativePath&gt;../my-parent&lt;/relativePath&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">relativePath ： 在搜索本地和远程存储库之前，它不是必需的，但可以用作 maven 的指示符，以首先搜索给定该项目父级的路径。</span><br></pre></td></tr></table></figure>

<p><code>&lt;modules&gt;</code> - 子模块列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;my-project-api&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;my-project-repository&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;properties&gt;</code> - 属性列表。定义的属性可以在 pom.xml 文件中任意处使用。使用方式为 ${propertie} 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子：</span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;!-- Test --&gt;</span><br><span class="line">		&lt;junit.version&gt;1.16.1&lt;/junit.version&gt;</span><br><span class="line">	&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;dependencies&gt;</code> - 依赖配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupId, artifactId, version - 和基本配置中的 groupId、artifactId、version 意义相同。</span><br><span class="line"></span><br><span class="line">type - 对应 packaging 的类型，如果不使用 type 标签，maven 默认为 jar。</span><br><span class="line"></span><br><span class="line">scope - 此元素指的是任务的类路径（编译和运行时，测试等）以及如何限制依赖关系的传递性。有 5 种可用的限定范围：</span><br><span class="line">compile : 如果没有指定 scope 标签，maven 默认为这个范围。编译依赖关系在所有 classpath 中都可用。此外，这些依赖关系被传播到依赖项目。</span><br><span class="line">provided : 与 compile 类似，但是表示您希望 jdk 或容器在运行时提供它。它只适用于编译和测试 classpath，不可传递。</span><br><span class="line">runtime : 此范围表示编译不需要依赖关系，而是用于执行。它是在运行时和测试 classpath，但不是编译 classpath。</span><br><span class="line">test : 此范围表示正常使用应用程序不需要依赖关系，仅适用于测试编译和执行阶段。它不是传递的。</span><br><span class="line">system : 此范围与 provided 类似，除了您必须提供明确包含它的 jar。该 artifact 始终可用，并且不是在仓库中查找。</span><br><span class="line"></span><br><span class="line">systemPath - 仅当依赖范围是系统时才使用。否则，如果设置此元素，构建将失败。该路径必须是绝对路径，因此建议使用 propertie 来指定特定的路径，如\$ &#123;java.home&#125; / lib。由于假定先前安装了系统范围依赖关系，maven 将不会检查项目的仓库，而是检查库文件是否存在。如果没有，maven 将会失败，并建议您手动下载安装。</span><br><span class="line"></span><br><span class="line">optional - optional 让其他项目知道，当您使用此项目时，您不需要这种依赖性才能正常工作。</span><br><span class="line"></span><br><span class="line">exclusions - 包含一个或多个排除元素，每个排除元素都包含一个表示要排除的依赖关系的 groupId 和 artifactId。与可选项不同，可能或可能不会安装和使用，排除主动从依赖关系树中删除自己。</span><br></pre></td></tr></table></figure>

<p><code>&lt;dependencyManagement&gt;</code> - 是在<code>&lt;dependencies&gt;</code>外用的。表示依赖 jar 包的声明。即你在项目中的 dependencyManagement 下声明了依赖，maven 不会加载该依赖，dependencyManagement 声明可以被子 POM 继承。<br>它的一个使用案例是当有父子项目的时候，父项目中可以利用 <code>&lt;dependencyManagement&gt;</code> 声明子项目中需要用到的依赖 jar 包，之后，当某个或者某几个子项目需要加载该依赖的时候，就可以在子项目中 dependencies 节点只配置 groupId 和 artifactId 就可以完成依赖的引用。<br><code>&lt;dependencyManagement&gt;</code> 主要是为了统一管理依赖包的版本，确保所有子项目使用的版本一致，类似的还有plugins和pluginManagement。</p>
<p><code>&lt;build&gt;</code> - 构建配置。<br><code>&lt;plugins&gt;</code> - 配置插件，在<code>&lt;build&gt;</code>下。<br><code>pluginManagement</code> - 与 dependencyManagement 很相似，在当前 POM 中仅声明插件，而不是实际引入插件。子 POM 中只配置 groupId 和 artifactId 就可以完成插件的引用，且子 POM 有权重写 pluginManagement 定义。<br>它的目的在于统一所有子 POM 的插件版本。<br><code>&lt;extensions&gt;</code> - 扩展配置，扩展是在构建期间激活的 artifacts。扩展不需要实际执行任何操作，也不包含 Mojo。因此，扩展对于指定普通插件接口的多个实现中的一个是非常好的。</p>
<p>pom.xml解析：<a href="https://zhuanlan.zhihu.com/p/76874769">https://zhuanlan.zhihu.com/p/76874769</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》之网络编程</title>
    <url>/2021/12/02/myblog/java/%E3%80%8AJava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="IP地址和端口号"><a href="#IP地址和端口号" class="headerlink" title="IP地址和端口号"></a>IP地址和端口号</h2><p>IPv4由四个字节大小的二进制数来表示，通常写成十进制形式，每个数在0-255之间。</p>
<p>IPv6使用16个字节表示IP地址。</p>
<p>最初设计互联网时，为了便于寻址以及层次化构造网络，每个IP地址由两部分组成，即”网络.主机”，网络部分表示其属于互联网的哪一个网络，是网络的地址编码，主机部分表示其属于该网络中的哪一台主机，是网络中一个主机的地址编码，二者是主从关系。</p>
<p>IP地址分为五类：常用的是A.B.C类：</p>
<p>①A类地址：第一段网络地址，其余三段主机地址，范围是1.0.0.0 – 127.255.255.255。</p>
<p>②B类地址：前两段网络地址，其余两段主机地址，范围是128.0.0.0 – 191.255.255.255。</p>
<p>③C类地址：前三段网络地址，最后一段主机地址，范围是192.0.0.0 – 223.255.255.255。</p>
<p>另外，还有一个本地回环地址127.0.0.1，指本机地址，改地址一般用来测试使用，例如：ping 127.0.0.1 用来测试本机TCP&#x2F;IP协议是否正常。</p>
<p>端口号用来访问目标计算机中的某个应用程序。计算机中，不同的应用程序是通过端口号来区分的，端口号是用两个字节（16位二进制数）表示的，取值范围是：0 ~ 65535。其中，0 ~ 1023之间的端口号用于一些知名的网络服务和应用，用户的普通应用程序需要使用1024以上的端口号，从而避免端口号被另外一些应用或服务所占用。</p>
<h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><p>JDK中提供了一个与IP地址相关的InetAddress类，该类用于封装一个IP地址，并提供一系列与IP地址有关的方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getByName(String host);  <span class="comment">//获取表示指定主机的InetAddress对象</span></span><br><span class="line">getLocalHost()      <span class="comment">//获取本机的InetAddress对象，InetAddress.getLocalHost()</span></span><br><span class="line">getHostName()     <span class="comment">//InetAddress对象.getHostName  获取主机名，返回String</span></span><br><span class="line">isReachable(<span class="type">int</span> timeout)   <span class="comment">//InetAddress对象.isReachable，判断在限定时间内指定的IP地址是否可以访问，返回boolean</span></span><br><span class="line">getHostAddress()    <span class="comment">//InetAddress对象.getHostAddress，获取字符串格式的原始IP地址，返回String</span></span><br></pre></td></tr></table></figure>

<p><code>getHostName</code>获取某个主机的域名，如果InetAddress对象是通过主机名创建的，则将返回该主机名；否则根据IP地址反向查找对应的主机名，如果找到则将其返回，否则返回IP地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: InetAddress类使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-02 12:52</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InetAdd</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取本机InetAddress对象</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">local</span> <span class="operator">=</span> InetAddress.getLocalHost();  <span class="comment">//相当于 InetAddress.getByName(&quot;localhost&quot;);</span></span><br><span class="line">        <span class="comment">//获取主机名为&quot;www.baidu.com&quot;的InetAddress对象</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">remote</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;InetAddress对象：&quot;</span>+local);</span><br><span class="line">        System.out.println(<span class="string">&quot;本机ip：&quot;</span>+local.getHostAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;百度ip：&quot;</span>+remote.getHostAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;3s内是否可访问百度：&quot;</span>+remote.isReachable(<span class="number">3000</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;本机主机名：&quot;</span>+local.getHostName());</span><br><span class="line">        System.out.println(<span class="string">&quot;百度主机名：&quot;</span>+remote.getHostName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>疑问：为什么一定要throws异常。</p>
</blockquote>
<h2 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h2><p>UDP：user datagram protocol 用户数据报协议</p>
<p>TCP：transmission control protocol 传输控制协议</p>
<p>UDP：无连接通信协议，数据的发送端和接收端不建立逻辑连接。发送端不会确认接收端是否存在，接收端也不会向发送端反馈是否收到数据。消耗资源小，通信效率高，延迟小。用于音频、视频传输。但是不保证数据的完整性。</p>
<p>TCP：传输数据前先在发送端和接收端建立逻辑连接，然后再传输数据，必须明确客户端与服务端，保证两台计算机之间可靠无差错的数据传输。</p>
<h2 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h2><p>UDP通信过程相当于在两个码头之间通过集装箱发送货物。JDK中提供一个DatagramPacket类，该类的实例对象相当于一个集装箱，用于封装UDP通信中发送或者接收的数据。DatagramSocket类，该类的实例对象相当于码头，用于发送和接收DatagramPacket数据报。</p>
<h3 id="DatagramPacket"><a href="#DatagramPacket" class="headerlink" title="DatagramPacket"></a>DatagramPacket</h3><p>创建发送端和接收端的DatagramPacket对象时，使用的构造方法有所不同。接收端的构造方法只需要接收一个字节数组来存放接收到的数据。发送端的构造方法不但要接收存放了发送数据的字节数组，还需要指定接收端IP地址和端口号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramPacket(<span class="type">byte</span>[] buf, <span class="type">int</span> length)   用于接收端，指定字节数组和数据的大小</span><br><span class="line">DatagramPacket(<span class="type">byte</span>[] buf, <span class="type">int</span> offset, <span class="type">int</span> length)   增加一个偏移量，从该位置开始发送</span><br><span class="line">DatagramPacket(<span class="type">byte</span>[] buf, <span class="type">int</span> length, InetAddress add, <span class="type">int</span> port)   用于发送端，指定字节数组和数据的大小，必须的目标ip和端口</span><br><span class="line">DatagramPacket(<span class="type">byte</span>[] buf, <span class="type">int</span> offset, <span class="type">int</span> length, InetAddress add, <span class="type">int</span> port)   增加一个偏移量，从该位置开始发送</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意传入的是InetAddress对象，而不是String形式的ip地址。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramPacket对象.getAddress()  得到InetAddress对象，发送端的得到的是接收端的</span><br><span class="line">DatagramPacket对象.getPort()  返回<span class="type">int</span>端口号，发送端返回接收端的</span><br><span class="line">DatagramPacket对象.getData()  返回接收/发送的数据，发送的返回发送的，返回<span class="type">byte</span>[]类型</span><br><span class="line">DatagramPacket对象.getLength() 返回<span class="type">int</span>接收/发送的数据长度</span><br></pre></td></tr></table></figure>

<h3 id="DatagramSocket"><a href="#DatagramSocket" class="headerlink" title="DatagramSocket"></a>DatagramSocket</h3><p>用于创建发送端和接收端对象，创建发送端和接收端DatagramSocket对象时，使用的构造方法不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket(<span class="type">int</span> port)  用于发送端，在创建发送端DatagramSocket对象时，可以不指定端口号，系统进行分配，也可以指定。用于接收端，必须指定端口号。</span><br><span class="line">DatagramSocket(<span class="type">int</span> port, InetAddress addr)  指定端口号外，还指定了ip地址，用于计算机上有多块网卡，明确规定数据通过哪块网卡向外发送或接收。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket对象.receive(DatagramPacket p)   用于接收DatagramPacket数据报，在接收到数据之前会一直处于阻塞状态，如果发送消息的长度比数据报长，则消息会被截取。</span><br><span class="line">DatagramSocket对象.send(DatagramPacket p)   用于发送DatagramPacket数据报，其中应该包含发送的数据、长度、接收端ip、端口号</span><br><span class="line">DatagramSocket对象.close()   关闭当前socket，通知驱动程序释放为这个socket保留的资源。</span><br></pre></td></tr></table></figure>

<h3 id="UDP实现"><a href="#UDP实现" class="headerlink" title="UDP实现"></a>UDP实现</h3><p>通信时，需要接收端程序先运行，才能避免因发送端发送的数据无法接收而造成的数据丢失。</p>
<p>接收端程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: UDP接收端程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-02 19:41</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPReceiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//定义一个指定端口号为8900的接收端DatagramSocket对象</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8900</span>);</span><br><span class="line">        <span class="comment">//定义一个长度为1024的字节数组，用于接收数据</span></span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//定义一个DatagramPacket数据报对象，用于封装接收的数据</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收数据&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;   <span class="comment">//使得一直循环接收</span></span><br><span class="line">            <span class="comment">//等待接收数据，在没有接收到之前处于阻塞状态</span></span><br><span class="line">            server.receive(packet);</span><br><span class="line">            <span class="comment">//调用DatagramPacket的方法获得接收到的信息，并转换成字符串形式</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line">            System.out.println(packet.getAddress()+<span class="string">&quot;:&quot;</span>+packet.getPort()+<span class="string">&quot;发送消息：&quot;</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送端程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: UDP发送端程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-02 20:25</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPSender</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//定义一个指定端口号3000的发送端DatagramSocket对象</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">3000</span>); <span class="comment">//可以不指定端口</span></span><br><span class="line">        <span class="comment">//定义要发送的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">        System.out.println(Arrays.toString(str.getBytes()));</span><br><span class="line">        <span class="comment">//定义一个DatagramPacket数据报对象，封装发送端信息以及发送地址</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(str.getBytes(),</span><br><span class="line">                str.getBytes().length, InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">8900</span>);  <span class="comment">//这个一定要与接收端程序设置一样</span></span><br><span class="line">        System.out.println(<span class="string">&quot;开始发送数据...&quot;</span>);</span><br><span class="line">        client.send(packet);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>byte[]数组，里面存的是数字，编解码变为字符串。</p>
<p>疑问：byte是1字节，8bit，char是2字节，如何对应？</p>
<p>一个字符等于几个字节？</p>
<p>不同的字符所占的字节是不同的。</p>
<p>ASCII码：</p>
<p>一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。如一个ASCII码就是一个字节。</p>
<p>UTF-8编码：</p>
<p>一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。</p>
<p>Unicode编码：</p>
<p>一个英文等于两个字节，一个中文（含繁体）等于两个字节。</p>
<p>GBK编码：</p>
<p>中文占两个字节，英文占1个字节。</p>
</blockquote>
<p>UDP程序在发送数据时是一次性全部封装到<code>DatagramPacket</code>数据报中进行统一发送的，然而<code>DatagramPacket</code>数据报一次性允许封装的数据量是有限度的，理论最大值是：65507个字节（IP数据报的最大限制65535字节减去IP首部的20字节和UDP首部的8字节）。但是许多平台实际的最大限制是8192字节（8K）。</p>
<blockquote>
<p>检查计算机使用的端口：netstat -anb</p>
<p>报错：netstat: option requires an argument – p</p>
<p>在Mac上正确使用的方法是：即-f需要加上地址族，-p需要加上协议TCP或者UDP等</p>
<p>a）如果需要查询inet，netstat -anvf inet</p>
<p> b）如果需要查询TCP， netstat -anvp tcp</p>
<p> b）如果需要查询UDP，netstat -anvp udp   </p>
<p>netstat -anvp tcp |grep 10001</p>
</blockquote>
<h3 id="小项目-聊天程序"><a href="#小项目-聊天程序" class="headerlink" title="小项目-聊天程序"></a>小项目-聊天程序</h3><p>模拟qq中两个用户一对一聊天，通过多线程实现发送端和接收端功能。</p>
<p>主机程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 聊天程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-02 21:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatRoom1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;输入本机端口号：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">serverPort</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.print(<span class="string">&quot;输入目标计算机端口号：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetPort</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;聊天服务启动！&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建聊天程序收发平台DatagramSocket对象</span></span><br><span class="line">            <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(serverPort);</span><br><span class="line">            <span class="comment">//启动信息接收端和发送端程序</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ChatReceiver</span>(socket), <span class="string">&quot;接收端服务&quot;</span>).start();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ChatSender</span>(socket, targetPort), <span class="string">&quot;发送服务&quot;</span>).start();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SocketException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 接收端程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-02 22:06</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatReceiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//需要有DatagramSocket对象</span></span><br><span class="line">    <span class="keyword">private</span> DatagramSocket server;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChatReceiver</span><span class="params">(DatagramSocket server)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.server = server;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//定义一个DatagramPacket数据报对象，用于封装接收的数据</span></span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length);</span><br><span class="line">            System.out.println(<span class="string">&quot;等待接收数据&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;   <span class="comment">//使得一直循环接收</span></span><br><span class="line">                <span class="comment">//等待接收数据，在没有接收到之前处于阻塞状态</span></span><br><span class="line">                server.receive(packet);</span><br><span class="line">                <span class="comment">//调用DatagramPacket的方法获得接收到的信息，并转换成字符串形式</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;收到&quot;</span>+packet.getAddress()+<span class="string">&quot;:&quot;</span>+packet.getPort()+<span class="string">&quot;发送的数据：&quot;</span>+str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 发送端程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-02 22:14</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatSender</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//需要有DatagramSocket对象</span></span><br><span class="line">    <span class="keyword">private</span> DatagramSocket client;</span><br><span class="line">    <span class="comment">//还需要目标端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> targetPort;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChatSender</span><span class="params">(DatagramSocket client, <span class="type">int</span> targetPort)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.client = client;</span><br><span class="line">        <span class="built_in">this</span>.targetPort = targetPort;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                <span class="type">byte</span>[] buf = data.getBytes();</span><br><span class="line">                <span class="comment">//这里需要目标ip地址，以及目标端口号</span></span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length,</span><br><span class="line">                        InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), targetPort);</span><br><span class="line">                <span class="comment">//127.0.0.1 和 localhost 一样，都是本机</span></span><br><span class="line">                client.send(packet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于端口号有点乱：</p>
<p>发送端：DatagramSocket中可指定也可不指定端口号。DatagramPacket一定要指定接收端的ip和接收端接收端口。</p>
<p>接收端：DatagramSocket一定要指定接收端口，DatagramPacket里面不需要ip和端口。</p>
<p>在上面的UDP实现中，发送和接收的端口号不同。是单向的。</p>
<p>这个聊天程序中，模拟两个主机，一个主机的发送和接收的端口是一样的，所以一个主机发送和接收的socket一样。但是两个目标主机的端口要对应上。是双向的。</p>
</blockquote>
<h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><p>UDP只有发送端和接收端，不区分客户端和服务器端，计算机之间可以任意地发送数据。</p>
<p>TCP严格区分客户端和服务器端，在通信时，必须先由客户端去连接服务器端才能实现通信，服务器端不会主动连接客户端。</p>
<p>JDK提供ServerSocket类表示服务器端，Socket类表示客户端。通信时，首先创建代表服务器端的ServerSocket对象，开启一个服务，并等待客户端的连接；然后创建Socket对象代表客户端，向服务器端发出连接请求。服务器端响应请求，两者建立连接后正式进行通信。</p>
<h3 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h3><p>java.net包中，表示服务器端，需要自己端口号，构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>ServerSocket()   <span class="comment">//没有指定端口号，不能直接使用，需要bind(SocketAddress endpoint)方法将其绑定到指定端口号。</span></span><br><span class="line"><span class="number">2.</span>ServerSocket(<span class="type">int</span> port)   <span class="comment">//指定端口，如果参数是0，系统会分配一个未被占用的端口号，并不常用，因为客户端需要知道端口号。（最常用）</span></span><br><span class="line"><span class="number">3.</span>ServerSocket(<span class="type">int</span> port, <span class="type">int</span> backlog)  <span class="comment">//backlog表示在服务器忙时，可与之保持连接请求的等待客户端数量。默认50。</span></span><br><span class="line"><span class="number">4.</span>ServerSocket(<span class="type">int</span> port, <span class="type">int</span> backlog, InetAddress bindAddr)  <span class="comment">//在多网卡情况下使用，指定使用服务器的哪个ip</span></span><br></pre></td></tr></table></figure>

<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket对象.accept()   <span class="comment">//等待与客户端的连接，与客户端连接之前一直处于阻塞状态，如果有连接就返回与之连接的客户端Socket对象</span></span><br><span class="line">ServerSocket对象.getInetAddress()   <span class="comment">//返回一个InetAddress对象，表示ServerSocket绑定的ip</span></span><br><span class="line">ServerSocket对象.isClosed()   <span class="comment">//返回boolean，判断ServerSocket对象是否为关闭状态</span></span><br><span class="line">ServerSocket对象.bind（SocketAddress endpoint）  <span class="comment">//无返回，将ServerSocket对象绑定到指定ip和端口</span></span><br></pre></td></tr></table></figure>

<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>用于实现TCP客户端程序，需要目标ip和端口号（本机端口号呢？），构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>Socket()  <span class="comment">//没有指定ip和端口号，不能直接使用，需要调用connect(SocketAddress endpoint)方法完成与指定服务器端的连接，参数endpoint封装了ip地址和端口号。</span></span><br><span class="line"><span class="number">2.</span>Socket(String host, <span class="type">int</span> port)   <span class="comment">//host表示一个字符串类型的ip地址</span></span><br><span class="line"><span class="number">3.</span>Socket(InetAddress add, <span class="type">int</span> port)   <span class="comment">//add封装ip</span></span><br></pre></td></tr></table></figure>

<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>Socket对象.getPort()  <span class="comment">//返回int，获得Socket连接的远程服务器的端口号</span></span><br><span class="line"><span class="number">2.</span>Socket对象.getLocalAddress()   <span class="comment">//返回Socket对象绑定的本地ip</span></span><br><span class="line"><span class="number">3.</span>Socket对象.close()  <span class="comment">//无返回，关闭Socket连接，关闭之前，先关闭所有输入输出流</span></span><br><span class="line"><span class="number">4.</span>Socket对象.getInputStream()  <span class="comment">//返回一个InputStream类型的输入流对象。服务器端的Socket调用，用于获取来自客户端发送的数据。客户端的Socket调用，用于获取来自服务端发送的数据。</span></span><br><span class="line"><span class="number">5.</span>Socket对象.getOutputStream()  <span class="comment">//返回一个OutputStream类型的输出流对象。服务器端的Socket调用，用于向客户端发送数据。客户端的Socket调用，用于向服务端发送数据。</span></span><br></pre></td></tr></table></figure>

<p>当客户端与服务端建立连接后，数据是以I&#x2F;O流的形式进行交互的。</p>
<p>输入流和输出流的方法都是Socket对象调用的，无论客户端还是服务器端中，都有Socket对象。输入流用来获取输入到本机的数据，read方法。输出流用来向另一台输出数据，write方法。</p>
<h3 id="TCP实现"><a href="#TCP实现" class="headerlink" title="TCP实现"></a>TCP实现</h3><p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TCP服务器端实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-03 11:23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建指定端口号的服务端ServerSocket对象</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">7788</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//调用accept方法开始接收数据</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;accept返回，连接成功。&quot;</span>);</span><br><span class="line">            <span class="comment">//向客户端发送数据，write方法</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">            <span class="comment">//向客户端发送数据，用客户端的输出流</span></span><br><span class="line">            os.write((<span class="string">&quot;我是服务端。&quot;</span>).getBytes());</span><br><span class="line">            <span class="comment">//模拟交互耗时</span></span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="comment">//关闭流和Socket连接</span></span><br><span class="line">            os.close();</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client（Socket类型的对象）用于表示客户端，通过该对象可以获取与客户端关联的输出流并向客户端发送信息。</p>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.SocketHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TCP客户端程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-03 13:01</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建一个Socket并连接到指定的服务端</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">7788</span>);</span><br><span class="line">        <span class="comment">//获取输入到本机的数据，并打印，用read方法</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> client.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(buf);</span><br><span class="line">        <span class="keyword">while</span>(len!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, len));</span><br><span class="line">            len = is.read(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭流和Socket连接</span></span><br><span class="line">        is.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，一台主机两个端口分别服务端和客户端，服务端等待连接，客户端连接成功后，服务端知道了自己输出连接成功。然后服务端向客户端传输我是服务端，客户端并没有向服务端传输。服务端 –&gt; 客户端。   服务端需要指定端口号，客户端需要指定要连接的目标的ip和端口号（和服务端端口号一样）。客户端不需要自己的端口号？系统自己给客户端端口。</p>
<p>以上涉及到IO操作。</p>
<h3 id="多线程的TCP网络程序"><a href="#多线程的TCP网络程序" class="headerlink" title="多线程的TCP网络程序"></a>多线程的TCP网络程序</h3><p>上面的实现是：一个客户端程序请求服务器端时，服务器端会结束阻塞状态，完成程序的运行。实际上，服务器端程序允许多个应用程序访问，服务器端都是多线程的。</p>
<p>服务器端为每个客户端创建一个对应的Socket对象，并且开启一个新线程使两个Socket建立专线进行通信。</p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.threadtcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 多线程TCP服务端程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-03 20:06</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建指定端口号的服务端ServerSocket对象</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">7789</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//调用accept方法开始接收数据</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">            <span class="comment">//针对每个客户端请求创建一个线程进行连接管理</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> client.getPort();</span><br><span class="line">                    System.out.println(<span class="string">&quot;与端口号为&quot;</span>+port+<span class="string">&quot;的客户端连接成功！&quot;</span>);</span><br><span class="line">                    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">                    <span class="comment">//向客户端发送数据，用输出流（不应该用服务端的输出流吗？）</span></span><br><span class="line">                    os.write((<span class="string">&quot;我是服务端，服务端向你问好。&quot;</span>).getBytes());</span><br><span class="line">                    <span class="comment">//模拟交互耗时</span></span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;结束与客户端数据交互。&quot;</span>);</span><br><span class="line">                    <span class="comment">//关闭流和Socket连接</span></span><br><span class="line">                    os.close();</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//执行线程类，与客户端进行数据交互</span></span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端程序没变，搞三个客户端进行测试。同样只是服务端向客户端发送数据。</p>
<h3 id="小项目-文件上传"><a href="#小项目-文件上传" class="headerlink" title="小项目-文件上传"></a>小项目-文件上传</h3><p>实现客户端向服务端发送图片，服务端接收图片并保存。略。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》类与集合</title>
    <url>/2021/11/17/myblog/java/%E3%80%8AJava%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E3%80%8B%E7%B1%BB%E4%B8%8E%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="java中的常用类"><a href="#java中的常用类" class="headerlink" title="java中的常用类"></a>java中的常用类</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String类的几种初始化方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>使用字符串常量直接初始化一个String对象</span><br><span class="line"><span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="literal">null</span>;  初始化为空</span><br><span class="line"><span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> “”;  初始化为空字符串</span><br><span class="line"><span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> “abc”;  初始化为abc</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>使用String的构造方法初始化字符串对象</span><br><span class="line"><span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();  初始化为空字符串</span><br><span class="line"><span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);  初始化为abc</span><br><span class="line"><span class="comment">//根据指定字符数组创建字符串</span></span><br><span class="line"><span class="type">char</span>[] ch = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br></pre></td></tr></table></figure>

<p>String类基本操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">&quot;abcdefghigk&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;字符串长度：&quot;</span>+s.length());</span><br><span class="line"><span class="comment">//字符串是.length()，数组是.length</span></span><br><span class="line">System.out.println(<span class="string">&quot;字符串第i个字符：&quot;</span>+s.charAt(i));</span><br><span class="line">System.out.println(<span class="string">&quot;字符c第一次出现的位置：&quot;</span>+s.indexOf(<span class="string">&#x27;c&#x27;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;字符c最后一次出现的位置：&quot;</span>+s.lastIndexOf(<span class="string">&#x27;c&#x27;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;子字符串第一次出现的位置：&quot;</span>+s.indexOf(<span class="string">&quot;ab&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;子字符串最后一次出现的位置：&quot;</span>+s.lastIndexOf(<span class="string">&quot;ab&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>字符串的转换操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="comment">//字符串转换为字符数组：</span></span><br><span class="line"><span class="type">char</span>[] ch=s.toCharArray();</span><br><span class="line">System.out.println(<span class="string">&quot;int值转换为string类型：&quot;</span>+String.valueOf(<span class="number">100</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;字符串转换为大写：&quot;</span>+s.toUpperCase());</span><br></pre></td></tr></table></figure>

<p>字符串的替换和去除空格操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">&quot;  a b &quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;去除字符串两端空格后的结果：&quot;</span>+s.trim());</span><br><span class="line"><span class="comment">//用字符串替换操作完成去除空格</span></span><br><span class="line">System.out.println(<span class="string">&quot;去除字符串所有空格后的结果：&quot;</span>+s.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>replace()方法是可以替换子字符串的。</p>
<p>字符串的判断操作：返回boolean类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">&quot;Starter&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否以字符串St开头：&quot;</span>+s.startWith(<span class="string">&quot;St&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否以字符串er结尾：&quot;</span>+s.endWith(<span class="string">&quot;er&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否包含ar：&quot;</span>+s.contains(<span class="string">&quot;ar&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否为空：&quot;</span>+s.isEmpty());</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否相等：&quot;</span>+s.equals(<span class="string">&quot;St&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="和equals"><a href="#和equals" class="headerlink" title="&#x3D;&#x3D;和equals()"></a>&#x3D;&#x3D;和equals()</h4><p> &#x3D;&#x3D;对于基本类型和引用类型 的作用效果是不同的，如下所示：</p>
<ul>
<li>基本类型：比较的是值是否相同</li>
<li>引用类型：比较的是引用（对象的内存地址）是否相同，string是引用类型。</li>
</ul>
<p>equals 本质上就是 &#x3D;&#x3D;，只不过 String 和 Integer 等重写了 equals 方法，<strong>把它变成了值比较。</strong></p>
<p>在String类中，重写了父类Object中的equals()方法。把它变成了<strong>值比较</strong>。</p>
<p>&#x3D;&#x3D;和equals()方法不同，equals方法用来比较两个字符串中的字符值是否相等，&#x3D;&#x3D;方法用于比较两个字符串对象的内存地址是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">x==y  (<span class="literal">true</span>)  x.equals(y)  (<span class="literal">true</span>)</span><br><span class="line"><span class="type">String</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;string&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">z==m  (<span class="literal">false</span>)  z.equals(m)  (<span class="literal">true</span>)</span><br><span class="line">x==z  (<span class="literal">false</span>)  x.equals(z)  (<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>字符串的截取与分割：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">&quot;2021-11-11&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;截取：&quot;</span>+s.substring(<span class="number">5</span>));</span><br><span class="line"><span class="comment">//结果为11-24  左闭右开原则，从下标5开始截取</span></span><br><span class="line">System.out.println(<span class="string">&quot;截取：&quot;</span>+s.substring(<span class="number">5</span>,<span class="number">7</span>));</span><br><span class="line"><span class="comment">//结果为11</span></span><br><span class="line">String[] sArray=s.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="comment">//将字符串按照某个字符进行分割，变为字符串数组</span></span><br></pre></td></tr></table></figure>

<p>java中，String类是final类型的，所以使用String类定义的字符串是一个常量，它一旦创建，内容和长度不可改变。</p>
<h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><p>类似一个字符容器，在其中添加和删除字符时，操作的都是这个字符容器，不会产生新的StringBuffer对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb.append(<span class="string">&quot;abc&quot;</span>);   <span class="comment">//添加字符串，始终是添加到缓冲区的末尾</span></span><br><span class="line">sb.insert(<span class="number">3</span>,<span class="string">&quot;de&quot;</span>);   <span class="comment">//在3的前面插入，变为abcde</span></span><br><span class="line">sb.setCharAt(<span class="number">2</span>,<span class="string">&#x27;f&#x27;</span>);  <span class="comment">//修改指定位置字符，变为abfde</span></span><br><span class="line">sb.replace(<span class="number">3</span>,<span class="number">5</span>,<span class="string">&quot;gh&quot;</span>);  <span class="comment">//左闭右开替换指定位置字符串或字符</span></span><br><span class="line">System.out.println(sb.reverse());   <span class="comment">//字符串翻转结果</span></span><br><span class="line">sb.delete(<span class="number">3</span>,<span class="number">7</span>);   <span class="comment">//左闭右开删除</span></span><br><span class="line">sb.deleteCharAt(<span class="number">2</span>);   <span class="comment">//删除指定位置字符</span></span><br><span class="line">sb.delete(<span class="number">0</span>,sb.length());   <span class="comment">//清空缓冲区</span></span><br></pre></td></tr></table></figure>

<h3 id="String和StringBuffer区别"><a href="#String和StringBuffer区别" class="headerlink" title="String和StringBuffer区别"></a>String和StringBuffer区别</h3><p>（1）String类定义的字符串是常量，一旦创建后，内容和长度都是无法改变的。StringBuffer类表示字符容器，其内容和长度可以随时修改。</p>
<p>（2）String类重写了Object类的equals()方法，而StringBuffer类没有重写Object类的equals方法，依然表示内存地址相同？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String s2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(s1.equals(s2));   <span class="comment">//结果为true</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb1=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">StringBuffer sb2=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(sb1.equals(sb2));   <span class="comment">//结果为false</span></span><br></pre></td></tr></table></figure>

<p>（3）String类对象可以用操作符+进行连接，而StringBuffer类对象之间不能。</p>
<h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>除了使用StringBuffer外，JDK1.5之后提供了StringBuilder类，同样可以操作字符串。</p>
<p>不同之处在于，StringBuffer是线程安全的，而StringBuilder没有实现线程安全功能，所以性能略高。因此，一般创建一个内容可变的字符串对象，应该优先考虑StringBuilder类。</p>
<p>StringBuilder类的方法和StringBuffer类一样。</p>
<h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p>System类定义了一些与系统相关的属性和方法，它所提供的属性和方法都是静态的，可以直接使用System类进行调用（不用创建对象进行调用）。</p>
<h4 id="getProperties-方法"><a href="#getProperties-方法" class="headerlink" title="getProperties()方法"></a>getProperties()方法</h4><p>用于获取当前系统的全部属性，该方法返回一个Properties对象，其中封装了系统的所有属性，这些属性以键值对的形式存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemPropertiesDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	    <span class="comment">//获取系统所有属性</span></span><br><span class="line">		<span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> System.getProperties();</span><br><span class="line">		<span class="comment">//获取所有系统属性的key，返回set对象</span></span><br><span class="line">        Set&lt;String&gt;proName=pro.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span>(String key:proName)&#123;</span><br><span class="line">            <span class="comment">//获取key（属性名）对应的属性值</span></span><br><span class="line">            String value=System.getProperty(key);</span><br><span class="line">            System.out.println(key+<span class="string">&quot;-&gt;&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="currentTimeMillis"><a href="#currentTimeMillis" class="headerlink" title="currentTimeMillis()"></a>currentTimeMillis()</h4><p>currentTimeMillis()方法返回一个long类型的值，表示当前时间与1970年1月1日0点0分0秒之间的时间差，单位毫秒。</p>
<h4 id="arraycopy-方法"><a href="#arraycopy-方法" class="headerlink" title="arraycopy()方法"></a>arraycopy()方法</h4><p>用于将一个数组中的元素快速拷贝到另一个数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a=&#123;<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>,<span class="number">104</span>,<span class="number">105</span>,<span class="number">106</span>&#125;;  <span class="comment">//源数组</span></span><br><span class="line"><span class="type">int</span>[] b=&#123;<span class="number">201</span>,<span class="number">202</span>,<span class="number">203</span>,<span class="number">204</span>,<span class="number">205</span>&#125;;   <span class="comment">//目标数组</span></span><br><span class="line">System.arraycopy(a,<span class="number">2</span>,b,<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//最终b变为103，104，105，106，205</span></span><br></pre></td></tr></table></figure>

<p>以上例子中，从a数组索引为2的元素开始拷贝，并且拷贝4个元素存放在目标数组中索引为0的位置。</p>
<p>注意：进行数组拷贝时，一定要保证源数组类型和目标数组类型一致，截取的长度不能超过源数组界限，也不能超过目标数组可以容纳的个数。</p>
<h4 id="gc-方法和exit-int-status-方法"><a href="#gc-方法和exit-int-status-方法" class="headerlink" title="gc()方法和exit(int status)方法"></a>gc()方法和exit(int status)方法</h4><p>gc()方法用于启动java的垃圾回收器，并对内存中的垃圾对象进行回收。</p>
<p>exit(int status)用于终止当前正在运行的java虚拟机，参数表示当前发生的异常状态，一般指定0，表示正常退出，否则表示异常终止。</p>
<h3 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h3><p>Runtime类用于表示Java虚拟机运行时的状态，用于封装Java虚拟机进程，因此可以通过该类的实例对象来获取当前虚拟机的相关信息。</p>
<p>每次使用java命令启动java虚拟机时都会对应一个Runtime实例，并且只有一个实例，应用程序会通过该实例与其运行时的环境相连。应用程序不能创建自己的Runtime实例，若想在程序中获得一个Runtime实例，可以通过getRuntime()方法获取与之相关的Runtime对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime rt=Runtime.getRuntime(); <span class="comment">//获取java程序关联的运行时对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;处理器个数：&quot;</span>+rt.availableProcessors()); <span class="comment">//单位个</span></span><br><span class="line">System.out.println(<span class="string">&quot;空闲内存大小：&quot;</span>+rt.freeMemory()); <span class="comment">//单位字节</span></span><br><span class="line">System.out.println(<span class="string">&quot;最大可用内存大小：&quot;</span>+rt.maxMemory()); <span class="comment">//单位字节</span></span><br></pre></td></tr></table></figure>

<h4 id="exec-方法"><a href="#exec-方法" class="headerlink" title="exec()方法"></a>exec()方法</h4><p>该方法用于执行一个DOS命令，实现和在终端中输入DOS命令同样的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime rt=Runtime.getRuntime();</span><br><span class="line">rt.exec(<span class="string">&quot;notepad.exe&quot;</span>)   <span class="comment">//打开记事本</span></span><br></pre></td></tr></table></figure>

<p>exec()方法返回一个Process对象，该对象表示操作系统的一个进程，通过Process对象可对产生的新进程进行管理，如关闭destroy()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime rt=Runtime.getRuntime();</span><br><span class="line"><span class="type">Process</span> <span class="variable">pr</span> <span class="operator">=</span> rt.exec(<span class="string">&quot;notepad.exe&quot;</span>)   <span class="comment">//打开记事本</span></span><br><span class="line"><span class="comment">//程序休眠3s</span></span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">pr.destroy();   <span class="comment">//关闭进程</span></span><br></pre></td></tr></table></figure>

<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>Math类是一个工具类，主要用于完成复杂的数学运算，如求绝对值，三角函数，指数运算等。其构造方法被定义为private，因此无法创建Math类的对象。</p>
<p>Math类的多有方法都是静态方法，可以直接通过类名来调用它们。</p>
<p>除静态方法外，Math类中还有两个静态常量PI和E，分别表示Π和e。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math.abs(-1);</span><br><span class="line">Math.sin/tan/cos(2.0);</span><br><span class="line">Math.sqrt(4);  //求平方根</span><br><span class="line">Math.cbrt(9);  //求立方根</span><br><span class="line">Math.pow(2,2);  //幂次运算</span><br><span class="line">Math.ceil(1.2);  //大于参数的最小整数，返回double类型的数</span><br><span class="line">Math.floor(1.2);  //小于参数的最大整数，返回double类型的数</span><br><span class="line">Math.round(1.2);  //四舍五入的整数，返回int类型的数</span><br><span class="line">Math.max(1,2);</span><br><span class="line">Math.min(1,2);</span><br><span class="line">Math.random();   //生成一个大于等于0.0小于1.0的随机值</span><br></pre></td></tr></table></figure>

<h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><p>在JDK的java.util包中，有一个Random类，可以在指定的取值范围内随机产生数字。</p>
<p>Random类有两个构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random()   无参构造，通过它创建的Random实例对象每次使用的种子随机，因此每个对象所产生的随机数不同。</span><br><span class="line">Random(<span class="type">long</span> seed)  有参构造，使用种子创建伪随机数生成器，当seed相同时，每次实例化Random对象会生成相同的随机数</span><br></pre></td></tr></table></figure>

<p>Random类的各种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">r.nextBoolean()    随机的<span class="type">boolean</span></span><br><span class="line">r.nextDouble()   <span class="type">double</span>类型的随机数</span><br><span class="line">r.nextFloat()  <span class="type">float</span>类型的随机数</span><br><span class="line">r.nextInt()   <span class="type">int</span>类型的随机数</span><br><span class="line">r.nextInt(<span class="number">10</span>)  <span class="number">0</span>到<span class="number">10</span>之间<span class="type">int</span>类型的随机数</span><br><span class="line">r.nextLong()   <span class="type">long</span>型随机数</span><br></pre></td></tr></table></figure>

<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>虽然Java是面向对象的编程语言，但它所包含的8种基本数据类型却不支持面向对象的编程机制（没有属性和方法）。Java之所以提供这8种基本数据类型，是为了方便常规数据的处理。但是在Java种，很多类的方法都需要接收引用类型的对象，此时就无法将一个基本数据类型的值传入。</p>
<p>为了解决这一问题，JDK提供了一系列的包装类，通过包装类可以将基本数据类型的值包装为引用数据类型的对象。</p>
<table>
<thead>
<tr>
<th align="center">byte</th>
<th align="center">Byte</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
</tbody></table>
<p>包装类和基本数据类型在转换时，引入了自动装箱和自动拆箱</p>
<p>装箱：将基本数据类型的变量赋给对应的包装类变量（对象）。</p>
<p><code>int a=20;    Integer b=a;</code></p>
<p>拆箱：将包装类对象类型直接赋给一个对应的基本数据类型变量。</p>
<p><code>int c=b</code></p>
<p>此外，Java还提供了其他方法来支持基本数据类型、基本数据包装类以及字符串之间的相互转换。</p>
<p>（1）String类的valueOf()方法，将八种基本数据类型转化为字符串类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num=123;</span><br><span class="line">String s=String.valueOf(num);</span><br></pre></td></tr></table></figure>

<p>（2）包装类的valueOf()方法，既可以实现装箱，也可以实现将内容匹配的字符串转换为对应的包装类（除Character包装类）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num=123;</span><br><span class="line">Integer in=Integer.valueOf(num);</span><br><span class="line">String s=&quot;123&quot;;</span><br><span class="line">Integer in2=Integer.valueOf(s);</span><br></pre></td></tr></table></figure>

<p>（3）通过包装类的有参构造方法将基本数据类型转换为包装类（装箱），也可以将字符串转换为包装类（除Character包装类）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num=123;</span><br><span class="line">Integer in=new Integer(num);</span><br><span class="line">String s=&quot;123&quot;;</span><br><span class="line">Integer in2=new Integer(s);</span><br></pre></td></tr></table></figure>

<p>（4）通过包装类的静态方法parseXxx()方法将字符串转换为对应的基本数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s=&quot;123&quot;;</span><br><span class="line">int num=Integer.parseInt(s);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>凡是类名.方法名的，都是静态static方法</p>
</blockquote>
<p>（5）包装类都重写了Object类中的toString方法，将包装类转换为字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer in=new Integer(123);</span><br><span class="line">//Integer in=Integer.valueOf(123);</span><br><span class="line">String s=in.toString();</span><br></pre></td></tr></table></figure>

<p>注意：包装类的<code>valueOf(String s)</code>和<code>parseInt(String s)</code> 中，参数s不能为null，而且需要和解析对应。</p>
<h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>JDK中的java.util包中，提供了一个Date类用来表示日期和时间，该类在JDK1.0时已经开始使用。JDK8中有两个构造方法可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date()  <span class="comment">//用来创建当前日期时间的Date对象。</span></span><br><span class="line">Date date1=<span class="keyword">new</span> <span class="title class_">Date</span>();  <span class="comment">//Sat Jan 11:09:21 CST 2021</span></span><br><span class="line">Date(<span class="type">long</span> date)  <span class="comment">//用于创建指定时间的Date对象，date是1970.1.1.0.0.0以来的毫秒数，即时间戳</span></span><br><span class="line">Date date2=<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis()+<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//Sat Jan 11:09:22 CST 2021</span></span><br></pre></td></tr></table></figure>

<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>Calendar类用于完成日期和时间字段的操作，可以通过特定方法设置和读取日期的特定部分。</p>
<p>Calendar类是一个抽象类，不可以被实例化，在程序中需要调用静态方法getInstance()来得到一个Calendar对象，然后才能调用其相应的方法。</p>
<blockquote>
<p>疑问？抽象类创建对象，这是什么操作？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">ca</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="type">int</span> year=ca.get(Calendar.YEAR);</span><br><span class="line"><span class="type">int</span> month=ca.get(Calendar.MONTH)+<span class="number">1</span>;  <span class="comment">//注意月份0-11，需要加1</span></span><br><span class="line"><span class="type">int</span> date=ca.get(Calendar.DATE);</span><br><span class="line"><span class="type">int</span> hour=ca.get(Calendar.HOUR);</span><br><span class="line"><span class="type">int</span> minute=ca.get(Calendar.MINUTE);</span><br><span class="line"><span class="type">int</span> second=ca.get(Calendar.SECOND);</span><br></pre></td></tr></table></figure>

<p>添加和修改时间的功能可以通过add和set方法实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Calendar ca = Calendar.getInstance();</span><br><span class="line">ca.set(2021.11.11);   //设置指定日期</span><br><span class="line">ca.add(Calendar.DATE,100);  //为指定日期增加时间</span><br><span class="line">输出时间依然需要用get方法来获取年月日。</span><br></pre></td></tr></table></figure>

<p>Calendar有两种解释日历字段的模式，容错模式和非容错模式，容错模式下，月是12是可以接受的。默认容错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Calendar ca = Calendar.getInstance();</span><br><span class="line">ca.set(Calendar.MONTH, 13);  //不会报错</span><br><span class="line">//开启non-lenient非容错模式</span><br><span class="line">ca.setLenient(false);</span><br><span class="line">ca.set(Calendar.MONTH, 13);  //会报错</span><br></pre></td></tr></table></figure>

<p>Date和Calendar对象之间的转化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(ca.getTime());  //Calendar的getTime方法返回一个表示Calendar时间值的Date对象。</span><br><span class="line">setTime(Date date)</span><br><span class="line">Calendar ca = setTime(date);  //Calendar的setTime方法接收一个Date对象，将Date对象表示的时间值设置给Calendar对象。</span><br></pre></td></tr></table></figure>

<h3 id="JDK8的日期和时间类"><a href="#JDK8的日期和时间类" class="headerlink" title="JDK8的日期和时间类"></a>JDK8的日期和时间类</h3><p>为了满足更多的需求，JDK8比之前的版本增加了一个java.time包，在该包下包含了更多日期和时间操作类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、Clock类</span><br><span class="line"><span class="type">Clock</span> <span class="variable">cl</span> <span class="operator">=</span> Clock.systemUTC();</span><br><span class="line">获取UTC时区转换的当前时间： cl.instance()</span><br><span class="line">获取UTC时区转换的毫秒数： cl.millis()</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>Duration类</span><br><span class="line"><span class="type">Duration</span> <span class="variable">du</span> <span class="operator">=</span> Duration.ofDays(<span class="number">1</span>);</span><br><span class="line">一天等于多少小时：  du.toHours()</span><br><span class="line">一天等于多少分钟：  du.toMinutes()</span><br><span class="line">一天等于多少秒：  du.toMillis()</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>Instant类</span><br><span class="line"><span class="type">Instant</span> <span class="variable">in</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">UTC时区的当前时间：in</span><br><span class="line">当前时间一小时后的时间：in.plusSeconds(<span class="number">3600</span>)</span><br><span class="line">当前时间一小时前的时间：in.minusSeconds(<span class="number">3600</span>)</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>LocalDate</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">lo</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">从默认时区的系统时钟获得当前日期：lo</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span>LocalTime</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">lo</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">从默认时区的系统时钟获得当前时间：lo</span><br><span class="line">    </span><br><span class="line"><span class="number">6.</span>LocalDateTime</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">lo</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">从默认时区的系统时钟获得当前日期和时间：lo</span><br><span class="line">当前的日期和时间加上<span class="number">1</span>天<span class="number">3</span>小时<span class="number">30</span>分钟：</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.plusDays(<span class="number">1</span>).plusHours(<span class="number">3</span>).plusMinutes(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>Year、YearMonth、MonthDay</span><br><span class="line">当前年份：<span class="type">Year</span> <span class="variable">ye</span> <span class="operator">=</span> Year.now();</span><br><span class="line">当前年月：<span class="type">YearMonth</span> <span class="variable">ym</span> <span class="operator">=</span> YearMonth.now();</span><br><span class="line">当前月日：<span class="type">MonthDay</span> <span class="variable">md</span> <span class="operator">=</span> MonthDay.now();</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>获取系统默认时区</span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">zi</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br></pre></td></tr></table></figure>

<p>注意，clock.instant()和Instant.now()获取的时间都是默认使用UTC时区（世界协调时间，世界标准时间），比中国标准时间CST早八小时。</p>
<h3 id="格式化类"><a href="#格式化类" class="headerlink" title="格式化类"></a>格式化类</h3><h4 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h4><p>使用Date类时，程序打印Date对象所输出的当前时间都是英文格式输出的，要想以中文的格式输出，就需要DateFormat类。</p>
<p>DateFormat类专门用于将日期格式化为字符串或者将用特定格式显示的日期字符串转换为一个Date对象。</p>
<p>DateFormat类是一个抽象类，不能被直接实例化，但它提供了一系列的静态方法来获取DateFormat类的实例对象，并能调用其他相应的方法进行操作。</p>
<p>定义了四种静态方法用于获取DateFormat类的实例对象，它们分别对日期或者时间部分进行格式化。</p>
<blockquote>
<p>疑问。</p>
</blockquote>
<p>在DateFormat类中还定义了许多常量，其中四个常量值是用于作为参数传递给方法的，包括FULL、LONG、MEDIUM、SHORT。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Date对象</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">//1.当前日期的完整格式对象</span></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">fullFormat</span> <span class="operator">=</span> DateFormat.getDateInstance(DateFormat.FULL);</span><br><span class="line"><span class="comment">//format将一个Date格式化为日期/时间字符串</span></span><br><span class="line">System.out.println(fullFormat.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.当前日期的长格式对象</span></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">longFormat</span> <span class="operator">=</span> DateFormat.getDateInstance(DateFormat.LONG);</span><br><span class="line"><span class="comment">//format将一个Date格式化为日期/时间字符串</span></span><br><span class="line">System.out.println(longFormat.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.当前日期时间的普通格式对象</span></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">mediumFormat</span> <span class="operator">=</span> DateFormat.getDateTimeInstance(DateFormat.MEDIUM);</span><br><span class="line"><span class="comment">//format将一个Date格式化为日期/时间字符串</span></span><br><span class="line">System.out.println(mediumFormat.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.当前日期时间的短格式对象</span></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">shortFormat</span> <span class="operator">=</span> DateFormat.getDateTimeInstance(DateFormat.SHORT);</span><br><span class="line"><span class="comment">//format将一个Date格式化为日期/时间字符串</span></span><br><span class="line">System.out.println(shortFormat.format(date));</span><br></pre></td></tr></table></figure>

<p>DateFormat类中还有parse(String source)方法，能够将一个字符串解析为Date对象，但是它要求字符串必须符合日期&#x2F;时间的格式要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建普通格式的DateFormat对象</span></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">dt1</span> <span class="operator">=</span> DateFormat.getDateInstance();</span><br><span class="line"><span class="comment">//创建Long格式的DateFormat对象</span></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">dt2</span> <span class="operator">=</span> DateFormat.getDateInstance(DateFormat.LONG);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义日期格式的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;2021-11-11&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;2021年11月11日&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出对应格式的字符串解析为Date对象后的结果</span></span><br><span class="line">System.out.println(dt1.parse(s1));</span><br><span class="line">System.out.println(dt2.parse(s2));</span><br></pre></td></tr></table></figure>

<h4 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h4><p>DateFormat类中parse方法将字符串解析为日期时，需要固定格式，不灵活。</p>
<p>SimpleDateFormat类是DateFormat类的子类，可以使用new关键字创建实例对象。在创建实例对象时，构造方法需要接收一个表示日期格式模板的字符串参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;Gyyyy年MM月dd日：今年时yyyy年的第D天，星期：E&quot;</span>);    <span class="comment">//创建对象</span></span><br><span class="line"><span class="comment">//按SimpleDateFormat对象的日期模板格式化Date对象</span></span><br><span class="line">System.out.println(sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br></pre></td></tr></table></figure>

<p>上面是将一个Date时间对象转换为指定格式字符串形式。</p>
<p>SimpleDateFormat类也可以将一个指定格式字符串解析为Date对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy/MM/dd&quot;</span>);    <span class="comment">//创建对象,并指定日期格式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2021/11/11&quot;</span>;</span><br><span class="line"><span class="comment">//将字符串解析为Date对象</span></span><br><span class="line">System.out.println(sdf.parse(s));</span><br></pre></td></tr></table></figure>

<h4 id="DateTimeFormatter类"><a href="#DateTimeFormatter类" class="headerlink" title="DateTimeFormatter类"></a>DateTimeFormatter类</h4><p>除DateFormat类以及SimpleDateFormat类，JDK8在java.time.format包下还提供了一个DateTimeFormatter类，该类也是格式化类，相当于DateFormat类以及SimpleDateFormat类的合体，它不仅可以将日期时间类型转换为字符串，还可以将字符串解析成日期、时间对象。</p>
<p>1.字符串转换成日期时间类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStringT0LocalDate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// String --&gt; LocalDate</span></span><br><span class="line">        <span class="comment">//使用模式字符串创建DateTimeFormatter格式器</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2019-12-07&quot;</span>);</span><br><span class="line">　　　　　<span class="type">DateTimeFormatter</span> <span class="variable">pattern</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);		　　　　　　    </span><br><span class="line">　　　　　System.out.println(LocalDate.parse(<span class="string">&quot;2019-10-09&quot;</span>).format(pattern));</span><br><span class="line">　　　　　</span><br><span class="line">        <span class="comment">// String --&gt; LocalTime</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;07:43:53&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String --&gt;LocalDateTime</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>); <span class="comment">// 12小时</span></span><br><span class="line">　　　　 <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); <span class="comment">// 24小时              LocalDate localDate = LocalDate.parse(&quot;2019-12-07 07:43:53&quot;,formatter);</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(localDate);</span><br><span class="line">        System.out.println(localTime);</span><br><span class="line">        System.out.println(localDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.日期时间类型转换成字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testLocalDateToString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//localDate --&gt; String </span></span><br><span class="line">        <span class="comment">//使用常量创建DateTimeFormatte</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">String</span> <span class="variable">format1</span> <span class="operator">=</span> localDate.format(DateTimeFormatter.BASIC_ISO_DATE);    <span class="comment">//yyyyMMdd</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">format2</span> <span class="operator">=</span> localDate.format(DateTimeFormatter.ISO_DATE);            <span class="comment">//yyyy-MM-dd</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.LocalTime  --&gt; String</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">        <span class="type">String</span> <span class="variable">format3</span> <span class="operator">=</span> localTime.format(DateTimeFormatter.ISO_TIME);            <span class="comment">//20:19:22.42</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;hh:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">format4</span> <span class="operator">=</span> localTime.format(formatter);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.LocalDateTime  --&gt; String        </span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter2</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">format5</span> <span class="operator">=</span> localDateTime.format(formatter2);</span><br><span class="line">        </span><br><span class="line">        System.out.println(format1);</span><br><span class="line">        System.out.println(format2);</span><br><span class="line">        System.out.println(format3);</span><br><span class="line">        System.out.println(format4);</span><br><span class="line">        System.out.println(format5);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>数组的长度不可变，因此为了保存数目不确定的对象，Java提供了一系列特殊的类，统称集合，集合可以存储任意类型的对象，并且长度可变。</p>
<h3 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h3><p>Java中的集合就像一个容器，专门用来存储Java对象（实际上是对象的引用），这些对象可以是任意的数据类型，并且长度可变。这些集合类都位于java.util包中。</p>
<p>集合类按照其存储结构可以分为两大类：单列集合Collection，双列集合Map。</p>
<p>（1）Collection：单列集合的根接口，用于存储一系列符合某种规律的元素。Collection集合有两个重要的子接口，分别是List和Set。List集合特点：元素有序，可重复。Set集合特点：元素无序，不可重复。List接口的主要实现类：ArrayList、LinkedList。Set接口的主要实现类：HashSet、TreeSet。</p>
<p>（2）Map：双列集合的根接口，用于存储具有键值映射关系的元素。Map接口的主要实现类：HashMap、TreeMap。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2017af8f90a9dff713a5fa908b990a05.png" alt="image-20211113111401531"></p>
<p>虚线是接口类型，实线是实现类。</p>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>List接口继承自Collection接口，是单列集合的一个重要分支，习惯性地将实现了List接口的对象称为List集合。</p>
<p>在List集合中<strong>允许出现重复</strong>的元素，所有的元素以一种线性方式进行存储，在程序中可以通过索引来访问集合中的指定元素，另外，List集合<strong>元素有序</strong>，即元素的存入顺序和取出顺序一致。</p>
<h4 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h4><p>ArrayList是程序中最常见的一种集合。在ArrayList内部封装了一个长度可变的数组对象，当存入的元素超过数组长度时，ArrayList会在内存中分配一个更大的数组来存储这些元素，因此ArrayList可以看作是一个长度可变的数组。</p>
<p>正是由于ArrayList内部的数据存储结构是数组形式，在增加和删除指定位置的元素时，会创建新的数组，效率比较低，因此不适合做大量的增删操作。但是在遍历和查找元素时显得非常高效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建ArrayList集合</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">lis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">lis.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">lis.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">长度： lis.size();</span><br><span class="line">查询： lis.get(i);</span><br></pre></td></tr></table></figure>

<p>注意：在使用ArrayList集合时并没有显式地指定集合中存储什么类型的元素，会产生安全隐患，涉及到泛型安全机制的问题。</p>
<h4 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h4><p>ArrayList查询时速度很快，增删时效率较低，因此另一个实现类：LinkedList。</p>
<p>该集合内部包含两个Node类型的first和last属性维护一个双向循环链表，链表中的每一个元素都使用引用的方式记住它的前一个元素和后一个元素，从而可以将所有的元素彼此连接起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">lik</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">lik.add(<span class="string">&quot;bb&quot;</span>);   <span class="comment">//添加元素</span></span><br><span class="line">lik.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">lik.offer(<span class="string">&quot;dd&quot;</span>);  <span class="comment">//向集合尾部追加元素</span></span><br><span class="line">lik.push(<span class="string">&quot;aa&quot;</span>);  <span class="comment">//向集合头部添加元素</span></span><br><span class="line">System.out.println(lik);   <span class="comment">//输出集合中的元素</span></span><br><span class="line"><span class="comment">//获取元素</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> lik.peek();   <span class="comment">//获取集合第一个元素</span></span><br><span class="line">System.out.println(obj);</span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">lik.removeFirst();   <span class="comment">//删除集合第一个元素</span></span><br><span class="line">lik.pollLast();   <span class="comment">//删除集合最后一个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="Collection集合遍历"><a href="#Collection集合遍历" class="headerlink" title="Collection集合遍历"></a>Collection集合遍历</h3><h4 id="Iterator遍历集合"><a href="#Iterator遍历集合" class="headerlink" title="Iterator遍历集合"></a>Iterator遍历集合</h4><p>Iterator接口是Java集合框架中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用来存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被叫做迭代器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建ArrayList集合</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">lis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">lis.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">lis.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"><span class="comment">//获取Iterator对象</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> lis.iterator();</span><br><span class="line"><span class="comment">//判断集合中是否存在下一个元素</span></span><br><span class="line"><span class="keyword">while</span>(it.hashNext())&#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();  <span class="comment">//获取ArrayList集合中的元素</span></span><br><span class="line">	System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素。</p>
<p>在调用Iterator的next()方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，第一次调用迭代器的next()方法后，迭代器的索引指向第一个元素并将该元素返回。</p>
<p>注意：在使用Iterator迭代器对集合中的元素进行迭代时，如果调用了集合对象的remove()方法去删除元素，会出现异常。因为集合中删除了元素会导致迭代器预期的迭代次数发生变化，导致迭代器的结果不准确。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(it.hashNext())&#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();  <span class="comment">//获取ArrayList集合中的元素</span></span><br><span class="line">	System.out.println(obj);</span><br><span class="line">	<span class="keyword">if</span>(<span class="string">&quot;aa&quot;</span>.equals(obj))&#123;</span><br><span class="line">		lis.remove(obj);  <span class="comment">//删除集合元素</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法一：在删除后用break退出。</p>
<p>解决方法二：使用迭代器本身的删除方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(&quot;aa&quot;.equals(obj))&#123;</span><br><span class="line">	it.remove();   //删除集合元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用迭代器对象的remove()方法删除元素导致的迭代次数变化，对迭代器对象本身来讲是可预知的。</p>
<h4 id="foreach遍历集合"><a href="#foreach遍历集合" class="headerlink" title="foreach遍历集合"></a>foreach遍历集合</h4><p>JDK5开始提供，是一种简洁的for循环，也称增强for循环，用于遍历数组或集合中的元素。会自动遍历容器中的每个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">lis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="keyword">for</span>(Object obj:lis)&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，在foreach循环遍历集合和数组时，只能访问集合中的元素，不能对其中的元素进行修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String[] str = &#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String s:str)&#123;</span><br><span class="line">	s=<span class="string">&quot;aa&quot;</span>;   <span class="comment">//改变对string数组没效果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有效果是因为代码中<code>s=&quot;aa&quot;;</code>只是将临时变量s指向一个新的字符串，和数组中的元素没有关系。</p>
<p>而在普通的for循环中，可以通过索引来进行修改。</p>
<h4 id="JDK8的forEach遍历集合"><a href="#JDK8的forEach遍历集合" class="headerlink" title="JDK8的forEach遍历集合"></a>JDK8的forEach遍历集合</h4><p>在JDK8中，根据Lambda表达式特性，增加了一个<code>forEach(Consumer action)</code>方法来遍历集合，该方法需要一个函数式接口作为参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">lis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">lis.forEach(obj-&gt;System.out.println(<span class="string">&quot;迭代集合元素：&quot;</span>+obj))</span><br></pre></td></tr></table></figure>

<p>该方法传递的是一个Lambda表达式形式书写的函数式接口。forEach方法在执行时会自动遍历集合元素并将元素逐个传递给Lambda表达式的形参。</p>
<p>除此之外，JDK8还为Iterator迭代器对象增加了forEachRemaining(Consumer action)方法来进行遍历，同样需要一个函数式接口作为参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">lis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> lis.iterator();</span><br><span class="line">it.forEachRemianing(obj-&gt;System.out.println(<span class="string">&quot;迭代集合元素：&quot;</span>+obj));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：本节对lList集合遍历的方法，对单列集合Collection进行遍历，因此对Set集合也适用。</p>
</blockquote>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>习惯性地将实现了Set接口的对象称为Set集合。Set集合中的元素<strong>无序</strong>（指存入的顺序和一起输出的顺序是否一致），并且会以某种规则保证存入的<strong>元素不出现重复</strong>。Set接口主要有两个实现类：HashSet、TreeSet。</p>
<p>HashSet是根据对象的哈希值来确定元素在集合中的存储的位置，因此具有良好的存取和查找性能。</p>
<p>TreeSet是以二叉树的方式来存储元素，它可以实现对集合中的元素进行排序。</p>
<h4 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h4><p>HashSet是Set接口的一个实现类，元素不可重复且无序。</p>
<p>保重不重复：当向HashSet集合中添加一个元素时，即调用HashSet集合的add()方法，首先调用当前存入元素的hashCode()方法获得对象的哈希值，然后根据对象的哈希值计算出一个存储位置：如果该位置上没有元素，则直接将元素存入；如果该位置上有元素存在，则会调用equals()方法让当前存入的元素依次和该位置上的元素进行比较。如果返回的结果为false就将该元素存入集合；返回的结果为true则说明有重复元素，就将该元素舍弃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">se</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">se.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">se.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"><span class="comment">//遍历输出Set集合的元素</span></span><br><span class="line">set.forEach(obj-&gt;System.out.println(obj));</span><br></pre></td></tr></table></figure>

<p>为了保证HashSet的正常工作，在存入对象时，需要重写Object类中的hashCode()和equals()方法。String类已经默认重写了<code>hashCode()</code>和<code>equals()</code></p>
<p>如果将开发者自定义的类型对象存入HashSet，需要重写<code>hashCode()</code>和<code>equals()</code>，改为值比较，否则没重写的<code>equals()</code>方法认为两个值相同的引用变量所引用的对象地址不同，认为是两个不同的对象，达不到去重的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String id, String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.id=id;</span><br><span class="line">		<span class="built_in">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写toString()方法</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id+<span class="string">&quot;:&quot;</span>+name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写hashCode方法，根据id判定</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id.hashCode();  <span class="comment">//返回id属性的哈希值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写equals方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">		<span class="comment">//this表示该对象，判断是否为同一对象，如果是则true相同</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span> == obj)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断对象是否为Student类型，如果不是，返回false</span></span><br><span class="line">		<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Student))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将对象强制转换为Student类型</span></span><br><span class="line">		<span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student)obj;</span><br><span class="line">		<span class="comment">//根据id值是否相等</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="built_in">this</span>.id.equals(stu.id);</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TreeSet集合"><a href="#TreeSet集合" class="headerlink" title="TreeSet集合"></a>TreeSet集合</h4><p>TreeSet内部采用平衡二叉树存储元素，这样的结构保证TreeSet集合中没有重复的元素，并且可以对元素进行排序（和Set的无序无关）。左子树小于根节点，右子树大于根节点。当插入一个元素时，首先与顶层元素进行比较，小于左边，大于右边，直到最后一个叶子节点，如果和叶子节点一样，则将该重复元素去掉。否则小于左边，大于右边。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TreeSet</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">ts.add(<span class="number">3</span>);</span><br><span class="line">ts.add(<span class="number">9</span>);</span><br><span class="line">ts.add(<span class="number">1</span>);</span><br><span class="line">ts.add(<span class="number">21</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;ts集合：&quot;</span>+ts);  <span class="comment">//输出为[1,3,9,21]有序</span></span><br><span class="line">首元素： ts.first()  <span class="comment">//1</span></span><br><span class="line">尾元素： ts.last()   <span class="comment">//21</span></span><br><span class="line"><span class="comment">//比较并获取元素</span></span><br><span class="line">ts.floor(<span class="number">9</span>)  <span class="comment">//集合中小于或等于9的最大一个元素 9</span></span><br><span class="line">ts.higher(<span class="number">10</span>)  <span class="comment">//集合中大于10的最小元素 21</span></span><br><span class="line">删除并返回第一个元素： </span><br><span class="line"><span class="type">Object</span> <span class="variable">first</span> <span class="operator">=</span> ts.pollFirst();</span><br><span class="line">删除并返回最后一个元素： </span><br><span class="line"><span class="type">Object</span> <span class="variable">last</span> <span class="operator">=</span> ts.pollLast();</span><br></pre></td></tr></table></figure>

<p>集合中元素添加顺序无论如何，最后都会按一定顺序排列。因为平衡二叉树，每次插入都会与其他元素进行比较，最后插入有序的对象序列中。</p>
<p>集合中的元素在进行比较时，都会调用<code>compareTo()</code>方法，该方法是<code>Comparable</code>接口中定义的，因此要想对集合中的元素进行排序，就必须实现<code>Comparable</code>接口。Java中大多数类都实现了<code>Comparable</code>接口，并默认实现接口中的<code>compareTo()</code>方法，如Integer、Double、String等。</p>
<p>实际开发中，对自定义类型的数据没有实现<code>Comparable</code>接口，无法直接在TreeSet集合中进行排序操作。因此，Java提供了两种TreeSet的排序规则：自然排序、定制排序。默认情况下采用自然排序。</p>
<p>（1）自然排序</p>
<p>自然排序要求向TreeSet集合中存储的元素所在类必须实现<code>Comparable</code>接口，并重写<code>compareTo()</code>方法。然后TreeSet集合就会对该类型元素使用<code>compareTo()</code>方法进行比较，默认升序排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义Teacher类实现Comparable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name=name;</span><br><span class="line">		<span class="built_in">this</span>.age=age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name+<span class="string">&quot;:&quot;</span>+age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写compareTo方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">		<span class="type">Teacher</span> <span class="variable">s</span> <span class="operator">=</span> (Teacher)obj;</span><br><span class="line">		<span class="comment">//定义比较方式，先比较年龄age，再比较name,升序</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span>.age-s.age&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span>.age-s.age==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(s.name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）定制排序</p>
<p>通过在创建TreeSet集合时就自定义一个比较器来对元素进行定制排序。自定义的类型数据中无需实现Comparable接口，并且可以按照自己的想法进行排序。</p>
<p>例子：按照集合中字符串的长度进行定制排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="comment">//定义比较器实现Comparator接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object obj1, Object obj2)</span>&#123;</span><br><span class="line">		String s1=(String)obj1;</span><br><span class="line">		String s2=(String)obj2;</span><br><span class="line">		<span class="type">int</span> temp=s1.length()-s2.length();</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="comment">//法1.创建集合时，传入Comparator接口实现定制排序</span></span><br><span class="line">		TreeSet ts=<span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">MyComparator</span>());</span><br><span class="line">		ts.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		ts.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">		ts.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">		System.out.println(ts);</span><br><span class="line">	<span class="comment">//法2.创建集合时，使用Lambda表达式定制排序，无序上面的MyComparator</span></span><br><span class="line">		TreeSet ts2=<span class="keyword">new</span> <span class="title class_">TreeSet</span>((obj1,obj2)-&gt;&#123;</span><br><span class="line">			String s1=(String)obj1;</span><br><span class="line">			String s2=(String)obj2;</span><br><span class="line">			<span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">		&#125;);</span><br><span class="line">		ts2.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		ts2.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">		ts2.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">		System.out.println(ts2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>Map接口是一种双列集合，包含键对象key和值value，键和值对象之间存在一种映射，一对一的，一个key对应唯一一个value，键对象key不可重复。</p>
<h4 id="HashMap集合"><a href="#HashMap集合" class="headerlink" title="HashMap集合"></a>HashMap集合</h4><p>HahMap集合存储键值映射关系，该集合的键和值允许为空，但键不能重复，且集合中的元素是<strong>无序的</strong>。</p>
<p>HashMap底层：哈希表结构&#x3D;数组+链表。数组是HashMap的主体结构，链表则是为了解决哈希值冲突而存在的分支结构。因此HashMap对元素的增删改查表现出的效率都很高。</p>
<p>水平方向上数组的长度称为HashMap集合的容量（capacity），竖直方向每个元素对应的链表结构称为一个桶（bucket），每个桶的位置在集合中都有对应的桶值，用于快速定位。每个链表结构是&lt;key,value&gt;的键值对。</p>
<p>当向HashMap集合添加元素时，首先调用键对象k的hash(k)方法，快速定位并寻址到该元素在集合中要存储的位置。在定位到存储元素键对象k的哈希值所对应桶位置后，会出现两种情况：<br>1.键对象k的hash值所在的桶位置为空，则直接向该桶插入元素对象。<br>2.键对象k的hash值所在的桶位置不为空，则继续通过键对象的equals(k)方法比较新插入的元素键对象k和已存在的元素键对象k是否相同：<br>1.如果相同，则会对原有元素的值对象v进行替换并返回原来的旧值。<br>2.如果都不相同，则在该桶的链表结构头部新增一个节点来插入新的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>);  <span class="comment">//put已存在的key，会进行覆盖</span></span><br><span class="line">System.out.println(m);  <span class="comment">//打印</span></span><br><span class="line"><span class="comment">//查看键是否存在</span></span><br><span class="line">m.containsKey(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="comment">//获取键对应的值</span></span><br><span class="line">m.get(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="comment">//获取键集合、值集合</span></span><br><span class="line">m.keySet()</span><br><span class="line">m.values()</span><br><span class="line"><span class="comment">//替换指定键的值</span></span><br><span class="line">m.replace(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;dd&quot;</span>);</span><br><span class="line">删除指定键值对</span><br><span class="line">m.remove(<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注意，HashMap查找时，需要遍历链表，逐一通过equals方法进行比对，因此桶越多，HashMap中的链表越少，性能越好。属于空间换时间。</p>
<p>HashMap中，<strong>动态分配桶的数量</strong>：通过<code>new HashMap()</code>方法创建HashMap时，会默认集合容量capacity大小为16，加载因子loadFactor为0.75，此时集合桶的阈值为12，超过12个时，HashMap会默认增加一倍桶的数量。开发者也可以使用<code>new HashMap(int intialCapacity, float loadFactor)</code>构造方法，在创建HashMap集合时指定集合容量和加载因子。</p>
<h4 id="Map集合遍历"><a href="#Map集合遍历" class="headerlink" title="Map集合遍历"></a>Map集合遍历</h4><h5 id="Iterator迭代器遍历"><a href="#Iterator迭代器遍历" class="headerlink" title="Iterator迭代器遍历"></a>Iterator迭代器遍历</h5><p>使用Iterator迭代器遍历Map集合，需要先将Map集合转换为Iterator接口对象，然后进行遍历，有两种方法进行转换：</p>
<p>（1）keySet()方法</p>
<p>先将Map集合中所有键对象转换为Set单列集合，然后将Set集合转换为Iterator接口对象，遍历得到键，再获得值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>); </span><br><span class="line"><span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> map.keySet();   <span class="comment">//获取键的集合</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> keySet.iterator();  <span class="comment">//迭代键的集合</span></span><br><span class="line"><span class="keyword">while</span>(it.hashNext())&#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">k</span> <span class="operator">=</span> it.next();</span><br><span class="line">	<span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> m.get(key);</span><br><span class="line">	System.out.println(k+<span class="string">&quot;:&quot;</span>+v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）entrySet()方法</p>
<p>将原有Map集合中的键值对作为一个整体返回为Set集合，接着将Set转换为Iterator接口对象，然后获取键值对映射关系，取出键和值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>); </span><br><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> m.entrySet();</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	Map.<span class="type">Entry</span> <span class="variable">en</span> <span class="operator">=</span> (Map.Entry)(it.next());</span><br><span class="line">	<span class="type">Object</span> <span class="variable">k</span> <span class="operator">=</span> en.getKey();</span><br><span class="line">	<span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> en.getValue();</span><br><span class="line">	System.out.println(k+<span class="string">&quot;:&quot;</span>+v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Map.Entry是Map接口内部类，每个Map.Entry对象代表Map中的一个键值对。getKey和getValue是映射对象的方法。</p>
<h5 id="forEach-方法"><a href="#forEach-方法" class="headerlink" title="forEach()方法"></a>forEach()方法</h5><p>再JDK8中根据Lambda表达式特性新增了一个forEach方法来遍历Map集合，该方法需要的参数是一个函数式接口，可以用Lambda表达式书写这个函数式接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>); </span><br><span class="line">m.forEach((k,v)-&gt;System.out.println(k+<span class="string">&quot;:&quot;</span>+v));</span><br></pre></td></tr></table></figure>

<p>如果只想遍历value：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">v</span> <span class="operator">=</span> m.values();</span><br><span class="line">v.forEach(va-&gt;System.out.println(va));</span><br></pre></td></tr></table></figure>

<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>HashMap无序，不保证集合元素存入和取出的顺序。</p>
<p>但是LinkedHashMap是HashMap的子类，和LinkedList一样使用双向链表来维护内部元素的关系，使得元素有序（存入和取出的顺序）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>();  <span class="comment">//创建</span></span><br></pre></td></tr></table></figure>

<h4 id="TreeMap集合"><a href="#TreeMap集合" class="headerlink" title="TreeMap集合"></a>TreeMap集合</h4><p>Map接口的另一个实现类TreeMap，同样不允许重复的键。TreeMap内部是通过二叉树的原理来保证键的唯一性，这与TreeSet集合存储的原理一样，因此，TreeMap中所有的键是按照某种顺序排列的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">System.out.println(m);</span><br></pre></td></tr></table></figure>

<p>上面的键是String类型，String类实现了Comparable接口，因此默认会按照自然顺序从小到大进行排列。</p>
<p>桶TreeSet一样，TreeMap可以自定义比较器Comparator的方式对所有的键进行定制排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义比较器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object obj1, Object obj2)</span>&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">key1</span> <span class="operator">=</span> (String)obj1;</span><br><span class="line">		<span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> (String)obj2;</span><br><span class="line">	    <span class="keyword">return</span> key2.compareTo(key1);  <span class="comment">//从大到小排列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Map</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">MyComparator</span>());</span><br></pre></td></tr></table></figure>

<h4 id="Properties集合"><a href="#Properties集合" class="headerlink" title="Properties集合"></a>Properties集合</h4><p>Map接口还有一个实现来Hashtable，它和HashMap十分相似，区别在于Hashtable是线程安全的，因此在使用上Hashtable的效率不及HashMap。因此通常使用HashMap。</p>
<p>但是Hashtable有一个子类Properties，主要用来存储字符串类型的键值，在实际开发中，经常用来存取应用的配置项。</p>
<p>假设有一个配置文件：test.properties</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">color = red;</span><br><span class="line">size = 10;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="comment">//1.通过Properties进行属性文件读取操作</span></span><br><span class="line">	<span class="type">Properties</span> <span class="variable">pps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">	<span class="comment">//加载文件</span></span><br><span class="line">	pps.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.properties&quot;</span>));</span><br><span class="line">	<span class="comment">//遍历键值对信息</span></span><br><span class="line">	pps.forEach((k,v)-&gt;System.out.println(k+<span class="string">&quot;:&quot;</span>+v));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.通过Properties进行属性文件写入操作</span></span><br><span class="line">	<span class="comment">//指定写入操作的文件名称和位置</span></span><br><span class="line">	FileOutputStream out <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.properties&quot;</span>);</span><br><span class="line">	<span class="comment">//向Properties类文件进行写入键值对信息</span></span><br><span class="line">	pps.setProperty(<span class="string">&quot;charset&quot;</span>,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">	<span class="comment">//将此Properties集合中新增的键值对写入配置文件</span></span><br><span class="line">	pps.store(out, <span class="string">&quot;新增charset编码&quot;</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Properties的setProperty方法，用来新增一个键值对元素。store方法用来将新增信息写入到properties配置文件。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>在之前创建集合，当把一个对象存入集合后，集合会忘记这个对象的类型，将该对象从集合中取出时，这个对象的编译类型就会统一变成Object类型。也就是说，存入元素啥类型都行，但是取出元素后，进行强制转换容易出错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList lis = new ArrayList();</span><br><span class="line">lis.add(&quot;aa&quot;);</span><br><span class="line">lis.add(&quot;bb&quot;);</span><br><span class="line">for(Object obj:lis)&#123;</span><br><span class="line">	String s = (String)obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为解决该问题，Java引入“参数化类型”概念，即泛型。泛型可以限定操作的数据类型，在定义集合类时，可以使用“&lt;参数化类型&gt;”的形式指定集合中存储的数据类型。</p>
<p><code>ArrayList&lt;String&gt;lis = new ArrayList&lt;String&gt;();</code></p>
<p>这样限定了集合元素的数据类型，程序编译时类型不必配的话会编译不通过，避免运行时发生错误。遍历时<code>for(String s:lis)&#123;&#125;</code></p>
<h2 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h2><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p>Java提供的一个专门工具类用来操作集合，位于java.util包中。Collections类中提供了大量的静态方法用于对集合中的元素进行排序、查找、修改等操作。</p>
<h4 id="添加、排序"><a href="#添加、排序" class="headerlink" title="添加、排序"></a>添加、排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt;lis = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">Collections.addAll(lis,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">//集合可以直接输出，而数组不可以，数组可以用forEach的Lambda表达式？</span></span><br><span class="line">System.out.println(lis);</span><br><span class="line">Collections.sort(lis);  <span class="comment">//排序</span></span><br><span class="line">Collections.reverse(lis);  <span class="comment">//反转</span></span><br><span class="line">Collections.shuffle(lis);  <span class="comment">//随机打乱集合顺序</span></span><br><span class="line">Collections.swap(lis,<span class="number">0</span>,lis.size()-<span class="number">1</span>);  <span class="comment">//交换元素</span></span><br></pre></td></tr></table></figure>

<h4 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt;lis = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">Collections.addAll(lis,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">最大元素： Collections.max(lis);</span><br><span class="line">最小元素： Collections.min(lis);</span><br><span class="line">Collections.replace(lis,<span class="number">2</span>,<span class="number">0</span>);  <span class="comment">//将集合中的2用0替换掉</span></span><br><span class="line">Collections.sort(lis);  <span class="comment">//排序</span></span><br><span class="line"><span class="comment">//通过二分查找查找元素3所在的角标，一定要先排序</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Collections.binarySearch(lis, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h3><p>java针对数组操作提供的数据工具类Arrays，提供大量静态方法。</p>
<h4 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">不能通过System.out直接打印数组，需要<span class="keyword">for</span>循环打印</span><br><span class="line">Arrays.sort(arr);  <span class="comment">//排序</span></span><br><span class="line">Arrays.sort(arr,<span class="number">1</span>,<span class="number">4</span>);  左闭右开</span><br></pre></td></tr></table></figure>

<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="type">int</span> index=Arrays.binarySearch(arr,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h4><p>在不破坏原数组的情况下使用数组的部分元素，将指定范围的元素拷贝到一个新的数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] cop = Arrays.copyOfRange(arr, <span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line"><span class="comment">//结果cop：8，3，5，2，0，0，左闭右开共六个，没有的用默认0</span></span><br></pre></td></tr></table></figure>

<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>将数组的所有元素替换为一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.fill(arr,<span class="number">8</span>);  <span class="comment">//全换为8</span></span><br></pre></td></tr></table></figure>

<h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>Lambda表达式可以简化集合和数组的遍历、过滤和提取等操作。基于此特性，JDK8新增了聚合操作。</p>
<h4 id="Stream接口"><a href="#Stream接口" class="headerlink" title="Stream接口"></a>Stream接口</h4><p>JDK8提供，该接口将集合、数组中的元素转换为Stream流的形式，并结合Lambda表达式进一步简化集合、数组中元素的查找、过滤、转换操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt;lis <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">lis.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">lis.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">lis.add(<span class="string">&quot;dddd&quot;</span>);</span><br><span class="line"><span class="comment">//创建一个Stream流对象</span></span><br><span class="line">Stream&lt;String&gt;stream = lis.stream();</span><br><span class="line"><span class="comment">//对Stream流中的元素进行过滤、截取</span></span><br><span class="line">Stream&lt;String&gt;stream2 = stream.filter(i-&gt;i.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">Stream&lt;String&gt;stream3 = stream.filter(i-&gt;i.length()&gt;<span class="number">1</span>);</span><br><span class="line">Stream&lt;String&gt;stream4 = stream2.limit(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//对Stream流中的元素进行终结操作</span></span><br><span class="line">stream4.forEach(j-&gt;System.out.println(j));</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过链式表达式的形式完成聚合操作</span></span><br><span class="line">lis.stream().filter(i-&gt;i.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">			.limit(<span class="number">1</span>)</span><br><span class="line">			.forEach(j-&gt;System.out.println(j));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>疑问：创建list时，最先的List和ArrayList有何区别？</p>
<p>List<int>可以吗？还是说元素必须为引用类型</p>
</blockquote>
<p>链式表达式：调用有返回值的方法时不获取返回值而是直接再调用另一个方法，实现聚合操作，也被称为操作管道流。</p>
<p>执行某个方法返回类型仍为stream流对象的方法归为中间操作，如过滤截取排序。</p>
<p>执行方法后返回类型不再是Stream流对象的方法归为终结操作，如遍历统计收集。</p>
<h4 id="创建Stream流对象"><a href="#创建Stream流对象" class="headerlink" title="创建Stream流对象"></a>创建Stream流对象</h4><p>聚合操作针对的是可迭代数据进行操作：如集合、数组。因此创建Stream流对象是将集合、数组通过一些方法转换为Stream流对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Stream流对象的集中方法</span></span><br><span class="line">Integer[] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//将数组转换为List集合</span></span><br><span class="line">List&lt;Integer&gt;lis=Arrays.asList(arr);</span><br><span class="line"><span class="comment">//1.使用集合对象的stream()静态方法创建stream流对象</span></span><br><span class="line">Stream&lt;Integer&gt;stream=lis.stream();</span><br><span class="line">stream.forEach(i-&gt;System.out.print(i+<span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用Stream接口的of()静态方法为基本类型包装类数组、引用类型数组、单个元素创建stream流对象</span></span><br><span class="line">Stream&lt;Integer&gt;stream2=Stream.of(arr);</span><br><span class="line">stream2.forEach(i-&gt;System.out.print(i+<span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.使用Arrays数组工具类的stream()静态方法创建stream流对象</span></span><br><span class="line">Stream&lt;Integer&gt;stream3=Arrays.stream(arr);</span><br><span class="line">stream3.forEach(i-&gt;System.out.print(i+<span class="string">&quot; &quot;</span>));</span><br></pre></td></tr></table></figure>

<p>注意：集合对象的stream()静态方法只是针对单列集合Collection接口对象提供的，对Map集合首先通过Map集合的<code>keySet()  values()  entrySet()</code>方法转换为单列Set集合。</p>
<h4 id="map-映射"><a href="#map-映射" class="headerlink" title="map()映射"></a>map()映射</h4><p>Stream流对象的map()方法可以将流对象中的元素通过特定的规则进行修改然后映射为另一个流对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt;stream=Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">stream.map(String::toUpperCase)  <span class="comment">//流中所有元素字母转为大写</span></span><br><span class="line">	  .sorted()</span><br><span class="line">	  .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="截取limit"><a href="#截取limit" class="headerlink" title="截取limit()"></a>截取limit()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.skip(<span class="number">1</span>)   <span class="comment">//跳过流中的前一个元素</span></span><br><span class="line">      .limit(<span class="number">2</span>)   <span class="comment">//截取前2个元素</span></span><br><span class="line">      .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h4><p>forEach()操作无法将进行中间操作后的流元素作为我们熟悉的对象或是数据类型进行保存，为此JDK8为操作流对象增加了一个终结操作—-collect。</p>
<p>collect可以把Stream中的元素保存为另一种形式，如集合、字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存为List集合</span></span><br><span class="line">Stream&lt;String&gt;stre = Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">List&lt;String&gt;lis = stre.filter(i-&gt;i,startWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">					  .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//将流元素使用&quot;and&quot;连接，收集到一个字符串中</span></span><br><span class="line">Stream&lt;String&gt;stre = Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">st</span> <span class="operator">=</span> stre.filter(i-&gt;i,startWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">					  .collect(Collectors.joining(<span class="string">&quot;and&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存为数组</span></span><br><span class="line">Stream&lt;String&gt;stre = Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">String[] arr = stre.filter(i-&gt;i,startWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">					  .collect(Collectors.toArray());</span><br></pre></td></tr></table></figure>

<p>注意：一个Stream可以进行多个中间操作，但只能进行一个终结操作，一旦进行了终结操作，流对象就不复存在了。因此，只能保存一次。</p>
<h4 id="Parrel-Stream并行流"><a href="#Parrel-Stream并行流" class="headerlink" title="Parrel Stream并行流"></a>Parrel Stream并行流</h4><p>JDK8针对大批量数据提供并行流，并行流是将源数据分为多个子流对象进行多线程操作（多个管道流），然后将处理的结果再汇总为一个流对象。</p>
<p>并行流可以提高程序执行效率，但是在多线程执行时会出现线程安全问题，需要保证源数据在并行执行时不会被改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建List集合数据源</span></span><br><span class="line">List&lt;String&gt;lis = Arrays.asList(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="comment">//1.直接用Collection接口的parallelStream()创建并行流</span></span><br><span class="line">Stream&lt;String&gt;para = lis.parallelStream();</span><br><span class="line"><span class="comment">//判断是否为并行流</span></span><br><span class="line">System.out.println(para.isParallel());</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用BaseStream接口的parallel()方法将串行流转变为并行流</span></span><br><span class="line">Stream&lt;String&gt;str = Stream.of(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>.<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">Stream&lt;String&gt;para = str.parallel();</span><br><span class="line"><span class="comment">//判断是否为并行流</span></span><br><span class="line">System.out.println(para.isParallel());</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》之GUI</title>
    <url>/2021/11/26/myblog/java/%E3%80%8Ajava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8BGUI/</url>
    <content><![CDATA[<p>GUI：Graphical User Interface 图形用户接口。用来提供给用户操作的图像界面的接口。</p>
<p>java针对GUI设计提供了一些基本的图形用户接口开发工具，如AWT、Swing、JavaFX。</p>
<p>AWT是sun公司最早推出的一套API，组件种类有限，无法实现GUI设计的全部功能。</p>
<h2 id="Swing概述"><a href="#Swing概述" class="headerlink" title="Swing概述"></a>Swing概述</h2><p>早期JDK1.0发布时，就为GUI开发提供了一套基础类库（AWT），即抽象窗口工具包。AWT需要牺牲功能来实现平台无关性。因此，Sun公司对AWT进行改进，提出Swing组件，提供更加丰富的组件和功能，来满足GUI设计的一切需求。</p>
<p>Swing是一组轻量级组件，由Java语言开发，同时底层以AWT为基础。Swing并不是AWT的替代品，而是在原有的AWT的基础上进行补充和改进。</p>
<p>Swing组件的所有类都继承自Container类，然后根据GUI开发的功能扩展了两个主要分支：容器分支（Window窗口和Panel面板）和组件分支。</p>
<p>容器分支是为了实现图形用户界面窗口容器而设计的。</p>
<p>组件分支是为了实现向容器中填充数据、元素以及人机交互组件等功能。</p>
<p>Swing组件类中常用的顶级容器类包括：JApplet、JFrame和JDialog。常用的组件类：AbstractButton类及其子类就是用来定义按钮常见行为的工具类，JTextComponent类及其子类就是用来定义文本内容编辑区域的工具类。</p>
<h2 id="JavaFX概述"><a href="#JavaFX概述" class="headerlink" title="JavaFX概述"></a>JavaFX概述</h2><p>JavaFX同Swing一样，都用于处理图形用户界面，是一个强大的图形和多媒体处理工具包集合，允许开发者设计、创建、测试、调试和部署富客户端程序，并且和Java一样具有跨平台特性。</p>
<p>Sun公司于2008年推出JavaFX，来弥补Java在桌面应用程序的缺陷。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》IO</title>
    <url>/2021/11/25/myblog/java/%E3%80%8Ajava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8BIO%E6%B5%81/</url>
    <content><![CDATA[<h2 id="I-O流概述"><a href="#I-O流概述" class="headerlink" title="I&#x2F;O流概述"></a>I&#x2F;O流概述</h2><p>java中将不同输入输出设备之间的数据传输抽象表述为“流”。</p>
<p>分类1：根据操作的数据单位不同，分为字节流和字符流。</p>
<p>分类2：根据传输方向，分为输入流和输出流。输入流只能从流中读取数据，而不能写入数据；输出流只能向流中写入数据，而不能从中读取数据。</p>
<p>分类3：根据流的功能不同，分为节点流和处理流。节点流被称为低级流，指可以从一个特定的I&#x2F;O设备读写数据的流，它只能直接连接数据源，进行数据的读写操作。处理流也被称为高级流，用于对一个已存在的节点流进行连接和封装，通过封装后的流来实现流的读写能力。当使用处理流时，程序不会直接连接到实际的数据源，而是连接在已存在的流之上。</p>
<p>java中的I&#x2F;O流主要定义在java.io包中，该包有四个顶级类，都是抽象类，是所有流类型的父类。</p>
<p><img src="/images/IO%E6%B5%81.jpg"></p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>计算机中，所有文件都是二进制（字节）形式存在的。JDK提供了<code>InputStream</code>和<code>OutputStream</code>。字节输入流：从源设备经流中走向程序。字节输出流：从程序输出经流中走向目标。输入输出是相对程序而言的，输入到输出到的意思。</p>
<h3 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h3><p>针对文件的读写，有两个类：<code>FileInputStream</code>和<code>FileOutputStream</code>。</p>
<p><code>FileInputStream</code>是<code>InputStream</code>的子类，由于从文件读取数据是重复的操作，因此需要通过循环语句来实现数据的持续读取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="comment">//创建一个文件字节输入流来读取文件</span></span><br><span class="line">		<span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">		<span class="comment">//定义int变量</span></span><br><span class="line">		<span class="type">int</span> b=<span class="number">0</span>; </span><br><span class="line">		<span class="comment">//通过循环读取文件，当返回值为-1结束循环</span></span><br><span class="line">		<span class="keyword">while</span>((b=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			System.out.println(b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		in.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如内容为hello，字符占一个字节，因此显示的是这五个字节所对应的ASCII码值。</p>
<p><code>FileOutputStream</code>负责将数据写入文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="comment">//创建一个文件字节输出流来写文件</span></span><br><span class="line">		<span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line">		<span class="comment">//定义一个字符串</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">		<span class="comment">//将字符串转换为字节数组进行写入操作</span></span><br><span class="line">		out.write(str.getBytes());</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若文件已存在，则会首先将文件中内容擦空，再写入。</p>
<p>若想追加内容：<code>FileOutputStream out = new FileOutputStream(&quot;out.txt&quot;, true);</code></p>
<p>I&#x2F;O流在进行数据读写时，会出现异常，上述代码使用throws将异常抛出。但是一旦遇到I&#x2F;O异常，close方法无法执行，流对象所占用的系统资源将不能释放。因此通常将关闭流的操作写在finally代码块中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(in!=<span class="literal">null</span>)  in.close();</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(out!=<span class="literal">null</span>)  out.close();</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件的拷贝"><a href="#文件的拷贝" class="headerlink" title="文件的拷贝"></a>文件的拷贝</h3><p>通过输入流来读取文件中的数据，并通过输出流将数据写入新文件。</p>
<p>定义一次输出流创建一个文件，定义之后多次写入，都是追加的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;source/src.jpg&quot;</span>)</span><br><span class="line">		<span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;target/src.jpg&quot;</span>);</span><br><span class="line">		<span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">		<span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">while</span>((b=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			out.write(b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;花费时间为：&quot;</span>+(endTime-beginTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		in.close();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节流的缓冲区"><a href="#字节流的缓冲区" class="headerlink" title="字节流的缓冲区"></a>字节流的缓冲区</h3><p>一个字节一个字节地拷贝，需要频繁操作文件，因此构建一个字节数组作为临时缓冲区。可以一次性读写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;source/src.jpg&quot;</span>);</span><br><span class="line">		<span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;target/src.jpg&quot;</span>);</span><br><span class="line">		<span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">		<span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">while</span>((len=in.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">//通过变量len记住读入数组的字节数，len表示读取字节的数目</span></span><br><span class="line">			out.write(buffer, <span class="number">0</span>, len); <span class="comment">//从buffer的0位置开始写入len个字节</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;花费时间为：&quot;</span>+(endTime-beginTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		in.close();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>read方法内无东西时，表示从输入流读取一个8位的字节，把它转换为0-255的整数，并返回这个整数，当没有可用字节时，将返回-1。</p>
<p>read方法内是byte数组时，表示读取若干字节，并将其保存到指定的字节数组中，返回整数表示读取的字节的数目。</p>
<p>write方法内，一个int表示写入一个字节，一个字节数组表示写入字节数组中的所有字节，也可以写入指定数目字节。</p>
<p>输出流的flush()方法表示将输出缓冲区（通常是字节数组）中的数据强制写入目标设备，此过程称为刷新。</p>
</blockquote>
<h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>I&#x2F;O包中提供了两个带缓冲的字节流，分别为<code>BufferedInputStream</code>和<code>BufferedOutputStream</code>，它们的构造方法中分别接收<code>InputStream</code>和<code>OutputStream</code>类型的参数作为对象。再读写数据时提供缓冲功能。</p>
<p>其实就像是上一节的系统实现。</p>
<p>关系：源设备—字节流—字节缓冲流—应用程序—字节缓冲流—字节流—目标设备</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="type">BufferedInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;source/src.jpg&quot;</span>));</span><br><span class="line">		<span class="type">BufferedOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;target/src.jpg&quot;</span>));</span><br><span class="line">		<span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">		<span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">while</span>((len=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			out.write(len)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;花费时间为：&quot;</span>+(endTime-beginTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		in.close();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓冲流对象内部都定义了一个大小为8192的字节数组。读写都是到一个字节数组中，充当缓冲。</p>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>Reader是字符输入流，用于从某个源设备读取字符。Writer是字符输出流。用于向某个目标设备写入字符。</p>
<p>输入输出是相对程序而言的，输入到输出到的意思。读和写是读到程序和从程序中写出的意思。</p>
<h3 id="字符流操作文件"><a href="#字符流操作文件" class="headerlink" title="字符流操作文件"></a>字符流操作文件</h3><p>从文件读取字符用字符输入流FileReader。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;reader.txt&quot;</span>);</span><br><span class="line">		<span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((b=fileReader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			System.out.print((<span class="type">char</span>)b)</span><br><span class="line">		&#125;</span><br><span class="line">		fileReader.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>read返回的是int类型，因此要获得字符需要强制类型转换。</p>
<p>向文件中写入字符用FileWriter类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;writer.txt&quot;</span>);</span><br><span class="line">		fileWriter.write(<span class="string">&quot;你好,\r\n&quot;</span>);</span><br><span class="line">		fileWriter.write(<span class="string">&quot;世界。\r\n&quot;</span>);</span><br><span class="line">		fileWriterr.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写入文件，如果文件已存在则先清空，项追加的话，则构造时后面加true。</p>
<p>与字节流类似，这里也可以加字符流缓冲区</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>[] buff=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>((len=fileReader.read(buff))!=-<span class="number">1</span>)&#123;</span><br><span class="line">	fileWriter.write(buff, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p>字符流也提供了带缓冲区的字符缓冲流，<code>BufferedReader</code>和<code>BufferedWriter</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">	    <span class="comment">//创建字符输入缓冲流对象</span></span><br><span class="line">	    <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;read.txt&quot;</span>));</span><br><span class="line">	    <span class="comment">//创建字符输出缓冲流对象</span></span><br><span class="line">	    <span class="type">BufferedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;write.txt&quot;</span>));</span><br><span class="line">	    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	    <span class="keyword">while</span>((str=in.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">	    	out.write(str);</span><br><span class="line">	    	out.newLine();</span><br><span class="line">	    &#125;</span><br><span class="line">	    in.close();</span><br><span class="line">	    out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BufferedReader</code>的readLine()方法，用于一次读取一行文本。</p>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>JDK中提供了两个类实现字节流转换为字符流。</p>
<p>字节输入流转变为字符输入流：<code>InputStreamReader</code></p>
<p>字节输出流转变为字符输出流：<code>OutputStreamWriter</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建字节输入流，获取源文件</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line"><span class="comment">//将字节输入流对象转换为字符输入流对象</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in);</span><br><span class="line"><span class="comment">//创建字符输入缓冲流对象</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建字节输出流，指定目标文件</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;write.txt&quot;</span>);</span><br><span class="line"><span class="comment">//将字节输出流对象转换为字符输出流对象</span></span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamReader</span>(out);</span><br><span class="line"><span class="comment">//创建字符输出缓冲流对象</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>疑问，不明白意义何在，文件时字节码文件，程序侧用字符流有何益处。</p>
</blockquote>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>通过I&#x2F;O流可以对文件的内容进行读写操作，但是对文件本身进行一些常规操作，例如创建、删除、重命名等，JDK提供了一个File类。</p>
<p>File类用于封装一个路径，可以是绝对路径，也可以是相对路径。该类主要用于文件和目录的创建、文件的查找和文件的删除等。</p>
<p>File对象代表磁盘中实际存在的文件和目录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dirname</span> <span class="operator">=</span> <span class="string">&quot;/java&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dirname);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/文件夹名称：&quot;</span>+f1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/文件夹大小：&quot;</span>+f1.length()+<span class="string">&quot;bytes&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (f1.isDirectory()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Directory of &quot;</span> + dirname);</span><br><span class="line">            String s[] = f1.list();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">                <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dirname + <span class="string">&quot;/&quot;</span> + s[i]);</span><br><span class="line">                <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                    System.out.println(s[i] + <span class="string">&quot; is a directory&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(s[i] + <span class="string">&quot; is a file&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(dirname + <span class="string">&quot; is not a directory&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;是否成功删除：&quot;</span>+f1.delete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历某个目录下的所有文件，用list方法，除了上面的方法外，还可以采用数组工具类Arrays的stream方法进行遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line">String[] fileNames = file.list();</span><br><span class="line">Arrays.stream(fileNames).forEach(f-&gt;System.out.println(f));</span><br></pre></td></tr></table></figure>

<p>若是想要获得指定类型的文件，例如.txt文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向list传入lambda表达式形式的参数，进行过滤。</span></span><br><span class="line">String[] fileNames=file.list((dir,name)-&gt;name.endsWith(<span class="string">&quot;.txt&quot;</span>));</span><br><span class="line">Arrays.stream(fileNames).forEach(f-&gt;System.out.println(f));</span><br></pre></td></tr></table></figure>

<p>若是要遍历所有文件及目录，包括子目录下的文件。使用listFiles方法返回的是一个File对象数组。进行递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;路径&quot;</span>);</span><br><span class="line">        func(file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历目录及其子目录方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(File file)</span>&#123;</span><br><span class="line">        File[] listFiles=file.listFiles();</span><br><span class="line">        <span class="keyword">for</span>(File files:listFiles)&#123;</span><br><span class="line">            <span class="keyword">if</span>(files.isDirectory())&#123;</span><br><span class="line">                func(files);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：java中的删除文件是通过java虚拟机直接删除的，而不走回收站。</p>
</blockquote>
<h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><p>不属于流类，但具有读写文件数据的功能，可以随机从文件的任何位置开始执行读写数据的操作。</p>
<h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><p>程序在运行过程中，需要将一些数据永久地保存到磁盘上，而数据在java中都是保存在对象当中的，如何将对象中的数据保存到磁盘上，就用java中的对象序列化。</p>
<p>对象的序列化（Serializable）是指将一个Java对象转换为一个I&#x2F;O流中字节序列的过程。可以使内存中的Java对象转换成与平台无关的二进制流。</p>
<p>将I&#x2F;O流中的字节序列恢复为Java对象的过程–反序列化。</p>
<p>整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。</p>
<p>想让对象序列化，那么这个对象所在的类必须是可序列化的，必须实现Serializable或Externalizable两个接口之一。Externalizable性能好但是编程复杂，因此大部分采用Serializable。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeDemo</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">      e.name = <span class="string">&quot;Reyan Ali&quot;</span>;</span><br><span class="line">      e.address = <span class="string">&quot;Phokka Kuan, Ambehta Peer&quot;</span>;</span><br><span class="line">      e.SSN = <span class="number">11122333</span>;</span><br><span class="line">      e.number = <span class="number">101</span>;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span></span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/tmp/employee.ser&quot;</span>);</span><br><span class="line">         <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br><span class="line">         out.writeObject(e);</span><br><span class="line">         out.close();</span><br><span class="line">         fileOut.close();</span><br><span class="line">         System.out.printf(<span class="string">&quot;Serialized data is saved in /tmp/employee.ser&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException i)</span><br><span class="line">      &#123;</span><br><span class="line">          i.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeserializeDemo</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/tmp/employee.ser&quot;</span>);</span><br><span class="line">         <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">         e = (Employee) in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line">         fileIn.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException i)</span><br><span class="line">      &#123;</span><br><span class="line">         i.printStackTrace();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(ClassNotFoundException c)</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Employee class not found&quot;</span>);</span><br><span class="line">         c.printStackTrace();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Deserialized Employee...&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Name: &quot;</span> + e.name);</span><br><span class="line">      System.out.println(<span class="string">&quot;Address: &quot;</span> + e.address);</span><br><span class="line">      System.out.println(<span class="string">&quot;SSN: &quot;</span> + e.SSN);</span><br><span class="line">      System.out.println(<span class="string">&quot;Number: &quot;</span> + e.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>readObject() 方法中的 try&#x2F;catch代码块尝试捕获 ClassNotFoundException 异常。对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个 ClassNotFoundException 异常。</p>
<p>注意，readObject() 方法的返回值被转化成 Employee 引用。</p>
<p>当对象被序列化时，属性 SSN 的值为 111222333，但是因为该属性是短暂的，该值没有被发送到输出流。所以反序列化后 Employee 对象的 SSN 属性为 0。</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>从JDK1.4开始，java提供了一系列改进的用于处理输入输出的新功能，被称为NIO（New I&#x2F;O）。</p>
<p>NIO采用内存映射文件的方式来处理输入输出，将文件或文件的一段区域映射到内存中，像访问内存一样来访问文件。</p>
<p>标准的IO中使用字节流和字符流，NIO中，使用通道Channel和缓冲区Buffer。数据总是从通道读入缓冲区，或从缓冲区写入通道。</p>
<p>Buffer可以看成是一个容器，本质是一个数组缓冲区，读入或写出到Channel中的所有对象都先放在Buffer中。</p>
<p>Channel是对传统的输入输出的模拟，所有的数据都通过通道流的形式传输。</p>
<p>Selector选择器，用于监听多个通道的事件（例如连接打开、数据到达）主要用于多线程处理。</p>
<h2 id="NIO-2"><a href="#NIO-2" class="headerlink" title="NIO.2"></a>NIO.2</h2><p>JDK7引入新的I&#x2F;O API，提供全面的文件输入输出以及文件系统的访问与支持，并且新增java.nio.file包及其子包，提供基于异步Channel的输入输出。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》之多线程</title>
    <url>/2021/11/30/myblog/java/%E3%80%8Ajava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>在程序设计中，多线程就是指一个应用程序中有多条并发执行的线索，每条线索称为一个线程，它们交替执行，彼此间可以进行通信。</p>
<h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>在一个操作系统中，每个独立执行的程序都可称为一个进程。</p>
<p>在多任务操作系统中，表面上看是支持进程并发执行的，但实际上并不是在同一时刻运行的。计算机的应用程序都是由CPU执行的，一个CPU在某个时间点只能执行一个进程，操作系统能在极短的时间内在不同的进程之间进行切换，所以给人以同时执行多个程序的感觉。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>多线程看似是同时并发执行的，其实是和进程一样，也是由CPU控制并轮流执行的，只不过CPU运行速度非常快。</p>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>在Java中，可以通过三种方式来实现多线程</p>
<p>1.继承Thread类，重写run()方法。</p>
<p>2.实现Runnable接口，重写run()方法。</p>
<p>3.实现Callable接口，重写call()方法，并使用Future来获取call()方法的返回结果。</p>
<h3 id="Thread类实现多线程"><a href="#Thread类实现多线程" class="headerlink" title="Thread类实现多线程"></a>Thread类实现多线程</h3><p>Thread类是java.lang包下的一个线程类，用来实现Java多线程。</p>
<p>第一步：创建一个Thread线程类的子类（子线程），同时重写Thread类的run()方法。</p>
<p>第二步：创建该子类的实例对象，并通过调用start()方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义一个继承Thread线程类的子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="comment">//创建子线程有参构造方法,name是线程名字</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyThread1</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写Thread类的run()方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i++,<span class="number">5</span>)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()</span><br><span class="line">							+<span class="string">&quot;的run方法在运行&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//2.创建MyThread1实例对象</span></span><br><span class="line">		<span class="type">MyThread1</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>(<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">		<span class="comment">//调用start方法启动线程</span></span><br><span class="line">		thread1.start();</span><br><span class="line">		<span class="type">MyThread1</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>(<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">		<span class="comment">//调用start方法启动线程</span></span><br><span class="line">		thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>currentThread()是Thread类的静态方法，用来获取当前线程对象，getName方法用来获取线程名称。</p>
<p>结果是：两个线程实例交互运行。</p>
<h3 id="Runnable接口实现多线程"><a href="#Runnable接口实现多线程" class="headerlink" title="Runnable接口实现多线程"></a>Runnable接口实现多线程</h3><p>Thread类实现多线程的局限性：因为Java只支持类的单继承，如果某个类已经继承了其他父类，就无法再继承Thread类来实现多线程。因此，考虑通过实现Runnable接口来实现多线程。</p>
<p>第一步：创建一个Runnable接口的实现类，同时重写接口中的run方法。</p>
<p>第二步：创建Runnable接口的实现类对象。</p>
<p>第三步：使用Thread有参构造方法创建线程实例，并将Runnable接口的实现类的实例对象作为参数传入。</p>
<p>第四步：调用线程实例的start方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义一个实现Runnable接口的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="comment">//重写run方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i++,<span class="number">5</span>)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()</span><br><span class="line">							+<span class="string">&quot;的run方法在运行&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//2.创建Runnable接口实现类的实例对象</span></span><br><span class="line">		<span class="type">MyThread2</span> <span class="variable">myThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">		<span class="comment">//3.使用Thread(Runnable target, String name)构造方法创建线程对象</span></span><br><span class="line">		<span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread2, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">		<span class="comment">//4.调用线程对象的start方法启动线程</span></span><br><span class="line">		thread1.start();</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread2, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">		thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runnable接口中只有一个抽象的run方法，该接口属于JDK8中定义的函数式接口，在使用中可以直接通过Lambda表达式的方式简洁地实现线程实例。</p>
<h3 id="Callable接口实现多线程"><a href="#Callable接口实现多线程" class="headerlink" title="Callable接口实现多线程"></a>Callable接口实现多线程</h3><p>Thread类和Runnable接口实现多线程，重写run方法，由于该方法没有返回值，因此无法从多个线程中获取返回结果。因此，JDK5开始，java提供了一个Callable接口，来满足这种既能创建多线程又可以有返回值的需求。</p>
<p>与Runnable不同，这次传入Thread类有参构造方法的是Runnable接口的子类FutureTask对象作为参数，对象中封装了带有返回值的Callable接口实现类。</p>
<p>第一步：创建一个Callable接口的实现类，同时重写Callable接口的call方法</p>
<p>第二步：创建Callable接口的实现类对象。</p>
<p>第三步：通过FutureTask线程结果处理类的有参构造方法来封装Callable接口实现类对象。</p>
<p>第四步：使用参数为FutureTask类对象的Thread有参构造方法创建Thread线程实例。</p>
<p>第五步：调用线程实例的start方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.cocurrent.*;</span><br><span class="line"><span class="comment">//1.定义一个实现Callable接口的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread3</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Object&gt;&#123;</span><br><span class="line">	<span class="comment">//重写call方法</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i++,<span class="number">5</span>)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()</span><br><span class="line">							+<span class="string">&quot;的run方法在运行&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,</span><br><span class="line">														ExecutionException&#123;</span><br><span class="line">		<span class="comment">//2.创建Callable接口的实现类对象</span></span><br><span class="line">		<span class="type">MyThread3</span> <span class="variable">myThread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread3</span>();</span><br><span class="line">		<span class="comment">//3.使用FutureTask封装Callable接口</span></span><br><span class="line">		FutureTask&lt;Object&gt;ft1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(myThread3);</span><br><span class="line">		<span class="comment">//4.使用Thread()构造方法创建线程对象</span></span><br><span class="line">		<span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft1, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">		<span class="comment">//5.启动线程</span></span><br><span class="line">		thread1.start();</span><br><span class="line">		FutureTask&lt;Object&gt;ft2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(myThread3);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft2, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">		thread2.start();</span><br><span class="line">		<span class="comment">//通过FutureTask对象的方法管理返回值</span></span><br><span class="line">		System.out.println(<span class="string">&quot;thread1返回结果：&quot;</span>+ft1.get());</span><br><span class="line">		System.out.println(<span class="string">&quot;thread2返回结果：&quot;</span>+ft2.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask类用来封装和管理返回结果，直接父接口是RunnableFuture，RunnableFuture接口是实现自Runnable接口和Future接口。</p>
<p>Future接口时JDK5提供的用来管理线程执行返回结果的，共有五个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> 参数)</span>   <span class="comment">//由于取消任务，参数为true表示可以取消正在执行的任务</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>    <span class="comment">//判断是否被取消成功</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>    <span class="comment">//判断任务是否已经完成</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">()</span>     <span class="comment">//获取执行结果，这个方法会发生阻塞，一直等到任务执行完毕才返回执行结果</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(<span class="type">long</span> time, TumeUnit unit)</span>  <span class="comment">//由于在指定时间内获取执行结果</span></span><br></pre></td></tr></table></figure>

<h3 id="三种方法的对比分析"><a href="#三种方法的对比分析" class="headerlink" title="三种方法的对比分析"></a>三种方法的对比分析</h3><p>Callable接口的方法有返回值，并且可以声明抛出异常。</p>
<p>若是想要多个线程共享一个数据，则由于继承Thread的方法需要创建多个子类的线程对象，无法共享类内的private变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">MyThread1</span>().start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MyThread1</span>().start();</span><br></pre></td></tr></table></figure>

<p>创建多线程时，如果没有通过构造方法指定线程名称，则系统会默认生成线程名称。</p>
<p>为了确保多个线程共享一个数据，用Runnable接口实现，程序只创建一个类的对象，而是创建多个thread类的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyThread2</span> <span class="variable">myThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(myThread2, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(myThread2, <span class="string">&quot;线程2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>因此，Runnable接口或Callable接口实现多线程相比于继承Thread类来说，好处在于：</p>
<p>（1）适合多个线程处理同一个共享资源的情况，体现面向对象设计思想。</p>
<p>（2）避免Java单继承的局限，若类已继承某父类，则还可以实现接口。</p>
<h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>main方法中创建并启动几个新线程后，主线程随之结束，但是，虽然主线程结束了，但整个Java程序并未结束，对java程序来说，只要还有前台线程在运行，这个进程就不会结束。如果一个进程中只有后台线程运行，这个进程就会结束。</p>
<p>新创建的线程默认是前台线程，如果某个线程对象在启动之前调用了setDaemon(true)语句，这个线程就变成一个后台线程。</p>
<p>判断是否是后台线程：<code>th.isDaemon()</code></p>
<p><code>th.setDaemon(true);   thread.start();  </code>  &#x2F;&#x2F;一定是在start启动之前</p>
<p>整个进程结束，JVM会通知后台线程结束，由于后台线程从接收指令到做出响应，需要一定的时间，结束后台进程会有一定的延迟。</p>
<h2 id="线程的生命周期及状态转换"><a href="#线程的生命周期及状态转换" class="headerlink" title="线程的生命周期及状态转换"></a>线程的生命周期及状态转换</h2><p>在Java中，任何对象都有生命周期，线程也不例外，Thread对象创建完成时，线程的生命周期便开始了，当执行完毕或抛出异常或错误时，生命周期便结束。</p>
<p><img src="/images/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg"></p>
<p><em><strong>新建状态</strong></em>：创建一个线程对象后，仅仅由JVM为其分配了内存，没有表现出任何线程的动态特征。</p>
<p><em><strong>就绪状态</strong></em>：线程对象调用start方法之后，等待JVM调度，此时并未运行。</p>
<p><em><strong>运行状态</strong></em>：线程对象获得JVM调度，如果存在多个CPU，则允许多个线程并行运行。</p>
<p><em><strong>阻塞状态</strong></em>：线程运行过程中，发出I&#x2F;O请求时，该线程进入阻塞状态。当线程运行过程中获取同步锁时，却被另一个线程获取，此时JVM把当前线程存到对象的锁池中，该线程进入阻塞状态。此时，JVM不会给线程分配CPU，直到线程重新进入就绪状态，才有机会转换到运行状态。</p>
<p><em><strong>等待状态</strong></em>：当处于运行状态的线程调用了限制的方法后，如wait()方法、join()方法，当前线程进入等待状态。<br>处于等待状态的线程无法立即争夺CPU使用权，需要等待其他线程执行特定的操作后，才有机会再次争夺，将等待状态变为运行状态。<br><code>wait()</code>方法：等待其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法，来唤醒当前等待中的线程。<br><code>join()</code>方法：必须等待其他加入的线程终止。</p>
<p><em><strong>定时等待状态</strong></em>：类似等待状态，执行<code>sleep(long millis)、wait(long timeout)、join(long millis)</code>等方法。必须等待其他相关线程执行完特定操作<strong>或</strong>限时时间结束后，才有机会再次争夺CPU，进入运行状态。</p>
<p><em><strong>终止状态</strong></em>：线程的run()方法或者call()方法执行完毕，或线程抛出一个未捕获的异常（Exception）、错误（Error），线程进入终止状态。一旦进入终止状态，线程将不再拥有运行的资格，也不能再转换到其他状态，生命周期结束。</p>
<h2 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h2><p>Java虚拟机会按照特定的机制为程序中的每个线程分配CPU的使用权，这种机制叫做线程的调度。</p>
<p>计算机中线程的调度有两种模型：<br>1、分时模型：所有线程轮流获得CPU的使用权，并且平均分配每个线程占用的CPU时间片。<br>2、抢占式调度模式：让可运行池中所有就绪状态的线程争抢CPU的使用权，优先级高的线程获得CPU概率更大。</p>
<p>Java虚拟机默认采用抢占式调度模式，特定需求下需要改变模式，由程序自己来控制CPU的调度。</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>线程的优先级用1-10之间的整数来表示，数字越大优先级越高。除了直接用数字外，还可用Thread类中提供的三个静态常量表示线程的优先级。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//用lambda表达式创建线程？</span></span><br><span class="line">		<span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()</span><br><span class="line">						+<span class="string">&quot;正在输出i+&quot;</span>+i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="string">&quot;优先级较低的线程&quot;</span>);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()</span><br><span class="line">						+<span class="string">&quot;正在输出j+&quot;</span>+j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="string">&quot;优先级较高的线程&quot;</span>);</span><br><span class="line">		<span class="comment">//设置线程的优先级</span></span><br><span class="line">		th1.setPriority(Thread.MIN_PRIORITY);  <span class="comment">//MIN=1 NORM=5  MAX=10</span></span><br><span class="line">		th2.setPriority(<span class="number">10</span>);</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><p>将正在执行的线程暂停，将CPU使用权让给其他线程，这是可以使用静态方法sleep(long millis)，该方法使得线程进入休眠等待状态，这样其他线程就可以得到执行的机会。sleep(long millis)方法会声明抛出InterruptedException异常，因此在调动该方法时应该捕获异常，或者声明抛出异常。休眠时间结束后，线程才会转换到就绪状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()</span><br><span class="line">						+<span class="string">&quot;正在输出i+&quot;</span>+i);</span><br><span class="line">				<span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span>&#123;</span><br><span class="line">						<span class="comment">//在该线程执行过程中进入睡眠状态，让其他线程先执行</span></span><br><span class="line">						Thread.sleep(<span class="number">500</span>);</span><br><span class="line">					&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()</span><br><span class="line">						+<span class="string">&quot;正在输出j+&quot;</span>+j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程让步"><a href="#线程让步" class="headerlink" title="线程让步"></a>线程让步</h3><p><code>Thread.yield();</code> 使当前正在运行的线程暂停，但不会阻塞该线程，只是将线程转换成就绪状态，让线程的调度器重新调度一次。Thread的yield方法，在线程类实现内使用。</p>
<p>相当于让占着CPU的线程让步，交出CPU，大家重新抢占一次，因此，也有可能自己再抢到。</p>
<h3 id="线程插队"><a href="#线程插队" class="headerlink" title="线程插队"></a>线程插队</h3><p>当某个线程a中调用其他线程b的join方法时，线程a将被阻塞，线程b插队优先执行，直到线程b执行完成后，线程a才会完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;输入：&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">		<span class="comment">//创建线程</span></span><br><span class="line">		<span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Thread1</span>(), <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">		th1.start();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;输入&quot;</span>+i);</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">				th1.join();  <span class="comment">//th1插队执行，main阻塞，在th1执行完才会继续执行</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除join无参数的线程插队方法外，Thread还提供了带有时间参数的线程插队方法<code>join(long millis)</code>。表示需要等待插队的线程执行指定时间后，才可以继续执行其他线程。</p>
<p>mian函数本身也算是一个主线程。</p>
<h2 id="多线程同步"><a href="#多线程同步" class="headerlink" title="多线程同步"></a>多线程同步</h2><p>多线程同步：限制某个资源在同一时刻只能被一个线程访问。</p>
<p>Runnable接口实现多线程，适合多个线程处理同一个共享资源的情况。但是共享的时候会出现线程安全的问题。</p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>Java提供了线程同步机制，当多个线程使用同一共享资源时，可以将<strong>处理共享资源的操作代码</strong>放置在一个使用synchronized关键字来修饰的代码块中，这段代码块被称作同步代码块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">	<span class="comment">//操作共享资源代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lock是一个锁对象，是同步代码块的关键。当线程执行同步代码块时，首先会检查锁对象的标志位，默认情况下标志位为1，此时线程会执行同步代码块，同时将锁对象的标志位置为0。当一个新的线程执行到这段同步代码块时，由于锁对象的标志位为0，新线程会发生阻塞，等锁对象的标志位被置为1，新线程才能进入同步代码块执行其中的代码。（好比公共电话亭，前一个打完出来，后面的人才能进去）。</p>
<p>同步代码块中的锁对象可以是任意类型的对象，但多个线程共享的锁对象必须是相同的。锁对象的创建代码不能放在run()方法中，否则每个线程运行到run()方法都会创建一个新对象，这样每个线程都会有一个不同的锁，每个锁有自己的标志位，无法同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.multithread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: multithread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 多线程模拟售票</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-11-30 13:15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SaleThread</span> <span class="variable">saleThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SaleThread</span>();</span><br><span class="line">        <span class="comment">//创建并开启4个线程，模拟四个售票窗口</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(saleThread, <span class="string">&quot;窗口1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(saleThread, <span class="string">&quot;窗口2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(saleThread, <span class="string">&quot;窗口3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(saleThread, <span class="string">&quot;窗口4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SaleThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  <span class="comment">//定义任意一个对象，用作同步代码块的锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);  <span class="comment">//模拟售票耗时过程</span></span><br><span class="line">                    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                +<span class="string">&quot;正在发售第&quot;</span>+tickets--+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个文件中可以有多个class类，但只能有一个含mian函数的类，并且文件名需要和含main函数的类的名字相同。</p>
</blockquote>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>在方法前面也可以使用synchronized关键字来修饰，被修饰的方法为同步方法，它能实现和同步代码块同样的功能。</p>
<p><code>[修饰符] synchronized 返回值类型 方法名(参数)&#123;&#125;</code></p>
<p>被synchronized修饰的方法在某一时刻只允许一个线程访问，访问该方法的其他线程都会发生阻塞，直到当前线程访问完毕后，其他线程才有机会执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.multithread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: multithread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同步方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-11-30 13:47</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_Thread1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SaleThread1</span> <span class="variable">saleThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SaleThread1</span>();</span><br><span class="line">        <span class="comment">//创建并开启4个线程，模拟四个售票窗口</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(saleThread, <span class="string">&quot;窗口1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(saleThread, <span class="string">&quot;窗口2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(saleThread, <span class="string">&quot;窗口3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(saleThread, <span class="string">&quot;窗口4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SaleThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;    <span class="comment">//在run方法中调用synchronized修饰的同步方法</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            saleTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">saleTicket</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);  <span class="comment">//模拟售票耗时过程</span></span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                    +<span class="string">&quot;正在发售第&quot;</span>+tickets--+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步代码块的锁是自己定义的任意类型的对象。同步方法的锁是当前调用该方法的对象，也就是this指向的对象。同步方法被所有线程所共享，方法所在的对象相对于所有线程来说是唯一的，从而保证了锁的唯一性。当一个线程执行该方法，其他的线程就不能进入该方法。</p>
<p>有时，需要同步的方法是静态方法，静态方法不需要创建对象就可用类名调用，静态同步方法的锁是该方法所在类的class对象，该对象可以直接用<code>类名.class</code>的方式来获取。</p>
<p>同步代码块和同步方法：解决了多线程访问共享数据时的线程安全问题，即加锁来使同一时间只有一个线程执行。</p>
<p>弊端：线程在执行同步代码时每次都会判断锁的状态，消耗资源，效率较低。</p>
<h3 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h3><p>synchronized同步代码块和同步方法使用一种封闭式的锁机制，但是它无法中断一个正在等候获得锁的线程，也无法通过轮询得到锁。</p>
<p>JDK5开始，java提供了一个功能更强大的Lock锁，Lock锁与synchronized隐式锁在功能上基本相同，最大的优势在于Lock锁可以让某个线程在持续获取同步锁失败后返回，不再继续等待，使用起来更加灵活。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.multithread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: multithread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Lock锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-11-30 14:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tset_Lock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LockThread</span> <span class="variable">saleThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockThread</span>();</span><br><span class="line">        <span class="comment">//创建并开启4个线程，模拟四个售票窗口</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(saleThread, <span class="string">&quot;窗口1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(saleThread, <span class="string">&quot;窗口2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(saleThread, <span class="string">&quot;窗口3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(saleThread, <span class="string">&quot;窗口4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//定义一个lock锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            lo.lock();</span><br><span class="line">            <span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);  <span class="comment">//模拟售票耗时过程</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            +<span class="string">&quot;正在发售第&quot;</span>+tickets--+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    lo.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Lock</code>接口的实现类：<code>ReentrantLock</code>。</p>
<p>还有<code>tryLock()</code>方法用来判断某个线程锁是否可用。</p>
<blockquote>
<p>注意：不管是同步代码块、同步方法还是同步锁，锁对象都是几个线程共享的，不能在run方法中定义，都是在run方法之外定义。同步方法中，只创建一个对象，一个对象代表锁对象。</p>
</blockquote>
<h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><p>两个线程都需要对方所占用的锁，但是都无法释放自己所拥有的锁。</p>
<h2 id="多线程通信"><a href="#多线程通信" class="headerlink" title="多线程通信"></a>多线程通信</h2><p>控制多个线程按照一定的顺序轮流执行，此时就需要让线程间进行通信，保证线程任务的协调进行。</p>
<p>Java在Object类中提供了<code>wait()、notify()、notifyAll()</code>等方法用于解决线程间的通信问题。所有类都是Object类的子类或间接子类，因此任何类都可直接用这些方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span>  <span class="comment">//使当前线程进入等待状态</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>  <span class="comment">//唤醒此同步锁上等待的第一个调用wait()方法的线程</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>  <span class="comment">//唤醒此同步锁上调用wait()方法的所有线程</span></span><br></pre></td></tr></table></figure>

<p>这些方法的调用者都是<strong>同步锁对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.multithread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: multithread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 线程间通信</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-11-30 15:40</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread_Commu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个集合类，模拟存储生产的商品</span></span><br><span class="line">        List&lt;Object&gt; goods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//记录线程执行前统一的起始时间start</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//创建一个生产者线程，由于生产商品并存入商品集合</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(System.currentTimeMillis()-start&lt;=<span class="number">1000</span>)&#123;  <span class="comment">//控制执行时间</span></span><br><span class="line">                <span class="comment">//使用synchronized关键字同步商品生产和消费</span></span><br><span class="line">                <span class="keyword">synchronized</span> (goods)&#123;</span><br><span class="line">                    <span class="comment">//有商品就让生产者等待</span></span><br><span class="line">                    <span class="keyword">if</span>(goods.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            goods.wait();</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//生产者继续生产商品</span></span><br><span class="line">                        num++;</span><br><span class="line">                        goods.add(<span class="string">&quot;商品&quot;</span>+num);</span><br><span class="line">                        System.out.println(<span class="string">&quot;生产商品&quot;</span>+num);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(System.currentTimeMillis()-start&lt;=<span class="number">1000</span>)&#123;  <span class="comment">//控制执行时间</span></span><br><span class="line">                <span class="comment">//使用synchronized关键字同步商品生产和消费</span></span><br><span class="line">                <span class="keyword">synchronized</span> (goods)&#123;</span><br><span class="line">                    <span class="comment">//商品不足就唤醒生产者进行生产</span></span><br><span class="line">                    <span class="keyword">if</span>(goods.size()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                        goods.notifyAll();</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//继续消费商品</span></span><br><span class="line">                        num++;</span><br><span class="line">                        goods.remove(<span class="string">&quot;商品&quot;</span>+num);</span><br><span class="line">                        System.out.println(<span class="string">&quot;消费商品&quot;</span>+num);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line">        <span class="comment">//同时启动生产者和消费者两个线程，并统一执行100ms时间</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，实现供需有序、均衡，按照先生产后消费的顺序轮流执行。</p>
<p>注意：wait函数中，可有时间，时间到了，也可以自动唤醒处于等待状态的线程。唤醒的方式：其他线程notify唤醒 或 时间到。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>前面的多线程中，复杂任务会频繁手动式地创建、管理线程，线程对象使用了大量的内存，在大规模应用中，创建、分配和释放多线程对象会产生大量内存管理开销。为此，Java提供了线程池来创建多线程，进一步优化线程管理。</p>
<h3 id="Executor接口实现线程池管理"><a href="#Executor接口实现线程池管理" class="headerlink" title="Executor接口实现线程池管理"></a>Executor接口实现线程池管理</h3><p>从JDK5开始，java.util.concurrent包下增加了Executor接口及其子类，允许使用线程池技术来管理线程并发问题。</p>
<p>Executor接口提供一个常用的ExecutorService子接口，通过该子接口可以方便地管理线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.multithread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: multithread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-01 12:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.定义一个实现Runnable接口或者Callable接口的实现类，同时重写run()或者call()方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread4</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Object&gt;&#123;</span><br><span class="line">    <span class="comment">//1.1重写Callable接口的call()方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++&lt;<span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                              +<span class="string">&quot;的call()方法在运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread_Pool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="comment">//2.创建Runnable接口或者Callable接口的实现类对象</span></span><br><span class="line">        <span class="type">MyThread4</span> <span class="variable">myth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread4</span>();</span><br><span class="line">        <span class="comment">//3.使用Executors线程执行器类创建可扩展的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//4.将Callable接口实现类对象提交到线程池进行管理</span></span><br><span class="line">        Future&lt;Object&gt;res1 = executor.submit(myth);</span><br><span class="line">        Future&lt;Object&gt;res2 = executor.submit(myth);</span><br><span class="line">        <span class="comment">//5.关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="comment">//对于有返回值的线程任务，获取执行结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;thread-1返回结果：&quot;</span>+res1.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;thread-2返回结果：&quot;</span>+res2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池executor系统给名字pool-1.该线程池中管理有两个默认生成名称的线程thread-1和thread-2.</p>
<p>线程池通过Executors的newCachedThreadPool方法创建，Executors是JDK5增加的线程执行器工具类，提供四种方法创建线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newCachedThreadPool()    创建一个可扩展线程池的执行器。适合由于启动许多短期任务的应用程序。</span><br><span class="line">newFixedThreadPool(<span class="type">int</span> n)     创建固定线程数量线程池的执行器。</span><br><span class="line">newSingleThreadExecutor()     创建一个只执行一个任务的单线程</span><br><span class="line">newScheduledThreadPool(<span class="type">int</span> size)    创建一个定长线程池，支持定时及周期性任务执行。</span><br></pre></td></tr></table></figure>

<h3 id="CompletableFuture类实现线程池管理"><a href="#CompletableFuture类实现线程池管理" class="headerlink" title="CompletableFuture类实现线程池管理"></a>CompletableFuture类实现线程池管理</h3><p>使用Callable接口实现多线程时，会用到FutureTask类对线程执行结果进行管理和获取，该类获取结果时是通过阻塞或者轮询的方式，消耗过多资源。</p>
<p>JDK8增加了一个强大的函数式异步编程辅助类CompletableFuture，该类同时实现了Future接口和CompletionStage接口（Java8增加的线程任务完成结果接口），可以简化异步编程。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》之JDBC</title>
    <url>/2021/11/27/myblog/java/%E3%80%8Ajava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8BJDBC/</url>
    <content><![CDATA[<p>实际开发中，项目中的数据是存储在数据库中的，Java对数据库的操作提供了一套可以执行SQL语句的API，即JDBC。</p>
<h2 id="JDBC概念"><a href="#JDBC概念" class="headerlink" title="JDBC概念"></a>JDBC概念</h2><p>JDBC（java database connectivity，Java数据库连接）是一套用于执行SQL语句的Java API。应用程序通过该API连接到关系型数据库，并使用SQL语句来完成对数据库中数据的增删改查。</p>
<p>JDBC要求各个数据库厂商按照统一的规范来提供数据库驱动，在程序中由JDBC和具体的数据库驱动联系，使得应用程序不必直接与底层数据库交互，使得代码的通用性更强。</p>
<p>JDBC在应用程序与数据库之间起到一个桥梁作用。当应用程序使用JDBC访问特定的数据库时，只需要通过不同的数据库驱动与其对应的数据库进行连接，连接后即可对该数据库进行相应的操作。</p>
<h2 id="JDBC常用API"><a href="#JDBC常用API" class="headerlink" title="JDBC常用API"></a>JDBC常用API</h2><p>JDBC的API主要位于java.sql包中，定义了一系列访问数据库的接口和类。</p>
<h3 id="Driver接口"><a href="#Driver接口" class="headerlink" title="Driver接口"></a>Driver接口</h3><p>是所有JDBC驱动程序必须实现的接口，专门提供给数据库厂商使用。</p>
<h3 id="DriverManager类"><a href="#DriverManager类" class="headerlink" title="DriverManager类"></a>DriverManager类</h3><p>用于加载JDBC驱动并创建与数据库的连接。在加载数据库驱动时，通常使用Class类的静态方法forName()来实现。参数是数据库驱动类所对应的字符串。</p>
<h3 id="Connection接口"><a href="#Connection接口" class="headerlink" title="Connection接口"></a>Connection接口</h3><p>代表Java程序和数据库的连接对象，只有获得该连接对象后，才能访问数据库，并操作数据表。</p>
<h3 id="Statement接口"><a href="#Statement接口" class="headerlink" title="Statement接口"></a>Statement接口</h3><p>用于执行静态的SQL语句，并返回一个结果对象。</p>
<p>Statement接口对象可以通过Connection实例的createStatement()方法获得，该方法把静态的SQL语句发送到数据库中编译执行，然后返回数据库的处理结果。</p>
<h3 id="PreparedStatement接口"><a href="#PreparedStatement接口" class="headerlink" title="PreparedStatement接口"></a>PreparedStatement接口</h3><p>使用Statement接口操作SQL语句会过于繁琐，并且存在安全隐患，因此，JDBC提供了扩展的PreparedStatement接口。是Statement的子接口，用于执行预编译的SQL语句，可以使用占位符？来替代参数，然后通过setXXX()方法为SQL语句的参数赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql=<span class="string">&quot;insert into users(is,name,email) values(?,?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">prestmt</span> <span class="operator">=</span> conn.preparedStatement(sql);</span><br><span class="line">prestmt.setInt(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">prestmt.setString(<span class="number">2</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">prestmt.setObject(<span class="number">3</span>,<span class="string">&quot;111@1.com&quot;</span>);  <span class="comment">//通用方法？</span></span><br><span class="line">prestmt.executeUpdate();</span><br></pre></td></tr></table></figure>

<h3 id="ResultSet接口"><a href="#ResultSet接口" class="headerlink" title="ResultSet接口"></a>ResultSet接口</h3><p>用于保存JDBC执行查询时返回的结果集，结果集封装在一个逻辑表格中。接口内部有一个指向表格数据行的游标（或指针），ResultSet对象初始化时，游标在第一行之前。调用next()方法，游标移动到下一行，若下一行没有数据，则返回false。</p>
<p>应用程序中使用next方法作为while循环的条件来迭代ResultSet结果集。</p>
<p>getXXX方法用于获取指定的数据，可以用索引（从1开始）也可用字段的名称来获取。</p>
<p>例如第1列字段名为id，字段类型int，可以用getInt(“id”)或getInt(1)获得该列的值。</p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="第一步：加载数据库驱动"><a href="#第一步：加载数据库驱动" class="headerlink" title="第一步：加载数据库驱动"></a><em>第一步：加载数据库驱动</em></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);  <span class="comment">//加载mysql数据库的驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);   <span class="comment">//加载Oracle数据库的驱动</span></span><br></pre></td></tr></table></figure>

<h3 id="第二步：获取数据库连接"><a href="#第二步：获取数据库连接" class="headerlink" title="第二步：获取数据库连接"></a><em>第二步：获取数据库连接</em></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(String url, String user, String pwd);</span><br></pre></td></tr></table></figure>

<p>连接数据库的url需要遵循固定写法：</p>
<p><code>jdbc:mysql://hostname:port/databasename</code></p>
<p>mysql指MySQL数据库，hostname指主机的名称（如果数据库在本机上，hostname可以为localhost或127.0.0.1。如果在其他机器上，那么hostname为所要连接机器的IP地址。port指端口号，mysql默认端口号为3306，databasename指的是mysql中相应数据库的名字。</p>
<h3 id="第三步：通过Connection对象获取Statement对象"><a href="#第三步：通过Connection对象获取Statement对象" class="headerlink" title="第三步：通过Connection对象获取Statement对象"></a><em>第三步：通过Connection对象获取Statement对象</em></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br></pre></td></tr></table></figure>

<p>也可以用PreparedStatement。</p>
<h3 id="第四步：使用Statement执行SQL语句"><a href="#第四步：使用Statement执行SQL语句" class="headerlink" title="第四步：使用Statement执行SQL语句"></a><em>第四步：使用Statement执行SQL语句</em></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execute(String sql);  用于执行任意sql语句</span><br><span class="line">executeQuery(String sql);   执行查询操作，返回一个ResultSet结果集对象</span><br><span class="line">executeUpdate(String sql);  执行insert、update、delete会返回受sql语句影响的行数，执行create、alter返回<span class="number">0</span></span><br><span class="line"></span><br><span class="line">ResultSet rs=stmt.executeQuery(sql);</span><br></pre></td></tr></table></figure>

<h3 id="第五步：操作ResultSet结果集"><a href="#第五步：操作ResultSet结果集" class="headerlink" title="第五步：操作ResultSet结果集"></a><em>第五步：操作ResultSet结果集</em></h3><h3 id="第六步：关闭连接，释放资源"><a href="#第六步：关闭连接，释放资源" class="headerlink" title="第六步：关闭连接，释放资源"></a><em>第六步：关闭连接，释放资源</em></h3><p>顺序为：ResultSet、Statement、Connection。为了保证在异常情况下也能关闭资源，用try…catch的finally代码块统一关闭资源。</p>
<h2 id="第一个JDBC程序"><a href="#第一个JDBC程序" class="headerlink" title="第一个JDBC程序"></a>第一个JDBC程序</h2><h3 id="数据库建表"><a href="#数据库建表" class="headerlink" title="数据库建表"></a>数据库建表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database jdbc;</span><br><span class="line">show databases;</span><br><span class="line">use jdbc;</span><br><span class="line">create table test_table(</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">    name varchar(40),</span><br><span class="line">    sex varchar(2),</span><br><span class="line">    birthday date</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看表结构： desc test_table;</span><br><span class="line">查看建表语句：show create table test_table;</span><br></pre></td></tr></table></figure>

<p>如果出现中文乱码的情况，是因为MySQL数据库默认使用UTF-8编码格式，而命令行窗口默认使用的是GBK编码格式，所以执行带有中文数据的插入语句会出现解析错误。需要执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set character_set_client=gbk;</span><br><span class="line">set character_set_results=gbk;</span><br></pre></td></tr></table></figure>

<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into test_table(name, sex, birthday)</span><br><span class="line">values(&#x27;jade&#x27;,&#x27;男&#x27;,&#x27;2000-1-1&#x27;),(&#x27;marry&#x27;,&#x27;女&#x27;,&#x27;1999-2-21&#x27;),(&#x27;james&#x27;,&#x27;男&#x27;,&#x27;2010-2-3&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="新建项目，导入数据库驱动"><a href="#新建项目，导入数据库驱动" class="headerlink" title="新建项目，导入数据库驱动"></a>新建项目，导入数据库驱动</h3><p>IDE下正常创建一个项目，右键新建一个文件夹，取名libs。</p>
<p>下载Mysql驱动文件：<a href="https://dev.mysql.com/downloads/connector/j/%EF%BC%8C%E9%80%89%E6%8B%A9platform">https://dev.mysql.com/downloads/connector/j/，选择platform</a> independent，下载 <strong>ZIP Archive</strong>。直接No thanks, just start my download.  复制到libs文件夹下。</p>
<p>把jar包添加到项目里，类似eclipse的add to build path功能，file – project structure – modules – dependencies – 加号 – 第一项–添加jar包 – apply。</p>
<h3 id="编写JDBC程序"><a href="#编写JDBC程序" class="headerlink" title="编写JDBC程序"></a>编写JDBC程序</h3><p>src下新建包com.liuxuan.jdbc。创建类Test。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.internal.parser.JSONParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: JDBCdemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: jdbc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-11-27 22:09</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.加载数据库驱动 com.mysql.jdbc.Driver 多加了cj</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//2.通过DriverManager获取数据库连接</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/jdbc&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;liuxuan&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;jade&quot;</span>;</span><br><span class="line">            conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">            <span class="comment">//3.通过Connection对象获取Statement对象</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">//4.使用Statement执行SQL语句</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from test_table&quot;</span>;</span><br><span class="line">            rs = stmt.executeQuery(sql);</span><br><span class="line">            <span class="comment">//5.操作ResultSet结果集</span></span><br><span class="line">            System.out.println(<span class="string">&quot;id  |  name  |  sex  &quot;</span></span><br><span class="line">                            +<span class="string">&quot;  birthday  &quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;sex&quot;</span>);</span><br><span class="line">                <span class="type">Date</span> <span class="variable">birthday</span> <span class="operator">=</span> rs.getDate(<span class="string">&quot;birthday&quot;</span>);</span><br><span class="line">                System.out.println(id+<span class="string">&quot;  |  &quot;</span>+name+<span class="string">&quot;  |  &quot;</span></span><br><span class="line">                                +sex+<span class="string">&quot;  |  &quot;</span>+birthday);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//6.关闭连接，释放资源</span></span><br><span class="line">            <span class="keyword">if</span>(rs != <span class="literal">null</span>)&#123;rs.close();&#125;</span><br><span class="line">            <span class="keyword">if</span>(stmt != <span class="literal">null</span>)&#123;stmt.close();&#125;</span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="literal">null</span>)&#123;conn.close();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>python之零碎知识点</title>
    <url>/2025/08/05/myblog/python/python%E4%B9%8B%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="python通过执行命令获取参数"><a href="#python通过执行命令获取参数" class="headerlink" title="python通过执行命令获取参数"></a>python通过执行命令获取参数</h2><p>1、sys.argv：获取脚本运行时的命令行参数，是一个列表，第一个元素是脚本名称 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Script name:&quot;</span>, sys.argv[<span class="number">0</span>])  <span class="comment"># 脚本名称 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Arguments:&quot;</span>, sys.argv[<span class="number">1</span>:])  <span class="comment"># 参数列表 </span></span><br><span class="line">运行命令：python script.py arg1 arg2 arg3</span><br></pre></td></tr></table></figure>

<p>2、argparse：高级命令行参数解析 </p>
<p>首先使用argparse.ArgumentParser创建解析器。然后定义参数（如位置参数、可选参数等）。最后解析参数并访问其值。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建解析器 </span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;A simple argument parser example.&quot;</span>) </span><br><span class="line"><span class="comment"># 添加参数 </span></span><br><span class="line">parser.add_argument(<span class="string">&quot;name&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;User&#x27;s name&quot;</span>) </span><br><span class="line">parser.add_argument(<span class="string">&quot;--age&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&quot;User&#x27;s age&quot;</span>, default=<span class="number">18</span>) </span><br><span class="line">parser.add_argument(<span class="string">&quot;--verbose&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Enable verbose mode&quot;</span>) </span><br><span class="line"><span class="comment"># 解析参数 </span></span><br><span class="line">args = parser.parse_args() </span><br><span class="line"><span class="comment"># 访问参数 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;args.name&#125;</span>!&quot;</span>) </span><br><span class="line"><span class="comment"># 一个可选参数。只要它出现在命令行中，args.verbose 的值就会被设置为 True。</span></span><br><span class="line"><span class="keyword">if</span> args.verbose: </span><br><span class="line">运行命令：python script.py Alice --age <span class="number">25</span> --verbose</span><br></pre></td></tr></table></figure>



<h2 id="动态加载模块"><a href="#动态加载模块" class="headerlink" title="动态加载模块"></a>动态加载模块</h2><p>importlib: 用于动态加载模块。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">importlib.import_module <span class="comment"># 在运行时根据条件或配置导入不同模块 </span></span><br><span class="line">module = import_module(<span class="string">&#x27;math&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(module.sqrt(<span class="number">4</span>)) </span><br></pre></td></tr></table></figure>

<p>pkgutil.iter_modules：用于动态地列出指定包或路径中的所有模块 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> module_info <span class="keyword">in</span> pkgutil.iter_modules():    </span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&quot;Name: <span class="subst">&#123;module_info.name&#125;</span>, Is Package: <span class="subst">&#123;module_info.ispkg&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>inspect.getmembers ：用于获取对象（模块、类、实例等）的所有成员属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">methods = inspect.getmembers(MyClass, predicate=inspect.isfunction) </span><br><span class="line">inspect.ismethod	实例方法 </span><br><span class="line">inspect.isfunction	普通函数 </span><br><span class="line">inspect.isclass	类对象 </span><br><span class="line">inspect.isdatadescriptor	数据描述符（如<span class="built_in">property</span>） </span><br><span class="line">inspect.isgenerator	生成器对象</span><br></pre></td></tr></table></figure>



<h2 id="OutputNamedTuple"><a href="#OutputNamedTuple" class="headerlink" title="OutputNamedTuple"></a>OutputNamedTuple</h2><p>命名元组，命名元组是由 <code>collections.namedtuple()</code> 函数创建的数据类型。命名元组本质上是一个类的实例，这个类是从内置的元组类型继承而来的，但与普通元组不同的是，它的元素可以通过名字来访问，而不仅仅是通过索引位置。</p>
<p>特性：<strong>可命名性</strong>、<strong>不可变性</strong>、<strong>轻量级对象</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个命名元组类型 &#x27;Person&#x27;</span></span><br><span class="line">Person = namedtuple(<span class="string">&#x27;Person&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 Person 实例</span></span><br><span class="line">person = Person(name=<span class="string">&#x27;Alice&#x27;</span>, age=<span class="number">30</span>, gender=<span class="string">&#x27;female&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过名称访问字段</span></span><br><span class="line"><span class="built_in">print</span>(person.name)   <span class="comment"># 输出: Alice</span></span><br><span class="line"><span class="built_in">print</span>(person.age)    <span class="comment"># 输出: 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样也可以通过索引访问</span></span><br><span class="line"><span class="built_in">print</span>(person[<span class="number">0</span>])     <span class="comment"># 输出: Alice</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解包操作</span></span><br><span class="line">name, age, gender = person</span><br><span class="line"><span class="built_in">print</span>(gender)        <span class="comment"># 输出: female</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为字典</span></span><br><span class="line">person_dict = person._asdict()</span><br><span class="line"><span class="built_in">print</span>(person_dict)   <span class="comment"># 输出: OrderedDict([(&#x27;name&#x27;, &#x27;Alice&#x27;), (&#x27;age&#x27;, 30), (&#x27;gender&#x27;, &#x27;female&#x27;)])</span></span><br></pre></td></tr></table></figure>



<h2 id="元组和字典"><a href="#元组和字典" class="headerlink" title="元组和字典"></a>元组和字典</h2><p><strong>元组</strong>：是一个有序的、不可变的数据集合。元组中的元素通过索引来访问，支持重复值。<br>一旦创建后，其内容不能被修改。这被称为“不可变性”，意味着你不能添加、删除或更改元组中的元素。<br>使用场景：多返回值函数、固定集合等。此外，元组占用的空间相对较小，适合用于存储少量但固定的项目。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple_example = (<span class="number">1</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="number">3.14</span>)</span><br><span class="line"><span class="built_in">print</span>(tuple_example[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p><strong>字典</strong>：是一个无序的键值对集合，键必须是唯一的且不可变（如字符串、数字或元组），而值可以是任何类型的数据。字典通过键来访问对应的值。<br>是可变的，你可以随时添加、删除或更新字典中的键值对。<br>使用场景：适用于需要频繁查找、插入和删除操作的场合，尤其是在键值对应关系明显时特别有效。但是，字典会消耗更多的内存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict_example = &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">3.14</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict_example[<span class="string">&#x27;name&#x27;</span>])</span><br></pre></td></tr></table></figure>



<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p><code>class BaseClass(metaclass=abc.ABCMeta)</code> 这行代码定义了一个<strong>抽象基类</strong>（Abstract Base Class）。</p>
<p><strong><code>metaclass=abc.ABCMeta</code></strong>：</p>
<ul>
<li><code>metaclass</code>（元类）是创建类的“类”。它控制着类的创建过程。</li>
<li><code>abc.ABCMeta</code> 是 Python <code>abc</code> (Abstract Base Classes) 模块提供的一个特殊元类。</li>
<li>通过将 <code>BaseClass</code> 的元类指定为 <code>abc.ABCMeta</code>，我们告诉 Python <code>BaseClass</code> 应该被当作一个<strong>抽象基类</strong>来处理。</li>
</ul>
<p><strong>抽象基类的核心特点和作用：</strong></p>
<ul>
<li><strong>不能直接实例化</strong>：你不能直接创建 <code>BaseClass</code> 的实例（例如 <code>obj = BaseClass()</code> 会抛出错误）。</li>
<li><strong>定义接口（契约）</strong>：它的主要目的是定义一组方法（称为抽象方法），这些方法<strong>必须</strong>由它的子类（继承它的类）来实现。</li>
<li><strong>强制子类实现</strong>：如果一个子类继承了 <code>BaseClass</code>，但没有实现其所有的抽象方法，那么尝试创建这个子类的实例时，Python 会抛出 <code>TypeError</code> 错误。</li>
<li><strong>如何定义抽象方法</strong>：在 <code>BaseClass</code> 内部，使用 <code>@abstractmethod</code> 装饰器来标记哪些方法是抽象的。</li>
<li><strong>非抽象方法</strong>：这些方法在抽象基类中提供了具体的实现。子类<strong>可以</strong>直接继承并使用这些方法，也可以根据需要选择**重写（覆盖）**它们。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span>(metaclass=abc.ABCMeta):</span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;这是一个抽象方法，子类必须实现它。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_another_thing</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;这是另一个抽象方法。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 这是一个非抽象方法（具体方法）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">common_function</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;这是一个非抽象方法，子类可以直接继承使用。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is a common function provided by the base class.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误：不能实例化抽象基类</span></span><br><span class="line"><span class="comment"># instance = BaseClass()  # TypeError!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass</span>(<span class="title class_ inherited__">BaseClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Doing something!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注意：这里没有实现 do_another_thing</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误：ConcreteClass 没有实现所有抽象方法，不能实例化</span></span><br><span class="line"><span class="comment"># obj = ConcreteClass()  # TypeError!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FullyImplementedClass</span>(<span class="title class_ inherited__">BaseClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Doing something!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_another_thing</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Doing another thing!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确：可以实例化，因为所有抽象方法都被实现了</span></span><br><span class="line">obj = FullyImplementedClass()</span><br><span class="line">obj.do_something()  <span class="comment"># 输出: Doing something!</span></span><br><span class="line">obj.do_another_thing()  <span class="comment"># 输出: Doing another thing!</span></span><br></pre></td></tr></table></figure>

<p>现代 Python 更推荐使用 <code>abc.ABC</code> 作为基类，效果相同，但写法更简洁</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span>(abc.ABC):</span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年做过的编程题之Letcode100</title>
    <url>/2025/07/27/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%81%9A%E8%BF%87%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B9%8BLetcode100/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目 通用：数组初始化后填充某个数：Arrays.fill(arr, 0);    数组排序：Arrays.sort(names, Collections.reverseOrder());  数组装箱：Integer[] boxedNums = Arrays.stream(nums).boxed().toArray(Integer[]::new);  反转数组：需要先变为List，List list = Arrays.asList(arr);   Collections.reverse(list);    arr = list.toArray(new Integer[0]); (变为Integer[]) 或者 resList.stream().mapToInt(Integer::intValue).toArray();  (变为int[]) 小顶堆：PriorityQueue minHeap = new PriorityQueue&lt;&gt;();   PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; minHeap =          new PriorityQueue&lt;&gt;(Comparator.comparingInt(Map.Entry::getValue)); 大顶堆：PriorityQueue maxHeap = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());    heap.offer插入 poll删除元素 堆顶元素peek。 s.substring(startIndex, endIndex) 左闭右开 int sum = Arrays.stream(nums).sum(); 求和 回文链表：先把元素遍历出来到数组list，然后前后双指针进行对比。还可以使用递归，使用递归反向迭代节点，同时使用递归函数外的变量向前迭代。 环形链表：方法一：使用HashSet记录走过的节点，如果之前走过，则环形链表。方法二：快慢指针，有换一定会遇到，遇到后，一个指针从起始节点出发，一个指针从相遇节点出发，相同速度移动，撞见就是环形相交节点。 合并两个有序链表：双指针，while条件里可以是两个其中之一不为null，也可以是两个都不为null，然后next直接指向剩余的那个ListNode。注意ListNode a = new Listnode(1);  然后ListNode b = a; a/b再变，另一个是不跟着变得，因为不是ab指向的对象发生了变化，而是b指向了别的东西。 两数相加：while循环中求当前数和进位数，最后判断进位是否为0，也就是是否要加一个数。 删除链表的倒数第N个结点：双指针，得模拟一下，快指针移动几步（n步），然后慢指针停止的条件是什么（fast!=null）。考虑只有一个结点的情况，得用preHead。 两两交换链表中的节点（不能改节点的值）：跟链表翻转类似，遍历过程中模拟翻转的过程，需要定义哪些临时节点进行记录。注意要用preHead。链表翻转就不用preHead。 k个一组翻转链表：是翻转链表的复杂版本，不光要翻转，翻转之后连接分段，所以要在遍历过程中记录头节点和尾节点。首先判断分段是否够，顺便遍历到tail节点。子函数进行分段翻转，传入preHead和k，遍历用k，提前定义pre和cur，循环中1保存next，2箭头翻转，3移动pre和cur。然后连线，再移动。 排序链表：二分，归并排序（递归）先用快慢指针找到链表中点，分割进行递归，终止条件是只有一个节点。递归排序后进行merge，双指针法进行合并，得用preHead。 合并k个升序链表：优先级队列PriorityQueue，因为数组里的列表都是排好序的，所以先把数组中每个列表的头节点加进去，然后取队列里最小的，然后把取到的节点的next加入优先级队列，直到优先级队列为空了 LinkedHashMap：LinkedHashMap继承自HashMap，在 HashMap 的基础上增加了对元素顺序的维护能力，既可以按照插入顺序排序，也可以按照访问顺序排序。底层实现：HashMap（实现O(1) 时间复杂度的插入、删除和查找操作）+ 双向链表（用于记录键值对的顺序，链表的头节点表示最早插入或最久未访问的元素，尾节点表示最近插入或最近访问的元素。当哈希表需要扩容时，LinkedHashMap 会重新分配桶中的节点，但不会影响双向链表的顺序。扩容时机：当哈希表中的元素数量超过 容量 × 负载因子（默认0.75） 时，触发扩容操作。扩容为原数组容量的两倍。LinkedHashMap默认不移除元素，重写removeEldestEntry方法进行移除来实现LRU。 为什么LRU得是双向链表：涉及到找到节点，然后把节点移动到链表尾部，双向链表实现该操作只需要O1时间复杂度，单向链表无法获取上一个节点，是On复杂度。 实现LRU缓存：存放的是key-value对，自定义双向链表，节点内维护key和value，HashMap是用来快速找到节点的，所以key就是key，value是Node节点。需要自定义双向链表类，get方法中，首先判断在不在map中，如果在则移动节点到尾部。put方法中，首先判断容量是否达到上限，如果达到则移除头部节点（伴随改变size和map），然后添加节点到尾节点（伴随改变size和map）。注意前后都要哨兵节点，并且相连。 层序遍历：用队列来实现。每次访问一层，并把下一层加入到队列中。 栈： Stack 类由于继承自 Vector 导致的性能问题，不推荐使用。Deque（双端队列）接口提供了更灵活和高效的栈实现方法。ArrayDeque 和 LinkedList 是最常用的 Deque 实现类。 Deque stack = new ArrayDeque&lt;&gt;(); stack.pop()、 stack.peek()、 stack.push(num) 队列：使用Queue 队列：Queue queue = new ArrayDeque&lt;&gt;(); queue.offer(num)、queue.poll()、queue.peek() Queue 是一个接口，表示队列（FIFO，先进先出）的数据结构。 单向队列，offer()、poll() 和 peek() Deque 是一个接口，表示双端队列的数据结构。 addFirst()、addLast()、pollFirst()、pollLast()、用作栈，通过 push() 、 pop() 、peek() Deque 继承了 Queue 接口。 ArrayDeque 和 LinkedList 都实现了 Deque 接口，因此它们都可以用作双端队列或普通队列。 ArrayDeque：基于动态数组实现。不支持存储 null 元素。不是线程安全的。 LinkedList：基于双向链表实现。支持存储 null 元素。不是线程安全的。 前/中/后序遍历：方法一：递归法，递归的时候隐式地维护了一个栈。方法二：迭代法，显式地将这个栈模拟出来。前序遍历先把root节点压进去，然后遍历中pop加到res里，再右左节点压进去。后序遍历，先把root节点压进去，然后左右节点，这样是前右左顺序，再Collections.reverse(result)一下。中序遍历先一直压左边的，压到头了，再加到res，再压右节点，注意while里的条件是栈不空或root不为null，pop后，压pop节点的右节点。 广度优先搜索：一种逐层遍历的方式，从根节点开始，先访问当前层的所有节点，然后再访问下一层的所有节点。使用队列Queue来实现。 深度优先搜索：一种沿着树的深度方向尽可能深入访问节点的方式，直到到达叶子节点后再回溯。使用递归或者栈。 二叉树的最大深度：深度优先搜索，递归，终止条件是null节点返回0，不然看左右谁大。也可以用广度优先搜索，类似层序遍历，看有多少层。 翻转二叉树：深度优先搜索，递归，终止条件是null，返回null，然后左右节点递归，然后左右节点互换。 对称二叉树：递归，输入两个节点，一左一右，比较。 二叉树的直径：树中任意两个节点之间最长路径的长度。其实跟左子树深度和右子树深度(节点数)有关。但是需要注意，最大直径不一定需要经过根节点！!因此在递归中需要记录结果。递归返回节点数，边就在节点数基础上 - 1。 将有序数组转换为二叉搜索树：高度平衡的二叉树，不能选择中点之后直接做一支右一支，用递归，左边右边分别再递归。其实就是根据中序遍历恢复二叉树，只不过指定中点。 验证二叉树：使用递归，但是不能单纯地只判断左子树和右子树，递归输入中还得传最大值和最小值，不能只比父节点，父节点的父节点也得比，就传一个max一个min。 二叉搜索树中第k小的元素：中序遍历是顺序数列，先中序遍历再找数。拓展：如果一个数要频繁地找第k小，怎么优化，每个节点记录以该节点为根的节点数，然后再找。 二叉树的右视图：类似层序遍历，但是只记录每层的最后一个数。用队列。 二叉树展开为链表：先序遍历的方式，右指针是next。可以先先序遍历，然后再展开为列表。方法二是同时进行，但是要用迭代方式的前序遍历，用栈把右子树节点记录下来。 从前序与中序遍历序列构造二叉树：递归，前提条件是遍历中没有重复元素。前序遍历第一个节点是根节点，再从中序遍历中拆出左子树的中序遍历和右子树的中序遍历。 在中序遍历中找节点，用一个hash来快速找，通过数来找索引 路径总和：用递归解决，但是要注意从根节点到叶子结点，叶子结点得是left和right都为null的 路径总和2：需要找出从根节点到叶子结点的符合要求的所有路径。注意1:添加结果时需要添加结果的拷贝，因为是引用传递。注意2:需要回溯，就是在返回上一层前list去掉该节点。 路径总和3：不限制从根节点到叶子结点，但是需要从上到下，也就是从父节点到叶子结点。 解法1:暴力法，每个节点都走一遍递归。dfs函数，计算的是以root为开始，不管谁为结束的符合要求的数量，会存在整数溢出的问题，把dfs函数的targetSum参数类型变为long就行了。解法2: 用前缀和，就是用一个Map记录之前路径上从根节点到某节点的和对应的数量，这样只需要用从根节点到当前节点的和来解决问题了。dfs递归过程中记录根节点到目前的总和。dfs表示以当前节点为尾节点。依然要用Long解决溢出问题。 二叉树的最近公共祖先：用递归，递归函数的输出的是最近公共祖先，退出条件是如果当前节点是 p 或 q 或 空，则直接返回当前节点。在左右子树中分别递归查找 p 和 q：如果左子树返回非空结果且右子树返回非空结果，则当前节点就是最近公共祖先。如果只有左子树返回非空结果，则返回左子树的结果。如果只有右子树返回非空结果，则返回右子树的结果。脑子里模拟一下这个过程，一个函数就解决。 二叉树中的最大路径和：用递归，不限制父节点到子节点，所以，当前节点路径=当前节点+左路径+右路径，对比全局最大。注意，递归函数是包含root节点的单边的。 岛屿数量：递归dfs，递归使相邻的置为0。也可以使用并查集，并查集的核心思想是通过树形结构维护集合关系，并通过路径压缩优化查找效率。第一步初始化父节点和深度节点列表，然后合并，合并过程中寻找root节点是否相同，不相同则需要合并，find的过程中递归。深度小的往深度大的合并，提高查找根结点的效率。将rank较小的根节点指向rank较大的根节点，以保持树的平衡。如果两个根节点的rank相同，则可以将其中一个根节点作为另一个根节点的子节点，并将rank增加1。 腐烂的橘子：广度优先搜索，用到队列，将最开始腐烂的橘子加入到队列中，然后一层层往外遍历。注意，while判断里，除了queue不为空，还需要新鲜橘子数量大于0. 课程表：判断图中有没有环。用邻接表来表示图，维护节点状态：未访问、正在访问、已访问，用深度优先搜索，遍历所有节点，递归遍历后序节点（反个方向是不是也行？）。其实就是判断图中有没有环。首先，构建邻接表，放的是节点的后置节点。其次，创建初始状态，0未访问，1访问中，2已访问。然后进行DFS。 List转换为Integer[]：list.toArray(new Integer[list.size()]) List转换为int[]：res.stream().mapToInt(Integer :: intValue).toArray() 课程表输出顺序：注意，应该在递归回溯的时候再往结果里放入，如果遍历的是后序节点，还应该Collections.reverse(list)。 全排列：给的元素无重复，同一个元素不能重复使用。用递归DFS，但是需要记录哪些元素已经使用过了。在回溯的时候需要移除List和移除记录使用元素的Set。拷贝一个list：new ArrayList&lt;&gt;(list)。 子集：给的元素无重复，返回所有子集，不能包含重复的子集。不是看排列了，而是看子集了。使用递归DFS，但是不用记录使用set了，需要记录开始递归位置start。 电话号码的字母组合：递归DFS，带start，初始化map，new HashMap&lt;&gt;()&#123;&#123;put(1,&quot;a&quot;); put...)&#125;&#125;，注意得是两个大括号。遍历字符串中的字符：for(char c : s.toCharArray())。s.substring(start, end)。 组合总和：给的是无重复的数组，返回和为target的组合方案，一个数可以使用多次。用DFS，先给数组排个序，DFS中如果大于target就False，后面就不遍历了。为了避免重复，应该用start来限制开始遍历的数字。注意：1.写入结果传副本。2.先排序，大了就不用往后走了。3.回溯后移除节点。4.传start避免结果重复。 括号生成：给出一个n，返回可能的括号组合。DFS中两种情况：放左括号和放右括号。 单词搜索：深度优先搜索，不能光遍历四周，遍历过的还不能再遍历了，不然一直在dfs。用set维护路径。最开始的想法：从头开始DFS，用Set记录走过的路径防止重复遍历。但是比较字符串需要比较结尾。改进方法：DFS，dfs起点：每个点；dfs需要携带的：匹配上的字符长度；dfs出口：字符不一样/字符长度达到。已经用过的字母不能再用：向下一个递归之前变为其他字符，递归完之后再变回来 分割回文串：给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。 解法：DFS+回溯，要传start记录切割位置，for横向遍历，dfs纵向遍历。把一个字符串分割成若干个回文串，DFS，目标是挨个遍历，遍历到回文串存一个，然后继续向后遍历，出递归的条件是遍历到了末尾。要用start记录遍历到了哪里，注意单个字符也算回文。 N皇后：输入n，求得所有可能的排布。使用回溯，用什么表示：用一个数组，数组表示index行的皇后放在value列。什么时候记录：所有行都完备了添加。需要有检查排布是否可以的方法。用StringBuilder，s.setCharAt(track[i], &#x27;Q&#x27;); 二分查找：mid = l + (r - l) /2; 要注意while里的条件是l&lt;=r。l要更新为mid-1。r要更新为r+1。 搜索二维矩阵：先用一遍二分找在哪个行，注意所在行是最后的l-1。再用二分找在哪个列。 在排序数组中查找元素的第一个和最后一个位置：先二分查找找到目标，再前后移动找位置. 寻找旋转排序数组中的最小值：直接遍历虽然能解，但是复杂度要求达不到，要用二分。画张图举个例子好理解，中间节点和两边节点判断可过滤不可能的，注意和传统二分区别：while里条件l&lt;r。 寻找两个正序数组的中位数：限制时间负责度logm+n，所以双指针前后遍历是不行的，得二分。思路：扩展到获取第k大的数，分别获取两个数组k/2的位置，小的左边就能淘汰。第一步：出递归条件：如果一个数组已经被淘汰没了，则直接从另一个获取。第二步：递归：获取每个数组的第k/2位置数做比较，可能越界，所以得判断。注意得是index=s1+k/2-1，然后淘汰index及之前的。先要看k是不是等于1，等于1则可以直接判断。 有效的括号：构件一个map和左括号list，用栈，为空或者为左括号则加入，为右括号则pop出来看是否匹配，最后返回栈是否为空。Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;()&#123;&#123;put(&#x27;)&#x27;, &#x27;(&#x27;);   List left = Arrays.asList(&#x27;(&#x27;, &#x27;&#123;&#x27;, &#x27;[&#x27;);  Deque stack = new ArrayDeque&lt;&gt;();   遍历string：char c : s.toCharArray() 字符串解码：重复次数可能是多位的，开始使用一个栈记录重复次数和字符串，有点乱。使用两个栈分别记录。使用两个栈：一个存重复次数，一个存之前的解码结果。注意3[a2[c]这种，左括号的时候进行压栈，右括号的时候pop栈，这时候需要重复的是currentStr，栈里pop出的是需要在前面的，重复完之后要更新currentStr。判断一个char为数字的两种办法：Character.isDigit()、c - &#x27;0&#x27;&lt;=9。 每日温度：一个数组表示温度，返回数组表示对于i天，下一个更高温度出现在几天后，如果不会升高则0。使用栈，纠结于如何记录结果，其实栈中存放的元素不是温度，而是索引。栈里的元素应该是从大到小的，遍历过程中，元素大于栈顶就pop。注意，栈里放的是索引，不是实际温度。 柱状图中最大的矩形：一个数组表示柱状图的高度，返回能勾勒出矩形的最大面积。思考暴力情况下如何解决：对每一个柱子，向左向右扩展，直到遇到比它矮的，那么以当前柱子高度为高的矩形的宽度就确认出来，这样再全局比较。所以，关键点在于找左边第一个比它小的位置和右边第一个比它小的位置。用单调栈，栈中依然保存索引。每当遇到一个比栈顶元素小的高度时，说明找到了栈顶元素的右边界；弹出栈顶元素，此时它的左边是前一个栈顶元素（即左边界）。注意，获取左边界时stack为空，则left=-1可以。还需要管最后一个元素的结果，所以for循环边界是heights.length，搞个最后的0作为哨兵节点。 数组中的第k个最大元素：使用最小堆，优先级队列。如果堆大小为k，则需要对比堆顶元素和当前元素哪个更大。其实不用，先插入，大于k则弹出堆顶元素即可。 前k个高频元素：先用Map记录频率，然后用小顶堆记录k个Map.Entry，表示键值对项，其他和k个最大元素一样。 买卖股票的最佳时机：贪心，遍历过程中记录历史最低点，同时记录最大收益。 跳跃游戏：判断是否能到达最后一个下标。遍历过程中记录最远能跳到哪里，如果当前索引小于maxReach则直接返回false。 跳跃游戏2：返回最少跳跃数。最少跳跃数，两种方法：一种用动态规划记录最少跳跃数，然后双层遍历外层遍历数组，内层遍历该位置跳跃范围。另一种是贪心，双层循环，外层while从后往前遍历能跳到的位置，内层从前往后找最少跳跃位置。前提是一定能跳到，不然会死循环，所以pos &gt; 0。 划分字母区间：同一个字母最多出现在一个片段中，返回表示每个字符串片段长度的列表。用一个map记录每个字符最后出现的位置，然后遍历字符串进行切分，记录start和end，遍历过程中更新end，如果i==end则表示可以切分。 爬楼梯：每次爬1或2阶，总共有多少种爬台阶的方法。动态规划，dp[n+1]，初始化0和1，然后遍历。 杨辉三角：动态规划，List创建时初始化：List list = Arrays.asList(&quot;apple&quot;)。List获取get(index). 打家劫舍：不能偷窃相邻的房屋，动态规划，dp[i]表示偷到i的最大收益，初始化前两个。 完全平方数：返回和为n的完全平方数的最少数量，可重复使用的。动态规划，一个一维数组初始化比较大的值。双层遍历，外层遍历1-n/2的平方数，内层遍历dp数组。如果大于平方数，则更新。 零钱兑换：给定一个可用零钱面值数组和总金额，返回需要的最少硬币数量，都是可重复使用的，思路和完全平方数一样。注意初始化用Integer.MAX_VALUE-1。 单词拆分：给一个字符串，一个字符串列表，判断能否用列表中的字符串拼接出该字符串，可重复使用。是背包问题。完全平方数是先遍历平方数，再遍历数。这里需要先遍历字符串再遍历物品列表。因为这里对物品顺序是有要求的。dp[i]表示以字符串i-1索引结尾的结果。// 检查以i-1结尾的字符往前倒的字符串，和wordDict[j]是不是一样。 最长递增子序列：子序列是顺序不能变，可以删掉部分元素组成。动态规划dp[i]表示以i结尾的最长递增子序列，双层遍历。 乘积最大子数组：得是连续的最大子数组。用动态规划，两维数组记录i-j的连续乘积，要双层遍历，感觉不是最优。正解：关键点：因为负数的存在，最大和最小可能一下反转。记录阶段最大值和阶段最小值（也就是以上一个数为尾部的最大值最小值）。因为负数存在，当遍历到负数时，最大数和最小数要做交换。遍历过程中记录最大的阶段最大值。 分割等和子集：给一个数组，能否分成两个和相等的子集，不要求连续。是一个背包问题，维护dp[i][j]，i表示考虑0-i的物品，j表示容量为j，dp值表示背包最大能放的重量。初始化i=0的时候，j为多少能放下改物品。不需要提前排序的。遍历时候双层循环，外层物品，内层重量。内层也得从1开始遍历。两种选择：一种不放这个，一种放这个。 最长有效括号：只包含()的字符串，找出最长有效的连续字串长度。用栈保存左括号的索引，初始化时，栈先压入 -1，表示“有效括号子串起点前的位置”。遇到右括号则弹出栈顶，如果弹出后栈空了，说明遇到不能配对的右括号，把当前位置下标入栈（新起点）。否则，当前有效括号长度为i - 栈顶下标，更新最大长度。这里记录不是遇到不有效再记录，而是每次遇到有效时记录。 不同路径：多维动态规划，简单。 最小路径和：依然多维路径规划，初始化左边和上边，直接在原数组上操作。 最长回文子串：多维数组表示i-j的子串是否是回文子串，推演关系决定遍历顺序，ij依赖i+1,j-1，所以从左下角开始遍历。如果ij字符相等，相差&lt;=1，或者dp[i+1][j-1]为true，则为回文，记录结果 最长公共子序列：两位数组表示text1的i-1结尾和text2的j-1结尾的最长公共子序列长度。注意字符不等于的时候，Math.max(dp[i - 1][j], dp[i][j - 1]). 编辑距离：插入、删除、替换。思路：二维动态数组，长度len1+1*len2+1，表示i-1结尾和j-1结尾的。为什么数组长度要+1，因为0的位置需要遍历，初始化不好初始化，只能用-1的初始化，初始化为对应的ij。状态转移：字符相等则等于dp[i-1][j-1]，不想等则删除：dp[i-1][j], dp[i][j-1]，修改：dp[i-1][j-1]，其中取最小然后+1。 只出现一次的数字：遍历，用map可以，但是最好的是用异或运算，^，相同异或为0，与0异或为自己。 多数元素：使用投票机制，记录一个结果数和一个数量，如果数量等于0则换数，否则看当前数是否等于结果数，决定投票+1/-1。 颜色分类：三色国旗问题，双指针，都从0开始遍历，一个指针用来换1，一个指针用来换0，但是换0需要注意，可能把1换出去了，所以换完0之后如果p0&lt;p1就得交换i和p1。 下一个排列：举个例子123654，124653，先要从后往前找到第一个升序的，然后从后往前找到第一个比升序对第一个数大的，然后交换，变成了124653，然后反转i+1到末尾这段。 </span><br></pre></td></tr></table></figure>

<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</span><br><span class="line">你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</span><br><span class="line">你可以按任意顺序返回答案。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, map.get(target - nums[i])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="## 字母异位词分组"></a>## 字母异位词分组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</span><br><span class="line">示例 1:</span><br><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用stream聚合strs</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = Arrays.stream(strs)</span><br><span class="line">                .collect(Collectors.groupingBy(str -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 对数组排序</span></span><br><span class="line">                    <span class="type">char</span>[] array = str.toCharArray();</span><br><span class="line">                    Arrays.sort(array);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">                &#125;));</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</span><br><span class="line">请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] != nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                maxLen = Math.max(maxLen, preLen);</span><br><span class="line">                preLen = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                preLen ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = Math.max(maxLen, preLen);</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</span><br><span class="line"></span><br><span class="line">例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</span><br><span class="line">整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</span><br><span class="line"></span><br><span class="line">例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。</span><br><span class="line">类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。</span><br><span class="line">而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</span><br><span class="line">给你一个整数数组 nums ，找出 nums 的下一个排列。</span><br><span class="line"></span><br><span class="line">必须 原地 修改，只允许使用额外常数空间。</span><br></pre></td></tr></table></figure>

<p><strong>纯找规律，举例：123654，从后往前找到第一个正向升序的，就是36，然后从后往前找第一个比3大的数，就是4，然后交换，交换之后反转i+1到末尾这段。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 举例：123654，纯找规律，从后往前找到第一个正向升序的，就是36，然后从后往前找第一个比3大的数，就是4，然后交换，交换之后反转i+1到末尾这段。</span></span><br><span class="line">        <span class="comment">// 1.找第一个正向升序的</span></span><br><span class="line">        <span class="comment">// 没有找到就不做第二步交换，比如321，得反转</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">record</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                record = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.从后向前找比record大的数</span></span><br><span class="line">        <span class="keyword">if</span> (record &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bigger</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[bigger] &lt;= nums[record] &amp;&amp; bigger &gt; record) &#123;</span><br><span class="line">                bigger --;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(record, bigger, nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.翻转record+1到末尾的</span></span><br><span class="line">        reverse(record + <span class="number">1</span>, nums.length - <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            swap(i, j, nums);</span><br><span class="line">            i ++;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a>寻找重复数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</span><br><span class="line">假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</span><br><span class="line">你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,3,4,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>不能用map、set，数组中如果没有重复的数，那就是一对一的关系，有重复的就是多个下标对应一个数的关系。和环形链表类似，使用快慢指针。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 衍生为环形链表问题，用快慢指针找到环的入口。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到相遇处</span></span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[nums[fast]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 慢指针从0出发，快指针从原地出发，都+1行走</span></span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>那些年背过的面试题</category>
      </categories>
      <tags>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年背过的面试题之Python</title>
    <url>/2025/08/10/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BPython/</url>
    <content><![CDATA[<h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><p>Django 是一个用 Python 编写的高级 Web 框架，倡导“开箱即用”和快速开发。它内置了 ORM（对象关系映射）、URL 路由、模板引擎、表单处理、用户认证和强大的后台管理（Admin）等核心功能，能有效处理 Web 开发中的常见任务。Django 遵循 **MVT（模型-视图-模板）**设计模式，结构清晰，代码复用性高。它注重安全性，能自动防范 CSRF、XSS 等常见攻击。凭借其完备的生态系统和严谨的设计，Django 非常适合构建数据驱动、安全可靠的中大型 Web 应用，让开发者更专注于业务逻辑的实现。</p>
<p><strong>使用 Django 开发的步骤</strong>：1. <strong>安装</strong>：<code>pip install django</code>。2. <strong>创建项目</strong>：<code>django-admin startproject mysite</code>，生成项目骨架。3. <strong>创建应用</strong>：<code>python manage.py startapp myapp</code>，Django 鼓励功能模块化。4. <strong>定义模型</strong>：在 <code>models.py</code> 中用 Python 类定义数据结构，Django ORM 映射到数据库。5. <strong>注册应用</strong>：将应用名添加到 <code>settings.py</code> 的 <code>INSTALLED_APPS</code> 中。6. <strong>设计 URL</strong>：在项目和应用中配置 <code>urls.py</code>，将 URL 路由到视图。7. <strong>编写视图</strong>：在 <code>views.py</code> 中处理请求并返回响应（如渲染模板）。8. <strong>创建模板</strong>：在 <code>templates</code> 目录下编写 HTML 模板。9. <strong>迁移数据库</strong>：<code>makemigrations</code> 生成迁移文件，<code>migrate</code> 同步模型到数据库。10. <strong>运行</strong>：<code>python manage.py runserver</code> 启动开发服务器。</p>
<p><strong>在Docker内运行</strong>：编写 <code>Dockerfile</code> 定义Python环境、安装依赖（包括Django）；创建 <code>docker-compose.yml</code> 配置Web服务和数据库（如PostgreSQL）；将代码复制到镜像；暴露端口（如8000）；使用 <code>docker-compose up</code> 构建并运行容器，Django应用即在隔离环境中启动。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>那些年背过的面试题</category>
      </categories>
      <tags>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>不那些年之开始刷LetCode题米</title>
    <url>/2025/08/10/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%B8%8D%E9%82%A3%E4%BA%9B%E5%B9%B4%E4%BA%86%E5%BC%80%E5%A7%8B%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p>动态规划，dp表示以当前数结尾的最大连续和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a>旋转链表</h2><p>旋转多少就是把后面多少节点搬到前面。注意k是链表长度整数倍时不需要动。1.先计算长度。2.取余。3.找新的尾节点。4.重新拼接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 本质：旋转多少就是把后面多少节点搬到前面。注意k是链表长度整数倍时不需要动。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 1.先计算长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (tail.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            len ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.取余</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> k % len;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// 3.找新的尾节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newTail</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len - n; i ++) &#123;</span><br><span class="line">            newTail = newTail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.重新拼接</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> newTail.next;</span><br><span class="line">        newTail.next = <span class="literal">null</span>;</span><br><span class="line">        tail.next = head;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><p>DFS深度优先搜索</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 用DFS深度优先搜索，三种情况：p和q在最近公共祖先的左右子树、p是公共祖先q是子节点、q是公共祖先p是子节点</span></span><br><span class="line">        <span class="comment">// 返回条件：到叶子节点/遇到了pq就不用往下了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == root || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">// 递归函数返回的是最近公共祖先的候选</span></span><br><span class="line">        <span class="comment">// 如果left和right都不空，证明是第一种情况，在左右子树，返回root</span></span><br><span class="line">        <span class="comment">// 如果其中一个为空，证明在当前root的一边，返回非空的</span></span><br><span class="line">        <span class="comment">// 都为null，就是遍历到叶子结点了，返回null</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != left &amp;&amp; <span class="literal">null</span> != right) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != left) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h2><p>想着用DFS，但是时间复杂度是O(2^n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;</span><br><span class="line">        <span class="comment">// 深度优先搜索+回溯</span></span><br><span class="line">        res = Integer.MAX_VALUE;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, triangle, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> layer, <span class="type">int</span> index, List&lt;List&lt;Integer&gt;&gt; triangle, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer == triangle.size()) &#123;</span><br><span class="line">            res = Math.min(res, sum);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(layer + <span class="number">1</span>, index, triangle, sum + triangle.get(layer).get(index));</span><br><span class="line">        dfs(layer + <span class="number">1</span>, index + <span class="number">1</span>, triangle, sum + triangle.get(layer).get(index));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用动态规划，并进行空间优化，时间复杂度是O(n^2)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;</span><br><span class="line">        <span class="comment">// 可以用动态规划，n行n列的dp数组表示，双层遍历状态转移，然后从根节点找最小的。</span></span><br><span class="line">        <span class="comment">// 动态规划可进行空间优化，只用两行的数组表示dp。</span></span><br><span class="line">        <span class="comment">// 用一行，行不行，状态转移index依赖index和index-1，所以从左到右遍历不行，得从右到左。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> triangle.size();</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">layer</span> <span class="operator">=</span> <span class="number">1</span>; layer &lt; n; layer ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> layer; index &gt;= <span class="number">0</span>; index --) &#123;</span><br><span class="line">                <span class="comment">// 注意边界，左边的只能index，右边的只能index-1，left表示从左边下来</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> index == layer? Integer.MAX_VALUE : dp[index] + triangle.get(layer).get(index);</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index == <span class="number">0</span>? Integer.MAX_VALUE : dp[index - <span class="number">1</span>] + triangle.get(layer).get(index);</span><br><span class="line">                dp[index] = Math.min(left, right);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Arrays.toString(dp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) res = Math.min(res, dp[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>那些年背过的面试题</category>
      </categories>
      <tags>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年背过的面试题之Spring</title>
    <url>/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BSpring/</url>
    <content><![CDATA[<h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><ul>
<li><p>Spring的架构：1⃣️控制反转IOC容器，负责管理对象的生命周期。2⃣️AOP面向切面编程，实现跨应用程序的共有关注点，代码前后做增强。3⃣️简化数据访问，如JDBC，提供一致的数据访问。4⃣️Web层，Spring MVC提供一个分离的模型-视图-控制器实现，用于构建Web应用。</p>
</li>
<li><p>spring bean的加载过程&#x2F;生命周期：1⃣️启动spring应用上下文。2⃣️加载bean定义：读取xml文件、java注解、java配置类，为每个声明的Bean创建一个BeanDefinition对象，包含bean的所有定义信息。 3⃣️实例化bean：调用构造函数、依赖注入、BeanPostProcessor 的前处理。4⃣️初始化bean：调用bean的初始化方法：@PostConstruct注解的方法、指定的init-method、InitializingBean的afterPropertiesSet方法。5⃣️使用bean。6⃣️销毁：容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy方法。</p>
</li>
<li><p>spring IOC：控制反转，通过spring来管理对象的创建、配置、生命周期，把控制权交给spring。提供BeanFactory和ApplicationContext两种IOC容器，实现对bean的管理。实现原理：依赖注入DI、Bean生命周期管理。</p>
</li>
<li><p>spring AOP：面向切面编程，一种编程范式，代码前后做增强操作，提高代码模块性。实现：基于动态代理，实现接口用JDK动态代理，否则CGLIB动态代理。@Aspect注解和@Around切入点实现切面。</p>
</li>
<li><p>JDK和CGLIB动态代理：JDK动态代理针对类实现某个接口，基于反射生成实现同样接口的代理类。CGLIB底层基于asm第三方框架，通过修改字节码生成一个子类。</p>
</li>
<li><p>Spring AOP和AspectJ AOP：Spring AOP 基于动态代理实现，只能在运行时织入，性能比AspectJ编译织入慢。AspectJ只支持编译前后和类加载时织入，性能更好，功能更加强大。</p>
</li>
<li><p>java反射：对于任何一个类，都能知道这个类所有的属性和方法；对于任何一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。getField(属性名字)和getDeclaredField（忽略访问控制）获取属性Field。getMethod获取方法Method。invoke执行。</p>
</li>
<li><p>BeanFactory和ApplicationContext：都是Spring中管理Bean的容器。BeanFactory是Spring IoC容器的基础接口，ApplicationContext实现BeanFactory，提供更丰富功能：国际化、事件发布、注解支持。BeanFactory 采用懒加载（延迟初始化）策略，只有在请求获取 Bean 时才会创建和初始化该 Bean。ApplicationContext采用即时加载策略，容器启动时会预先创建和初始化所有 Singleton Bean。</p>
</li>
<li><p>FactoryBean和BeanFactory：BeanFactory是IOC容器，负责生产和管理Bean对象：读取bean配置、加载bean、依赖注入、bean生命周期管理。FactoryBean是工厂Bean，可以实现该接口来自定义Bean的创建过程。重写getObject方法控制Bean的创建，getBean获取Bean实例。</p>
</li>
<li><p>Spring事务的传播机制：用来定义业务方法之间事务处理方式的机制，根据给定的事务规则来创建和控制事务的边界和范围，保证数据一致性。@Transactional注解的propagation属性指定。例如银行转账操作中有个审计方法，这个方法异常不想影响转账事务的回滚，就用REQUIRES_NEW创建新事务。一共有七种：1.REQUIRED：默认的，存在就加入该事务，没有事务就创建新的。2.REQUIRES_NEW：无论存不存在都创建新的。3.NOT_SUPPORTED：非事务方式执行，存在事务则挂起。4.SUPPORTS：存在则加入事务，不存在则非事务。5.NESTED：如果存在事务，则在嵌套事务（可独立提交，外部事务回滚它也得回滚）内执行。如果没有事务，则按REQUIRED属性执行。6.NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。7.MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p>
</li>
<li><p>@Autowired和@Resource：都是用来实现依赖注入的注解。@Autowired是spring的注解，默认根据类型注入，多个类型相同则进一步根据名称。如果按照类型匹配接口不同实现类需要结合@Qualifier。提供required属性允许找不到bean时是否抛出异常。@Resource是j2ee的注解，默认按byName自动注入，不能用于构造函数。</p>
</li>
<li><p>Spring核心注解：@SpringBootApplication：组合注解，用于启动Spring Boot应用，包含@Configuration、@EnableAutoConfiguration和@ComponentScan。@Component：标注一个类为需要Spring管理的bean。@Configuration：表明该类是用于定义Bean的配置类，配合@Bean来在容器中注册自定义的Bean，方法返回对象被容器管理。@Transactional：用于声明一个方法或类需要事务管理。</p>
</li>
<li><p>Spring依赖注入注解：@Autowired、@Qualifier、@Resource、@Value：注入普通类型的属性。</p>
</li>
<li><p>Spring组件扫描注解：@Service：用于Service层的组件。@Repository：用于DAO层的组件。@Controller：用于标记控制层组件。</p>
</li>
<li><p>spring bean生命周期：1.创建bean的实例，在堆中开辟一块内存空间给这个对象，生成实例对象。2.填充bean的成员属性。3.调用initializeBean方法初始化bean（调用@PostConstruct、实现Aware接口的方法、before…方法、init-method方法、afterPropertiesSet方法）。</p>
</li>
<li><p>spring的三级缓存：用来解决单例bean循环依赖问题，提前拿到未初始化完全的对象。第一级缓存：用来保存实例化、初始化都完成的对象。第二级缓存：用来保存实例化完成但是未初始化完成的对象。第三级缓存：保存创建早期bean的工厂ObjectFactory，getObject()创建一个对该bean的早期引用，这个引用可以被二级缓存使用，确保bean可以按需要的代理和增强创建出来。原理：实例化和初始化流程分开，在Bean完全初始化之前，可以暴露一个早期的bean引用，从而打破循环依赖。</p>
</li>
<li><p>二级缓存行不行：当涉及AOP或其他代理增强时，仅凭二级缓存不够，因为要在返回代理对象前确保执行所有增强的逻辑。所以，如果一个bean需要被代理，它首先应该通过三级缓存的ObjectFactory被创建，该工厂负责处理所有的代理相关逻辑。一旦经过这个步骤得到的bean被放入二级缓存中，它就可以被其他bean使用了。</p>
</li>
<li><p>spring解决循环依赖的具体流程：1.单例bean首先检查一级缓存，存在则直接返回。2.不存在则实例化对象，还未属性注入和初始化。3.创建好bean实例后，将ObjectFactory放入三级缓存。4.属性注入，请求创建依赖的bean，如果有循环依赖，通过三级缓存创建一个早期的bean引用，并放到二级缓存，同时删除三级缓存。5.完成注入及初始化，bean创建成功。6.bean放入一级缓存，并从二级和三级缓存中移除。</p>
</li>
<li><p>spring bean：根据作用域，Singleton：默认的作用域，整个容器中只有一个实例，适用于配置类、工具类、服务类。Prototype：原型bean，每次请求都会创建一个新的实例。spring容器仅负责实例化，不管生命周期。Request：每个HTTP请求都会创建一个Bean，仅适用于web应用。Session：每个HTTP Session都会创建一个Bean，仅适用于web应用。</p>
</li>
<li><p>@PostConstruct：Java EE 5引入的注解，在Bean的实例化和依赖注入完成后被自动调用。用来执行必要的初始化代码，例如资源分配，加载数据。通过容器来控制初始化。修饰无参数无返回值方法，每个类只能有一个该方法。InitializingBean接口的afterPropertiesSet和配置bean时的init-method也有类似功能。@PostConstruct先于他俩。</p>
</li>
<li><p>InitializingBean：接口，定义了afterPropertiesSet方法，这个方法会在bean的所有属性都设置好之后执行，用于在依赖注入后执行某些初始化操作。</p>
</li>
<li><p>ApplicationContextAware：用于方便获取ApplicationContext，spring会自动调用setApplicationContext(ApplicationContext applicationContext)方法，可将ApplicationContext实例注入到bean中，用于获取其他bean、访问资源文件、发布事件。</p>
</li>
<li><p>spring事务的实现原理：两种事务的实现方式：编程式（通过代码控制事务处理逻辑）、声明式（@Transactional注解实现）。事务的操作本由数据库自动控制，为方便业务逻辑操作，由spring框架控制。spring事务的实现原理是通过AOP实现，生成代理对象，代理会在方法执行前后织入事务管理的相关操作：事务开始，先把事务的自动提交给关闭、提交事务、异常回滚。可以设置事务的传播行为、隔离级别、超时设置。总之，Spring AOP 提供了声明式事务管理的基础，使得事务管理逻辑能够以切面的形式，织入到业务逻辑中。</p>
</li>
<li><p>a方法加了@Transactional，b方法没加，b内部调用a，会有事务产生吗：@Transactional声明式事务，事务的传播行为决定事务如何传播和边界所在。由于spring的事务管理是基于AOP，通过代理实现的，分两种情况：第一种，如果方法在同一个类中，自调用，a方法的调用不会通过spring生成的代理对象调用，不会开始新的事务。第二种，在不同的类中，a方法通过spring的代理对象调用，开始一个新事务。</p>
</li>
</ul>
<h2 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h2><ul>
<li>什么是springboot：基于spring的开源框架，用于快速创建独立的生产级别的可运行的Spring应用程序。不是Spring功能上的增强，而是提供一种快速开发Spring项目的方式。spring问题：写配置文件繁琐，依赖繁琐，maven坐标版本问题。springboot提供的优点：自动配置、起步依赖、安全。约定优于配置的理念，开发者不需要手动配置大量spring配置文件，而是自动配置。提供一系列的起步依赖starter，快速构建出一些常用的应用程序，整合Junit、redis、mybatis等很方便。帮助管理jar包版本，避免依赖版本不一致的问题。</li>
<li>Spring、Spring MVC和SpringBoot区别：Spring是Java开发框架，用于创建企业级的java应用程序，提供IOC和AOP等功能。Spring MVC是Spring框架的一个模块，用于创建Web应用程序，使用控制器、视图和模型来实现MVC设计模式。Spring Boot是一个基于Spring框架的快速开发工具，使用自动配置快速创建Spring应用程序。总结：Spring是基础框架，Spring MVC是基于Spring的Web框架，而Spring Boot则是基于Spring的快速开发框架。Spring Boot内嵌了Tomcat、Jetty等Web容器，可以直接运行Web应用程序，而Spring MVC需要部署到Web容器中才能运行。</li>
<li>springboot自动配置的原理：基于Spring的条件化配置功能实现，Condition接口和@Conditional注解。以及springboot的一系列自动配置类，Spring Boot应用的入口类会使用@SpringBootApplication注解，它包含@SpringBootConfiguration，@EnableAutoConfiguration和@ComponentScan注解，@EnableAutoConfiguration是自动配置的核心。@EnableAutoConfiguration利用Spring的@Import注解来加载配置类，META-INF&#x2F;spring.factories配置文件中定义了大量的配置类，springboot应用启动时会自动加载这些配置类。并且在配置类中使用Condition来加载满足条件的bean，如DataSource、JdbcTemplate等。（总结：1.条件注解 2.@EnableAutoConfiguration）</li>
<li>springboot核心注解：@SpringBootApplication：复合注解，标识springboot应用的主类。@Configuration表明该类是java配置类。@ EnableAutoConfiguration开启自动配置功能。@ComponentScan用于自动扫描和注册bean。</li>
<li>spring boot starter：是预配置的依赖管理器，将一组库&#x2F;依赖捆绑在一起，便于开发特定类型的应用程序。简化依赖管理，提供开箱即用的配置，是约定优于配置的应用，集成常用技术和库。spring-boot-starter-web：开发Web应用，包含Spring MVC、Tomcat容器等。spring-boot-starter-data-jpa：使用JPA的Starter，包含Hibernate、Spring Data JPA、Spring ORM等依赖。spring-boot-starter-data-redis：使用Redis的Starter，包含Jedis客户端和Spring Data Redis等依赖。spring-boot-starter-test：适用于测试的Starter，包含JUnit、Mockito、Spring Test等依赖。spring-boot-starter-actuator：监视器，适用于监控和管理Spring Boot应用程序的Starter，包含Spring Boot Actuator等依赖。</li>
<li>spring-boot-starter-parent：springboot官方提供的一个Maven父工程，是springboot项目的父工程，parent元素设置为它，继承一些常用依赖和插件，减少手动配置。统一管理springboot中的常用依赖版本号，确保版本兼容性。</li>
<li>如何自定义spring boot starter：在项目的src&#x2F;main&#x2F;resources目录下创建META-INF&#x2F;spring.factories文件，内容如下：org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;com.example.my_starter.MyAutoConfiguration，告诉springboot启动时自动加载配置类。创建MyAutoConfiguration配置类，并在类上加上@Configuration注解，在其中定义需要自动配置的Bean。然后打包上传Maven仓库。</li>
<li>spring-boot-maven-plugin：用于将SpringBoot应用，以及依赖项和配置文件打包成可执行的Jar包或War包，包含嵌入式的Tomcat容器或Jetty容器。方便部署和运行。</li>
<li>springboot打成的jar包和普通jar包区别：1⃣️springboot的jar包是可执行的jar包，包含了内嵌的Tomcat、Jetty等Web服务器，可直接运行。普通jar包纸包含类、资源等，需要在外部环境中手动配置Web服务器运行。2⃣️springboot打的jar包中包含了启动类的main方法，可直接运行。普通jar包需要指定启动类。3⃣️springboot的jar包中包含一些默认的配置文件，如application.properties，用于配置属性、数据源等。普通jar包不包含。</li>
<li>springboot实现热部署：使用Spring DevTools工具，支持应用程序代码修改后自动重新加载应用程序上下文和服务器。spring loaded也行，避免反复构建和部署。</li>
<li>springboot可以兼容老spring项目吗：可以使用@ImportResource注解来加载老的xml配置文件，用于@Configuration或@SpringBootApplication类上。</li>
</ul>
]]></content>
      <categories>
        <category>那些年背过的面试题</category>
      </categories>
      <tags>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年背过的面试题之redis&amp;mysql</title>
    <url>/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bredismysql/</url>
    <content><![CDATA[<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><ul>
<li><p>redis分布式锁原理：1⃣️setnx键不存在时设置，expire过期时间避免死锁。2⃣️看门狗机制，如果客户端仍在运行，自动续租锁。3⃣️自旋，尝试自旋固定时间。固定次数。4⃣️lua脚本用于执行复杂操作，并保证原子性。5⃣️redis分布式锁不完全可靠，主从复制，主节点同步到从节点之前崩溃，从节点升级，又获取到锁。</p>
</li>
<li><p>redis集群：1⃣️自动分片：数据划分为多个哈希槽，每个节点负责多个哈希槽。2⃣️无中心架构：节点对等，无中心节点。3⃣️主从复制：一个节点可以有多个从节点，实现故障恢复、数据冗余、读写分离。</p>
</li>
<li><p>redis两种同步策略：全量RDB文件、增量同步AOF</p>
</li>
<li><p>redis持久化：redis数据存在内存中，持久化机制将数据存储到磁盘文件。RDB快照是某个时间点数据的二进制全量备份。AOF日志是修改内存数据的指令记录。</p>
</li>
<li><p>redis的RDB：redis是单线程的，为了不阻塞请求响应，fork子线程进行快照持久化，持久化期间，两线程共享一份实体资源，只有在写操作发生时，共享的内存页会被复制，副本供写操作使用（写时复制），最小化对主进程影响。</p>
</li>
<li><p>redis的AOF：使用fsync命令将指令记录存入AOF文件，每1s执行一次</p>
</li>
<li><p>redis重启使用哪种持久化：都开启的话使用AOF持久化，因为包含更完整的操作历史记录。</p>
</li>
<li><p>redis哨兵机制：保证高可用，实现集群监控故障转移。多个sentinel节点。1⃣️监控：sential节点与其他master&#x2F;slave&#x2F;sentinel节点发送PING做心跳检测，交换信息监控主从拓扑。2⃣️主观客观下线：主观一台认为，客观大多数认为。3⃣️哨兵选举：sentinel选出一个leader做故障转移，raft算法，1.节点认为主管下线就申请成为leader，2.其他节点没有答应别人就答应他，3.票数达标就成为leader。4⃣️故障转移：根据从节点优先级选择新的master节点，sentinel leader向其他节点发送命令，并关注原master。</p>
</li>
<li><p>redis双写一致性：更新操作同时写入数据库和缓存，因为分布式系统中网络延迟、系统故障等原因，导致两者数据不一致，解决：1.先写数据库再删缓存：高并发可能会多次缓存穿透，增加数据库压力。2.先写数据库再更新缓存：不会缓存穿透，但是更新缓存操作需要并发控制防止竞争。更高级：消息队列保障顺序、分布式锁。</p>
</li>
<li><p>redis延时双删：在删除数据时，防止删除不能完全同步，首先删除数据库记录，再第一次删除缓存记录，延时短暂时间后，再删一次缓存。避免缓存网络抖动未删除。如果之间又写入，缓存穿透一次读到数据库。</p>
</li>
<li><p>redis缓存击穿：单个key访问并发过高，过期时请求直接打在DB上，数据库压力大。解决：加锁，缓存没有就对key加锁查库后更新缓存、将过期时间也写在value中，异步刷新过期时间、接口限流降级熔断。</p>
</li>
<li><p>redis缓存穿透：查询在缓存和DB不存在的数据时，都打到DB，就像缓存不存在。解决：在请求缓存前加布隆过滤器，筛掉一定不存在的数据。</p>
</li>
<li><p>redis缓存雪崩：大批量数据同时过期，大量请求直接打到DB。解决：缓存数据过期时间设置随机，热点数据均匀分布在不同缓存数据库。</p>
</li>
<li><p>布隆过滤器：快读判断一个元素是否在集合中，可能误判不会漏判。实现：长度m的位数组、k个哈希函数得到k个位置，将对应位置为1。查找时看是不是所有哈希函数得到的位都是1.</p>
</li>
<li><p>RDBMS和NoSQL：关系型数据库（组织化结构，行列格式）、Not only sql（数据存储没有固定格式，可横向扩展）。RDBMS：固定查询语言、事务一致性ACID。NoSQL：无固定查询语言、键值redis、列存储HBase、文档MongoDB、图形存储Neo4j、最终一致性BASE。</p>
</li>
<li><p>redis：远程字典服务，键值对，数据缓存在内存，周期性持久化到磁盘、主从同步、哨兵机制高可用。应用：高速缓存、计数器。</p>
</li>
<li><p>redis数据结构：1⃣️String：最大512M，实现：未使用C语言字符串，自己实现简单动态字符串SDS，带长度信息，embstr编码和raw编码，字符串修改时检查字符串长度避免缓冲区溢出，减少内存重新分配次数。2⃣️列表List：双向链表型数据结构，可两端插入弹出，可指定下标&#x2F;范围获取。实现消息队列、分页。实现：quikList，外层是双向链表linkedList，每个节点是zipList压缩列表，将多个元素序列化存储在一块连续内存中。3⃣️Set集合：不允许重复，没有顺序，支持多集合间并集交集差集操作。实现：如果元素都整数且数量较少，使用intset整数集合压缩数据结构。否则使用hashTable。4⃣️zset有序集合：给每个元素多设置一个分数，作为排序的依据。实现：hashTable存储元素到分数的映射，快速查询和更新分数。跳跃表skiplist维护元素的有序性，并提供高效范围查询。5⃣️hash：存储key-value记录。实现：当字段和值数量不多时，使用压缩列表zipList。否则使用哈希表hashtable，每项都包含指向键的指针和指向值的指针。</p>
</li>
<li><p>redis为什么快：1.完全基于内存 2.单线程无上下文切换成本 3.基于C语言，优化过的数据结构 4.基于非阻塞的IO多路复用和事件驱动模型，使用Seletor监视所有注册的通道，IO事件发生时进行通知。单线程高效处理大量并发连接。</p>
</li>
<li><p>redis6.0改用多线程：依然使用单线程处理客户端请求，只是多线程处理数据读写和协议解析。redis性能瓶颈在网络IO而非CPU。</p>
</li>
<li><p>redis热key问题：某个key大量并发打到一台服务器，达到网卡上线，宕机。缓存雪崩。解决：热key打散在不同服务器。提前加载热key到内存，内存做二级缓存。</p>
</li>
<li><p>redis设置过期时间：expire key seconds；set key value EX seconds；底层采用过期字典存储键的过期时间。</p>
</li>
<li><p>redis过期策略：1⃣️惰性删除：查询key时才对过期时间检测，已过期删除。2⃣️定期删除：定期执行过期键的扫描和删除，避免消耗过多计算资源，使用采样的过程随机抽取，如果过期的多就再抽样。3⃣️都没删除的：等redis内存淘汰机制。</p>
</li>
<li><p>redis内存淘汰：LRU最近最久未使用，淘汰最长时间没有访问的。链表&#x2F;哈希表+双向链表。redis中使用近似的LRU，随机抽取一些键，检查最后访问时间戳，淘汰最久未访问的。</p>
</li>
<li><p>redis高可用：主从架构、哨兵、持久化</p>
</li>
<li><p>redis事务：1⃣️事务是一组命令的集合，数据库事务通过ACID保证，undo log撤销日志。2⃣️redis中事务机制：通过MULTI、EXEC、WATCH 和 DISCARD 四个命令提供。MULTI开启事务，输入多个命令，不会立即执行而是放入一个队列，调用EXEC命令才会将队列中命令原子执行。3⃣️事务监控：WATCH命令设置监控的键，在事务操作之前就监控，如果EXEC之前键被其他客户端修改，则不执行DISCARD。是一种CAS乐观锁的机制。</p>
</li>
<li><p>redis操作一个命令最耗时的地方：网络IO延迟：尽可能使用长连接或连接池。数据持久化延迟：合理配置RDB快照和AOF Rewrite时机（每秒？每条指令？），避免频繁的fork带来的延迟。数据淘汰引发的延迟：避免同一时间大量key过期。</p>
</li>
</ul>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><ul>
<li><p>RDBMS和NoSQL：RDBMS关系型数据库（组织化结构，表格行列格式，Mysql、Oracle、PostgreSQL）、Not only sql非关系型数据库（数据存储没有固定格式，可横向扩展）。1⃣️数据结构：结构化与非结构化，键值redis、列存储HBase、文档MongoDB、图形存储Neo4j。2⃣️数据关联：sql中多张表可关联，nosql数据之间无关联。3⃣️查询语言：sql固定查询语言，nosql不固定查询语言。4⃣️事务一致性：sql提供强一致性和完整事务支持，nosql提供BASE基本可用、软状态、最终一致性。5⃣️存储方式：sql存在磁盘，nosql存在内存。6⃣️扩展性：sql垂直扩展，升级单个服务器的内存cpu存储空间。nosql可水平扩展，分布式存储。</p>
</li>
<li><p>数据库事务：一条&#x2F;多条语句组成，要么全部执行要么全部不执行的执行单元。1⃣️原子性：最小执行单元，操作失败时undo log来回滚。2⃣️一致性：事务执行前后数据保持一致。3⃣️隔离性：并发执行的事务之间不会互相干扰，MVCC、锁机制实现不同隔离级别。4⃣️持久性：事务一旦提交对数据库的修改是永久的，系统崩溃时使用redo日志来恢复。</p>
</li>
<li><p>redo日志和undo日志：1⃣️redo log：重做日志，保障持久性，系统崩溃时恢复数据。物理日志，记录数据页的物理修改操作。更新先写入redo log，再空闲时更新到磁盘，预写式技术减少IO频率。2⃣️undo log：撤销日志，保障原子性，回滚时恢复数据。逻辑日志，记录数据操作的逆向操作。还提供一致性读，即使数据被修改也能从undo log访问到修改前的数据。</p>
</li>
<li><p>事务的隔离级别：事务隔离级别定义了一个事务可能受其他事务影响的程度。1⃣️读未提交：可能脏读（读到其他事务未提交的修改）。2⃣️读已提交：不可重复度（事务内两次读到数据不一致）。3⃣️可重复度：默认的，幻读（可能读到第一次读没有的新纪录，行数不一致）。4⃣️串行化：事务串行执行，强制锁定事务访问的数据，锁竞争。（表级锁）</p>
</li>
<li><p>解决不可重复度：MVCC多版本并发控制，同一时刻不同事务读取到不同版本的数据。实现：隐藏列、undo log、版本链。每行数据多个隐藏列（版本号、删除时间、指向undo log的指针），undo log通过回滚指针把一个数据行所有快照连接起来形成一个版本链，使用事务版本号比较来控制数据版本。优点：避免加锁，允许读写操作并发执行。</p>
</li>
<li><p>mysql的锁：表锁、行锁（Innodb有，通过给索引项加锁实现，如果没有索引相当于表锁）。共享锁、排他锁。insert、update、delete操作innodb会自动给涉及到的数据加排他锁。select for update加排他锁。select lock in share mode加共享锁。</p>
</li>
<li><p>间隙锁：Innodb中的，用于锁定一个范围，不是固定的行数据。Innodb中可重复读及更高级别使用的锁机制。可以避免幻读，避免其他事务在该范围内插入。</p>
</li>
<li><p>意向锁：Innodb中的锁机制，用来事务获行锁之前表明锁定意图，分为意向共享锁和意向排他锁。意向锁是表级锁，获行锁之前先获取对应意向锁，不需要检查每行的锁状态，通过意向锁了解表的锁使用情况。意向共享锁不阻塞其他意向共享锁，意向排他锁不阻塞其他意向排他锁。意向共享锁（IS）或意向排他锁（IX）会阻塞整个表的排他锁。</p>
</li>
<li><p>快照读和当前读：快照读：执行普通的select查询，Innodb使用MVCC进行快照读，不加行锁，不会阻塞其他事务的读写操作，提供一致性的非阻塞读取。当前读：显式加锁select、update、delete，会对对应数据行加排他锁，获取数据的最新版本。</p>
</li>
<li><p>Innodp和Myisam：InnoDB支持事务处理、行级锁定和外键约束，适合于高并发和需要强数据完整性的应用。MyISAM拥有较高的读取速度和全文索引支持，但不支持事务处理，只有表级锁定。</p>
</li>
<li><p>Mysql索引：数据库表中一个特殊的数据结构，帮助提高数据检索速率。使用B树和B+树作为索引的数据结构。Innodb中主键索引使用聚簇索引，B+树叶子结点存储表的实际行数据。非主键索引使用B+树，叶子结点存储对应行主键而不是行数据本身。Myisam中都是非聚簇索引，B+树叶子结点存储行数据的指针。</p>
</li>
<li><p>Mysql索引缺点：空间成本、维护成本（数据插入删除更新时索引也需要更新，导致更新操作变慢）。索引通常以索引文件的形式存储在磁盘。</p>
</li>
<li><p>Mysql中有哪些索引：主键索引、唯一索引、普通索引、全文索引、空间索引、组合索引、外键索引</p>
</li>
<li><p>B树和B+树区别：都是多路搜索树，自平衡。B+树所有的值存储在叶子结点，并且形成有序链表，适合范围查询，内部节点存储键和指向叶子结点的指针。更胖更低，IO效率高。B树每个节点都存储键和值，对于点查询更为高效。</p>
</li>
<li><p>哈希索引：Memory存储引擎使用，基于内存。散列算法使用哈希表很快O(1)，适合等值比较查询，不适合范围查询。如果重复的键会哈希冲突。Innodb中自适应哈希索引。</p>
</li>
<li><p>红黑树：自平衡的二叉搜索树，节点要么红色要么黑色，根节点黑色，红节点的子节点都是黑色，叶子结点都是黑色空节点。通过旋转、重新着色来维持平衡。</p>
</li>
<li><p>聚簇索引和非聚簇索引：聚簇索引：数据存储和索引放在一块，索引结构的叶子结点保存了行数据（主键索引）、非聚簇索引：数据和索引分开，索引结构的叶子结点存储行数据的指针（辅助索引）。聚簇索引中，表中数据的物理顺序和索引顺序一致，所以一个表只能有一个聚簇索引。</p>
</li>
<li><p>最左前缀匹配：联合索引中，查询时使用的where子句中的条件必须包含联合索引中最左边的列索引才能生效，如果跳过或使用范围查询，则后面列不能有效使用索引。因为B+树是有序的。</p>
</li>
<li><p>sql语句执行过程：1.建立连接 2.mysql8.0查看是否开启缓存 3.解析器进行语法解析，生成解析树，检查语法正确 4.优化器生成执行计划，查看是否可优化。5.执行引擎执行sql。</p>
</li>
<li><p>数据库三范式：1.列不可分割 2.所有非主键字段都依赖于主键 3.所有非主键字段直接依赖于主键。</p>
</li>
<li><p>回表查询和覆盖索引：回表查询是普通索引，先定位主键，再定位行记录，扫描两遍索引树。覆盖索引是索引中包含了查询所需的所有字段，直接从索引中获取数据，不需要回表查询，减少磁盘IO。</p>
</li>
<li><p>explain：展示如何执行select语句：如何使用索引、表连接顺序、估计扫描行数。</p>
</li>
<li><p>数据库优化：1.建索引，where order by group by涉及的列建立索引。2.索引优化，最左匹配原则，不使用like “%abc”。3.建立分区，如时间字段4.利用缓存redis，缓存热数据5.查询限定数据范围，如查询一个月内的6.读写分离7.分库分表，垂直拆分水平拆分8.数据异构到es9.冷热数据分离10.升级OceanBase</p>
</li>
<li><p>无法使用索引：!&#x3D;、is null、or、&gt;&lt;、in、not in</p>
</li>
<li><p>mysql中char和varchar的区别：char是固定长度的字符串，即使存储数据短于设计长度，会用空格填充，所以可以快速查询。varchar可变长度的字符串，只占用必要空间加一个额外的长度字节，节省空间但影响查询性能。</p>
</li>
<li><p>delete和truncate：delete删除表时会增加大量undo日志和redo日志，truncate会立即删除表中所有数据，不能回滚，快速释放占用的空间。</p>
</li>
<li><p>mysql主从复制：主服务器将变更记录到二进制日志（binary log）文件，从服务器连接到主服务器后，请求从上次停止的位置开始传送日志，存到中继日志relay log，开线程重放。数据冗余、读写分离、高可用性。</p>
</li>
<li><p>主从复制的数据一致性问题：主从复制有延时，可能造成读到不一致的数据。根据数据复制到从服务器对主服务器事务提交的影响，分为：1.异步复制（写入二进制日志之后确认事务提交，从服务器落后于主服务器，不一致风险高）2.半同步复制（等待至少一个从服务器收到二进制日志，主服务器故障时可以找到这个从服务器成为主）3.同步复制（等待所有从服务器，较高的数据一致性）</p>
</li>
<li><p>mysql集群架构：1⃣️一主多从架构：写操作都主库，从库负责读。2⃣️多级复制架构：一主和多从之间增加一个master2主库，表都是空表，仅负责转发binlog。减轻主库负担。3⃣️双主架构：master1和master2互为主从。</p>
</li>
<li><p>mysql分库分表：将数据分散在多个数据库和表中。垂直拆分：按照表的列来进行拆分，将一个表分割成多个表。水平拆分：按照表的行进行拆分，用某个id做哈希取余进行分散。挑战：数据一致性、跨库或跨表的事务处理、数据迁移和重新分片等问题。解决：两阶段提交会锁定资源。XA协议。事务补偿。</p>
</li>
<li><p>跨库事务：tddl不支持跨库事务提交，强一致性需要使用切面事务实现。最终一致性可以用状态机+定时任务实现。</p>
</li>
<li><p>自增id：1.redis提供incr命令，单线程。2.雪花id：41位时间戳（毫秒，能用70年），10位机器标识，12位序列号。</p>
</li>
<li><p>分库分表之主键id：需要一个全局唯一的分布式id：1⃣️数据库自增长id，根据表的数量设置步长，但是不能扩表了。2⃣️redis incr&#x2F;incrby命令生成自增长id。数据存在内存，实例宕机可能丢数据。3⃣️uuid：本地生产不占用网络资源，缺点是太长，不具备有序性。适合用于编号。4⃣️雪花算法：有序增长，全局唯一。每秒可生成四百多万id。分三段：时间毫秒级、集群+机器id、序列号。可灵活分配比特位。缺点：强依赖机器时钟，可能导致发号重复。美团Leaf分布式id中，引入zookeeper，服务向zookeeper获取机器id，zookeeper检测时间是否正确。</p>
</li>
<li><p>mysql和Oracle的区别：1⃣️oracle数据库是一个重量级对象关系数据库管理系统（ORDBMS），收费的。mysql是一个轻量级开源的关系数据库管理系统（RDBMS），开源的免费的。2⃣️安全性上：oracle验证用户的参数有很多，有着较强的安全性，mysql验证用户的参数只有三个（用户名、密码、位置），安全性较弱。3⃣️对事务的支持：MySQL在innodb存储引擎的行级锁的情况下才可支持事务，而Oracle则完全支持事务。4⃣️mysql的诊断调优方法较少，主要有慢查询日志。Oracle有各种成熟的性能诊断调优工具。5⃣️并发性：mysql虽然InnoDB引擎的表可用行级锁，但行级锁机制依赖于表的索引，如果表没有索引，或者sql语句没有使用索引，将使用表级锁。Oracle使用行级锁，对资源锁定粒度更小，不依赖于索引。6⃣️应用：Oracle应用于大型复杂的企业级应用，性能、可伸缩性、可靠性更强大。mysql应用于中小型应用。</p>
</li>
<li><p>mysql当前读和快照读：1⃣️快照读是指读取数据不需要等待其他事务对数据锁的释放，通过MVCC允许读取数据的历史版本，提供一致性视图，实现了非阻塞的读。普通的select操作就是快照读，RR可重复读和RC读已提交下的select是快照读。2⃣️当前读：读取数据的最新版本，并对读取的数据加锁（行锁或间隙锁）。常用于需要修改数据的场景，例如update、delete、select for update。在串行化隔离级别下，即使普通select也是当前读。</p>
</li>
<li><p>索引优化：建立合适的联合索引，达到覆盖索引，尽量保持区分度高的在最左</p>
</li>
<li><p>mysql的delete文件大小不变：Innodb采用延迟空间回收，删除数据仅做标记，不立即回收磁盘空间，避免频繁磁盘操作。数据文件以数据页为单位组织。而且delete会记录redo和undo日志，消耗IO资源和存储空间。使用：Truncate table删除表的所有数据并初始化。drop重建表，删除后重建。</p>
</li>
<li><p>drop、delete、truncate：delete可回滚，会触发表上的触发器。truncate删除表中所有数据，不能回滚，更快，占用空间小。drop删除表，触发器不会触发。</p>
</li>
<li><p>适合&#x2F;不适合建立索引：适合：频繁使用的、用来缩小查询范围的、需要排列的。不适合：查询中很少涉及的、重复值比较多的、特殊的数据类型如text的。</p>
</li>
<li><p>mybatis是否支持延迟加载：延迟加载是用到数据时才进行加载，避免一次性加载大量关联数据，提高查询效率。配置文件中可以设置延迟加载，按需取材。底层使用CGLIB动态代理实现，创建目标对象的代理对象，目标对象是开启延迟加载的mapper所映射的实体类。通过字节码技术运行时生成代理类，调用目标方法时，进入拦截器的invoke方法，执行sql查询以获取关联数据，注入到对象属性中。</p>
</li>
</ul>
<h2 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h2><ul>
<li>Mybatis保证跨库数据一致性？：Mybatis是一个持久层框架，不直接提供跨库调用数据一致性的解决方案。需要借助外部分布式事务解决方案：分布式事务框架、两阶段提交、最终一致性、分布式事务中间件XA协议。</li>
</ul>
]]></content>
      <categories>
        <category>那些年背过的面试题</category>
      </categories>
      <tags>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年背过的面试题之java2024</title>
    <url>/2025/07/23/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bjava2024/</url>
    <content><![CDATA[<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><ul>
<li>jvm内存模型：线程共有：堆（对象实例和数组）、方法区（被虚拟机加载的类信息、方法信息、字段信息、常量、静态变量、即时编译器编译后的代码缓存）、直接内存（非运行时数据，IO操作）。线程私有：虚拟机栈（一个方法一个栈帧：局部变量表、操作数栈、动态链接、返回地址）、本地方法栈（native方法）、PC程序计数器（下一条指令位置的指针）</li>
<li>jmm内存模型：多线程环境下对共享变量的同步，保证多线程环境下的可见性、有序性。主内存和工作内存，可见性volatile线程更改了工作内存中的共享变量其他线程能够立马看到，有序性volatile禁止指令重排synchronized锁，原子性synchronized和CAS无锁的原子操作</li>
</ul>
<h2 id="锁、并发编程"><a href="#锁、并发编程" class="headerlink" title="锁、并发编程"></a>锁、并发编程</h2><ul>
<li><p>java有哪些锁：内置锁synchronized、重入锁ReentrantLock、读写锁ReadWriteLock、条件锁Condition</p>
</li>
<li><p>synchronized：内置锁，控制对共享资源访问的同步机制，修饰实例方法、静态方法、代码块，原理：对象头MarkWord，记录hashCode、锁标志、GC年龄。修饰代码块monitorenter和monitorexist字节码指令。修饰方法flags指令，锁的计数器。锁升级：无锁、偏向锁（记录线程指针）、轻量级锁（CAS自旋）、重量级锁（阻塞线程）</p>
</li>
<li><p>volatile：轻量级的synchronized，保证共享变量的可见性，读写操作直接对主内存进行，不会引起线程上下文的切换和调度。禁止指令重排。lock前缀指令，相当于内存屏障。保证原子操作线程安全。非原子操作不保证，用AtomicInteger、CAS。</p>
</li>
<li><p>CAS：无锁的原子操作，用来在并发编程中实现无锁同步。非阻塞的，减少锁开销。ABA问题，导致自旋，消耗CPU，只能一个变量的原子操作。</p>
</li>
<li><p>ReentrantLock：可重入的互斥锁，可重入、API层面锁、可响应中断、可公平不公平、Condition分离对象的等待集合。原理：队列同步器AQS，中volatile变量state记录锁的状态和重入次数，CAS操作更新状态变量和加入等待队列和更新队列头节点，FIFO队列管理等待锁的线程。</p>
</li>
<li><p>Condition：条件锁，与ReentrantLock结合使用，更精细控制等待唤醒，有选择地唤醒等待中的线程。</p>
</li>
<li><p>公平锁和非公平锁：公平锁所有线程都会被阻塞，非公平锁获锁之前不管等待队列，减少唤醒线程上下文切换开销。</p>
</li>
<li><p>RentrantLock如何实现公平非公平：子类 <code>FairSync</code> 和 <code>NonfairSync</code>。默认非公平锁，线程尝试直接获取锁，不考虑等待队列中的顺序。新到来的线程如果此时锁恰好可用，则可以直接获取锁，减少了上下文切换，提高了吞吐量。公平锁中，获取锁时会检查同步队列（AQS 队列）中是否有比当前线程等待时间更长的线程。如果有，则当前线程必须等待；如果没有其他线程或自己是队列中最前面的，则可以尝试获取锁。这样保证了最先进入等待状态的线程优先获得锁，遵循先来先服务的原则。</p>
</li>
<li><p>信号量Semaphore：控制对有限资源访问的计数器，实现资源池，控制并发数。permit为1时互斥锁。</p>
</li>
<li><p>闭锁CountDownLatch：用于等待一组线程都完成之后才继续操作，不可重用。</p>
</li>
<li><p>栅栏CyclicBarrier：一组线程互相等待都达到某个屏障点再继续执行，可重用。</p>
</li>
<li><p>读写锁ReadWriteLock：可同时读，写操作互斥，原理AQS，状态变量按位切割记录多个线程状态。锁降级：在释放写锁之前先获取读锁，避免在释放写锁和获取读锁之间其他线程修改变量，保证可见性。因为同一线程，所以允许获取读锁。</p>
</li>
<li><p>AQS：AbstractQueuedSynchronizer队列同步器，基于FIFO等待队列的同步框架，volatile和CAS实现同步状态管理，内置FIFO队列实现线程排队等待机制。构建各种阻塞性质的同步器。</p>
</li>
<li><p>锁优化：1.减小锁粒度：大锁变为不同的小锁来减少锁竞争提高并发，例如ConcurrentHashMap的分段锁。2.锁分离：读写分离ReadWriteLock读锁共享写锁独占。3.锁消除：不必要的不加锁，减少锁持有时间。4.锁粗化：短时间重复获取同一锁，将锁范围扩大，减少锁开销。5.使用无锁数据结构：CopyOnWriteArrayList，atomic下的原子类，volatile+cas，实现无锁的线程安全操作。</p>
</li>
<li><p>CopyOnWriteArrayList：线程安全的ArrayList。写时复制。读取的时候在当前数组进行，修改的时候，复制当前列表，在新列表上修改，然后将原列表引用指向新的列表。这个更新操作是原子性的，使用volatile 变量来存储底层数组的引用，写操作在读操作之前完成。</p>
</li>
<li><p>悲观锁和乐观锁：悲观锁认为冲突普遍存在，阻止并发访问保证一致性。乐观锁通过数据版本号来检测冲突，冲突之后撤销或重试。</p>
</li>
<li><p>死锁：多线程互相持有和等待对方的资源，形成循环等待。互斥条件、请求与保持条件、不可剥夺条件、循环等待条件。CAS破坏互斥条件，银行家算法分配资源之前先检查是否会死锁，破坏循环等待。</p>
</li>
<li><p>线程池：管理一系列线程的资源池，避免线程频繁创建销毁开销，提高响应速度。1.ThreadPoolExecutor构造函数创建（核心线程数、最大线程数、阻塞队列、最大线程存活时间、threadFactory、饱和策略）2.Executors工具类创建（不推荐，使用无界阻塞队列OOM，CachedThreadPool使用同步队列创建线程数无限制OOM）</p>
</li>
<li><p>线程池饱和策略：AbortPolicy抛出异常来拒绝、CallerRunsPolicy调用线程中运行、DiscardPolicy直接丢弃、DiscardOldestPolicy丢弃最早未处理的。</p>
</li>
<li><p>线程池阻塞队列：ArrayBlockingQueue基于数组结构的有界阻塞队列FIFO、LinkedBlockingQueue基于链表的无界阻塞队列、SynchronousQueue同步队列无容量、DelayQueue延迟无界阻塞队列，延迟期满时从队列取出、PriorityBlockingQueue支持优先级排序的无界阻塞队列。</p>
</li>
<li><p>线程池处理顺序：核心线程、任务队列、最大线程、饱和策略</p>
</li>
<li><p>ThreadPoolExecutor的execute和submit：1.execute是Executor方法，submit是ExecutorService方法。2.execute只接收Runnable，出现异常原地抛出。submit接收Runnable和Callable，返回Future，捕获异常在future.get方法中抛出。</p>
</li>
<li><p>happens-before：向程序员提供跨线程的内存可见性保证。volatile规则：对一个volatile的写happens - before后续对这个volatile的读。监视器规则：对一个锁的解锁happens - before随后对这个锁的加锁。线程生命周期规则：start、join。</p>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li>Thread的run方法和start方法：1.new一个Thread，调用start方法，表示启动一个线程，进入就绪状态，等待分配到时间片后运行。是多线程工作。2.直接执行run方法不会以多线程方式执行。</li>
<li>创建线程方式：1⃣️继承Thread类，重写run方法，创建对象调用start方法。2⃣️实现Runnable接口，重写run方法，创建对象作为参数传递给Thread的构造方法，调用start。或者传递给线程池的submit&#x2F;execute方法。3⃣️实现Callable接口，重写call方法，有返回，创建FutureTask对象，callable对象作为参数传递给FutureTask构造函数。将FutureTask对象作为参数传递给Thread构造函数，调用start。执行futureTask.get()方法获取线程执行的结果。</li>
<li>Runnable和Thread：1⃣️java单继承，Thread类有局限性。Thread类实现了Runnable接口。2⃣️Runnable更容易可以实现多个线程间的资源共享，提交给Thread同一个Runnable对象，共享其中的private对象。（只是共享，线程安全要加同步）。多个thread对象共享static变量。</li>
<li>Runnable和Callable：1.方法签名不同，Runnable是run方法，Callable是call方法。2.返回值类型不同，Runnable无返回，Callable的call方法返回指定类型结果，通过Future接口获取执行结果。3.异常处理不同：Runnable异常原地抛出，Callable的call方法通过Future.get方法来捕获异常信息。</li>
<li>线程状态：创建、就绪、运行、阻塞、等待、定时等待、终止。1⃣️start方法后等待JVM调度，就绪。调度到之后是运行。2⃣️运行到就绪：Thread.yield方法使线程从运行状态变为就绪状态，让出CPU资源给其他线程执行。3⃣️阻塞状态：线程运行过程中，发出I&#x2F;O请求时，该线程进入阻塞状态。当线程运行过程中尝试获取同步锁时，却被另一个线程获取，此时JVM把当前线程存到对象的锁池中，该线程进入阻塞状态。4⃣️阻塞到运行：获取到锁。5⃣️运行到等待：调用o.wait()方法和thread.join()方法（表示等待调用join方法的线程结束，当前线程才继续执行），进入等待状态。6⃣️定时等待：Thread.sleep方法进入等待状态，不释放锁。o.wait方法进入等待状态，释放同步锁，wait方法需要在同步方法&#x2F;代码块中。7⃣️notify方法唤醒在此对象监视器上等待的单个线程，进入就绪状态。</li>
<li>进程和线程：进程是操作系统资源分配的基本单元。线程是处理器任务调度和执行的基本单元。多个线程共享进程的堆和方法区，不共享栈和程序计数器。</li>
<li>ThreadLocal：是线程局部变量，线程私有，实现线程之间的数据隔离，避免使用共享变量的线程安全问题。注意在线程池中，线程被复用，需要及时清理，避免内存泄漏。</li>
<li>ThreadLocal和ThreadLocalMap的关系：ThreadLocalMap是ThreadLocal的内部数据结构，每个Thread对象有一个ThreadLocalMap对象，用于存储线程局部变量的键值对，键是ThreadLoca对象，值是ThreadLocal对象存的局部变量。每个线程可以有多个ThreadLocal对象。</li>
<li>ThreadLocal为什么内存泄露：每个线程的ThreadLocalMap，key是ThreadLocal对象（弱引用），value是存入的值（强引用）。ThreadLocal对象作为key是弱引用，外部强引用消失后，GC直接回收，但value还被强引用锁死。线程池中的线程反复利用，ThreadLocalMap跟着长寿。Map里的废弃物品（null key + value）越积越多，直到OOM。不调用set&#x2F;get&#x2F;remove，ThreadLocalMap不会自动清理null key的Entry。</li>
<li>ThreadLocal为什么不用强引用：用强引用→ThreadLocal对象永不回收，泄漏更严重！弱引用至少能回收key，给程序员一个补救机会。所以，用完必须要remove。线程结束会自动清理，但是线程池中的线程永不结束。</li>
<li>ThreadLocalMap如何清理：当一个线程终止时，该线程的 <code>ThreadLocalMap</code> 会随着线程对象一起被垃圾回收器自动清理。在 <code>set(T value)</code> 和 <code>get()</code> 操作中，如果发现某个 <code>Entry</code> 的 <code>key</code> 已经为 <code>null</code>（即 <code>ThreadLocal</code> 被垃圾回收了），那么这个 <code>Entry</code> 会被从 <code>ThreadLocalMap</code> 中移除。对于长时间运行的线程或线程池中的线程，如果不主动清除不再需要的 <code>ThreadLocal</code> 变量，可能会导致内存泄漏，因为 <code>ThreadLocalMap</code> 中的值是强引用类型的，即使对应的 <code>ThreadLocal</code> 实例已经被垃圾回收了（<code>ThreadLocalMap</code> 的键为弱引用），只要线程还在运行，这些值就不会被释放。线程池中，在finally中使用<code>threadLocal.remove();</code>手动清理。</li>
</ul>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><ul>
<li>SPI：service provider interface，服务加载机制，META-INF中配置接口和实现，ServiceLoader运行时发现和加载实现，可动态替换服务实现。提供可扩展的方式，使得第三方服务可以提供新的实现或自定义功能，解耦接口和服务实现。应用：JDBC驱动加载，日志框架选择。</li>
</ul>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><ul>
<li>IO：涉及到数据的存储、交换，都用IO，文件IO、网络IO</li>
<li>BIO：同步阻塞IO，每来一个新连接就需要创建一个线程，数据的读取写入都需要阻塞在线程中。浪费线程资源，不适合单机过多连接。</li>
<li>NIO：同步非阻塞IO，线程发起IO操作，如果数据还没准备好，可立即返回执行其他任务。数据写入读取不再阻塞，但是需要等待IO操作完成，可同时处理多个Socket请求。适用连接多且比较短的。</li>
<li>NIO多路复用：背景：应用程序询问数据是否就绪需要系统调用。因此为了解决频繁系统调用，一次向内核传递多个需要询问的Socket是否就绪（Seletor）。select、poll实现多路复用的机制，监控多个网络连接的IO事件，poll没有最大连接数限制。epoll提供了更高效的事件通知机制，在内核态开辟了两个集合，空间换时间，不需要每次传入整个Socket集合，减少拷贝，不需要主动地对所有文件描述符进行轮询。（单线程监控多个网络通道，轮询通道是否准备好，epoll通道准备好时得到通知）</li>
<li>epoll：1⃣️epoll_create:在内核申请一块内存区域用于存储需要监控的fd，红黑树存储。2⃣️epoll_ctl:将需要监控的fd添加到创建的集合中。3⃣️epoll_wait:调用epoll_wait以等待事件发生，这个调用会阻塞直到有事件发生，或者超时。返回就绪的fd集合，链表存储。开发者只需要遍历这个列表并处理每个事件。</li>
<li>IO多路复用的多线程版本：一个线程监听新连接的接入。若干个线程负责多个Socket的读写。</li>
<li>AIO：异步非阻塞IO，jdk1.7升级，发起IO请求后立即继续执行后续代码，不需要等待IO操作完成。完成通过回调事件通知来告知调用者。windows中操作系统实现，Linux中使用自建线程池实现。</li>
<li>Socket；网络通信基本概念，两程序连接进行数据交换</li>
<li>Channel：能进行读写操作的IO通道。</li>
<li>Selector：可以监视多个Channel的IO事件。Channel注册在Selector上，允许单线程管理多个网络连接。</li>
<li>FD：Linux中一切皆文件。无论文件、Socket、设备文件。File Descriptor文件描述符，看作文件的id。进程级别的资源句柄，提供访问文件的抽象层。</li>
<li>Linux系统分三层：User、Kernel、Hardware</li>
<li>用户态和内核态：内核态是控制计算机硬件资源，例如协调CPU分配内存空间。用户态是提供应用程序运行的空间。内核提供的一组通用的访问内核管理资源的接口是系统调用。系统调用需要内核态和用户态的切换，涉及到CPU中断、堆栈切换、寄存器保存。</li>
</ul>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><ul>
<li><p>死亡对象判断方法：1.引用计数法：给对象加一个引用计数器，被引用+1，引用失效-1，无法解决循环引用问题。2.可达性分析法：GC Root作为起始点，从它们向下搜索，走过的路径叫做引用链，一个对象与所有GC Root都不相连，需要被回收。</p>
</li>
<li><p>可达性分析中的两次标记：可达性分析中不可达的对象，并不是非死不可，而是缓刑，需要两次标记。一次标记筛选是否需要执行finalize方法，需要进入下一次标记。第二次标记查看对象finalize方法中对象是否被其他存活的对象引用，如果是那么该对象将变成可达的。finalize用来做外部资源清理，被try finally取代。</p>
</li>
<li><p>垃圾收集算法：1⃣️标记清除：标记要回收的对象，然后统一回收。会产生不连续的内存碎片。2⃣️标记复制：young使用，内存分为两块儿，一块儿使用完后，将存活的复制到另一块儿，然后清除。内存压缩一半，复制效率低。3⃣️标记整理：old使用，把存活对象向一端移动，然后清除边界外的内存。解决不连续内存碎片，但是移动存活对象并更新引用负担大。停顿时间长。4⃣️分代：新生代：每次存活对象较少，复制操作少，用标记复制，新生代分为较大的eden和两个较小的survivor，每次使用eden和一块儿survivor，回收时将存活对象复制到另一块儿survivor。回收时不用中断应用程序执行，避免碎片化问题。老年代存活率较高，没有额外空间分配担保，选用标记清除&#x2F;标记整理。</p>
</li>
<li><p>eden、survivor、old分配顺序：对象优先在eden区分配，大对象和长期存活的对象进入老年代。一次minor gc之后存活在survivor中的对象1岁，此后每在survivor中熬过一次minor gc就+1岁，达到阈值或一半超过同一年龄就晋升老年代。</p>
</li>
<li><p>空间分配担保：在minor gc之前，虚拟机检查老年代的最大可用连续空间是否大于新生代所有对象总空间，如果成立，minor gc安全。如果不成立，看虚拟机是否允许担保失败，允许的话检查之前历次晋升老年代对象的平均大小，如果大于则尝试minor gc。如果小于或不允许担保失败直接full gc。</p>
</li>
<li><p>几个gc：1⃣️minor gc：也叫young gc，在新生代空间不足时触发。2⃣️major gc：老年代空间不足时触发，通常涉及整个堆的回收。CMS中不会停止所有线程。3⃣️full gc：停止应用程序执行，整个堆和方法区的垃圾收集。老年代不足、元空间不足、显示调用System.gc、担保失败。</p>
</li>
<li><p>垃圾收集器CMS：Concurrent Mark Sweep，jdk8的，关注最短垃圾回收停顿时间，老年代使用多线程的标记清除算法。第一次实现垃圾收集与用户线程同时工作，第一款真正意义上的并发收集器。新生代使用标记复制ParNew 垃圾收集器，Serial收集器的多线程版本。1⃣️初始标记：暂停所有其他线程，标记所有直接与GC Roots相连的对象，速度很快。2⃣️并发标记：从根对象开始，遍历对象图，标记所有存活的对象。3⃣️重新标记：修正并发标记期间发生变动的对象引用，停顿。4⃣️并发清除：对未标记的对象进行清除。优点：并发、低停顿。缺点：对CPU资源敏感、无法处理浮动垃圾、产生内存碎片。</p>
</li>
<li><p>垃圾收集器G1：Garbage-First，jdk9的，精准控制停顿时间，G1整体来看是标记整理，局部来看是标记复制。保留分代的概念，把堆分为若干固定大小的region，每个region扮演eden、survivor、old，维护优先级列表，每次根据允许的收集时间，优先选择垃圾最多的区域回收。不再固定收集某个区域，而是灵活组成回收集。1⃣️初始标记：暂停工作线程，标记从GC Roots直接可达的对象。2⃣️并发标记：遍历对象图，标记所有存活的对象。3⃣️最终标记：修正在并发标记阶段由于应用程序继续运行导致标记信息变化的部分。4⃣️筛选回收：制定回收计划，构成回收集，把存活对象复制到空的region中，再清理旧的region。涉及到存活对象移动，需要暂停工作线程。这里多条收集器线程并行完成。</p>
</li>
<li><p>CMS和G1：1.专注不同：CMS专注于并发清除低延迟，只需处理老年代到新生代的引用，会内存碎片。G1指定最大停顿时间，分Region的内存布局，按收益动态确定回收集，不会产生内存碎片。2.小内存CMS占优，大内存G1占优，分界线6-8G。3.CMS分配大对象空间不足时full gc，G1期望停顿时间设置很小，垃圾回收赶不上分配时full gc。</p>
</li>
<li><p>垃圾收集器ZGC：jdk11的，低延迟垃圾收集。基于Region内存布局，不设分代，使用读屏障、染色指针，实现并发标记整理。着色笔：在对象头中增加额外内存，加快标记过程。读屏障：解决垃圾回收和应用程序同时进行时，应用程序读取到被回收的对象。在对象头部增加标识位表示对象是否正在被垃圾收集器访问。</p>
</li>
<li><p>java对象引用：1.强引用：传统的引用，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。2.软引用：用于维护一些可有可无的对象。只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。3.弱引用：拥有更短的生命周期，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。4.虚引用：一种形同虚设的引用，它主要用来跟踪对象被垃圾回收的活动。</p>
</li>
<li><p>jvm调优从哪里入手：1⃣️堆内存设置，-Xms设置初始堆大小，-Xmx设置最大堆大小，过小导致频繁的垃圾回收和OOM，过大导致长时间的垃圾回收停顿。2⃣️垃圾收集器选择，串行、并行、CMS、G1回收器，衡量指标：内存占用、吞吐量、延迟。监控GC活动：使用监控工具：jstat、VisualVM、YourKit和GC日志。3⃣️线程堆栈大小：-Xss调整，影响栈深度。4⃣️调优代码、调整元空间的大小，排查内存泄漏风险、系统级优化（CPU、内存、磁盘IO）。</p>
</li>
</ul>
<h2 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h2><ul>
<li>jvm排查线程cpu问题：1.ps -ef|grep java 或者 jps 查找出进程id。2.top -Hp 进程id 查找出最耗cpu的线程id。 top -c看进程的。3.printf “%x\n” 线程id ，转换为16进制的id。4.使用jstack 进程id | grep 16进制线程id 查找出堆栈信息，分析。另外，arthas也可以打印出前多少个线程及占有cpu情况thread -n 5。</li>
<li>jvm性能监控工具：1⃣️jps：输出jvm中运行的进程状态信息。2⃣️jstack：生成 Java 进程的线程堆栈信息，用于分析线程状态和死锁等问题。jstack 进程id | grep 16进制线程id。3⃣️jstat：JVM统计监测工具，排查gc，jstat -gc 进程id 250 4。4⃣️jmap和jhat：生成 Java 内存快照，分析内存使用和内存泄漏。用jmap把进程内存使用情况dump到文件中，再用jhat分析查看。</li>
<li>机器慢了怎么排查：CPU、内存、磁盘、磁盘IO、网络IO。</li>
<li>排查工具：1.df -h查看磁盘使用情况。2.free -h &#x2F; vmstat显示系统内存使用情况。3.mpstat命令查看cpu使用情况，输出各种cpu时间百分比。4.netstat -s查看网络状态，显示各种网络协议的统计信息，接收发送数据包数等。5.iostat -x查看IO统计信息。6.top命令实时显示Linux系统中进程的动态运行信息，包括CPU和内存的使用情况。top -Hp $pid用于显示特定进程的线程信息。</li>
<li>OOM排查：除了程序计数器，其他内存存储都可能OOM。原因：1.内存泄漏：程序未能释放不再使用的内存。2.Java堆分配空间不足导致内存溢出。排查：使用jmap -dump命令dump文件，在内存分析工具如VisualVM、MAT中观察对象引用关系、对象数量大小。可能未正确释放资源、关闭文件流、断开网络连接、销毁对象引用。定位到代码排查。</li>
<li>jvm调优：分配jvm内存需要考虑应用需求，是否处理大量数据。考虑垃圾收集器。16g机器将JVM最大堆内存设置为12G（Xms12G -Xmx12G），使用G1垃圾收集器。元空间存储类的元数据，设置初始值256M，最大值512M。线程堆栈大小，几百KB到1MB，取决于有没有深层递归（-Xss256k）。</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li><p>ArrayList和LinkedList：ArrayList基于动态数组，连续内存，适合遍历和查找元素，不适合增删，增删创建新数组。LinkedList基于双向链表，适合增删，不适合随机查找。</p>
</li>
<li><p>HashSet和TreeSet：HashSet底层基于HashMap。TreeSet基于红黑树，元素处于排序状态，支持有序集合操作。</p>
</li>
<li><p>队列：Queue接口是FIFO队列，Deque扩展Queue是双端队列接口。ArrayDeque是Deque的实现，双端队列。LinkedList也是Deque的实现，可以做双端队列。Stack栈，继承自Vector。Vector是同步集合，使用synchronized。</p>
</li>
<li><p>HashMap：数组+链表+红黑树。链表长度&gt;8数组长度&gt;64时变红黑树。链表解决哈希冲突，bucket。键和值都允许为空。</p>
</li>
<li><p>HashMap为什么使用红黑树：哈希函数质量不高&#x2F;存储大量数据，链表变长，影响搜索效率。所以jdk8之后，链表长度超过8时，链表变红黑树，自平衡的二叉查找树，搜索元素时间复杂度O(logn)，提高搜索效率。</p>
</li>
<li><p>HashMap扩容底层数组为什么扩为两倍保持2的幂次：1.方便利用位运算替代取模运算来计算元素索引位置。2.减少冲突：二进制位增加一位，只看最高位要么移动要么不变，确保分布均匀。 </p>
</li>
<li><p>ConcurrentHashMap：线程安全的HashMap，jdk7使用分段锁，分16段，一段一把锁。jdk8使用synchronized和CAS保证线程安全。</p>
</li>
<li><p>如何提高链表查询效率：1.使用双向链表。2.使用跳表，在链表上增加多级索引。3.元素存到哈希表进行映射。</p>
</li>
<li><p>B+树：索引数据记录在叶子结点，形成有序链表，方便范围查询。极端退化形成链表。具有更低的树高，降低磁盘寻址次数，减少IO次数。</p>
</li>
<li><p>跳表：skip list，分层结构多级链表，随机化的数据结构，用于存储有序元素。提供对数时间复杂度。每一层都是下一层的快照，只包含部分元素，每层元素通过指针相连。查找先从顶层查找，从而快速跨越多个不必要元素。应用：redis中zset使用hash+跳表。</p>
</li>
<li><p>大顶堆小顶堆：基于完全二叉树（除最底层外每一层都是满的，最底层从左向右填充），层序遍历用数组表示，用来实现优先队列。大顶堆中父节点大于子节点，根节点最大，同层没有顺序。</p>
</li>
<li><p>LRU：最近最久未使用。实现：1.链表，头部是要淘汰的，每次页面访问将页面移动到链表尾部。2.哈希表+双向链表，哈希表用来快速查找页面对应的链表节点。3.时间戳：每个页面分配时间戳，被访问时更新时间戳。</p>
</li>
<li><p>操作系统的页面淘汰算法：1.FIFO先进先出，使用队列。2.LFU最不常用，使用计数器跟踪每个页面访问次数，每次淘汰访问次数最少的，不考虑时间局部性。3.LRU最近最久未使用。4.时钟算法clock，LRU近似实现，维护循环列表。</p>
</li>
<li><p>八种基本数据类型及封装类：byte有符号整数（8bit，-128-127）、short有符号16bit整数、int有符号32bit整数、long有符号64bit整数、float32bit单精度浮点数、double64bit双精度浮点数、char16bit的unicode字符、boolean</p>
</li>
<li><p>装箱和拆箱：装箱：基本数据类型自动转换为对应封装类对象（编译器转换为Integer.valueOf）。拆箱：封装类对象自动转换为基本数据类型（编译器转换为o.intValue()）。</p>
</li>
<li><p>String、StringBuilder、StringBuffer：1⃣️String是不可变的，每次修改都是创建一个新的对象，性能较低。2⃣️StringBuilder可变，内部维护一个自动扩容的字符串数组，不是线程安全的。3⃣️StringBuffer可变，线程安全的，synchronized。</p>
</li>
<li><p>String不可变的设计原理：1⃣️内部使用私有的final字符数组存储字符串数据，创建之后引用不会指向另一个数组。2⃣️虽然数组本身可变，但是String没有提供方法修改数组内容。3⃣️虚拟机维护字符串池，相同内容的字符串可共享同一内存地址。创建时首先检查字符串池是否有相同内容字符串对象，有则返回引用。</p>
</li>
<li><p>String不可变的好处：1⃣️安全性：防止被恶意修改导致的安全漏洞。2⃣️线程安全：String对象本身线程安全。指向String对象的引用变量不是。3⃣️实现字符串常量池成为可能，重用字符串，节省内存开销。4⃣️创建字符串的哈希码缓存：字符串不可变，哈希码也不会变，适合作为键使用在哈希表中HashMap。</p>
</li>
<li><p>HashMap和TreeMap：HashMap基于哈希表，使用哈希函数提供O1的快速访问，不保证元素顺序。数组+链表&#x2F;红黑树。TreeMap基于红黑树，键值对按照键的自然顺序或指定比较器顺序Ologn复杂度排序。两者都是非线程安全的。</p>
</li>
<li><p>反射怎么创建对象：1⃣️Class的newInstance方法为无参构造器的类创建：Class&lt;?&gt; clazz &#x3D; Class.forName(“com.Demo”); Object o &#x3D; clazz.newInstance(); 2⃣️先获取Constructor，再newInstance。可以获取指定构造参数的构造器。3⃣️私有方法，可以constructor.setAccessible(true); 来设置可访问。</p>
</li>
<li><p>ArrayList 和 LinkedList怎么线程安全：1⃣️使用Collections.synchronizedList(list)将任何List转换为线程安全的List。（所有操作都使用相同的对象锁进行同步）。2⃣️使用显式的同步块，每次访问操作时加相同的锁。3⃣️使用concurrent包中的并发集合，CopyOnWriteArrayList，写时复制，适用于遍历操作远多于修改操作。ConcurrentHashMap、ConcurrentLinkedQueue。</p>
</li>
<li><p>java.util.concurrent包下有哪些：1⃣️Executor：线程调度框架：任务Runnable，Callable、任务执行ExecutorService，ThreadPoolExecutor ScheduledThreadPoolExecutor、异步计算结果Future，FutureTask。2⃣️同步器：CountDownLatch，CyclicBarrier，Semaphore。3⃣️并发集合：ConcurrentHashMap，ConcurrentLinkedQueue，CopyOnWriteArrayList，CopyOnWriteArraySet，以及支持阻塞的线程安全队列ArrayBlockingQueue等。4⃣️原子变量AtomicInteger等。5⃣️锁Lock：ReentrantLock，ReadWriteLock。</p>
</li>
<li><p>重写 <code>equals()</code> 时必须重写 <code>hashCode()</code>：是为了保证 <strong>相等的对象必须有相同的哈希码</strong>，这是 Java 的约定。否则在使用 <code>HashMap</code>、<code>HashSet</code> 等哈希结构时，会导致对象无法正确存取或比较，引发逻辑错误。</p>
</li>
</ul>
<h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><ul>
<li>java异常体系：一个以Throwable类为根的类层次结构，两个分支：1⃣️Error和Exception。Error错误代表了JVM无法预期或难以恢复的严重问题，比如OOM、StackOverflowError、线程死锁等，一般无需捕捉。Exception异常包括：2⃣️Checked Exceptions受检异常，又叫编译时异常，在编写可能会抛出它们的方法时需要显式地进行处理（通过try-catch块）或声明（通过throws关键字），这些异常通常是外部错误，如文件未找到（FileNotFoundException）、网络问题（IOException）、SQL异常等。3⃣️Unchecked Exceptions非受检异常，又叫运行时异常，包括RuntimeException及其子类，不需要显示处理或声明，通常是程序错误，例如数组越界、空指针。</li>
</ul>
<h2 id="变量修饰"><a href="#变量修饰" class="headerlink" title="变量修饰"></a>变量修饰</h2><ul>
<li><p>static：静态</p>
<ul>
<li>应用于变量：静态变量或类变量，变量属于类而不是对象，所有该类的对象共享同一个静态变量。</li>
<li>应用于方法：静态方法，表示该方法属于类，可以不依赖于对象实例被调用。只能访问static变量和方法。</li>
<li>定义静态代码块：在类被加载到JVM时仅执行一次，常用于初始化静态变量。</li>
<li>应用于类：只能用来修饰内部类，可以不依赖于外部类的实例被创建和使用，可以访问外部类的所有静态成员和静态方法。</li>
</ul>
</li>
<li><p>final：常量，用于创建不可变对象、防止方法或类被更改</p>
<ul>
<li>修饰变量：表示该变量一旦被初始化后就不能被修改，对于基本数据类型，变量的值不能改变，对于引用类型，变量不能再指向另一个对象，但所指向的对象内容本身可以变化。</li>
<li>当final应用于方法时，该方法不能被子类覆盖（重写）。</li>
<li>当final应用于类时，它表明该类不能被继承。</li>
</ul>
</li>
<li><p>类加载机制：运行时动态加载，类加载器（ClassLoader）负责将类的字节码Class文件从不同的来源（例如文件系统、网络等）加载到Java虚拟机中。1⃣️加载阶段：类加载器读取二进制数据（.class文件）并生成对应的java.lang.Class对象。2⃣️验证：确保加载的类的字节码是合法的，检查字节码的格式、语法、数据流、符号引用等。3⃣️准备：为类变量分配内存并初始化为默认值，方法区中分配。4⃣️解析：将常量池内的符号引用转换为直接引用的过程。5⃣️初始化：执行静态变量的赋值操作和静态代码块内的代码。</p>
</li>
<li><p>符号引用和直接引用：符号引用就是一组符号来描述所引用的目标，直接引用就是直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。</p>
</li>
<li><p>java编译阶段和运行阶段：编译阶段是源代码（.java文件）被编译器转换成字节码（.class文件）的过程，由Java编译器（ javac）负责。运行阶段是将.class 文件加载到JVM并执行的过程。类加载在运行阶段，支持运行时绑定（或晚期绑定），是Java动态链接和多态的基础。</p>
</li>
<li><p>常量池：运行时常量池位于方法区。它是类文件中每个类或接口的常量池表的运行时表示，用于存储编译器生成的字面量和符号引用。字符串常量池最初位于方法区，在Java 7以后被移到堆内存。它是一种特殊的常量池，用于存储字符串字面量和引用，目的是避免重复创建相同内容的字符串对象，以节省内存和提升性能。</p>
</li>
<li><p>双亲委派模型：JVM中的双亲委派是一种类加载机制，通过一层一层的父子关系将类的加载工作委派给上层的ClassLoader。这种机制的目的是为了避免类的重复加载，保证类的加载安全和类的共享。</p>
</li>
<li><p>想加载两个全路径相同的类：1.使用不具有父子关系的类加载器。2.打破双亲委派模型，自定义类加载器，并重写 loadClass() 方法，改变类加载的委派逻辑。</p>
</li>
<li><p>java接口中可以有非抽象方法吗：非抽象方法即具体实现的方法，java8之前只能包含抽象方法。java8引入了默认方法和静态方法。默认方法：default修饰。静态方法：static修饰，可以通过接口名直接调用。java9还提供了private私有方法。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>那些年背过的面试题</category>
      </categories>
      <tags>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年背过的面试题之java2025</title>
    <url>/2025/07/27/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bjava2025/</url>
    <content><![CDATA[<h2 id="Reactor响应式编程和Reactor线程模型"><a href="#Reactor响应式编程和Reactor线程模型" class="headerlink" title="Reactor响应式编程和Reactor线程模型"></a>Reactor响应式编程和Reactor线程模型</h2><p>Reactor 是一个响应式编程库，提供了非阻塞、高效的异步数据流处理能力。Project Reactor应用于Spring生态系统（Spring WebFlux），用于处理 HTTP 请求和响应的异步流式数据。</p>
<p><strong>特点</strong>：<br>非阻塞：通过事件驱动的方式处理数据流，避免线程阻塞。<br>背压支持：允许消费者控制生产者的速率，防止资源过载。<br>高效性：适合高并发场景，能够更好地利用系统资源。<br>函数式风格：提供丰富的操作符，可以通过链式调用对数据流进行转换和处理。</p>
<p><strong>适用场景</strong>：响应式系统（如 Spring WebFlux）、数据流处理（如实时日志分析、事件流处理）。</p>
<p>Reactor 提供了<strong>两个核心类</strong>：<br>Flux：表示可以发射 0到N个元素 的异步数据流。<br>Mono：表示可以发射 0或1个元素 的异步数据流。<br>Flux 是 Reactor 中的一个核心类，用于表示可以发射多个元素的异步数据流。发射 0到N个元素，并最终以完成或错误信号结束。Flux 提供了丰富的操作符，可以轻松地对数据流进行转换、过滤、合并和错误处理。<br>——————————————————————<br>Reactor线程模型：一种经典的IO多路复用设计模式，用于高效处理大量并发连接。核心思想是通过一个或多个线程监听 I&#x2F;O 事件（如读写就绪），并将这些事件分发给相应的处理器进行处理。</p>
<p><strong>特点</strong>：<br>事件驱动：通过监听 I&#x2F;O 事件（如 select、poll 或 epoll）来避免阻塞等待。<br>单线程或多线程模型：单线程 Reactor 模型：所有事件由一个线程处理。多线程 Reactor 模型：使用多个线程来处理事件，适合高并发场景。<br>非阻塞 I&#x2F;O：避免因等待 I&#x2F;O 操作完成而阻塞线程，从而提高吞吐量。</p>
<p><strong>典型实现</strong>：Java NIO、Netty 等框架基于 Reactor 模型构建。</p>
<p><strong>核心组件</strong>：<br>Acceptor：负责接收新的连接请求，并将其注册到事件监听器中。<br>Dispatcher：负责监听 I&#x2F;O 事件并分发给对应的处理器。<br>Handler：处理具体的业务逻辑。</p>
<p><strong>适用场景</strong>：高并发网络服务（如 Web 服务器、消息队列等）、需要高效处理大量短连接或长连接的场景。<br>——————————————————————<br>Project Reactor和Reactor线程模型的联系：<br>**Project Reactor 提供了更高层次的抽象，专注于业务逻辑的响应式处理，而 Reactor线程模型则更关注底层 I&#x2F;O 事件的分发，处理网络层IO。**都是非阻塞的，都是事件驱动的。</p>
<h2 id="record关键字"><a href="#record关键字" class="headerlink" title="record关键字"></a>record关键字</h2><p>record：一种用于<strong>定义不可变数据载体类</strong>的特殊类形式，是 Java 14 引入的一个关键字，正式在 Java 16 标准化。</p>
<p>record 是<strong>一种简化数据类的语法，目的是存储数据而不对这些数据进行复杂的操作或修改的场景。自动生成了包括构造函数，getter、toString、equals、hashCode 等方法。</strong></p>
<p>它是一种不可变（Immutable）的类，所有字段都是 final，创建后状态不能更改。</p>
<p><strong>用法</strong>：<br>1、作为独立的类文件<br><code>public record Film(String name, String desc) &#123;&#125;</code></p>
<p>2、嵌套在其他类中，类似静态内部类<br><code>public static record Film</code></p>
<p>3、方法内部<br>从 Java 16 开始，record 可以被定义为局部类（即在方法内部定义）。这种用法适合<strong>仅在某个方法中使用的临时数据结构</strong>。直接record Film</p>
<p>PS：静态内部类和非静态内部类：静态内部类不依赖于外部类的实例，可以直接通过外部类名访问。只能访问外部类的静态成员。非静态内部类依赖于外部类的实例，必须通过外部类的实例来创建。可以访问外部类的所有成员，因为内部类持有一个对外部类实例的隐式引用。</p>
<h2 id="线上redis机器爆了，如何优化"><a href="#线上redis机器爆了，如何优化" class="headerlink" title="线上redis机器爆了，如何优化"></a>线上redis机器爆了，如何优化</h2><p>如果在生产环境中发现 Redis 出现异常，比如内存爆了或者响应变慢，首先通过 Redis 的 INFO 命令（<strong>redis-cli info</strong>）和监控平台查看当前的资源使用情况，确认是<strong>内存、CPU、连接数还是某个慢查询</strong>引起的。</p>
<p>如果是** Big Key **（存储的数据体积很大，如一个Hash包含上万个字段）或者热 Key 造成的，我会进行数据结构优化、拆分 Key、引入本地缓存；如果是连接数过高，我会检查连接池配置，适当增加连接池大小或引入连接复用。</p>
<p>如果是 QPS 过高导致 Redis 成为瓶颈，我会考虑引入<strong>Redis 集群、读写分离、或者对热点数据进行缓存</strong>。</p>
<p>此外，我也会加强缓存的<strong>失效策略</strong>、防止缓存穿透和击穿，并结合布隆过滤器等手段保护后端数据库。</p>
<h2 id="spring声明式事务-Transactional"><a href="#spring声明式事务-Transactional" class="headerlink" title="spring声明式事务@Transactional"></a>spring声明式事务@Transactional</h2><p>在Spring中事务管理的方式有两种，编程式事务和声明式事务。编程式事务将业务代码和事务代码耦合到一块，当发生异常的时候还得需要手动回滚事务，不优雅。</p>
<p>声明式事务：<strong>基于AOP，设置好切点，当我们调用事务方法时，会调用到生成的代理对象，代理对象中加入了事务提交和回滚的逻辑。当方法执行成功时提交事务，当方法发生异常时回滚事务。</strong></p>
<p>@Transactional可以用在类，方法，接口上：</p>
<ol>
<li>用在类上，该类的所有public方法都具有事务</li>
<li>用在方法上，方法具有事务。当类和方法同时配置事务的时候，方法的属性会覆盖类的属性</li>
<li>用在接口上，一般不建议这样使用，因为只有基于接口的代理会生效，如果Spring AOP使用cglib来实现动态代理，会导致事务失效（因为注解不能被继承）</li>
</ol>
<p><strong>@Transactional失效的场景</strong></p>
<ol>
<li>@Transactional注解应用到非public方法（除非特殊配置，例如使用AspectJ 静态织入实现 AOP）</li>
<li>自调用，因为@Transactional是基于动态代理实现的，自调用时，方法执行不会经过代理对象</li>
<li>异常在代码中被你自己try catch了，不抛异常进入不了回滚的逻辑</li>
<li>异常类型不正确，默认只支持RuntimeException和Error，不支持检查异常，如果抛出任何异常都回滚，可以配置rollbackFor为Exception</li>
<li>事务传播配置不符合业务逻辑</li>
</ol>
<p><strong>为什么只有public方法上的@Transactional注解才会生效？</strong></p>
<p>首先JDK动态代理肯定只能是public，因为接口的权限修饰符只能是public。cglib代理的方式是可以代理protected方法的（private不行，子类访问不了父类的private方法）如果支持protected，可能会造成当切换代理的实现方式时表现不同，增大出现bug的可能性，所以统一一下。</p>
<p>Transactional的事务传播行为默认为Propagation.REQUIRED。<strong>「如果当前存在事务，则加入该事务。如果当前没有事务，则创建一个新的事务」</strong></p>
<p>Propagation.REQUIRES_NEW**「创建一个新事务，如果当前存在事务，则把当前事务挂起」**</p>
<h2 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h2><ul>
<li><p><strong>继承类不同</strong>：HashTable继承Dictionary类，HashMap继承AbstractMap类</p>
</li>
<li><p><strong>线程安全级别不同</strong>：HashTable是线程安全的类，每个public方法都有Synchronized修饰，HashMap不是线程安全的</p>
</li>
<li><p><strong>是否允许null的要求不同</strong>：HashTable：key不允许为null，value不允许为null。HashMap：key允许为null，value允许为null。</p>
</li>
<li><p><strong>底层数据结构不同</strong>：在JDK1.8以后，HashMap的底层数据结构改成了数组+链表+红黑树的实现，在链表的节点大于TREEIFY_THRESHOLD&#x3D;8时，链表转为红黑树，在树节点小于UNTREEIFY_THRESHOLD&#x3D;6时，红黑树转变为链表。（之所以有8和6两个阈值是为了避免某个链表在临界点频繁插入删除，导致转换频繁降低性能）。而Hashtable的底层实现就是数组+链表，而没有红黑树，因此各种操作都要简单很多。</p>
</li>
<li><p><strong>容量和扩容不同</strong>：Hashtable的容量是直接使用用户输入的容量initialCapacity。HashMap在用户输入的基础上，强制将容量转换为大于输入容量的最小2的幂次方数值。扩容方面，<code>HashMap</code> 自动扩容为 2 的幂，利于位运算提升性能，而 <code>Hashtable</code> 扩容为原容量的 2 倍加 1。</p>
</li>
<li><p><strong>索引计算上</strong>，<code>HashMap</code> 使用 <code>hash &amp; (length - 1)</code>，比 <code>Hashtable</code> 的取模运算更高效。</p>
</li>
<li><p><code>HashMap</code> 的迭代器为 fail-fast 类型，当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出并行修改异常，但迭代器本身的remove()方法移除元素则不会抛出。而 <code>Hashtable</code> 的 <code>Enumerator</code> 不是。</p>
</li>
</ul>
<h2 id="什么是零拷贝"><a href="#什么是零拷贝" class="headerlink" title="什么是零拷贝"></a>什么是零拷贝</h2><p>零拷贝（Zero-Copy）是一种高效的I&#x2F;O操作技术，旨在<strong>减少数据在内核空间与用户空间之间不必要的复制</strong>，从而提升数据传输性能。传统I&#x2F;O操作中，数据通常需从磁盘读取到内核缓冲区，再复制到用户缓冲区，处理后再写回内核缓冲区并发送到网络，涉及多次上下文切换和数据拷贝。零拷贝通过系统调用（如Linux的<code>sendfile</code>、<code>splice</code>或<code>mmap</code>），让<strong>数据直接在内核内部从文件系统缓冲区传输到网络协议栈</strong>，避免了用户空间的中转。这不仅<strong>减少了CPU的拷贝开销，也降低了上下文切换次数</strong>，显著提高了大文件传输、网络服务等场景的效率，是高性能系统设计中的关键技术。</p>
<p>例如Netty：使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝，避免了 JVM 堆内存与系统内存之间的数据拷贝。Netty的Zero-copy完全是在用户态（Java应用层）的，偏向于优化数据操作。OS层面的Zero-copy通常是避免在用户态和内核态之间的拷贝数据。</p>
<p>例如RocketMQ：在消息存储与传输过程中，RocketMQ 利用零拷贝技术优化消息的发送性能。当消费者拉取消息时，通过 <code>mmap</code> 将消息文件映射到内存，或使用 <code>transferTo</code> 调用实现数据从文件通道直接传输到网络通道，避免内核与用户空间的多次拷贝。这不仅减少了内存占用，也加快了消息传输速度，支持高吞吐量的消息处理。</p>
<h2 id="Redis字典的实现方式和冲突处理"><a href="#Redis字典的实现方式和冲突处理" class="headerlink" title="Redis字典的实现方式和冲突处理"></a>Redis字典的实现方式和冲突处理</h2><p>Redis字典基于哈希表实现，其核心结构是一个数组，每个元素是指向<code>dictEntry</code>链表的指针。每个<code>dictEntry</code>存储键值对及下一个节点的指针，通过**链地址法（拉链法）**处理哈希冲突：当多个键映射到同一槽位时，它们被链接在同一链表中。</p>
<p>Redis使用MurmurHash2算法计算键的哈希值，再通过<code>hash &amp; (size-1)</code>确定索引位置，确保分布均匀。</p>
<p>为应对数据增长，Redis支持动态扩容与缩容。当负载因子过高（如超过1）或过低时，会触发rehash。Redis采用<strong>渐进式rehash</strong>机制：分配新哈希表，每次访问字典时顺带迁移部分数据，直至全部完成。这避免了集中迁移带来的性能阻塞。也就是说，Redis字典内部维护两个哈希表（ht[0]和ht[1]），在rehash期间两者并存，查找、删除操作会兼顾访问两个表，确保数据一致性。插入操作仅作用于ht[1]。rehash完成后，ht[1]成为主表，ht[0]被清空。 </p>
<p>此外，Redis在哈希表扩容时，新表大小为大于当前容量的最小2的幂，确保位运算高效定位。</p>
<h2 id="介绍MVC机制"><a href="#介绍MVC机制" class="headerlink" title="介绍MVC机制"></a>介绍MVC机制</h2><p>MVC（Model-View-Controller，模型-视图-控制器）是一种软件架构模式，用于分离应用程序的逻辑与界面。</p>
<p>模型（Model）代表数据和业务逻辑，处理核心的数据管理和规则定义，并在数据发生变化时通知视图（View）。</p>
<p>视图（View）负责展示信息给用户，它从模型获取数据显示给用户，但不直接与模型交互，而是通过控制器（Controller）。</p>
<p>控制器接收用户的输入，解释这些输入并将它们转换为对模型或视图的操作命令，如更新数据或请求视图刷新。</p>
<p>这种分离使得代码更加模块化、易于维护和扩展，特别适合于开发复杂用户界面的应用程序，同时提高了灵活性和可重用性。MVC广泛应用于Web应用框架中，如Django（<strong>一个高级的Python Web框架，遵循模型-模板-视图（Model-Template-View, MTV）架构模式，模型（Model）定义数据结构；模板（Template）控制页面展示逻辑；视图（View）则是业务逻辑层，决定了哪些数据被呈现。</strong>）、Ruby on Rails等。</p>
<h2 id="Flink和Spark的区别"><a href="#Flink和Spark的区别" class="headerlink" title="Flink和Spark的区别"></a>Flink和Spark的区别</h2><p>Apache Flink 和 Apache Spark 都是分布式计算框架，Flink流处理，Spark批处理。</p>
<p>处理模型</p>
<ul>
<li><strong>Flink</strong> 主要支持流处理，并以流处理为基础扩展到批处理。这意味着它首先被设计用于实时数据处理，能够提供低延迟的数据处理能力，适用于需要即时响应的应用场景。</li>
<li><strong>Spark</strong> 最初是作为一个批处理框架而设计的，后来通过Spark Streaming增加了对流处理的支持。Spark Streaming采用微批处理的方式（mini-batch），即把流数据按时间窗口分割成一系列小批次来处理，这使得它的延迟比Flink稍高一些。</li>
</ul>
<p>吞吐量</p>
<p>关于吞吐量，两者都有很高的处理效率，但在不同场景下表现各异：</p>
<ul>
<li><strong>Flink</strong> 由于其原生的流处理架构，在处理持续不断的数据流时具有更高的吞吐量和更低的延迟。对于要求严格实时性的应用，比如欺诈检测、在线推荐系统等，Flink通常是更好的选择。</li>
<li><strong>Spark</strong> 在批处理任务上表现出色，尤其是在处理大规模静态数据集时。尽管Spark Streaming可以通过增加批次大小来提高吞吐量，但这样做会增加处理延迟。因此，对于那些可以容忍一定延迟的大规模数据分析任务，Spark可能更为合适。</li>
</ul>
<h2 id="介绍JVM"><a href="#介绍JVM" class="headerlink" title="介绍JVM"></a>介绍JVM</h2><p>JVM（Java虚拟机）是运行Java应用程序的虚拟机，它使得Java程序具有“一次编写，到处运行”的能力。JVM的主要任务是将编写的Java字节码（.class文件）转换成本地计算机的机器码并执行。通过提供一个跨平台的运行环境，JVM隐藏了底层操作系统的差异，确保了Java程序可以在任何安装有相应JVM的设备上运行。</p>
<p>JVM包含类加载器、运行时数据区（包括方法区、堆、栈等）、执行引擎等关键组件。类加载器负责加载程序所需的类文件；运行时数据区为程序执行提供内存空间；执行引擎则负责解释或即时编译字节码为机器码执行。此外，JVM还包含了垃圾回收机制，自动管理内存，释放不再使用的对象所占用的空间。JVM不仅支持Java语言，还支持其他可以编译成Java字节码的语言，如Kotlin和Scala。</p>
<h2 id="JVM调优经验"><a href="#JVM调优经验" class="headerlink" title="JVM调优经验"></a>JVM调优经验</h2><p>主要目标是优化内存使用、减少GC停顿时间以及提高系统吞吐量。</p>
<ol>
<li><strong>合理设置堆大小</strong>：根据应用的实际需求和服务器资源，合理配置<code>-Xms</code>（初始堆大小）和<code>-Xmx</code>（最大堆大小），避免频繁的GC。通常建议将初始堆和最大堆设置为相同值，以减少动态扩展带来的开销。16G机器设置12G。</li>
<li><strong>选择合适的垃圾回收器</strong>：<ul>
<li>对于低延迟要求的应用，可以选择G1或ZGC等低延迟回收器。</li>
<li>对于高吞吐量要求的批处理任务，可以使用CMS并发清除。</li>
</ul>
</li>
<li><strong>监控与分析GC日志</strong>：通过启用GC日志，结合工具如<code>GCViewer</code>或<code>GCEasy</code>分析GC行为，识别是否存在频繁的Full GC或长时间的停顿。jstat监控GC。</li>
<li><strong>优化新生代比例</strong>：通过<code>-XX:NewRatio</code>和<code>-XX:SurvivorRatio</code>调整新生代与老年代的比例，确保大多数对象在Minor GC中被回收，减少晋升到老年代的对象数量。</li>
<li><strong>合理使用元空间</strong>：JDK 8以后，永久代被元空间取代，使用本地内存存储类信息。可通过<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>控制其大小，防止因加载过多类导致内存溢出。</li>
<li><strong>线程栈大小调整</strong>：对于线程数较多的应用，适当减小<code>-Xss</code>（线程栈大小）可节省内存，但需确保不会导致栈溢出。</li>
</ol>
<h2 id="JVM的堆分为哪几部分"><a href="#JVM的堆分为哪几部分" class="headerlink" title="JVM的堆分为哪几部分"></a>JVM的堆分为哪几部分</h2><p>JVM的堆是内存管理的核心区域，用于存放对象实例，主要分为三部分：</p>
<ol>
<li><strong>新生代（Young Generation）</strong>：新创建的对象首先分配在此。它又分为Eden区、From Survivor区和To Survivor区。大多数对象在Eden区分配，经过几次垃圾回收后仍存活的对象将被移到Survivor区。</li>
<li><strong>老年代（Old Generation）</strong>：存放从新生代晋升过来的长期存活对象。当对象经历多次GC未被回收，或占用空间较大时，会被移入老年代。</li>
<li><strong>永久代&#x2F;元空间（PermGen&#x2F;Metaspace）</strong>：方法区，JDK 8之前为永久代，用于存储类信息、常量、静态变量等；JDK 8及以后改为元空间，使用本地内存管理，避免了永久代的内存溢出问题。</li>
</ol>
<p>堆由垃圾回收器统一管理，是GC的主要区域。</p>
<h2 id="数据仓库和传统数据库有什么区别"><a href="#数据仓库和传统数据库有什么区别" class="headerlink" title="数据仓库和传统数据库有什么区别"></a>数据仓库和传统数据库有什么区别</h2><p>用途：传统数据库主要用于OLTP（on-line transaction processing）翻译为联机事务处理，即即时的系统交互，数据仓库主要用于OLAP（On-Line Analytical Processing）翻译为联机分析处理，从字面上来看OLTP是做事务处理，OLAP是做分析处理。从对数据库操作来看，OLTP主要是对数据的增删改，OLAP是对数据的查询。</p>
<p>建模：传统数据库主要使用范式建模，数据仓库可以根据需要采用范式建模或者现在互联网普遍使用的星形模型等。</p>
<p>使用技术：传统数据库一般使用mysql等关系型数据库，数据仓库目前互联网行业更多的是使用hadoop等大数据技术，也有使用mysql等，可以根据实际情况搭建。 </p>
<p>存储的数据：传统数据库只存储当前状态的数据，数据仓库需要存储历史状态的数据，用户对历史数据的回溯分析。  </p>
<p>ODPS设计用于大规模数据存储、处理和分析，支持包括批处理、流计算、交互式查询在内的多种计算模式，更接近于数仓。</p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>IO多路复用是一种允许单个进程监视多个文件描述符的技术，使得系统在单线程的情况下可以同时处理多个客户端请求。一旦某个描述符就绪（通常是读就绪或写就绪），就能进行相应的IO系统调用。其核心机制依赖于操作系统提供的系统调用，如select、poll和epoll（Linux）。通过这些调用，程序可以一次性监听多个socket或其他IO资源的状态，避免了为每个连接创建独立线程或进程的开销。</p>
<p>epoll相对于select的改进：</p>
<p>1.select单进程打开的最大的fd是有限制的，默认是1024个，对于需要支持上万TCP连接的服务器来说太少。epoll没有这个限制，支持的最大fd上限是操作系统最大文件句柄数。1G内存的机器大约是10万个句柄。</p>
<p>2.IO效率不会随着FD增加而线性下降。select和poll缺点是当有很大的socket集合时，任意时刻只有少部分的socket是活跃的，select和poll每次调用都会扫描全部集合，导致效率下降。epoll以空间换时间，更高效的事件通知机制。</p>
<p>3.epoll通过mmap（内存映射）技术将内核空间中的事件就绪列表映射到用户空间，从而让应用程序可以直接访问这个列表，减少了内核与用户空间之间的数据复制和上下文切换的开销，加速了消息传递过程。这种方式提高了处理大量并发连接时的效率和性能。</p>
<h2 id="Java和Python的区别"><a href="#Java和Python的区别" class="headerlink" title="Java和Python的区别"></a>Java和Python的区别</h2><p><strong>语法与开发效率</strong>：Python 语法简洁直观，适合快速开发；Java 语法较严谨，代码量通常更多。</p>
<p><strong>类型系统</strong>：Python 是动态类型语言，变量类型在运行时确定；Java 是静态类型语言，需在编译时声明类型，类型安全更强。</p>
<p><strong>执行方式</strong>：Python 是解释型语言，通过解释器执行；Java 是编译型语言，先编译成字节码，再由 JVM 解释或 JIT 编译执行。</p>
<p><strong>性能</strong>：Java 通常性能更高，得益于 JVM 的优化；Python 在计算密集型任务中相对较慢。</p>
<p><strong>应用场景</strong>：Java 常用于大型企业级应用、Android 开发；Python 广泛应用于数据科学、AI、脚本和Web开发。</p>
<h2 id="Seata分布式事务解决方案"><a href="#Seata分布式事务解决方案" class="headerlink" title="Seata分布式事务解决方案"></a>Seata分布式事务解决方案</h2><p>Seata是蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。</p>
<p><strong>分布式事务</strong>：是指在分布式系统中，一次操作需要跨多个节点、服务或数据库协调完成，要求这些操作要么全部成功，要么全部失败，以保证数据的一致性。</p>
<p>其中三个重要角色： <strong>TC</strong> **事务协调者：**维护全局和分支事务的状态，协调全局事务提交或回滚。  **TM ** **事务管理器：**定义全局事务的范围、开始全局事务、提交或回滚全局事务。  **RM ** **资源管理器：**管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>
<p>四种不同的分布式事务解决方案：</p>
<ul>
<li>XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入 </li>
<li>TCC模式：最终一致的分阶段事务模式，通过业务层面定义尝试、确认和取消操作，实现灵活的补偿型事务。（柔性事务）</li>
<li>AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式 </li>
<li>SAGA模式：将长事务拆分为多个本地事务，每个步骤执行后记录状态，出错时通过补偿操作回滚前面已完成的步骤。（柔性事务）</li>
</ul>
<h2 id="Redis实现防超卖"><a href="#Redis实现防超卖" class="headerlink" title="Redis实现防超卖"></a>Redis实现防超卖</h2><p>使用Redis可以有效地管理库存并保证数据一致性。</p>
<p>一种常见的做法是利用Redis的<code>WATCH</code>机制结合事务来确保库存扣减操作的原子性和一致性。首先，将商品库存存储在Redis中。当有购买请求时，客户端先通过<code>WATCH</code>命令监控库存键的状态。然后，在事务中尝试执行库存检查和扣减操作（如<code>DECR</code>）。如果在这期间没有其他客户端修改该库存键，则<code>EXEC</code>命令会成功执行事务；如果有其他客户端在此期间修改了库存值，则当前事务会被放弃，需要重新尝试整个过程。</p>
<p><strong>为什么只用INCR&#x2F;DECR不行</strong>：虽然Redis的<code>INCR</code>和<code>DECR</code>命令本身是原子性的，可以直接用于增加或减少数值，但在并发环境下仅依赖这些命令无法完全避免超卖问题。这是因为：</p>
<ul>
<li><strong>缺乏前置条件判断</strong>：直接使用<code>DECR</code>可能会导致库存变为负数，即超过实际库存数量的商品被卖出。</li>
<li><strong>无回滚机制</strong>：一旦后续业务逻辑失败（例如订单创建失败），无法自动恢复已扣减的库存，造成数据不一致。</li>
</ul>
<p><strong>使用WATCH和事务：</strong></p>
<ul>
<li><strong>确保数据一致性</strong>：通过<code>WATCH</code>监控关键资源，在并发情况下只有在资源未被其他进程修改的前提下才执行事务，保证了多个步骤作为一个整体执行，避免了竞态条件。</li>
<li><strong>提供乐观锁功能</strong>：<code>WATCH</code>机制是一种实现乐观锁的方式。它允许客户端在执行事务前监视一个或多个键，如果在事务执行前这些键被其他客户端修改过，则事务将失败不会执行任何操作。这种机制非常适合读多写少的场景。一种无锁机制来解决并发问题。</li>
</ul>
<h2 id="高并发项目中的限流和熔断"><a href="#高并发项目中的限流和熔断" class="headerlink" title="高并发项目中的限流和熔断"></a>高并发项目中的限流和熔断</h2><p><strong>限流</strong>：目的是控制请求量，防止系统过载。常用算法包括令牌桶和漏桶算法。通过设定速率阈值，如每秒处理请求数（RPS），超过限制的请求将被拒绝或排队。例如，使用Guava的RateLimiter类实现平滑限流。阿里巴巴的Sentinel，实现对特定资源的精准限流，确保系统在高并发场景下的稳定性和可靠性。</p>
<p><strong>熔断</strong>：用于避免故障扩散。当服务调用失败率超过阈值时（如50%请求失败），启动熔断器，快速失败而不是尝试执行可能耗时的操作。一段时间后，允许部分请求通过进行试探性恢复。Hystrix是一个流行的熔断库，它提供了开箱即用的熔断、降级等功能。</p>
<h2 id="优化多节点流程编排，优化工作流引擎性能"><a href="#优化多节点流程编排，优化工作流引擎性能" class="headerlink" title="优化多节点流程编排，优化工作流引擎性能"></a>优化多节点流程编排，优化工作流引擎性能</h2><p><strong>多节点流程编排优化：</strong></p>
<ol>
<li><strong>并行执行</strong>：识别可以并行处理的任务，通过合理的任务调度机制（如DAG调度）最大化并发度，减少整体执行时间。</li>
<li><strong>减少节点间通信开销</strong>：尽量减少跨节点的数据传输量，使用高效的序列化&#x2F;反序列化格式（如Protocol Buffers或Avro），并对数据进行压缩。</li>
<li><strong>智能路由与负载均衡</strong>：根据各节点当前的负载情况动态分配任务，避免某些节点过载而其他节点闲置。</li>
<li><strong>缓存中间结果</strong>：对于重复计算的部分，可以在适当的位置增加缓存机制，存储中间结果以供后续步骤直接使用。</li>
<li><strong>重试机制</strong>：为可能失败的操作设置合理的重试策略，包括指数退避算法等，以提高系统的容错能力。</li>
</ol>
<p><strong>工作流引擎性能优化：</strong></p>
<ol>
<li><strong>异步处理</strong>：尽可能采用异步调用代替同步等待，降低请求间的耦合度，加快响应速度。</li>
<li><strong>数据库优化</strong>：使用索引加速查询。对于频繁读写的表，考虑分库分表策略。</li>
<li><strong>批处理</strong>：对于大批量的数据操作，应采用批量提交而非逐条处理的方式，减少IO次数。</li>
<li><strong>资源池管理</strong>：有效管理连接池、线程池等资源，防止因资源耗尽导致的服务不可用。</li>
</ol>
<h2 id="双写一致性问题"><a href="#双写一致性问题" class="headerlink" title="双写一致性问题"></a>双写一致性问题</h2><p>双写一致性问题主要出现在使用缓存与数据库共同存储数据的场景中，两个独立的数据存储系统，在并发更新时难以保证操作的原子性和顺序性。当应用同时写入缓存和数据库时，由于网络延迟、系统故障或并发读写，可能导致两者数据不一致。</p>
<p>例如，如果<strong>先更新数据库再更新缓存</strong>，在这期间若有其他请求读取了旧的缓存数据，则会导致短暂的数据不一致。缓存更新失败也会导致不一致。同样，若<strong>先更新缓存再更新数据库</strong>，而此时数据库更新失败或出现网络问题，也会造成缓存与数据库数据的差异。此外，并发操作加剧了这一问题，多个客户端可能同时对同一数据进行读写操作，如果没有适当的同步机制，很容易导致部分客户端读取到未更新或错误的数据版本。<strong>先删缓存再更新数据库</strong>存在并发窗口期，可能使旧数据重新加载进缓存。</p>
<p><strong>如何解决</strong>：</p>
<p><strong>先更新数据库，再删除缓存</strong>，结合延迟双删或消息队列异步补偿，确保最终一致。</p>
<ol>
<li><strong>先更新数据库，后删除缓存</strong>：最常用。当需要更新数据时，首先更新数据库，然后立即删除对应的缓存项。下次查询时会从数据库加载最新数据到缓存中。在更新数据库之后和删除缓存之前，有短暂的不一致窗口。但是降低了因并发引起的复杂性和潜在的数据不一致风险。</li>
<li><strong>延迟双删策略</strong>：在更新数据库之后，不仅立即删除缓存，还会设置一个小延迟（如50ms），再次删除同一缓存项。因为当一个线程正在更新数据库并删除缓存时，另一个并发线程可能已经从旧缓存中读取了数据，并在更新操作完成之前将其重新写入缓存，导致缓存中的数据比数据库还旧，这是缓存重建行为。</li>
<li><strong>消息队列同步</strong>：利用消息队列确保操作顺序执行。将所有对数据库的修改通过消息队列进行异步处理，确保每个操作按序到达并更新缓存和数据库，适用于对一致性要求较高的场景。</li>
<li><strong>使用分布式事务或Saga模式</strong>：对于复杂的业务逻辑，可以采用分布式事务或者Saga模式来管理跨服务的数据一致性，但这通常增加了系统的复杂度。</li>
</ol>
<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>CAP理论帮助开发者理解分布式系统的取舍。CAP理论指出，在分布式系统中，<strong>一致性（Consistency）</strong>、<strong>可用性（Availability）</strong> 和 <strong>分区容错性（Partition tolerance）</strong> 三者不可兼得，最多只能同时满足其中两项。</p>
<ul>
<li><strong>一致性</strong>：所有节点在同一时间看到的数据是相同的。</li>
<li><strong>可用性</strong>：每个请求都能在合理时间内收到成功或失败的响应，不保证数据最新。</li>
<li><strong>分区容错性</strong>：系统在部分节点间通信中断（网络分区）时仍能继续运行。</li>
</ul>
<p>由于网络故障难以避免，分区容错性通常是必须保证的。因此，系统设计通常在 <strong>CP（如ZooKeeper）</strong> 和 <strong>AP（缓存系统，一般会追求AP可用，并通过一些手段尽可能保证弱一致性和最终一致性）</strong> 之间权衡：CP系统在分区发生时保证数据一致但可能拒绝服务；AP系统保持可用，但允许数据暂时不一致。</p>
<h2 id="RocketMQ事务消息"><a href="#RocketMQ事务消息" class="headerlink" title="RocketMQ事务消息"></a>RocketMQ事务消息</h2><p>可以利用事务消息轻松地实现分布式事务，采用2PC的思想来实现提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息。</p>
<p>RocketMQ实现事务消息主要分为两个阶段：正常事务的发送及提交、事务信息的补偿流程 整体流程为：</p>
<ul>
<li>正常事务发送与提交阶段：1、生产者发送一个半消息给MQServer（半消息是指消费者暂时不能消费的消息） 2、服务端响应消息写入结果，半消息发送成功 3、生产者开始执行本地事务 4、执行完本地事务后再告诉MQServer本地事务的执行状态，确认消息究竟是Commit还是Rollback</li>
<li>事务信息的补偿流程 1、如果MQServer长时间没收到本地事务的执行状态，会向生产者发起一个确认回查的操作请求 2、生产者收到确认回查请求后，检查本地事务的执行状态 3、MQServer根据检查后的结果执行Commit或者Rollback操作。补偿阶段主要是用于解决生产者在发送Commit或者Rollback操作时发生超时或失败的情况。</li>
</ul>
<p>例如场景：用户请求订单微服务 <code>order-service</code> 接口删除订单（退货），删除订单后需要发送消息给用户服务<code>account-service</code>，用户微服务收到消息后会给用户账户增加余额。这个需求跟钱相关，肯定要保证消息的事务性。</p>
<p>事务消息相对普通消息最大的特点就是一阶段发送的消息对用户是不可见的，也就是说消费者不能直接消费。实现方法是改变主题。</p>
]]></content>
      <categories>
        <category>那些年背过的面试题</category>
      </categories>
      <tags>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年背过的面试题之场景题</title>
    <url>/2025/08/10/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E5%9C%BA%E6%99%AF%E9%A2%98/</url>
    <content><![CDATA[<h2 id="设计一个多人在线协同文本编辑系统"><a href="#设计一个多人在线协同文本编辑系统" class="headerlink" title="设计一个多人在线协同文本编辑系统"></a>设计一个多人在线协同文本编辑系统</h2>]]></content>
      <categories>
        <category>那些年背过的面试题</category>
      </categories>
      <tags>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年背过的面试题之中间件</title>
    <url>/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><ul>
<li><p>微服务是什么：架构风格，大型服务-多个小服务，轻量级通信机制协作。模块儿化，独立部署扩展维护、可靠、技术异构。</p>
</li>
<li><p>微服务组件：服务、通信机制、服务发现与注册、负载均衡、API网关</p>
</li>
<li><p>微服务间如何通信：http、消息队列、rpc</p>
</li>
</ul>
<h2 id="rpc、HSF"><a href="#rpc、HSF" class="headerlink" title="rpc、HSF"></a>rpc、HSF</h2><ul>
<li><p>rpc：远程过程调用，就像调用本地函数一样调用远程服务，通信协议、序列化协议，http、自定义报文tcp，文本xml json 二进制protobuf hessian。</p>
</li>
<li><p>自定义报文？http消息头复杂，短链接</p>
</li>
<li><p>HSF：高速服务框架，分布式rpc服务框架。统一服务的发布&#x2F;订阅&#x2F;调用方式，解决服务间的高效调用。</p>
</li>
<li><p>HSF架构：服务提供者、服务消费者、地址注册中心configServer（注册服务、订阅服务、向消费者推送服务提供者地址）、持久化配置中心diamond（configServer的类型和地址、订阅路由规则等）、元数据存储中心redis（服务上报元数据：方法列表参数结构）、控制台（服务查询治理测试运维）</p>
</li>
<li><p>HSF服务发布源码：核心是HSFSpringProviderBean，通过@Import注解引入配置类，配置类实现ImportBeanDefinationRegistrar来创建复杂的bean并注册到spring容器中。HSFSpringProviderBean的afterPropertiesSet()方法中进行服务初始化（初始化调用链，两条链，一是protocolFilterChain: Protocol，它专注于流程编排，在publish()流程顺序执行；一是invocationHandler链，用于后续处理hsf请求调用）、服务发布（使用线程池，Future阻塞等待服务发布成功。使用调用链进行，上报元数据到Redis，启动并监听tcp&#x2F;http端口、分配服务线程池、服务注册。使用Protocol进行流程编排，初始化时编排流程顺序。注册信息：ip&#x2F;port&#x2F;序列化方式&#x2F;路由规则&#x2F;应用名称&#x2F;超时时间。HSFProtocol中开启netty服务，设置tcp相关协议）。</p>
</li>
<li><p>HSF消费源码：1.服务初始化，初始化调用链，初始化HSF代理对象jdk。2.服务调用，同样使用调用链，在IO传输层使用netty长连接，使用hessian序列化，在服务提供方使用反射调用（运行时动态获取类的信息）。</p>
</li>
<li><p>HSF相比SpringCloud优势：1.HSF使用高性能的异步事件驱动的NIO框架Netty。2.序列化协议hession相比json。3.HSF只需将二方包暴露给用户 4.HSF使用代理机制，将协议封装、选址、远程调用封装，用户只需Spring配置。</p>
</li>
<li><p>HSF源码心得：从服务端初始化、服务注册、客户端初始化、调用服务，使用Netty、Hession、ProtocolFilter、InvocationHandler链式调用过程进行流程编排、灵活配置的注册中心、事件监听机制、通过随机数的方式实现随机负载均衡。高内聚低耦合的设计方法。</p>
</li>
<li><p>一次完整的HSF调用：服务寻址、网络连接、序列化传输、反射调用</p>
</li>
<li><p>一个rpc框架最重要的是什么部分：通信机制（传输协议自定义tcp报文还是http、负载均衡、容错机制）、序列化反序列化协议（网络只能传输字节流，需要将对象转换为字节流），还需要服务发现与注册机制、服务治理机制。</p>
</li>
<li><p>shell脚本查询对应错误出现次数：grep “2024-01-01*error” error.log ｜ wc -l</p>
</li>
</ul>
<h2 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h2><ul>
<li><p>dubbo：高性能RPC框架，阿里开源，netty网络框架，异步IO，线程池</p>
</li>
<li><p>dubbo框架：服务提供者启动时向注册中心注册服务，服务消费者启动时订阅服务，注册中心Registry向消费者推送服务提供者地址列表，如果发生变化通过长链接推送变更，消费者用负载均衡选择地址，监控中心Monitor，消费者和提供者定时发送统计数据（调用次数调用时间）</p>
</li>
<li><p>dubbo负载均衡：随机、轮询、最少活跃调用、一致性哈希、权重</p>
</li>
<li><p>dubbo中的Filter：责任链模式的实现，根据配置生成Filter链，实现对Dobbo代码的拦截和扩展，类似于AOP，优雅的代码增强手段，逻辑分层，代码解耦。应用：日志、鉴权、限流、负载均衡。</p>
</li>
<li><p>dubbo中的spi扩展：服务扩展机制，可以在运行时动态加载实现类。提供丰富的SPI扩展点，类似java SPI，可以自定义扩展实现，配置方式替换框架中的组件。使用了url总线设计，url参数识别用哪个接口实现。使用@SPI注解指定扩展点名。面向接口编程。</p>
</li>
<li><p>dubbo的SPI实现：1.ExtensionLoader单例工厂类，负责加载和管理扩展点实现类。2.不仅通过接口名获取，还有一个key。3.Adaptive自适应扩展，可以在运行时通过传入参数动态选择合适的扩展实现。</p>
</li>
<li><p>dubbo的SPI应用：Protocol协议、Cluster集群容错策略、LoadBalance负载均衡策略。都是根据配置动态切换。</p>
</li>
<li><p>dubbo中的url总线设计：为了各层解耦，交换参数不用Model，用url参数，方便扩展。底层netty。</p>
</li>
<li><p>dubbo启动过程：注册中心（加载配置、启动定时、NettyServer启动netty）提供者（DubboProtocol提供远程服务，RemoteRegistry建立与注册中心连接）消费者（RemoteRegistry，RegistryDirectory订阅服务，创建代理，实际调用InvokerInvocationHandler）</p>
</li>
<li><p>dubbo服务治理：负载均衡（请求均匀分配）、集群容错（调用失败时切换机器重试）、服务降级（负载过高时屏蔽部分服务保障核心）、路由策略（选择最优服务提供者）、监控管理（监控报警）</p>
</li>
<li><p>dubbo中的设计模式：ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();是工厂模式，Adaptive运行时动态决定调用哪个实现，代理模式。使用调用链Filter责任链模式。ClassLoaderFilter在主功能上添加功能装饰器模式。注册中心向消费者发送notify消息表示服务更新，观察者模式。</p>
</li>
<li><p>dubbo总结：Dubbo考虑了框架可扩展性，url总线设计，层次划分。一个调用链路中存在很多Filter拦截，相对HSF性能差，但是可以将自己逻辑整合到调用链中。</p>
</li>
<li><p>dubbo限流：服务治理的一种，确保服务提供者不会因为过高请求负载而崩溃。基于令牌桶算法，以恒定速率向桶中添加令牌，每个请求需要从桶中消耗令牌，Guava中RateLimiter实现令牌桶。基于信号量Semaphore，控制同时执行服务的线程数。</p>
</li>
<li><p>dubbo序列化有哪些：Hessian2序列化，紧凑且效率高，二进制序列化协议，跨语言，dubbo中默认的。java内置序列化。Fastjson序列化，将对象序列化为json字符串，适合web通信场景。Protobuf序列化，使用.proto文件定义数据结构，生成二进制格式存储数据，跨语言。</p>
</li>
<li><p>dubbo比spring cloud优势：1.轻量级和高性能：基于RPC和Netty框架。强调性能。2.灵活的服务治理：路由规则、负载均衡、故障转移、集群支持。3.独立的注册中心：zookeeper等可选，提供分离的服务发现设计。4.支持跨语言的服务调用，gRpc、Hessian集成。5.简单易用，二方包的形式</p>
</li>
<li><p>Spring Cloud：基于Spring Boot，一整套微服务解决方案，提供一系列用于构建微服务应用的工具和框架。相对更重。基于REST原则，基于HTTP&#x2F;REST的服务通信。</p>
</li>
</ul>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ul>
<li>分布式：多台计算机位于不同地理位置，分布式存储处理数据和应用程序。组件之间通过网络连接。</li>
<li>分布式优点：可扩展性、容错性、地理分散降低延时。</li>
<li>分布式难点：数据一致性、系统管理（部署、管理、容灾、处理节点故障）、跨节点事务</li>
<li>分布式事务：事务的操作分布在不同节点，跨库事务，需要确保事务ACID（原子性、一致性、隔离性、持久性）</li>
<li>分布式事务方法：两阶段提交2PC（准备阶段询问所有参与者是否可提交，根据答复指示所有参与者提交&#x2F;回滚，所有ok才提交）、三阶段提交3PC（增加预提交，参与者将事务操作记录写入日志，即使协调者失去响应，参与者也有足够的信息来完成或回滚事务。减少因协调者故障导致的阻塞，提高容错）、分布式事务框架（XA事务协议）、事务补偿、BASE理论（宽松，基本可用，软状态，最终一致性）</li>
<li>分布式锁：分布式系统中同步访问共享资源的机制，避免多节点同时修改同一数据的冲突。1⃣️基于数据库锁，select for update对特定行上行级锁。2⃣️基于redis，SETNX命令，expire过期时间。3⃣️基于zookeeper，分布式协调服务，创建一个独特的节点表示获锁。保障原子性和唯一性。</li>
</ul>
<h2 id="metaq"><a href="#metaq" class="headerlink" title="metaq"></a>metaq</h2><ul>
<li>metaq：分布式的，基于队列模型的消息队列中间件，基于发布订阅模式，有push&#x2F;pull两种消费模式。支持严格的消息顺序，亿级别堆积能力，支持消息回溯。延时消息。</li>
<li>消息队列三大场景：异步、解耦、削峰。</li>
<li>metaq架构：NameServer（路由注册中心，实例彼此独立，用于服务发现和Topic的注册中心，每个节点维护topic和broker的映射关系）、Broker（实际消息存储的服务器，分master和slave，每个Broker与所有的NameServer建立长连接，定时注册Topic信息到NameServer。主节点读写，从节点提供冗余和故障转移。）、Producer（消息生产者，与NameServer其中一个建立长连接，读取Topic路由信息。与提供Topic服务的Master Broker建立长连接，并定时向其发送心跳）、Consumer（消息消费者，与NameServer其中一个建立长连接，读取Topic路由信息。从Master Broker&#x2F;Slave Broker订阅消息，与Broker建立心跳。可pull可push，可集群可广播）。</li>
<li>metaq的存储模型：1⃣️CommitLog是物理存储文件，存储所有Topic的消息元数据，是全局的顺序写入的日志文件。2⃣️ConsumerQueue逻辑队列是每个Message Queue的索引文件及存储上的体现，记录CommitLog中的消息地址（偏移量、大小、消息tag的hashcode），每个条目20字节，提供快速访问。类似B+树，CommitLog是叶子结点存储实际数据，ConsumerQueue是中间节点负责索引数据。3⃣️Message Queue是逻辑上的消息队列，是Topic的分区，分散在不同Broker。用于并行发送和接收消息。4⃣️IndexFile用于快速检索消息，维护消息键（消息ID、Key）到物理位置的映射。</li>
<li>metaq如何保证消息高可用：1⃣️Producer：支持同步异步发送方式，同步消息发送确认、消息重试。使用负载均衡选择Broker进行消息投递。快速失败：调度线程定时检查第一个节点排队时间，超过就立即返回失败，以尽快重试。故障规避机制避开上次失败的Broker。2⃣️Consumer：消息拉取确认、消费失败重试队列、消费进度存储（定期存储消费进度offset，重启或故障后从进度继续消费）、业务层实现幂等消费（重复消费也不影响）。3⃣️Broker：持久化存储机制（存储到CommitLog，顺序写入磁盘）、主从部署（主从同步、主从切换，Master和Slave故障转移）、死信队列（无法成功消费的消息进入死信队列）、使用内存映射文件MappedFile（将磁盘文件映射到内存中，以操作内存方式操作磁盘，减少CPU拷贝）</li>
<li>同步刷盘和异步刷盘：将内存中数据持久化到磁盘中，同步刷盘是将消息成功写入commitLog中之后再返回给生产者成功，更可靠。异步刷盘是写到内存后直接返回，然后通过另一个后台线程来刷盘，吞吐量更高。</li>
<li>Broker主从同步：从节点定时向主节点发送同步请求，主节点根据从节点CommitLog最大偏移量返回消息。</li>
<li>NameServer作用：Broker的动态注册与发现（心跳检测是否存活）、路由信息管理（保存整个Broker集群的路由信息，topic和Broker的映射关系）。每个NameServer有一份完整数据。</li>
<li>Raft协议和Paxos：分布式系统中用于解决一致性问题的共识算法。例如Zookeeper中的Leader选举。</li>
<li>RocketMq集群模式：1⃣️单master模式：不能故障转移和高可用。2⃣️多master模式：不能故障转移。3⃣️多maste多slave异步模式：异步复制，实时性高，Master宕机磁盘损坏情况下会丢失少量消息。4⃣️多master多slave同步模式：同步双写，写成功才返回给应用，无单点故障。</li>
<li>RocketMq顺序消息如何保证：CommitLog的写入是顺序的，消息队列FIFO，对于单个Message Queue而言，是按存储顺序顺序消费的。多个Message Queue是不保证全局顺序的。需要确保消息只分配给一个Message Queue。</li>
<li>RocketMq负载均衡：Producer负载均衡，轮询方式发送到Message Queue。Consumer负载均衡，集群模式下queue均匀分配给实例，每个queue只分给一个Consumer实例。广播模式下所有consumer分到所有queue。</li>
<li>死信队列：消息重复消费失败，达到最大重试次数，进入死信队列。一个死信队列对应一个GroupId，不分Topic。</li>
<li>消息幂等：消费者接收到消息后，根据业务唯一Key（如Message key）做幂等，即使重复消费也没事。</li>
<li>推拉消息模式：Pull：拉取型，消费者主动定期轮询Broker，请求新消息。Push：消费者注册消息监听器来接收Broker的消息推送，被动消费。但实现上，都是消费端主动拉取的方式，RocketMq的服务端不会主动推送，push模式下还是消费端拉取消息，拉取后调用回调接口，模拟推送。</li>
<li>任何一台Broker宕机怎么办：Broker采用主从架构，多副本策略。Broker宕机后主从切换，高可用。4.5开始支持Dlegder模式，基于raft分布式一致算法。</li>
<li>消息被消费后会立即删除吗：不会，消费后只是消息队列的消费进度（offset）更新，消息的删除是通过定期清理过期文件来实现的。</li>
<li>延时消息实现：是在投递到Topic这一阶段延时的。1⃣️消息投递：提供若干个延时等级。有一个专门的延时Topic，存入对应延时等级的队列中。2⃣️消息调度：Broker启动时，创建ScheduledThreadPoolExecutor线程池，每个延迟队列一个线程扫描，定期检查延时队列中的消息是否到期。3⃣️转移消息：取出消息重新进行CommitLog写入，写入对应Consumer Queue。然后正常消费。</li>
<li>metaq总结：高性能（吞吐量高并发量高，队列模型、并行消费、基于Netty）、高可靠性（消息丢失可能小，重试机制、故障规避机制、重试、死信队列）、高实时性（低延迟，快速失败、异步刷盘、零拷贝）</li>
</ul>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul>
<li>消息队列：消息队列是一个用于接收消息、存储消息并且转发消息的中间件，异步、削峰、解耦。</li>
<li>metaq中的nameserver：类似kafka中zookeeper的角色，不直接采用ZooKeeper是因为ZooKeeper有自动选举Master的功能，MetaQ的架构设计上决定了它不需要进行Master选举，而只需要使用一个轻量级的元数据服务器就可以了。</li>
<li>kafka：一个多分区、多副本且基于 ZooKeeper协调的分布式消息系统。定位为一个分布式流式处理平台，高吞吐、可持久化、可水平扩展、支持流数据处理。</li>
<li>kafka的架构：zookeeper保存broker集群元数据，对控制器进行选举操作。Producer生产消息并发送到Broker。Consumer从Broker订阅并消费消息。Broker接收生产者的消息，存储消息，为消息设置偏移量。Topic消息的主题。一个Topic细分为多个分区，在存储上看作一个可追加的Log文件。offset是消息在分区中的唯一标识，保证消息在分区的顺序性，不跨分区，也就是kafka只保证分区有序性。Replication副本，保证高可用，同一Partion在多个Broker上存多个副本，主提供读写，主失效的话，zookeeper选举controller，controller选择主。</li>
<li>kafka高可用：多分区，一个Topic主题分区数据跨越多个broker分布式存储，每个分区有多个副本，主出现故障，可以故障转移。</li>
<li>kafka一定不会丢失消息吗：只有一个副本情况下会丢失，生产者确认策略是异步的还是同步的，异步的可能在消息到达服务器之前丢失。短暂网络故障、磁盘损坏。</li>
<li>netty的优点：1⃣️Reactor模型处理并发网络事件：主Reactor线程负责接收新的客户端连接，将连接分配给从Reactor，负责监控和处理IO事件。2⃣️内存管理：池化的内存分配方式，减少内存分配和回收成本。字节缓冲区ByteBuf提供内存读写，较JDK自带的ByteBuffer具有更高的性能，引用计数。3⃣️连接管理：基于事件循环(EventLoop)的模型来管理网络连接。每个EventLoop都维护了它自己的选择器(Selector)和任务队列，能够处理成百上千的连接而不会创建与之对等的线程，降低资源消耗。链式的处理器ChannelHandler来处理网络事件。</li>
<li>tcp和udp：tcp面向连接，udp无连接。tcp提供可靠传输，流量控制，拥塞控制，udp尽力而为，不保证数据包顺序、完整性、正确性，不会自动重传。tcp点到点的，面向字节流，传输慢，首部开销大20-60字节，适合文件传输、网页。udp一对一多对一多对多一对多，面向报文，传输效率快，不可靠，首部开销小8字节，适合视频通话。</li>
</ul>
<h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><ul>
<li>Netty是什么：提供异步的基于事件驱动的网络应用程序框架。用来快速开发高性能、高可靠性的网络IO程序，最流行的NIO框架。Elasticsearch、Dubbo、gRpc、Zookeeper、Rocketmq都用Netty。NIO、Seletor选择器、事件驱动、回调异步。</li>
<li>Netty的事件驱动：事件如连接打开、数据到达、连接关闭均以异步方式处理。提供EventLoop处理IO事件，其中ChannelHandlers响应事件。发起IO后，立即返回ChannelFuture对象，开发者在上面增加监听器ChannelFutureListener，在IO完成时收到通知。回调机制和Future的异步编程模型。</li>
<li>Reactor模型：事件驱动架构的一种实现方式。一个单线程监听就绪IO事件，并将IO事件分发给回调函数。Acceptor处理新连接，Reactor分派事件分派给Handler，Handler事件处理。NIO就是。</li>
<li>Netty优点：高并发基于NIO、传输快零拷贝、封装好、内存池设计使用直接内存、高性能序列化协议Protobuf</li>
<li>Netty应用场景：RPC框架的网络通信工具、实现HTTP服务器、实现即时通讯系统、消息推送系统</li>
<li>Netty相比原生NIO优势：易用性（封装API）、稳定性（修复了select空转导致CPU100%问题）、高性能（对象池复用和零拷贝技术）、Netty异步基于事件驱动</li>
<li>Netty和Tomcat区别：Tomcat是用作Servlet容器的Web服务器，Netty是异步事件驱动的网络应用框架。通信协议上，Tomcat基于http，Netty不仅支持http，可以通过编程自定义各种协议。Tomcat需要遵循Servlet规范请求与响应模型，Netty不需要。</li>
<li>Netty体系结构：1⃣️Channel：Socket的连接依据，创建、注册到EventLoop、连接到远程节点。2⃣️EventLoop：Executor在Netty的线程模型抽象，由EventLoopGroup分配管理。一个EventLoop可以被分配给多个Channel，一个Channel的IO操作由一个线程执行。作用是负载监听网络事件并调用事件处理器进行IO操作。3⃣️EventLoopGroup：线程池，通常两个，一个用于接受新连接，另一个用于处理已接受连接的数据传输IO操作。4⃣️ChannelHandler：处理具体的业务逻辑，用户自定义事件处理逻辑，如连接打开关闭、数据读取写入。5⃣️ChannelPipeline：ChannelHandler实例链，编排Handler事件处理器链式执行。6⃣️Bootstrap：启动类，用于配置整个Netty程序，进程绑定到端口、设置线程模型、事件处理流。分为服务端ServerBootstrap和客户端Bootstrap</li>
<li>Netty运行总结：Netty的服务端通过Channel处理每次的连接请求，Channel都会注册到EventLoop线程模型中等待排队或立即执行。EventLoop由EventLoopGroup管理和分配。Channel有四种生命状态，ChannaelHandler处理具体的业务逻辑，ChannelPipeline编排所有的Handler顺序执行。Bootstrap用于将这些逻辑成为一个可运行的程序，提供一个运行入口。</li>
<li>网关：客户端和服务之间的中介，简化网络结构，对外提供统一的访问接口。功能：路由转发、负载均衡、鉴权、限流、监控。Netty可实现网关，实现WebSocketHandler，两个EventLoopGroup，通过ServerBootstrap引导，异步调用的Channel方式，执行ChannelPipeline中的ChannelHandler。</li>
<li>Netty线程模型：使用事件循环EventLoop处理IO操作，每个EventLoop绑定到一个线程，服务多个Channel，负责调度和执行ChannelPipeline中的ChannelHandler。EventLoopGroup一个接收新连接的boss和负责已连接的worker。实现Reactor模式，每个EventLoop包含一个Selector选择器来监听注册在其上的channel事件。</li>
<li>Netty服务端启动过程：1.创建主从EventLoopGroup实例 2.初始化服务端启动引导ServerBootstrap实例，配置启动参数  3.设置ChannelPipeline，添加自定义ChannelHandler来处理事件和数据交互 4.ServerBootstrap的bind方法绑定服务器监听的端口，启动服务器来接收客户端连接 5.sync方法阻塞等待直到服务器绑定操作完成，随后进入服务模式</li>
<li>Netty的无锁化体现在哪：串行无锁化设计，在IO线程内部进行多个Handler串行操作，期间不进行线程切换，避免多线程导致的锁竞争。</li>
<li>Netty如何解决epoll空轮询的：使用NIO的epoll选择器时遇到无效的文件描述符而无限循环。Netty维护一个计数器监控epoll_wait返回次数，如果没有任何IO事件情况下连续多次返回，认为空轮询，Netty会重建Selector，将原来的Channel重新注册到新的Selector上。</li>
<li>拆包和粘包：TCP面向流，没有界限的一串数据，会根据TCP缓冲区的实际情况进行包的划分。通过上层应用协议设计来解决：1.消息长度固定 2.特殊分隔符作为结束标志 3.消息头定义消息长度</li>
<li>Netty解决拆包和粘包：依靠提供的一系列解码器（Decoder），能够根据应用层协议将接收到的字节流重新组合成有意义的数据单元（消息或帧）。</li>
<li>Netty零拷贝：使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。Netty的Zero-copy完全是在用户态（Java应用层）的，偏向于优化数据操作。OS层面的Zero-copy通常是避免在用户态和内核态之间的拷贝数据。</li>
<li>TCP长连接和短连接：TCP的长连接和短连接由应用层面决定。短连接是建立连接读写完成后关闭连接，每次建立连接消耗资源。长连接是读写后不关闭连接，后续继续使用。</li>
<li>Netty长连接和心跳机制：TCP长连接中可能出现断网异常，因此引入心跳机制，在client和server之间没有数据交互时给对方发送特殊数据包，对方收到后回应一个（PING-PONG交互），表示仍然在线。</li>
<li>Netty对象池技术：对象池缓存创建好的对象，避免需要时才创建。Netty中buffer是对数据的抽象，数据拷贝时用到，代表可读写的内存区域，通过ByteBuf类实现，Netty会对其进行池化，减少内存分配和垃圾回收开销。</li>
<li>Netty序列化协议：不强制使用特定的序列化协议。它提供了灵活的编解码器机制，允许开发者根据需要使用不同的序列化协议：json&#x2F;pb。</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li>设计模式：23种，为复杂解耦，将一大坨代码拆分成职责单一的模块，满足高内聚低耦合、开闭原则（不改变现有代码的基础上扩展功能）。创建型：创建和使用解耦。结构型：不同的功能代码解耦。行为型：不同的行为代码解耦。</li>
<li>面向对象的四大特征：封装（封装成对象，隐藏实现细节，private public控制访问权限）、抽象（忽略不同，抽象相同点，继承抽象类is a和实现接口has a）、继承（继承父类的属性和方法，允许重用和扩展）、多态（重载是静态，重写Override是动态）</li>
<li>创建型模式：封装复杂的创建过程，解耦对象创建和使用。单例模式：创建全局唯一对象。工厂模式：创建不同但相关类型的对象（同一父类&#x2F;接口），给定参数决定对象类型。建造者模式：创建复杂对象，设置不同可选参数定制化对象Builder。原型模式：创建成本大，复制已有对象进行创建。</li>
<li>单例模式：一个类创建全局唯一实例，提供全局访问点。spring容器一级缓存即单例池，ApplicationContext.getBean获取bean。唯一访问性能高，不适合有状态的。</li>
<li>单例模式实现：1⃣️饿汉式：类加载时就创建，线程安全，但无法延迟加载。2⃣️懒汉式：第一次使用时才创建，延迟加载，但多线程下需要加锁保证线程安全避免创建多实例。3⃣️静态内部类：在外部类加载时不会被加载，只有第一次使用才加载并创建实例，JVM保证线程安全。4⃣️枚举类：天生单例。5⃣️双重检查锁定：既延迟加载又线程安全，同步外检查一次，同步块内检查一次，volatile+synchronized。</li>
<li>线程唯一单例怎么实现：ConcurrentHashMap、或ThreadLocal线程局部变量。</li>
<li>工厂模式：提供工厂类来代替new操作。Executors方法时静态工厂模式。1⃣️简单工厂模式：工厂类方法根据传入参数不同决定生成不同对象。2⃣️工厂方法模式：工厂接口，不同产品创建实现类，开闭原则。3⃣️抽象工厂模式：接口代表一个产品族。不同方法创建不同产品。</li>
<li>建造者模式：创建复杂对象，@Builder传入参数定制化。</li>
<li>原型模式：创建对象成本大，直接复制已有对象方式创建。浅拷贝：只对基本数据类型复制，引用数据类型进行引用传递。深拷贝：引用数据类型创建新对象并复制内容。实现：实现Cloneable接口，重写Object的clone方法。或序列化实现。</li>
<li>代理模式：结构型模式，给某对象提供代理，由代理对象控制对真实对象的访问，直接调用变间接调用，不改变原代码前提下增加功能：鉴权、统计、监控、限流。1⃣️静态代理：在运行前就创建代理类，实现相同接口&#x2F;继承实现类。2⃣️动态代理：运行期间通过反射动态创建代理类，运行前不存在代理类字节码文件。不需要为每个代理类创建代理对象。</li>
<li>适配器模式：允许不兼容的接口之间交互，创建一个中间层，将一个接口转换为适配的接口。类适配器：继承实现。对象适配器：组合实现。例如Spring MVC中提供不同的HandlerAdapter适配不同的处理器，供DispatchServlet处理HTTP请求。Spring AOP中提供不同的适配器AdvisorAdapter来封装不同类型的通知。</li>
<li>观察者模式：行为型模式，基于发布订阅，对象发生变化时进行通知。同步阻塞：阻塞消息发布者。异步非阻塞：使用消息队列，非阻塞地通知观察者。</li>
<li>模版模式：通过定义一个算法的骨架，并将一些步骤的实现延迟到子类。算法结构不变，子类重新定义算法。例如JdbcTemplate。</li>
<li>策略模式：行为型模式，定义一个算法接口，不同算法实现该接口，上下文类表示使用策略的类，维护一个指向策略接口的引用。可以轻松增加、替换算法。</li>
<li>责任链模式：多个不同的处理类对象Handler组成一条链，请求在链上传递，链上每个对象处理，返回&#x2F;传递给下一个对象。</li>
<li>Spring中的设计模式：1⃣️单例模式：Spring容器单例池，bean都是单例的。2⃣️工厂模式：BeanFactory和ApplicationContext创建Bean。3⃣️代理模式：Aop功能使用JDK动态代理和Cglib动态代理。4⃣️模版模式：JdbcTemplate提供一套模板方法来处理数据库的连接、执行 SQL 语句、处理结果集。5⃣️观察者模式：Spring事件驱动模型，ApplicationEvent事件、发布者、监听器。6⃣️适配器模式：Spring MVC中适配不同的处理器Controller。AOP中适配不同的通知Advice。</li>
<li>工作中用到的设计模式：1⃣️单例模式：数据库连接池、XStream用来进行xml序列化反序列化，反复创建回造成ygc，使用单例模式。2⃣️工厂模式：根据不同业务类型返回对应的业务处理类。实现InitializingBean接口，重写afterPropertiesSet方法，用Map维护不同业务类的引用。3⃣️观察者模式：报警系统，定义事件类继承ApplicationEvent，业务类中使用applicationContext.publishEvent(ApplicationEvent)来发送事件，定义监听器EventListener，监听消息发送报警。4⃣️责任链模式：轨迹处理流程：解析、切分、抽稀、匹配、入库，定义责任链HandlerChain，按照流程处理。</li>
</ul>
<h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><ul>
<li>zookeeper：分布式协调服务，用来管理hadoop生态圈的。为分布式应用提供一致性服务的软件，功能：配置管理、服务发现、领导者选举、集群管理。</li>
<li>zookeeper为什么使用集群：1.高可用性，单节点失败仍可运行。2.数据一致性，ZAB协议实现所有节点数据一致性。3.负载均衡，分散负载。4.可伸缩性。</li>
<li>zooleeper架构：1.Client连接到一台Server，向server获取信息，周期性发送心跳给server，server回复ack，没回复则重定向一台server。2.Server包括一台Leader和多台Follower。3.ensemble表示一组服务器，至少3台。4.Leader，服务启动时进行Leader选举，负责处理写操作，在集群中同步数据。5.Follower跟随者，处理读操作，数据冗余，转发写请求，参与投票。</li>
<li>zookeeper中数据结构：和Unix文件系统类似，看作一棵树，节点称为Znode，存储1MB数据，通过其路径唯一标识。不能存大数据。create命令创建数据，get命令获取目录的值，用多版本并发控制来解决并发，set修改。</li>
<li>zookeeper三种目录节点znode类型：1.持久目录：创建之后一直存在，直到显式删除，存储长期有效的配置信息和系统状态信息。2.临时目录：在client活动期间有效，断开自动删除，不能有子目录。常用于锁和服务发现机制，例如标记某个资源正在被使用，或一个实例的注册信息。3.顺序目录：在指定路径后增加一个单调递增的计数器作为后缀，生成唯一的标识符，用于分布式锁中的实现队列顺序。</li>
<li>zookeeper分布式锁：顺序临时节点+watch监听器。创建一个锁节点&#x2F;locks，请求获锁，需要在该目录下创建一个顺序临时节点，然后判断自己是不是最小节点，是则获取到锁，不是则创建一个监听器监听比自己小一的上一个节点，上一个节点删除（手动删或断开连接自动删除）则该节点获取到锁。</li>
<li>zookeeper的观察者模式：zookeeper&#x3D;文件系统+通知机制。zookeeper允许客户端设置对znode的监视（watch），典型的发布-订阅模式，节点发生变化时，客户端会被通知。特点：一次性（监视被触发后会被移除），可以对分布式环境中的状态变化快速做出反应。</li>
<li>zookeeper的leader选举：最小号选举法：每个节点投票给自己，节点之间互相发送自己的投票，节点收到投票后评估选择最小id的节点成为领导者。当一个节点收到超过半数节点支持同一id的投票时，节点认为领导者已选好。考虑节点id和最大的事务id（zxid），确保领导者是数据最新的节点。</li>
<li>zookeeper的ZAB协议：原子广播协议，保证数据一致性。负责服务之间的数据复制（顺序一致性的）和领导者选举过程中的状态同步。1⃣️消息广播：类似两阶段提交，Leader接收写请求，请求封装成事务，事务zxid保证顺序，发送给所有Follower，超过半数成功响应则执行commit。未响应的随后同步。2⃣️崩溃恢复：选举数据最新的节点作为Leader，与集群中其他节点同步状态。</li>
<li>zookeeper集群搭建：准备至少三台服务器，安装zookeeper，zoo.cfg配置文件中设置数据目录，设置连接端口，配置服务器列表。启动zookeeper服务。</li>
<li>zookeeper如何保证hadoop高可用的：1⃣️故障切换和Leader选举：Zookeeper故障转移控制器ZKFC监控和处理NameNode的故障切换，协助备用NameNode成为主节点保障HDFS高可用。ResourceManager也是。2⃣️集群元信息同步：zookeeper提供一致性的分布式数据管理，Hadoop的组件可以利用zookeeper维护和同步系统信息如配置信息、集群状态。3⃣️服务发现：zooKeeper 可以作为一个服务注册表，帮助客户端发现当前可用的服务地址。</li>
<li>zookeeper的应用：Kafka中zookeeper用于集群管理和协调，包括 Broker 的注册、领导者选举、集群配置管理等。还是Kafka 集群元数据的存储中心。HBase中zookeeper用于领导者选举、存储集群元数据。</li>
</ul>
<h2 id="hadoop"><a href="#hadoop" class="headerlink" title="hadoop"></a>hadoop</h2><ul>
<li>hadoop：分布式计算框架，用于在分布式服务器集群上存储和处理大数据集的框架，包括底层存储框架HDFS、分布式计算框架MapReduce、资源调度系统YARN。可以分布式运行PB级别数据。Zookeeper提供协调服务，例如HBase中集群协调领导者选举。</li>
<li>HDFS：分布式文件系统，将文件数据存储在多台机器组成的集群上，每份数据具有多个备份，更可靠。</li>
<li>HDFS架构：主从结构，一个主节点namenode，多个从节点datanode。1⃣️namenode负责接收用户请求，维护文件目录结构、管理文件和block(文件被分为块)的关系以及block和datanode的关系。2⃣️datanode负责存储文件，文件被分成block存储（128M&#x2F;256M），在不同datanode上有多个副本。文件索引与实际数据分离。对硬件要求不高，可存储超大文件，目标是高数据吞吐量。</li>
<li>mapreduce：分布式运算程序的编程框架，用于大数据集的并行运算，海量计算任务分而治之。计算任务分摊到各个计算节点并行计算，汇总得到最终结果。分布式的，抽象了并行处理的复杂度，开发者只需要实现Mapper和Reducer。</li>
<li>mapreduce核心步骤：map拆解（处理输入的键值对，执行定义的Map函数，生成中间键值对）、reduce组合（汇总每个键的值，生成最终结果）。具体可分为：Split、Map、Combiner、Shuffle、Reduce。</li>
<li>split：将输入文件切割为若干块，每一块由不同节点处理。将文章分为不同句。</li>
<li>map：将每个节点的原始数据处理为中间数据，输入输出都是kv。</li>
<li>shuffle：洗牌，因为split是随机的，导致相同key数据处理在不同节点。shuffle将map后的结果重新分组，相同key给到同一reduce节点。</li>
<li>combiner：减少shuffle需要的网络IO操作，对Map后的结果提前做一次归约，相同key组成一条。</li>
<li>mapreduce的架构：计算向数据靠拢，使用主从架构，一个JobTracker接收客户端提交的计算任务，把计算任务分给TaskTracker执行，进行调度、监控。多个TaskTracker执行分配的计算任务。</li>
<li>JobTracker：跟踪任务的执行进度、资源使用量等信息，将这些信息告诉任务调度器TaskScheduler。</li>
<li>TaskTracker：使用slot划分节点资源（CPU、内存），将slot分配给MapTask和ReduceTask。2.0用YARN来进行资源调度。</li>
<li>YARN：负责资源管理、任务调度的框架。基于主从模式的分布式架构。一个ResourceManager，多个NodeManager其中包含ApplicationMaster和Container。1⃣️ResourceManager是中控模块，负责整个集群资源的管理和分配。2⃣️NodeManager是每个节点上的资源和任务管理器，启动管理container。3⃣️ApplicationMaster每个应用的调度和协调，向RM申请资源，告诉container做什么。4⃣️Container资源容器，程序执行环境，封装任务所需的资源：cpu、内存。</li>
<li>自己使用mapreduce：在odps处理大规模数据时，map任务组织数据键值对，定义key和value，key位分组依据adcode，value为数据。reduce中数据已经按照adcode进行了分组，在分组中做数据处理计算。</li>
<li>MaxCompute：odps，大规模数据计算服务，负责存储和处理大量数据。</li>
<li>DataWorks：数据开发与管理平台，负责流程设计、调度、管理，提交到 MaxCompute中执行计算任务。</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul>
<li>10G文件1G内存怎么排序：外部排序，分隔为小的文件块，对每个小文件放入内存进行排序，排序结果写回磁盘。对多个排序结果进行归并排序，使用优先队列（最小堆），归并过程中，每次从堆中取出的最小元素被挨个写入最终的输出文件中。</li>
<li>直接选择排序：第一次从arr[0到]arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]到arr[n-1]中选取最小值，与arr[1]交换。总共n-1次。</li>
<li>插入排序：逐渐构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</li>
<li>堆排序：通过构建二叉堆，不断移除堆顶元素并重建堆，最终得到一个有序序列。</li>
<li>归并排序：归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表</li>
<li>希尔排序：希尔排序又叫缩小增量排序，把所有的数据按照下标间隔进行分组，在每个组内进行插入排序。排完之后缩小分组数，再插入排序。不断缩小组的间距。直到只分一为组。</li>
<li>排序复杂度：快排时间Onlogn空间Ologn不稳定。冒泡时间On空间O1稳定。</li>
</ul>
<h2 id="计算机原理"><a href="#计算机原理" class="headerlink" title="计算机原理"></a>计算机原理</h2><ul>
<li><p>网络分层：物理层（比特流的透明传输，中继器、集线器）、数据链路层（传送帧MAC、网卡、网桥、交换机）、网络层（选择合适的路由，IP、ICMP、路由器、防火墙）、传输层（TCP、UDP）、应用层（DNS、HTTP、SMTP、FTP）</p>
</li>
<li><p>TCP的安全性：三次握手（客户端SYN，服务端ACKSYN，客户端ACK）、四次挥手（客户端FIN、服务端ACK、服务端传输完FIN、客户端ACK）</p>
</li>
<li><p>tcp流量控制：避免发送方发送得太快接收方来不及处理，滑动窗口的方式，接收端告诉客户端确认序列号和还能接受多少数据。发送端调整滑动窗口（已发送未确认、为发送可接受）。更新窗口信息可能丢失，设置0窗口探测报文。</p>
</li>
<li><p>tcp拥塞控制：防止过多数据注入网络。慢开始（加倍达到慢开始门限）。拥塞避免（拥塞窗口+1），如果拥塞，门限减半，窗口变1，执行慢开始。快重传：接收方收到失序报文发出重复ACK，发送方收到三个重复确认，就重传。快恢复：失序报文后，慢开始门限减半，拥塞窗口设为减半后的门限，执行拥塞避免。</p>
</li>
<li><p>tcp不提供加密功能，需要应用层的TSL&#x2F;SSL。两台服务器间可以建立多个tcp连接（socket&#x3D;ip+端口号不同即可）</p>
</li>
<li><p>输入url发生什么：1.DNS解析获取ip，浏览器缓存-路由器缓存-DNS缓存。2.根据ip建立TCP连接。3.浏览器向服务器发送http请求。4.服务器响应http请求。5.浏览器进行渲染。</p>
</li>
<li><p>tcp&#x2F;ip理解：IP协议是网络层的协议，使用分组交换技术来传输数据，通过路由器进行转发，最终到达目的地。无连接性、无状态性、不保证可靠传输。TCP是传输层协议，主要负责在IP协议提供的基础上实现可靠的、有序的、有连接的和无差错的数据传输。</p>
</li>
<li><p>cookie、session、token：1⃣️cookie用来保存一些信息在客户端比如记住密码和推荐显示。2⃣️session用来标识一次会话，记录用户状态，在一次会话期间共享数据。用户首次访问服务器时创建一个session，session id设置为cookie保存在浏览器。3⃣️token用来做密钥快捷登录的。</p>
</li>
<li><p>cookie、session、token：生成位置都在服务器，cookie和token保存在客户端，session保存在服务器。鉴权过程：请求携带cookie与服务器记录cookie对比确认用户状态。session用请求中session id提取，恢复用户状态。请求携带token与服务器通过请求信息生成token对比。</p>
</li>
<li><p>http状态码：301永久重定向。302临时重定向。400服务端无法理解客户端请求。401未授权，需要用户身份认证。403禁止访问，服务端拒绝。404未找到请求的资源。500服务端内部错误。</p>
</li>
<li><p>DNS基于什么协议：DNS域名解析系统，应用层，用于将人类可读的主机名转换为机器可读的IP地址。主要基于UDP进行工作，但当响应数据大小超过报文限制，或者需要更可靠传输时，用TCP。</p>
</li>
<li><p>DNS过程：解析域名时，首先检查本地DNS缓存，如果未找到，请求将发送至配置的递归DNS服务器，递归DNS服务器会进行一系列迭代查询，从根服务器开始，逐级向下询问直到找到该域名的权威DNS服务器，获取对应IP地址。沿着查询链路返回给用户的设备。</p>
</li>
</ul>
<h2 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h2><ul>
<li>边缘计算：一种分布式计算框架，在靠近数据生成的位置（边缘）处理数据的方法。将计算能力下放到网络的边缘，边缘网络基本上由终端设备、边缘设备、边缘服务器等构成。特点：低延迟、节省带宽、提高隐私和安全性、实时数据处理。应用场景：物联网（IoT）、智慧城市、无人超市。</li>
<li>边缘计算和云计算：边缘计算采用分布式计算架构，将运算分散在靠近数据源的近端设备处理，分担云平台的工作量，不需要把数据回传云端处理，实时性更好、效率更高、延迟最短，没有网络也不妨碍。</li>
<li>k8s：Kubernetes是一个开源的容器编排系统，用于自动化部署、扩展和管理容器化应用程序。由google设计。</li>
<li>docker：容器化技术允许将应用程序及其依赖项打包到一个轻量级、可移植的容器中，使得应用程序能够在任何环境中一致地运行。</li>
</ul>
]]></content>
      <categories>
        <category>那些年背过的面试题</category>
      </categories>
      <tags>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年背过的面试题之大数据</title>
    <url>/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E5%A4%A7%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<ul>
<li>谷歌的“三架马车”：谷歌文件系统GFS（2003），MapReduce（2004）和Big Table（2006），奠定了大数据时代的基础。</li>
<li>离线计算：Hadoop（Mapreduce）、Hive、Spark</li>
<li>2006年实现了由HDFS分布式文件系统和MapReduce计算框架组成的Hadoop，成为了离线数据处理的核心。</li>
<li>HDFS：Hadoop的存储部分，一个分布式文件系统，将数据文件分块存储在集群的节点上。HDFS可以实现在整个集群上高效地存储和访问数据。</li>
<li>MapReduce：大数据处理技术，属于离线计算的一种。将数据处理任务分成两个阶段：Map阶段，数据被切分成小块，并在计算机集群的各个节点上进行并行处理。Reduce阶段，将Map阶段的结果进行合并和汇总，生成最终的输出结果。</li>
<li>2007年Hive：起源于FaceBook，是基于Hadoop的一个数据仓库工具，用来进行数据提取、转化、加载ETL，一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制。能将结构化的数据文件映射为一张数据库表，并提供SQL查询功能，能将SQL语句转变成MapReduce任务来执行。</li>
<li>2010年Spark：Hadoop缺点：MapReduce框架在每个计算阶段都需进行磁盘读写导致较高的磁盘IO开销、对于迭代计算效率低下。Spark是加州大学伯克利分校开源的类Hadoop MapReduce的通用并行框架，与MapReduce不同：中间输出结果可以保存在内存中，从而不再需要读写HDFS，避免大部分磁盘IO开销，提高计算性能。同时Spark能更好的适用于数据挖掘与机器学习等需要迭代的MapReduce的算法。Spark通过使用RDD（弹性分布式数据集）、DAG切分的多阶段计算过程来实现高效的数据并行处理，支持大规模数据集的分布式计算和分析任务，是离线计算（批处理）领域的主流技术栈。</li>
<li>Spark拥有一个丰富的生态系统：Spark SQL（用于SQL查询）、Spark Streaming（用于实时流处理）、MLlib（用于机器学习）、GraphX（用于图计算）等。是一个强大且灵活的分布式计算框架，它通过内存计算和统一的编程模型，为大规模数据处理提供了高效的解决方案，适用于各种数据处理任务和应用场景。</li>
<li>实时计算：Storm、Spark Streaming、Flink</li>
<li>实时计算：在早期，基于Hadoop的数据处理主要采用批处理方式，也就是离线计算的方式：数据会先存储在分布式文件系统中，然后通过批处理作业进行处理和分析，数据处理的延迟较高，需要等待一段时间才能获取结果。</li>
<li>离线&#x3D;批处理，实时&#x3D;流式处理。流式处理技术将数据分成小的批次进行处理，在数据到达时立即进行处理和分析，流式处理技术又分为两种：原生流、微批拟流（Spark Streaming）</li>
<li>Storm是一个免费开源、分布式、高容错的实时计算系统。Storm最早于2011年诞生于Twitter。早期Storm用于实时计算，Hadoop用于离线计算。已不推荐使用。在Storm中，先要设计一个用于实时计算的图状拓扑（Topology），一个Topology是由多个Spout（数据输入处理模块）和Bolt（输出处理模块）通过Stream连接起来的有向无环图。</li>
<li>Spark Streaming：2013年Spark 2.0推出了Spark Streaming。但由于不是原生流处理技术栈，认为流是批的特例，将输入数据切分成一个个小的切片，存在时延，且高级功能不如Flink，已不是主流技术栈，不推荐使用。</li>
<li>Flink最初是由德国柏林工业大学开发。Apache Flink是分布式流式处理引擎，用于无界和有界数据流的有状态计算。Flink创造性地统一了流处理和批处理，作为流处理看待时输入数据流是无界的，而批处理被作为一种特殊的流处理，只是它的输入数据流被定义为有界的。</li>
<li>分布式存储HBase：一个分布式的、面向列的开源数据库，建立在 HDFS 之上。HBase 的计算和存储能力取决于 Hadoop 集群。它介于NoSql和RDBMS之间，仅能通过主键(row key)和主键的range来检索数据，仅支持单行事务。</li>
<li>OLAP 和 OLTP：OLTP（联机事务处理）对数据库的增删改。OLAP（联机分析处理）对数据的查询。</li>
<li>OLAP的分类：ROLAP（关系型联机分析处理）、MOLAP（多维联机分析处理）、HOLAP（混合型OLAP）。ROLAP：传统关系型数据库、MPP分布式数据库以及Hadoop的Spark。实时根据用户提出的需求对数据进行计算后返回给用户。使用灵活，可以随意选择维度组合进行实时计算。有性能问题。MOLAP：将客户的需求计算好以结果的形式存下来，提出需求后，找到对应的结果返回即可。需要的磁盘存储空间大。</li>
<li>MPP（Massive Parallel Processing,海量并行处理）：是一种基于共享磁盘的并行数据库处理架构，通过将数据分布到多个节点上进行并行处理，从而实现对大规模数据的快速分析和查询。只负责计算，不负责存储。</li>
<li>MapReduce和MPP架构：都是分布式并行处理，将任务并行的分散到多个服务器节点上，在每个节点上计算完成后，将各自部分的结果汇总到一起。不同的是，MapReduce任务的tasks会动态的分配在空闲的Executor上，执行慢的Executor会分配到更少的task。缺点是MapReduce将一个任务分解成有依赖关系的tasks（DAG），task是异步执行的，因此必须通过写入中间数据共享内存来解决数据的依赖，性能有所损耗。MPP每个处理数据的task被绑定在持有该数据切片的指定Executor上，单一的Executor只处理单一的task，不需要将中间数据写入磁盘，直接将数据Stream到下一个执行阶段，性能好。缺点是如果某个Executor执行过慢或者故障，整个集群的性能就会受限于这个异常节点，所以MPP架构的集群节点不宜过多。</li>
<li>Lambda架构：一种用于数据处理的架构设计模式，结合了实时计算和批处理两种方法，以满足不同的数据分析需求。L由三个层级组成：批处理层、速度层和服务层。批处理层负责离线处理大量数据，通常通过批处理系统（如Hadoop、Spark等）处理数据，并将结果存储在数据仓库中。速度层用于处理实时数据流，通常采用流式处理技术（如Storm、Spark Streaming等），以快速处理数据并产生实时结果。服务层负责将批处理层和速度层的结果整合，并为用户提供统一的数据查询和分析接口。优点：可扩展性强、能够处理大规模数据、满足实时和离线数据处理需求。</li>
</ul>
]]></content>
      <categories>
        <category>那些年背过的面试题</category>
      </categories>
      <tags>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年背过的面试题之算法</title>
    <url>/2025/08/10/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="MinHash与MinHashLSH"><a href="#MinHash与MinHashLSH" class="headerlink" title="MinHash与MinHashLSH"></a>MinHash与MinHashLSH</h2><p>MinHash 是一种用于快速估计两个集合（如文档、网页等）之间相似度的算法，特别是在处理高维数据或海量数据时非常高效。主要用于计算 Jaccard 相似度（集合交集与并集的比值）。Jaccard 相似度需要遍历整个集合，耗费时间和内存。</p>
<p>MinHash 提供了一种近似计算的方法，通过构造 “简化签名” 来高效估算集合之间的相似性，而无需直接操作整个集合。 </p>
<p>计算步骤：输入分词集合，定义n个哈希函数，集合中每个元素使用哈希函数计算，得到对应最小值，生成n大小的签名矩阵，比较签名中相同值的占比，得到近似的Jaccard相似度。 特点：minhash签名固定大小，降低计算复杂度；近似方法允许误差；适用于大规模文档去重、相似性查找等。 </p>
<p>MinhashLSH：局部敏感哈希，在MinHash的基础上进一步优化，通过分桶的方式将高相似度的数据快速归类到相同的桶中，减少不必要的相似性计算。 </p>
<p><strong>实战操作</strong>：首先将文本使用集合或者向量来表示，将文本进行分词，但是单纯分词变为集合没有考虑词间顺序问题，所以分词之后再用ngram来考虑顺序。然后使用jaccard系数表示两个集合的相似性，交集&#x2F;并集。 这样有两个问题：文本数量非常大、文本本身篇幅非常长。所以有两个优化方向：减少集合的长度、减少计算相似度的次数。 </p>
<p>使用minhash：根据分词组成的集合产生经过某种处理后的一组哈希值，相近的文本生成的哈希值相似度比较高。常用两种方法生成哈希值：1）使用一个哈希函数进行哈希后再进行多次重排。2）使用不同的哈希函数进行多次哈希。 </p>
<p>1）使用一个哈希函数进行哈希后再进行多次重排：用一个基础哈希函数对集合中元素求hash，然后使用多个简单的数学变换模拟重排，然后每次排列中取最小值作为每次打乱的代表。n次排列生成n序列哈希值。 </p>
<p>2）使用不同的哈希函数进行多次哈希（常用）：选取一批相互独立的哈希函数，每个函数对集合中元素求hash，选取该次哈希变换后集合中数值的最小值。不同的哈希函数相当于不同的投影规则。n个哈希函数生成n序列哈希值。 </p>
<p>minhash解决了文本向量表示维度的问题，但是两两比较次数太多的问题还在。如果能识别出相近的和不相近的，可以大大减少计算量。做法：借助局部敏感哈希( (Locality Sensitive Hashing，LSH) 来先进行一次分组或者聚类，让相近的文本分到一组去。 </p>
<p>LSH做法：通过minhash生成固定长度的签名，对签名分组，每组包含多个连续的哈希值，表示一个带band，对每个band应用一个哈希函数，映射到对应的桶中，一个文档会落入多个桶。接下来只需要在同一分桶中的数据之间计算相似性。 python中实现：用datasketch包中的MinHash, MinHashLSH。.update哈希化。insert（Hash名称，minHash值）载入LSH系统。</p>
<p>python实现MinHash和MinHashLSH：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datasketch <span class="keyword">import</span> MinHash, MinHashLSH</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 定义文档 ---</span></span><br><span class="line"><span class="comment"># 我们创建一些明显相似的文档</span></span><br><span class="line">documents = &#123;</span><br><span class="line">    <span class="string">&quot;doc1&quot;</span>: <span class="string">&quot;The quick brown fox jumps over the lazy dog near the river.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc2&quot;</span>: <span class="string">&quot;A quick brown fox leaps over a lazy dog by the riverside.&quot;</span>,  <span class="comment"># 与 doc1 高度相似</span></span><br><span class="line">    <span class="string">&quot;doc3&quot;</span>: <span class="string">&quot;The swift brown fox jumps over the sleepy dog close to the stream.&quot;</span>, <span class="comment"># 与 doc1 高度相似</span></span><br><span class="line">    <span class="string">&quot;doc4&quot;</span>: <span class="string">&quot;A fast brown fox jumps over a lazy hound near the water.&quot;</span>,   <span class="comment"># 与 doc1 较相似</span></span><br><span class="line">    <span class="string">&quot;doc5&quot;</span>: <span class="string">&quot;The cat sat on the mat and looked at the sun.&quot;</span>,             <span class="comment"># 与 doc1 不相似</span></span><br><span class="line">    <span class="string">&quot;doc6&quot;</span>: <span class="string">&quot;Dogs are loyal animals that make great companions.&quot;</span>,        <span class="comment"># 与 doc1 不相似</span></span><br><span class="line">    <span class="string">&quot;doc7&quot;</span>: <span class="string">&quot;Programming in Python is both powerful and enjoyable.&quot;</span>,     <span class="comment"># 与 doc1 不相似</span></span><br><span class="line">    <span class="string">&quot;doc8&quot;</span>: <span class="string">&quot;Data science involves statistics, programming, and domain expertise.&quot;</span>, <span class="comment"># 不相似</span></span><br><span class="line">    <span class="comment"># 添加大量不相关的文档来模拟“海量数据”场景</span></span><br><span class="line">    <span class="string">&quot;doc9&quot;</span>:  <span class="string">&quot;Machine learning models require large amounts of labeled data for training.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc10&quot;</span>: <span class="string">&quot;Cloud computing provides scalable resources over the internet.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc11&quot;</span>: <span class="string">&quot;Cybersecurity is essential for protecting digital information.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc12&quot;</span>: <span class="string">&quot;The solar system consists of the sun and the celestial bodies that orbit it.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc13&quot;</span>: <span class="string">&quot;Photosynthesis is the process by which green plants use sunlight to synthesize nutrients.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc14&quot;</span>: <span class="string">&quot;The human brain is a complex organ responsible for cognition and emotion.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc15&quot;</span>: <span class="string">&quot;Renewable energy sources include solar, wind, and hydroelectric power.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc16&quot;</span>: <span class="string">&quot;The internet has revolutionized communication and access to information.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc17&quot;</span>: <span class="string">&quot;Artificial intelligence aims to create machines that can perform tasks requiring human intelligence.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc18&quot;</span>: <span class="string">&quot;The history of the internet began with the development of ARPANET in the 1960s.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc19&quot;</span>: <span class="string">&quot;Quantum mechanics describes the behavior of matter and energy at atomic and subatomic scales.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc20&quot;</span>: <span class="string">&quot;The theory of evolution by natural selection was proposed by Charles Darwin.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 预处理和创建 MinHash 签名 ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preprocess_text</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;简单的文本预处理：转小写，分割成词&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> text.lower().split()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_minhash</span>(<span class="params">text, num_perm=<span class="number">128</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;为文本创建 MinHash 签名&quot;&quot;&quot;</span></span><br><span class="line">    m = MinHash(num_perm=num_perm)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> preprocess_text(text):</span><br><span class="line">        m.update(word.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正在为所有文档创建 MinHash 签名...&quot;</span>)</span><br><span class="line">minhashes = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> doc_id, text <span class="keyword">in</span> documents.items():</span><br><span class="line">    minhashes[doc_id] = create_minhash(text)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MinHash 签名创建完成。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 方法 1: MinHash LSH (近似搜索) ---</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n=== 方法 1: 使用 MinHash LSH 查找相似文档 ===&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 LSH 索引，设置相似度阈值</span></span><br><span class="line"><span class="comment"># threshold=0.5 表示我们希望找到 Jaccard 相似度 &gt;= 0.5 的文档</span></span><br><span class="line">lsh = MinHashLSH(threshold=<span class="number">0.5</span>, num_perm=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有文档的 MinHash 签名插入 LSH 索引</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正在构建 LSH 索引...&quot;</span>)</span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> doc_id, minhash <span class="keyword">in</span> minhashes.items():</span><br><span class="line">    lsh.insert(doc_id, minhash)</span><br><span class="line">lsh_build_time = time.time() - start_time</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;LSH 索引构建耗时: <span class="subst">&#123;lsh_build_time:<span class="number">.4</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择 doc1 作为查询文档</span></span><br><span class="line">query_doc_id = <span class="string">&quot;doc1&quot;</span></span><br><span class="line">query_text = documents[query_doc_id]</span><br><span class="line">query_minhash = minhashes[query_doc_id]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n查询文档 (<span class="subst">&#123;query_doc_id&#125;</span>): &#x27;<span class="subst">&#123;query_text&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正在使用 LSH 查找相似文档...&quot;</span>)</span><br><span class="line">start_time = time.time()</span><br><span class="line">similar_docs_lsh = lsh.query(query_minhash)</span><br><span class="line">lsh_query_time = time.time() - start_time</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;LSH 查询耗时: <span class="subst">&#123;lsh_query_time:<span class="number">.6</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;LSH 找到 <span class="subst">&#123;<span class="built_in">len</span>(similar_docs_lsh)&#125;</span> 个候选相似文档: <span class="subst">&#123;similar_docs_lsh&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 方法 2: 精确计算所有相似度 (全量比较) ---</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n=== 方法 2: 精确计算所有文档的相似度 (全量比较) ===&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;正在计算查询文档 &#x27;<span class="subst">&#123;query_doc_id&#125;</span>&#x27; 与其余 <span class="subst">&#123;<span class="built_in">len</span>(documents)-<span class="number">1</span>&#125;</span> 个文档的精确相似度...&quot;</span>)</span><br><span class="line">start_time = time.time()</span><br><span class="line">exact_similar_docs = []</span><br><span class="line">exact_similarities = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> doc_id, minhash <span class="keyword">in</span> minhashes.items():</span><br><span class="line">    <span class="keyword">if</span> doc_id == query_doc_id:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># 使用 MinHash 签名估算 Jaccard 相似度</span></span><br><span class="line">    similarity = query_minhash.jaccard(minhash)</span><br><span class="line">    exact_similarities[doc_id] = similarity</span><br><span class="line">    <span class="keyword">if</span> similarity &gt;= <span class="number">0.5</span>: <span class="comment"># 使用相同的阈值</span></span><br><span class="line">        exact_similar_docs.append(doc_id)</span><br><span class="line">exact_calc_time = time.time() - start_time</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;精确计算耗时: <span class="subst">&#123;exact_calc_time:<span class="number">.4</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;精确方法找到 <span class="subst">&#123;<span class="built_in">len</span>(exact_similar_docs)&#125;</span> 个相似文档: <span class="subst">&#123;exact_similar_docs&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 输出详细结果 ---</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n=== 详细结果 ===&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;LSH 找到的文档内容:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> doc_id <span class="keyword">in</span> similar_docs_lsh:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  <span class="subst">&#123;doc_id&#125;</span>: &#x27;<span class="subst">&#123;documents[doc_id]&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n精确方法找到的文档内容:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> doc_id <span class="keyword">in</span> exact_similar_docs:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  <span class="subst">&#123;doc_id&#125;</span>: &#x27;<span class="subst">&#123;documents[doc_id]&#125;</span>&#x27; (相似度: <span class="subst">&#123;exact_similarities[doc_id]:<span class="number">.3</span>f&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 性能与准确性比较 ---</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n=== 性能与准确性比较 ===&quot;</span>)</span><br><span class="line">lsh_set = <span class="built_in">set</span>(similar_docs_lsh)</span><br><span class="line">exact_set = <span class="built_in">set</span>(exact_similar_docs)</span><br><span class="line">true_positives = lsh_set &amp; exact_set</span><br><span class="line">false_positives = lsh_set - exact_set</span><br><span class="line">false_negatives = exact_set - lsh_set</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;召回率 (Recall): <span class="subst">&#123;<span class="built_in">len</span>(true_positives)&#125;</span>/<span class="subst">&#123;<span class="built_in">len</span>(exact_set)&#125;</span> = <span class="subst">&#123;<span class="built_in">len</span>(true_positives)/<span class="built_in">len</span>(exact_set) <span class="keyword">if</span> exact_set <span class="keyword">else</span> <span class="number">1.0</span>:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;假阳性 (False Positives): <span class="subst">&#123;false_positives&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;假阴性 (False Negatives): <span class="subst">&#123;false_negatives&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n=== 执行时间总结 ===&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;LSH 总耗时 (构建 + 查询): <span class="subst">&#123;lsh_build_time + lsh_query_time:<span class="number">.4</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;精确计算耗时:            <span class="subst">&#123;exact_calc_time:<span class="number">.4</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;LSH 相对于精确计算的查询加速比: <span class="subst">&#123;exact_calc_time / lsh_query_time:<span class="number">.0</span>f&#125;</span>x&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;注意: LSH 的优势在于索引可重用。如果进行10次查询，&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;     LSH 总时间约为: <span class="subst">&#123;lsh_build_time + <span class="number">10</span> * lsh_query_time:<span class="number">.4</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;     精确方法总时间:    <span class="subst">&#123;<span class="number">10</span> * exact_calc_time:<span class="number">.4</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 关键观察 ---</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n=== 关键观察 ===&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1. LSH 的查询时间 (微秒级) 远快于精确计算 (毫秒级)，即使在小数据集上。&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;2. LSH 是近似算法，可能漏掉一些相似文档 (假阴性) 或包含不相似文档 (假阳性)。&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;3. 一旦 LSH 索引构建完成，后续所有查询都极快，而精确方法每次查询都需全量计算。&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;4. 在需要频繁查询的海量数据场景下，LSH 的优势将呈数量级放大。&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="Transform-的架构，Encoder-和-Decoder"><a href="#Transform-的架构，Encoder-和-Decoder" class="headerlink" title="Transform 的架构，Encoder 和 Decoder"></a>Transform 的架构，Encoder 和 Decoder</h2><p>Transformer架构是一种用于序列数据处理的深度学习模型，特别适用于自然语言处理任务。它摒弃了传统的循环神经网络（RNN）和卷积神经网络（CNN），完全基于注意力机制（Attention Mechanism）构建。</p>
<p><strong>Encoder（编码器）</strong>：由多个相同的层堆叠而成，每层包括一个多头自注意力机制（Multi-Head Self-Attention）和一个位置前馈神经网络（Position-wise Feed-Forward Network）。编码器负责将输入序列转换为隐藏表示，这些表示捕捉了序列中元素之间的依赖关系，并且每个位置的信息都能被传递到下一个层次。</p>
<p><strong>Decoder（解码器）</strong>：同样由多个相同层组成，除了包含与编码器类似的组件外，还增加了一个额外的多头注意力层，称为“编码器-解码器注意力”层。这个层允许解码器关注到编码器的所有输出，帮助生成目标序列。此外，解码器在每个时间步只能访问到当前及之前的时间步信息，以保证预测的正确顺序。</p>
<p>通过这种结构，Transformer能够高效地并行训练，并显著提升处理长距离依赖问题的能力。</p>
<h2 id="FastText原理及实践"><a href="#FastText原理及实践" class="headerlink" title="FastText原理及实践"></a>FastText原理及实践</h2>]]></content>
      <categories>
        <category>那些年背过的面试题</category>
      </categories>
      <tags>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>BeanFactory、ApplicationContext</title>
    <url>/2022/04/26/myblog/spring/BeanFactory%E5%92%8CApplicationContext/</url>
    <content><![CDATA[<h3 id="BeanFactory与ApplicationContext"><a href="#BeanFactory与ApplicationContext" class="headerlink" title="BeanFactory与ApplicationContext"></a>BeanFactory与ApplicationContext</h3><p>BeanFactory使管理不同类型的java对象成为可能，应用上下文ApplacationContext建立在BeanFactor基础之上，提供了更多面向应用的功能，它提供了国际化支持和框架事件体系，更易于创建实际应用。我们一般称BeanFactory为IOC容器，而称ApplicationContext为应用上下文。但有时为了行文方便，我们也称ApplicationContext为Spring容器。</p>
<p>对于二者的用途，可以进行简单的划分：BeanFactor是Spring框架的基础设施，面向Spring本身；ApplicationContext面向使用Spring框架的开发者，几乎所有的应用场合都可以直接使用ApplicationContext而非底层的BeanFactory。</p>
<p>（1）BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：<br>①继承MessageSource，因此支持国际化。<br>②统一的资源文件访问方式。<br>③提供在监听器中注册bean的事件。<br>④同时加载多个配置文件。<br>⑤载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p>
<p>（2）BeanFactory通常是使用编程方式被创建的，而ApplicationContext可以用声明（就是用配置的方式）的方式创建，当然也可以使用ApplicationContext的实现类之一用编码方式来创建ApplicationContext的实例.</p>
<p>（3）BeanFactory采用的是延迟加载形式来注入bean的，只有在使用到getBean() 时，才对该bean进行加载实例化，这样我们就不能发现一些bean的配置问题。而ApplicationContext则相反，它是在容器启动的时候，一次性创建所有的bean，这样在容器启动时就能发现spring 中存在的配置错误。这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<p>（4）BeanFactory和ApplicationContext都支持BeanPostProcesser、BeanFactoryPostProcessor的使用，但两者的区别是：BeanFactory是手动注册的，ApplicationContext是自动注册的.</p>
<h3 id="ApplicationContext的创建方式"><a href="#ApplicationContext的创建方式" class="headerlink" title="ApplicationContext的创建方式"></a>ApplicationContext的创建方式</h3><h4 id="使用代码方式"><a href="#使用代码方式" class="headerlink" title="使用代码方式"></a>使用代码方式</h4><p>ApplicationContext接口常用实现类：</p>
<p>1.ClassPathXmlApplicationContext</p>
<p>a.加载单个配置文件方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationContext cxt = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure>

<p>b.加载多个配置文件方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] configs = &#123;&quot;bean1.xml&quot;,&quot;bean2.xml&quot;,&quot;bean3.xml&quot;&#125;;</span><br><span class="line">ApplicationContext cxt = new ClassPathXmlApplicationContext(configs);</span><br></pre></td></tr></table></figure>

<p>2.ConfigurableApplicationContext接口</p>
<p>StartApplication中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 启动springboot应用，获取spring的ioc容器</span><br><span class="line">ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br></pre></td></tr></table></figure>

<h4 id="使用配置-声明"><a href="#使用配置-声明" class="headerlink" title="使用配置(声明)"></a>使用配置(声明)</h4><p>在javaee应用中向Servlet容器中注入Spring容器的方法</p>
<p>ContextLoader 接口，它有两个实现 :ContextLoaderListener 和 ContextLoaderServlet. 其中常用的是 ContextLoaderListener. 从 spring 文档上可以查到，他们二者实现的功能基本一样，只是 ContextLoaderListener 不能在与 Servlet2.2 兼容的 web 容器中使用。另外，因为 ContextLoaderLitener 是一个 servlet Listener ，因此，它是在 servlet context 建立后立即执行，也就以为这 servlet 已建立， spring 的 ApplicationContext 就得到了初始化，并且能够相应第一个请求，所以首选 ContextLoaderListener.</p>
<p>在web.xml中添加如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;? xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; </span><br><span class="line"> &lt;! DOCTYPE web-app</span><br><span class="line">      PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span><br><span class="line">      &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt; </span><br><span class="line"> </span><br><span class="line"> &lt; web-app &gt; </span><br><span class="line">     &lt; display-name &gt; Baselib Application &lt;/ display-name &gt; </span><br><span class="line">    </span><br><span class="line">     &lt; context-param &gt; </span><br><span class="line">        &lt; param-name &gt; contextConfigLocation &lt;/ param-name &gt; </span><br><span class="line">        &lt; param-value &gt; </span><br><span class="line">        /WEB-INF/classes/spring-sup-middelbeans.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-action.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-beans.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-cm.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-hibernate.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-resource.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-sso.xml</span><br><span class="line">        /WEB-INF/classes/com/javaeye/jert/application_context.xml</span><br><span class="line">        &lt;/ param-value &gt; </span><br><span class="line">    &lt;/ context-param &gt; </span><br><span class="line"></span><br><span class="line">    &lt; listener &gt; </span><br><span class="line">        &lt; listener-class &gt; org.springframework.web.context.ContextLoaderListener &lt;/ listener-class &gt; </span><br><span class="line">    &lt;/ listener &gt; </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt; param-value &gt; /WEB-INF/classes/spring-*.xml &lt;/ context-param &gt; </span><br></pre></td></tr></table></figure>

<p>这里主要是配置了 spring 的监听器 ContextLoaderListener ，它检查 contextConfigLocation 这个参数。如果它不存在的话，它将用 &#x2F;WEB-INF&#x2F;applicationContext.xml 作为默认的配置文件。如果 contextConfigLocation 存在的话，它将根据该参数的值查找配置文件的位置，来一一读取 spring 参数。</p>
<p>contextConfigLocation 是被 spring 固定的，专门用来查  找配置文件位置的.</p>
<p>参考：<br><a href="https://blog.csdn.net/sole_ghost/article/details/1389664">https://blog.csdn.net/sole_ghost/article/details/1389664</a></p>
<h3 id="ApplicationContext-getBean"><a href="#ApplicationContext-getBean" class="headerlink" title="ApplicationContext.getBean"></a>ApplicationContext.getBean</h3><p>目的：获取Spring容器中已初始化的bean</p>
<p>第一种：getBean(String name)<br>参数name表示IOC容器中已经实例化的bean的id或者name,<br>在IOC容器中是唯一的不能重名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">Person p = (Person) ctx.getBean(&quot;p&quot;);</span><br></pre></td></tr></table></figure>

<p>第二种：getBean(Class<T> type)<br>type表示要加载的Bean的类型。<br>如果该类型没有继承任何父类(Object类除外)和实现接口的话，那么要求该类型的bean在IOC容器中也必须是唯一的.(比如定义同一类的两个bean，但是property注入的属性不一样)<br>不需要类型转换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">Person p = ctx.getBean(Person.class);</span><br></pre></td></tr></table></figure>

<p>第三种：getBean(String name,Class<T> type)<br>这种方式比较适合接口&#x2F;抽象类，有不同实现类或子类时，type写接口或父类，name写bean name。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person p = ctx.getBean(&quot;person&quot;,BasePerson.class);</span><br></pre></td></tr></table></figure>

<p>第四种： getBean(String name,Object[] args)<br>第二个参数Object[] args可以给bean的属性赋值，赋值的方式有两种：构造方法和工厂方法。但是通过这种方式获取的bean必须把scope属性设置为prototype，也就是非单例模式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.构造方法方式：</span><br><span class="line">&lt;bean name=&quot;p3&quot; class=&quot;com.bean.Person&quot; scope=&quot;prototype&quot;/&gt;</span><br><span class="line"></span><br><span class="line">Person p = (Person) ctx.getBean(&quot;p3&quot;,new Object[]&#123;&quot;王五&quot;,35&#125;);</span><br><span class="line"></span><br><span class="line">2.工厂注入方式：</span><br><span class="line">工厂类：</span><br><span class="line">public class PersonFactory &#123;</span><br><span class="line">//静态工厂注入</span><br><span class="line">public static Person getPersonInstance(String name,int age)throws Exception</span><br><span class="line">&#123;</span><br><span class="line">  Person p = (Person)Class.forName(&quot;com.bean.Person&quot;).newInstance();</span><br><span class="line">   Method m = p.getClass().getMethod(&quot;setName&quot;, java.lang.String.class);</span><br><span class="line">   m.invoke(p, name);</span><br><span class="line">   m = p.getClass().getMethod(&quot;setAge&quot;, int.class);</span><br><span class="line">   m.invoke(p, age);</span><br><span class="line">   return p;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">配置bean：</span><br><span class="line">&lt;bean name=&quot;p3&quot; class=&quot;com.factory.PersonFactory&quot; factory-method=&quot;getPersonInstance&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;name&quot;&gt;</span><br><span class="line">&lt;null/&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;age&quot; value=&quot;0&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">Person p = (Person) ctx.getBean(&quot;p3&quot;,new Object[]&#123;&quot;王五&quot;,35&#125;);</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/qq_23927391/article/details/80625578">https://blog.csdn.net/qq_23927391/article/details/80625578</a></p>
<h3 id="ApplicationContext-getBeanWithAnnotation"><a href="#ApplicationContext-getBeanWithAnnotation" class="headerlink" title="ApplicationContext.getBeanWithAnnotation"></a>ApplicationContext.getBeanWithAnnotation</h3><p>spring中可以通过getBeansWithAnnotation来获取ioc容器中使用了某个注解的所有bean,这个方法底层原理：我们知道可以通过反射来获取一个类中所有的注解，然后通过遍历spring容器中所有bean就能获取需要的结果。返回Map&lt;String, Object&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//自定义@Auditable注解</span><br><span class="line">package com.yk.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line">public @interface Auditable &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在person类中我们引入@Auditable，并通过@Component将其注入spring容器</span><br><span class="line">package com.yk.annotation;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Auditable(&quot;person.sleep&quot;)</span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    void sleep()&#123;</span><br><span class="line">        System.out.println(&quot;睡觉了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TestApplicationContext implements ApplicationContextAware &#123;</span><br><span class="line"> </span><br><span class="line">    protected ApplicationContext applicationContext;</span><br><span class="line">	</span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() throws Exception &#123;</span><br><span class="line">        Class aClass = Class.forName(&quot;com.yk.annotation.Auditable&quot;);</span><br><span class="line">        //boolean b = aClass.isAnnotation();</span><br><span class="line">        //System.out.println(b);</span><br><span class="line">        //Person person = applicationContext.getBean(Person.class);</span><br><span class="line">        Map beansWithAnnotation = applicationContext.getBeansWithAnnotation(aClass);</span><br><span class="line"></span><br><span class="line">        Iterator entries = beansWithAnnotation.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        while (entries.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">            Map.Entry entry = (Map.Entry) entries.next();</span><br><span class="line">            System.out.println(&quot;Key = &quot; + entry.getKey() + &quot;, Value = &quot; + entry.getValue());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://blog.csdn.net/weixin_42374693/article/details/115374179">https://blog.csdn.net/weixin_42374693/article/details/115374179</a></p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>一个使用工厂模式管理多个类实现同一个接口的例子：<br><a href="https://blog.csdn.net/weixin_33898233/article/details/91414228">https://blog.csdn.net/weixin_33898233/article/details/91414228</a></p>
<p><code>applicationContext.getBeansOfType(Sort.class);</code></p>
]]></content>
      <categories>
        <category>spring理解</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring入门案例</title>
    <url>/2021/08/25/myblog/spring/Spring%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="Spring入门案例"><a href="#Spring入门案例" class="headerlink" title="Spring入门案例"></a>Spring入门案例</h1><h2 id="0-java基础"><a href="#0-java基础" class="headerlink" title="0.java基础"></a>0.java基础</h2><h3 id="a-java版本"><a href="#a-java版本" class="headerlink" title="a.java版本"></a>a.java版本</h3><p>Java是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。</p>
<p>Java编程语言的风格十分接近C++语言。继承了C++语言面向对象技术的核心，舍弃了容易引起错误的指针，以引用取代；移除了C++中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。在Java SE 1.5版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装&#x2F;拆箱特性。</p>
<blockquote>
<p>Java的三个版本 : JAVASE(标准版),JAVAEE(企业版),JAVAME(微型版).</p>
<p>java是一个平台。他包括了，java语言，java开发环境(jdk)。java有三个版本<br>j2se(标准版),j2ee(企业版),j2me(微型版)<br>不管哪个版本，都是java语言实现的一个框架。之所以要分版本，是因为3个版本是针对不同问题，设计的解决方案。<br>j2EE是java的企业级开发版本，其实换句话说就是用来做web开发的java框架。javaEE通过设定统一的标准来解决web开发的问题，javaEE的接口，抽象类，规定了web开发所需要实现的流程。整个web的开发，有2层，第1层是服务器容器，比如tomcat，weblogic。他们在javaEE的规范下，实现套接字的连接，封装消息等等，第2层是业务，而这一层是你要做的，通过tomcat封装的消息，进行相应的业务处理。服务器容器的开发由大型的产商开发，而我们通常做的开发是在服务器容器上的业务开发，正是sun的javaEE统一了规范(比如用servlet)我们的业务代码，能和comcat进行很好的通讯。</p>
</blockquote>
<p>J2SE是标准版本，J2ME是手机方向的，J2EE是网站开发方向的。</p>
<blockquote>
<p>从JDK 5.0开始 J2EE 改名为 java EE，J2SE 改名为 java SE，J2ME 改名成 java ME.java EE 是java的企业版，主要面向web应用，尤其是企业级开发</p>
</blockquote>
<h3 id="b-jdk版本"><a href="#b-jdk版本" class="headerlink" title="b.jdk版本"></a>b.jdk版本</h3><p>Java Development Kit（JDK）是太阳微系统针对Java开发人员发布的免费软件开发工具包（SDK，Software development kit）。自从Java推出以来，JDK已经成为使用最广泛的Java SDK。</p>
<p>作为Java语言的SDK，普通用户并不需要安装JDK来运行Java程序，而只需要安装JRE（Java Runtime Environment）。而程序开发者必须安装JDK来编译、调试程序。</p>
<p>JDK是个Java开发的工具包，Java是门编程语言。</p>
<p>JDK8或者JDK1.8是由于自从JDK1.5&#x2F;JDK5命名方式改变后遗留的新旧命令方式问题。所以JDK8或者JDK1.8也是同一个东西。</p>
<blockquote>
<p>JDK1.4 正则表达式，异常链，NIO，日志类，XML解析器，XLST转换器<br>JDK1.5 自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环<br>JDK1.6 提供动态语言支持、提供编译API和卫星HTTP服务器API，改进JVM的锁，同步垃圾回收，类加载<br>JDK1.7 提供GI收集器、加强对非Java语言的调用支持（JSR-292,升级类加载架构<br>JDK8 Lambda 表达式、方法引用、默认方法、新工具、Stream API、Date Time API 、Optional 类、Nashorn, JavaScript 引擎<br>JDK9 1、集合加强；2、私有接口方法；3、垃圾收集机制；4、I&#x2F;O流加强；5、JShell工具<br>JDK10 1、局部变量类型推断；2、线程本地握手；3、GC改进和内存管理；<br>JDK11 1、字符串加强；2、HttClient Api；3、用于 Lambda 参数的局部变量语法；4、ZGC<br>JDK12 1、Switch Expressions；2、Shenandoah GC；<br>JDK13 1、switch优化更新；2、文本块升级；3、重新实现旧版套接字API；4、核心库&#x2F;java.util中：I18N；5、取消使用未使用的内存<br>JDK14 1、switch优化变更为最终版；2、垃圾回收相关；3、instanceof的模式匹配（预览版）；4、删除了安全库java.security.acl API；5、货币格式（优化）<br>JDK15</p>
</blockquote>
<h2 id="1-Spring简介"><a href="#1-Spring简介" class="headerlink" title="1.Spring简介"></a>1.Spring简介</h2><p>Spring是一个开源框架，Spring是2003年兴起的轻量级java开发框架，它是为了解决企业级开发的复杂性而创建的。Spring的用途不仅限于服务器端的开发，从简单性、可测试性、低耦合的角度而言任何java应用都可以在spring中受益。</p>
<p>简单的来说Spring就是轻量级的控制反转（IOC）和面向切面（AOP）的容器框架。</p>
<blockquote>
<p>javaBean：<br>符合一定规范编写的Java类，不是一种技术，而是一种规范。针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其他的程序员或者框架使用。这些约定包括：getXXX，setXXX，isXXX，addXXX。</p>
</blockquote>
<h3 id="Spring解决什么："><a href="#Spring解决什么：" class="headerlink" title="Spring解决什么："></a>Spring解决什么：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当客户端向服务器发出请求时，服务器把得到的请求发送给控制器Servlet，而在Servlet中需要创建Service对象来调用业务层相关功能(故说控制器层Servlet依赖于业务层Service),而在Service中又需要创建数据库层DAO对象来对数据库进行操作(故说业务层Service依赖于数据库层DAO)。</span><br><span class="line"></span><br><span class="line">针对上述问题，需要考虑：1.Servlet、Service以及Dao对象的创建时间、创建数量。2.Servlet、Service以及Dao之间的依赖关系。</span><br><span class="line"></span><br><span class="line">spring：</span><br><span class="line">用来处理对象的创建、以及对象之间依赖关系的一个开发框架。它打破了我们传统开发的观念，我们不再需要像以前那样在具体的类中创建具体的对象，而是将对象的创建交给它去完成。</span><br></pre></td></tr></table></figure>

<p>非侵入式设计：引入了框架，对现有的类结构没有影响。</p>
<h3 id="IOC控制反转"><a href="#IOC控制反转" class="headerlink" title="IOC控制反转"></a>IOC控制反转</h3><p>Inversion On Control，简称IOC。对象的创建交给外部容器自动完成，这个就叫做控制反转。(有控制反转就有控制正转，控制正转:对象的创建由我们自己创建)</p>
<p>依赖注入dependency injection,简称DI，用于处理对象间的依赖关系。</p>
<p><strong>二者区别:</strong><br>控制反转(IOC):解决对象创建的问题，(对象的创建交给别人)。<br>依赖注入(DI):在创建完对象后，对象关系的处理就是依赖注入，(通过set方法依赖注入。)</p>
<h3 id="AOP面向切面"><a href="#AOP面向切面" class="headerlink" title="AOP面向切面"></a>AOP面向切面</h3><p>面向切面编程。切面，简单来说可以理解为一个类，由很多重复代码形成的类。切面举例:事务、日志、权限。</p>
<h2 id="2-Mac下spring配置"><a href="#2-Mac下spring配置" class="headerlink" title="2.Mac下spring配置"></a>2.Mac下spring配置</h2><p>配置Spring不管在哪个环境下都是大同小异，下载Spring-framework，解压缩，然后导入使用的项目即可。</p>
<p>spring3.x与jdk1.7兼容，spring4.x与jdk1.8才兼容，IDEA默认下的JDK使用1.8版本。</p>
<blockquote>
<p>直接通过IDEA创建项目选择spring模版<br>发现：没有spring模板，打开设置-&gt;plugins-&gt;搜索spring assistant-&gt;安装后重启</p>
<p>依然没有，没法了</p>
</blockquote>
<p>![image-20210825183129555](&#x2F;Users&#x2F;liuxuan14&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210825183129555.png)</p>
<h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><p>Spring Boot 是 Pivotal 团队在 Spring 的基础上提供的一套全新的开源框架，其目的是为了简化 Spring 应用的搭建和开发过程。Spring Boot 去除了大量的 XML 配置文件，简化了复杂的依赖管理。</p>
<p>Spring Boot 具有 Spring 一切优秀特性，Spring 能做的事，Spring Boot 都可以做，而且使用更加简单，功能更加丰富，性能更加稳定而健壮。随着近些年来微服务技术的流行，Spring Boot 也成了时下炙手可热的技术。</p>
<h2 id="新建spring工程"><a href="#新建spring工程" class="headerlink" title="新建spring工程"></a>新建spring工程</h2><p>idea新建maven工程，选择模版maven-archetype-quikstart，依赖：spring-core、spring-beans、spring-context。</p>
<p>archetype的意思就是模板原型的意思，原型是一个Maven项目模板工具包。</p>
<p>maven-archetype-quickstart：在这个项目里，除了pom.xml外，没有其他的xml了，但是有main、test两个包，包里放了一个App、AppTest类。</p>
<p>maven-archetype-webapp：在这个项目里，有WEB-INF目录，并且有web.xml和一个index.jsp。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring B站学习笔记</title>
    <url>/2022/01/12/myblog/spring/Spring%20b%E7%AB%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><h3 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h3><p>理念：IOC（inversion of control）AOP（aspect oriented programming）控制反转、面向切面编程。</p>
<p>1 、JavaBean：一种java语言写成的可重用组件，更多是一种规范，可以被其它的程序员或者框架使用，包含一组set和get方法的java对象，可以使应用程序更加面向对象，把数据封装起来，把应用的业务逻辑和显示逻辑分开，降低了开发的复杂性和维护成本。</p>
<p>2.pojo：plain ordinary java object，简单的java对象，那些没有继承任何类、也没有实现任何接口，更没有被其它框架侵入的java对象。不允许有业务方法，也不能携带connection之类的方法，实际就是普通JavaBeans。</p>
<p>pojo类和Bean均用于定义Java对象，以提高其可读性和可重用性。pojo没有其他限制，而bean是具有某些限制的特殊pojo。</p>
<p>SpringBean是受Spring管理的对象，所有能受Spring容器管理的对象都可以成为SpringBean。Spring中的bean，是通过配置文件、javaconfig等的设置，由Spring自动实例化，用完后自动销毁的对象。</p>
<p>3.entity： Entity Bean是域模型对象，用于实现O&#x2F;R映射，负责将数据库中的表记录映射为内存中的Entity对象，事实上，创建一个Entity Bean对象相当于新建一条记录，删除一个 Entity Bean会同时从数据库中删除对应记录，修改一个Entity Bean时，容器会自动将Entity Bean的状态和数据库同步。</p>
<h3 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h3><p>里面装的是java对象，像一个农贸市场。</p>
<p>不是什么技术，而是一种设计思想，就是将原本在程序中手动创建对象的控制权，交给spring框架来管理。</p>
<p>以往的思想是：若要使用某个对象，自己去负责对象的创建。</p>
<p>反转的思想：若要使用某个对象，只需要从spring容器中获取需要使用的对象，不关心对象的创建过程，也就是把创建对象的控制权反转给了spring框架。</p>
<p>具体例子：要做一个青椒肉丝，原本是需要种青椒和养猪的，而有了spring，只需要去农贸市场买青椒和猪肉，就可以。</p>
<p>spring官网：<a href="https://spring.io/">https://spring.io</a></p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>maven仓库：<a href="https://mvnrepository.com/">https://mvnrepository.com</a></p>
<p>release稳定版本。 </p>
<h3 id="spring框架概念"><a href="#spring框架概念" class="headerlink" title="spring框架概念"></a>spring框架概念</h3><p>spring是一个轻量级的开源的JavaEE框架。</p>
<p>轻量级：体积比较小，里面的jar包比较少。解决企业应用开发的复杂性。</p>
<p>spring有两个核心内容：IOC控制反转，原始需要new个类来创建对象，而ioc将创建对象的过程交给spring。AOP面向切面，程序中扩展个功能，原始需要修改源代码来实现，而spring不需要修改代码进行功能增强。当然还有事务、mvc等操作。</p>
<p>spring框架的相关特点：1.方便解耦，简化开发，ioc创建对象包括调用通过spring实现，使得耦合度降低。2.Aop编程支持。3.方便程序测试。4.方便集成各种优秀框架：hibernate、struts、mybatis。5.降低javaEE API的使用：jdbc等。6.方便进行事务操作。</p>
<p>下载官网：spring.io，后跟GA的是稳定版本。</p>
<p><a href="https://repo.spring.io/ui/native/release/org/springframework/spring/">https://repo.spring.io/ui/native/release/org/springframework/spring/</a> 5.2.6版本。下载spring-5.2.6.RELEASE-dist.zip。docs文件夹下是一些文档、libs是一些jar包、schema是一些配置文件。jar包中每一种都有三个：jar包、文档、源代码。</p>
<h3 id="spring5模块"><a href="#spring5模块" class="headerlink" title="spring5模块"></a>spring5模块</h3><p>从下往上</p>
<p>test相关测试</p>
<p>Core Container：包含beans、core（前两个对应IOC）、context、expression。基本功能至少要有这四个jar包。commons-logging包日志相关的jar包。</p>
<p>再往上是Aop，再往上是数据访问部分和网络部分。</p>
<h3 id="导入jar包，ioc-xml案例"><a href="#导入jar包，ioc-xml案例" class="headerlink" title="导入jar包，ioc+xml案例"></a>导入jar包，ioc+xml案例</h3><p>不用maven的情况下，工程下新建lib文件夹，将要用的jar包（只要jar包）复制到这个目录下，再在file-project structure中，选择module，加+号导入相关的jar包。</p>
<p>探究ioc，创建一个普通的类，类内创建一个普通的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通的创建对象是通过new来实现，用spring创建对象，可以通过配置文件做到，可以通过注解做到。</p>
<p>因此，创建spring配置文件，在配置文件中配置创建的对象。<br>（1）spring配置文件使用xml格式，bean1.xml，用bean标签进行配置，id是别名，class是类路径+名字。（导了包才可以新建xml时出现spring config）</p>
<blockquote>
<p>Create project from template 是是否创建模板的意思，会多一些内容。</p>
<p>打包jar包：<a href="https://blog.csdn.net/weixin_45760579/article/details/114777280">https://blog.csdn.net/weixin_45760579/article/details/114777280</a></p>
<p>如何获取jar包，<a href="https://mvnrepository.com/">https://mvnrepository.com</a> 搜索即可</p>
</blockquote>
<p>在src文件夹下创建xml文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-配置User对象创建--&gt;</span><br><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.company.User&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>（2）进行测试代码编写，加载spring配置文件，获取配置创建的对象。</p>
<p>com.company下创建testdemo包，包下新建TestXML类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestXML</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span>   <span class="comment">//单元测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.加载spring配置文件</span></span><br><span class="line">        <span class="comment">//创建应用上下文，不在src下，需要路径+名称</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取配置创建的对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><h3 id="IOC容器-1"><a href="#IOC容器-1" class="headerlink" title="IOC容器"></a>IOC容器</h3><p>控制反转，是面向对象编程的一种设计原则，降低代码耦合度。通过控制反转，对象在被创建时，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它，也叫依赖注入DI。</p>
<p>通俗：创建对象，原始方法new对象，IOC把对象的创建和对象之间的调用过程都交给Spring进行管理。使用IOC来使得耦合度降低。</p>
<p>两种方式进行Bean管理：1.基于xml配置文件  2.基于注解方式</p>
<h3 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h3><p>（1）xml解析、工厂模式、反射</p>
<p>原始方式：一个类内调用另一个类的方法，需要在类A中创建一个类B的对象，再通过类B的对象调用类B的方法。这样做的缺点：耦合度太高，类B的路径和方法如果改变的话，类A也要跟着该，不利于程序扩展。</p>
<p>工厂模式进行解耦合：除了类A和类B，还新建一个工厂类，里面public static方法中：return new B()； 返回类B的对象，因此在类A中调用类B的方法时，调用工厂类的方法来创建类B的对象，然后调用类B的方法。降低类A和类B之间的耦合度。总结来说，通过工厂类来创建对象，实现解耦。</p>
<p>（2）IOC过程：xml解析、工厂模式、反射</p>
<p>第一步：xml配置文件，配置创建的对象</p>
<p><code>&lt;bean id=&quot;dao&quot; class=&quot;UserDao&quot;&gt;&lt;/bean&gt; </code></p>
<p>第二步：有service类（A类）和dao类（B类），创建工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserFactory</span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title function_">getDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">classValue</span> <span class="operator">=</span> class属性值; <span class="comment">//1.xml解析，多种方式，可以用dom4j实现</span></span><br><span class="line">      	<span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(classValue); <span class="comment">//2.用反射技术创建对象，得到类的字节码文件</span></span><br><span class="line">      	<span class="keyword">return</span> (UserDao)clazz.newInstance();  <span class="comment">//3.得到对象，强转一下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步解耦，例如当dao类路径改了，这里不需要修改service类，只需要修改配置文件里的类路径。</p>
<h3 id="IOC接口（BeanFactory）"><a href="#IOC接口（BeanFactory）" class="headerlink" title="IOC接口（BeanFactory）"></a>IOC接口（BeanFactory）</h3><p>IOC是一个容器，思想中基于容器来完成，容器本质上就是<strong>对象工厂</strong>，在里面可以读取配置文件，通过反射创建对象。因此，IOC思想基于IOC容器，IOC容器，底层本质是对象工厂。</p>
<p>工厂需要实例化，Spring提供IOC容器实现的两种方式，也就是两个重要的接口：都能实现加载配置文件，通过工厂创建对象。</p>
<p>（1）BeanFactory：IOC容器基本实现，Spring里面内部的使用接口，一般开发人员不使用。<br>*加载配置文件时不会创建对象，在获取对象（使用）时才去创建对象。</p>
<p>（2）ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员使用。<br>*加载配置文件时就会把配置文件对象进行创建</p>
<p>这两种，哪种更好，虽然第一种节约资源，但是一般spring框架结合web项目，用tomcat进行启动，因此耗时好资源的工作都在服务器启动时进行操作。</p>
<hr>
<p>ApplicationContext接口有不同的实现类（control+h打开，）</p>
<p>例如：一个文件路径，一个类路径。</p>
<p><img src="/images/applicationContext.png"></p>
<h3 id="IOC操作Bean管理（基于XML）"><a href="#IOC操作Bean管理（基于XML）" class="headerlink" title="IOC操作Bean管理（基于XML）"></a>IOC操作Bean管理（基于XML）</h3><p> 什么是Bean管理？：1.Spring创建对象，2.用Spring注入属性（创建对象时向变量设置值，最普通的话用set方法设置值，但是现在用spring做到）</p>
<p>（1）基于xml方式创建对象</p>
<p>做法：在spring配置文件中，使用bean标签，标签里面添加对应属性，就可以实现对象创建。<code>&lt;bean id=&quot;dao&quot; class=&quot;UserDao&quot;&gt;&lt;/bean&gt;</code></p>
<p>在bean标签中有很多属性：<br>*id属性：给对象取一个别名，唯一标识<br>*class属性：类全路径（包含路径）<br>*name属性：和id一样作用，id属性中不能加特殊符号，name属性中可以加特殊符号，name属性比较早期，用得少。</p>
<p>Xml创建对象时，默认执行无参数的构造方法完成对象创建。因此，如果类里创建了有参构造但是没有声明无参构造，就会报错。</p>
<blockquote>
<p>IDEA为一个类创建构造方法、set方法、get方法快捷键：alt+insert（Windows）command+n（Mac）</p>
</blockquote>
<p>（2）基于xml方式注入属性</p>
<p>DI：依赖注入，就是注入属性。</p>
<p>&lt;1&gt;第一种注入属性方式：使用set方法进行注入。</p>
<p>首先在类中定义属性，并定义对应的set方法，一个属性对应一个set方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String bname;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBname</span><span class="params">(String bname)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.bname = bname;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDemo</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(bname);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次在spring配置文件中配置对象创建，配置属性注入。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.Book&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用property完成属性注入</span></span><br><span class="line"><span class="comment">    	name：类里属性名称</span></span><br><span class="line"><span class="comment">    	value：向属性注入的值</span></span><br><span class="line"><span class="comment">    	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;西游记&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后写一个测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestXML</span> &#123;</span><br><span class="line">  <span class="comment">//一个类下就行</span></span><br><span class="line">    <span class="meta">@Test</span>   <span class="comment">//单元测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBook</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.加载spring配置文件</span></span><br><span class="line">        <span class="comment">//创建应用上下文，不在src下，需要路径+名称</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//ApplicationContext也可以换为BeanFactory</span></span><br><span class="line">        <span class="comment">//2.获取配置创建的对象</span></span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">        book.testDemo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;2&gt;第二种注入属性方式：有参构造进行注入</p>
<p>首先在类中定义属性，并定义有参构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Music</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String mname;</span><br><span class="line">		<span class="keyword">private</span> String mauthor;</span><br><span class="line">		<span class="comment">//有参构造</span></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Music</span><span class="params">(String mname, String mauthor)</span>&#123;</span><br><span class="line">				<span class="built_in">this</span>.mname = mname;</span><br><span class="line">				<span class="built_in">this</span>.mauthor = mauthor;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDemo</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(mname+<span class="string">&quot;::&quot;</span>+mauthor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，在Spring配置文件中进行配置，使用有参构造创建对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;music&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.Music&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用有参构造进行注入</span></span><br><span class="line"><span class="comment">    	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;mname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;倾城&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;mauthor&quot;</span> <span class="attr">value</span>=<span class="string">&quot;陈奕迅&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--name是使用名称，也可以使用索引值index，index=&quot;0&quot; 表示第一个参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后，写一个测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>   <span class="comment">//单元测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMusic</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.加载spring配置文件</span></span><br><span class="line">    <span class="comment">//创建应用上下文，不在src下，需要路径+名称</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//ApplicationContext也可以换为BeanFactory</span></span><br><span class="line">    <span class="comment">//2.获取配置创建的对象</span></span><br><span class="line">    <span class="type">Music</span> <span class="variable">music</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;music&quot;</span>, Music.class);</span><br><span class="line">    System.out.println(music);</span><br><span class="line">    music.testDemo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><h3 id="使用P名称空间注入"><a href="#使用P名称空间注入" class="headerlink" title="使用P名称空间注入"></a>使用P名称空间注入</h3><p>针对set方法进行属性注入，可以使用p名称空间注入，来简化xml配置方式。</p>
<p>第一步：添加p名称空间在配置文件中。</p>
<p><code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code></p>
<p>第二步：进行属性注入，在bean标签里进行操作</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.Book&quot;</span> <span class="attr">p:bname</span>=<span class="string">&quot;红楼梦&quot;</span> <span class="attr">p:bauthor</span>=<span class="string">&quot;曹雪芹&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="IOC操作Bean管理（xml注入其他类型属性）"><a href="#IOC操作Bean管理（xml注入其他类型属性）" class="headerlink" title="IOC操作Bean管理（xml注入其他类型属性）"></a>IOC操作Bean管理（xml注入其他类型属性）</h3><p>1.字面量：不特殊的属性</p>
<p>（1）null值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property name=&quot;bname&quot;&gt;</span><br><span class="line">   &lt;null/&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>（2）属性值包含特殊符号</p>
<p>可以将特殊符号进行转义</p>
<p><code>&lt;property name=&quot;bname&quot; value=&quot;&amp;lt;&amp;gt;《西游记》&quot;&gt;&lt;/property&gt;</code></p>
<p>也可以把带有特殊符号内容写到CDATA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property name=&quot;bname&quot;&gt; </span><br><span class="line">  &lt;value&gt;&lt;![CDATA[《南京》]]&gt;&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>2.注入属性-外部bean</p>
<p>web层调用service层，service调用dao层</p>
<p>（1）创建两个类service类和dao类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserService&#123;</span><br><span class="line">	public void add()&#123;</span><br><span class="line">		System.out.println(&quot;service add.....&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface UserDao&#123;</span><br><span class="line">	public void update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）在service调用dao里面的方法</p>
<p>原始方式：service中创建UserDao对象，再调用类中方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">userDao.update();</span><br></pre></td></tr></table></figure>

<p>现在：用spring的xml配置方法进行调用</p>
<p>首先配置文件中创建两个对象，然后将Dao对象注入到Service对象中。set注入或有参注入都行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserService类中创建UserDao类型属性，生成set方法</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.service.UserService&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.dao.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ref属性：创建userDao对象bean标签id值，完成外部bean注入</p>
<p>写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBean</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span>   <span class="comment">//单元测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.加载spring配置文件</span></span><br><span class="line">        <span class="comment">//创建应用上下文，不在src下，需要路径+名称</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean2.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//ApplicationContext也可以换为BeanFactory</span></span><br><span class="line">        <span class="comment">//2.获取配置创建的对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">        System.out.println(userService);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.注入属性-内部bean和级联赋值</p>
<p>（1）一对多关系：部门和员工</p>
<p>（2）在实体之间表示一对多关系，写部门类和员工类，员工表示所属部门，使用对象类型属性进行表示。</p>
<p>（3）在spring配置文件中进行配置</p>
<p>在emp对象创建时，有一个属性是dept，可以用ref外部bean的方式，也可以用内部bean的方式。相当于是嵌套bean了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--内部bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">	            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;研发部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（4）测试方法</p>
<p>4.注入属性–级联赋值</p>
<p>级联赋值指的是一个类内有其他类的对象作为属性，可以用外部bean的方法ref，也可以内部bean的方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;李四&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;测试部门&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;财务部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出测试部门，而不是财务部。</p>
<h3 id="IOC操作Bean管理（xml注入集合属性）"><a href="#IOC操作Bean管理（xml注入集合属性）" class="headerlink" title="IOC操作Bean管理（xml注入集合属性）"></a>IOC操作Bean管理（xml注入集合属性）</h3><p>1.注入数组类型属性，注入List集合类型属性，注入Map集合类型属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span>&#123;</span><br><span class="line">    <span class="comment">//1 数组类型属性</span></span><br><span class="line">    <span class="keyword">private</span> String[] course;</span><br><span class="line">    <span class="comment">//2 list集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; lists;</span><br><span class="line">    <span class="comment">//3 map集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt;maps;</span><br><span class="line">    <span class="comment">//4 set集合</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt;sets;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCourse</span><span class="params">(String[] course)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.course = course;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSets</span><span class="params">(Set&lt;String&gt; sets)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sets = sets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setList</span><span class="params">(List&lt;String&gt; lists)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lists = lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaps</span><span class="params">(Map&lt;String, String&gt; maps)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maps = maps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.在spring配置文件进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 集合类型属性注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.collectiontype.Stu&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;course&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>数据库<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lists&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>数据库<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;JAVA&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;PHP&quot;</span> <span class="attr">value</span>=<span class="string">&quot;php&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sets&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>redis<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组如果直接输出，不是值，而是地址值，需要Arrays.toString()</p>
</blockquote>
<p>3.集合中设置对象类型值</p>
<p> bean配置中，创建多个course对象，然后用ref注入到stu对象的集合属性中。</p>
<p>注意：这里Course类中没有重写toString类的话，输出clist中的值是对象地址，只有重写Course类中的toString方法，输出才能是对象中的各种属性值。</p>
<p>4.把集合注入部分提取出来作为公共部分</p>
<p>（1）在Spring配置文件中引入名称空间util</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）提取list集合属性注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 提取list集合属性注入,多个bean都可使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;stulist&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>课程1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>课程2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用公共list集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.collectiontype.Stu&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lists&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;stulist&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="IOC操作Bean管理（FactoryBean）"><a href="#IOC操作Bean管理（FactoryBean）" class="headerlink" title="IOC操作Bean管理（FactoryBean）"></a>IOC操作Bean管理（FactoryBean）</h3><p>1.Spring中有两种类型bean，一种普通bean，另外一种FactoryBean。</p>
<p>2.普通bean，在配置文件中定义bean类型就是返回类型。</p>
<p>3.工厂bean：在配置文件定义bean类型可以和返回类型不一样。</p>
<p>第一步：创建类，让这个类作为工厂bean，实现接口FactoryBean</p>
<p>第二步：实现接口里面的方法，在实现的方法中定义返回的bean类型。</p>
<h3 id="IOC操作Bean管理（Bean的作用域）"><a href="#IOC操作Bean管理（Bean的作用域）" class="headerlink" title="IOC操作Bean管理（Bean的作用域）"></a>IOC操作Bean管理（Bean的作用域）</h3><p>1.在Spring中，可以设置创建bean实例是单实例还是多实例。</p>
<blockquote>
<p>所谓单例就是所有的请求都用一个对象来处理，比如我们常用的service和dao层的对象通常都是单例的，而多例则指每个请求用一个新的对象来处理，比如action;</p>
</blockquote>
<p>2.在Spring中，默认情况下，创建的bean是单实例对象。</p>
<p>测试类中创建多个对象，输出地址，可以发现多个对象的地址相同。也就是多个请求用一个对象处理。</p>
<p>3.如何设置单实例还是多实例</p>
<p>（1）在spring配置文件bean标签里面有属性（scope）用于设置单实例还是多实例</p>
<p>（2）scope属性值：默认值singleton，表示单实例对象。prototype，表示多实例对象。</p>
<p>其他不常用的：<br>request表示一次请求<br>session表示一次会话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;emp&quot; class=&quot;com.company.bean.Emp&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>再看多个对象的地址，不一样，多实例对象。</p>
<p>（3）singleton和prototype区别</p>
<p>第一 singleton单实例  prototype多实例</p>
<p>第二 singleton在加载spring配置文件时就会创建单实例对象，prototype不是在加载spring配置文件时创建对象，而是在调用getBean方法时创建多实例对象。</p>
<h3 id="IOC操作Bean管理（bean生命周期）"><a href="#IOC操作Bean管理（bean生命周期）" class="headerlink" title="IOC操作Bean管理（bean生命周期）"></a>IOC操作Bean管理（bean生命周期）</h3><p>1.生命周期：从对象创建到对象销毁的过程</p>
<p>2.bean生命周期</p>
<p>（1）通过构造器创建bean实例（xml调用无参构造）<br>（2）为bean中的属性设置值和对其他bean引用（调用set方法）<br>（3）调用bean的初始化方法（需要进行配置）<br>（4）bean可以使用（对象获取到）<br>（5）当容器关闭时，调用bean的销毁方法（需要进行配置）</p>
<p>3.演示bean生命周期：见程序order相关</p>
<p>4.加上bean的后置处理器：bean的生命周期有七步。</p>
<p>第三步之前：把bean实例传递bean后置处理器的方法before</p>
<p>第三步之后：把bean实例传递bean后置处理器的方法after</p>
<p>创建类实现BeanPostProcessor接口，创建后置处理器。配置文件中进行配置。</p>
<h2 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h2><h3 id="IOC操作Bean管理（xml自动装配）"><a href="#IOC操作Bean管理（xml自动装配）" class="headerlink" title="IOC操作Bean管理（xml自动装配）"></a>IOC操作Bean管理（xml自动装配）</h3><p>1.什么是自动装配？<br>property注入属性，name-value值，这是手动装配。根据指定装配规则（属性名称或者属性类型），spring自动将匹配的属性值进行注入。</p>
<p>2.演示自动装配<br>外部bean手动装配：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.autowire.Employee&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;deport&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;deport&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.autowire.Deport&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>自动装配：bean标签属性autowire，配置自动装配，autowire属性常用两个值：byName根据属性名称注入（注入值bean的id值和类属性名字一样），byType根据属性类型注入（相同类型的bean不能定义多个，不然会报错）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.autowire.Employee&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.autowire.Deport&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="IOC操作Bean管理（外部属性文件）"><a href="#IOC操作Bean管理（外部属性文件）" class="headerlink" title="IOC操作Bean管理（外部属性文件）"></a>IOC操作Bean管理（外部属性文件）</h3><p>如果一个类的属性很多，需要很多property，并且类发生变化时，需要修改xml配置文件，改起来麻烦。将固定的值放在外部文件中。场景应用在操作数据库中，数据库的值放在property文件中，引用进来，进行读取。</p>
<p>1.直接配置数据库信息</p>
<p>（1）配置德鲁伊druid连接池</p>
<p>（2）引入德鲁伊连接池依赖jar包</p>
<p><a href="https://mvnrepository.com/artifact/com.alibaba/druid/1.1.9%EF%BC%88%E6%89%BE%E5%88%B0durid1.9%E4%B8%8B%E8%BD%BD%EF%BC%8C%E5%AF%BC%E5%85%A5lib%EF%BC%89">https://mvnrepository.com/artifact/com.alibaba/druid/1.1.9（找到durid1.9下载，导入lib）</a></p>
<p>（3）配置文件中进行配置（bean10），几个属性：驱动名称、数据库地址、用户、密码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/userDb&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>2.引入外部属性文件配置数据库连接池</p>
<p>（1）创建外部属性文件，properties格式文件，写数据库信息。等号左边的名字可以随便写。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">prop.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">prop.url</span>=<span class="string">jdbc:mysql://localhost:3306/userDb</span></span><br><span class="line"><span class="attr">prop.userName</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">prop.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>（2）把外部properties属性文件引入到spring配置文件中。</p>
<p>第一步：引入context名称空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">                   http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：在spring配置文件中使用标签引入外部属性文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入外部属性文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span>   <span class="comment">&lt;!--文件在本地写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上是基于xml方式进行bean管理，最重要的：创建对象、注入属性</p>
</blockquote>
<h3 id="IOC操作Bean管理（基于注解方式）"><a href="#IOC操作Bean管理（基于注解方式）" class="headerlink" title="IOC操作Bean管理（基于注解方式）"></a>IOC操作Bean管理（基于注解方式）</h3><p>1.什么是注解？<br>注解是代码中特殊的标记，格式：@注解名称(属性名称&#x3D;属性值, 属性名称&#x3D;属性值…)<br>注解可以作用在类上面，方法上面，属性上面。<br>使用注解的原因：为了简化xml配置</p>
<p>2.Spring针对Bean管理中创建对象提供注解</p>
<p>（1）@Component</p>
<p>（2）@Service：业务逻辑层service层</p>
<p>（3）@Controller：web层</p>
<p>（4）@Repository：dao持久层</p>
<p>*上面的四个注解功能是一样的，都可以用来创建bean实例，可以不同层混用的。</p>
<p>3.基于注解方式实现对象创建</p>
<p>重新搞一个工程。</p>
<p>第一步：引入依赖，aop。</p>
<p>第二步：开启组件扫描，看有没有注解，扫描哪个包中的哪个类。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                   http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描,扫描多个包用,隔开--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.company.dao,com.company.service&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第三步：创建类，在类上添加创建对象的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(value = &quot;userService&quot;)</span>  <span class="comment">//类似于&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;, value属性可以省略，默认为类名首字母小写。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add ......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestZhujie</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZhujie</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">con</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> con.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class); <span class="comment">//打后面的，然后.var会出现前面的匹配类型</span></span><br><span class="line">        System.out.println(userService);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.上面是扫描一个包下的所有类，也可以不扫描所有类</p>
<p>示例1 ：<br><code>user-default-filters=&quot;false&quot; </code>表示现在不使用默认filter，自己配置filter。<br><code>context:include-filter</code>，设置扫描哪些内容，<code>type=&quot;annotation&quot;</code>根据注解来扫描。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例1 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.company.dao,com.company.service&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Component&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>只扫描<code>@component</code>注解的类。</p>
<p>示例2：<br><code>context：exclude-filter</code> 设置哪些内容不扫描。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.company.dao,com.company.service&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Component&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>5.基于注解方式实现属性注入</p>
<p>（1）@Autowired：根据属性类型进行自动装配</p>
<p>第一步：把service和dao对象都创建，也就是在类上都添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDapImpt</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dao add ......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：在service中注入dao对象，在service内的dao对象属性上添加注入属性注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(value = &quot;userService&quot;)</span>  <span class="comment">//类似于&lt;bean id=&quot;&quot; class=&quot;&quot;/, value属性可以省略，默认为类名首字母小写。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userdao;  <span class="comment">//UserDao是接口也可以啊</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add ......&quot;</span>);</span><br><span class="line">        userdao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*Autowired标注了UserDao类型的，根据类型自动找到它的实现类</p>
<p>（2）@Qualifier：根据属性名称进行注入</p>
<p>需要个上面的@Autowired一起进行使用。和上面的bytype自动注入类似，如果一个接口有不同实现类，就会有多个可匹配的，这时需要根据名称（@component括号里的value）进行装配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(value = &quot;userService&quot;)</span>  <span class="comment">//类似于&lt;bean id=&quot;&quot; class=&quot;&quot;/, value属性可以省略，默认为类名首字母小写。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(value = &quot;hh&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userdao;  <span class="comment">//UserDao是接口也可以啊</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add ......&quot;</span>);</span><br><span class="line">        userdao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）@Resource：可以根据类型注入，也可以根据名称注入</p>
<p>直接@Resource是根据类型，@Resource(name&#x3D;”hh”)根据名称。</p>
<p>Resource是java扩展包javax中的，上面两个是spring中的。</p>
<p>（4）@Value：注入普通类型属性</p>
<p>上面三个都是注入对象类型数据，这个注入普通类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;liu&quot;)</span>  <span class="comment">//liu注入到sname中，相当于xml的property</span></span><br><span class="line"><span class="keyword">private</span> String sname;</span><br></pre></td></tr></table></figure>

<p>6.完全注解开发</p>
<p>使用注解方式管理Bean的目的是，简化xml配置，目前只有一行开启组件扫描，其他的都用注解来替代。</p>
<p>（1）创建配置类，替代xml配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>   <span class="comment">//作为配置类，替代xml配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.company&quot;&#125;)</span>  <span class="comment">//开启组件扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）编写测试方法，除了第一步加载配置类不同，其他都一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZhujie2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">con</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);  <span class="comment">//加载配置类</span></span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> con.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class); <span class="comment">//打后面的，然后.var会出现前面的匹配类型</span></span><br><span class="line">    System.out.println(userService);</span><br><span class="line">    userService.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种开发，在实际开发中用springboot，springboot本质上还是spring，对spring做了简化开发。</p>
<h2 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h2><h3 id="AOP-基本概念"><a href="#AOP-基本概念" class="headerlink" title="AOP 基本概念"></a>AOP 基本概念</h3><p>什么是AOP：面向切面编程，是OOP延续，可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高开发的效率。</p>
<p>例如：在用户登录功能基础上添加功能–权限判断</p>
<p>原始方式：修改源代码实现 if else</p>
<p>AOP：不通过修改源代码方式在主干功能里添加新功能，将权限判断模块通过配置方式添加。</p>
<h3 id="AOP底层原理"><a href="#AOP底层原理" class="headerlink" title="AOP底层原理"></a>AOP底层原理</h3><p>AOP底层使用动态代理</p>
<p>有两种情况的动态代理：</p>
<p>第一种：有接口情况，使用JDK动态代理</p>
<p>定义UserDao接口，定义一个UserDaoImpl实现类，类内重写登录函数实现登录功能。第一步，创建UserDao接口实现类代理对象，通过代理对象增强类的方法。</p>
<p>第二种：没有接口情况，使用CGLIB动态代理</p>
<p>有一个User类，可以定义一个子类来继承User类，重写方法扩展功能增强逻辑。CGLIB动态代理：创建一个当前类之类的代理对象，增强类的方法。</p>
<h3 id="AOP（有接口情况JDK动态代理实现）"><a href="#AOP（有接口情况JDK动态代理实现）" class="headerlink" title="AOP（有接口情况JDK动态代理实现）"></a>AOP（有接口情况JDK动态代理实现）</h3><p>1.概念：使用JDK动态代理，使用Proxy类里面的方法创建代理对象。</p>
<p>API文档：<a href="https://www.matools.com/api/java8%EF%BC%88java.lang.reflect.Proxy%EF%BC%89">https://www.matools.com/api/java8（java.lang.reflect.Proxy）</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newProxyInstance(ClassLoader loader, 类&lt;?&gt;[] interfaces, InvocationHandler h)    //静态方法</span><br></pre></td></tr></table></figure>

<p>返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。</p>
<p>newProxyInstance方法的三个参数：类加载器；增强方法要增强的接口实现类，支持多个接口；写个类实现InvocationHandler接口，创建代理对象，里面写增强的方法（可以写匿名内部类，也可以写个类实现这个接口）。 </p>
<p>2.编写JDK动态代理代码</p>
<p>（1）创建接口，定义方法</p>
<p>代码中的UserDao接口</p>
<p>（2）创建接口实现类，实现方法</p>
<p>代码中的UserDaoImpl类</p>
<p>（3）使用Proxy类创建接口代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: SpringAop</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-01-27 21:08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建接口实现类代理对象</span></span><br><span class="line">        Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line">        <span class="comment">//1.函数式接口方法</span></span><br><span class="line"><span class="comment">//        Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span></span><br><span class="line"><span class="comment">//                return null;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">        <span class="comment">//2.外面写个类方法</span></span><br><span class="line">        <span class="type">UserDaoImpl</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        <span class="comment">//做一个强转，创建接口实现类的代理对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">dao</span> <span class="operator">=</span> (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao));</span><br><span class="line">        <span class="comment">//int res = dao.add(1,2);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> dao.update(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span>+res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">    <span class="comment">//把创建的是谁的代理对象，把谁传递过来</span></span><br><span class="line">    <span class="comment">//有参构造传递</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增强的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//可以对要增强的方法作出判断，增强哪个，用getName()方法</span></span><br><span class="line">        <span class="comment">//方法之前</span></span><br><span class="line">        System.out.println(<span class="string">&quot;哪个方法之前执行：&quot;</span>+method.getName()+<span class="string">&quot;；传递的参数：&quot;</span>+ Arrays.toString(args));</span><br><span class="line">        <span class="comment">//被增强的方法</span></span><br><span class="line">        Object res= method.invoke(obj, args);</span><br><span class="line">        <span class="comment">//方法之后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;哪个方法之后执行：&quot;</span>+method.getName()+<span class="string">&quot;；传递的参数：&quot;</span>+ Arrays.toString(args));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AOP-操作术语"><a href="#AOP-操作术语" class="headerlink" title="AOP-操作术语"></a>AOP-操作术语</h3><p>1.连接点</p>
<p>类中有若干方法，这些方法都可以被增强，在一个类中哪些方法可以被增强，这些方法就叫做连接点。</p>
<p>2.切入点</p>
<p>实际被真正增强的方法，叫做切入点。</p>
<p>3.通知（增强）</p>
<p>（1）实际增强的逻辑部分称为通知或是增强。</p>
<p>（2）通知有多种类型<br>*前置通知：方法之前会执行<br>*后置通知：方法之后会执行<br>*环绕通知：方法的前后都执行<br>*异常通知：方法出现异常执行<br>*最终通知：类似try-catch-finally，不管有没有异常都执行</p>
<p>4.切面</p>
<p>是动作，把通知应用到切入点的过程叫做切面。</p>
<h3 id="AOP操作-准备工作"><a href="#AOP操作-准备工作" class="headerlink" title="AOP操作-准备工作"></a>AOP操作-准备工作</h3><p>1.Spring框架中一般基于AspectJ实现AOP操作。</p>
<p>（1）什么是AspectJ？</p>
<p>*AspectJ是独立的框架，不是Spring组成部分，独立AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作。</p>
<p>2.基于AspectJ实现AOP操作</p>
<p>（1）基于xml配置文件实现</p>
<p>（2）基于注解方式实现（一般用这个）</p>
<p>3.在项目工程中引入AOP相关依赖。</p>
<p>需要添加一个aspect的依赖包。在<a href="https://mvnrepository.com中搜索aspectj、cglib、aopalliance依赖包./">https://mvnrepository.com中搜索aspectj、cglib、aopalliance依赖包。</a></p>
<p>4.切入点表达式</p>
<p>（1）切入点表达式的作用：知道对哪个类里面的哪个方法进行增强。</p>
<p>（2）语法结构：<code>execution([权限修饰符][返回类型][类全路径][方法名称][参数列表])</code></p>
<p>举例1：对com.company.dao.BookDao类里面的add进行增强<br><code>execution(* com.company.dao.BookDao.add(...))</code></p>
<p>举例2：对com.company.dao.BookDao类里面的所有进行增强<br><code>execution(* com.company.dao.BookDao.*(...))</code></p>
<p>举例3：对com.company.dao包里面所有类的所有方法进行增强<br><code>execution(* com.company.dao.*.*(...))</code></p>
<h3 id="AOP-AspectJ注解操作"><a href="#AOP-AspectJ注解操作" class="headerlink" title="AOP-AspectJ注解操作"></a>AOP-AspectJ注解操作</h3><p>1.创建类，在类中定义方法</p>
<p>创建User类</p>
<p>2.创建增强类（编写增强逻辑）</p>
<p>在增强类UserProxy中，创建方法，让不同方法代表不同通知类型。</p>
<p>3.进行通知的配置</p>
<p>（1）在spring配置文件中，开启注解扫描（可以写配置类，也可以写配置文件）首先是名称空间，再开启组件扫描</p>
<p>（2）使用注解创建User和UserProxy对象，用@Component</p>
<p>（3）在增强类上面添加注解@Aspect</p>
<p>（4）在spring配置文件中开启生成代理对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                   http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                   http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描,扫描多个包用,隔开--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.company.aopdemo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启Aspect生成代理对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.配置不同类型的通知</p>
<p>在增强类的里面，在作为通知方法上面添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.aopdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: SpringAop</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-01-29 21:48</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">    <span class="comment">//Before注解表示作为前置通知，切入点表达式表示增强哪个方法</span></span><br><span class="line">    <span class="meta">@Before(value=&quot;execution(* com.company.aopdemo.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After(value=&quot;execution(* com.company.aopdemo.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(value=&quot;execution(* com.company.aopdemo.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing(value=&quot;execution(* com.company.aopdemo.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//环绕通知，方法之前和方法之后都执行</span></span><br><span class="line">    <span class="meta">@Around(value=&quot;execution(* com.company.aopdemo.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before around......&quot;</span>);</span><br><span class="line">        proceedingJoinPoint.proceed();  <span class="comment">//表示执行被增强的方法，有异常处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after around......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>&#x2F;&#x2F;after表示方法执行之后执行</strong>，最终通知，不管有没有异常</p>
<p><strong>&#x2F;&#x2F;afterreturning表示在方法返回值之后执行</strong>，后置通知，返回通知，有异常不执行</p>
<p><strong>&#x2F;&#x2F;如果异常了，afterReturning和环绕之后不执行</strong></p>
<p>5.相同切入点抽取，@Pointcut注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相同切入点抽取</span></span><br><span class="line"><span class="meta">@Pointcut(value=&quot;execution(* com.company.aopdemo.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointdemo</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Before注解表示作为前置通知，切入点表达式表示增强哪个方法</span></span><br><span class="line"><span class="comment">//@Before(value=&quot;execution(* com.company.aopdemo.User.add(..))&quot;)</span></span><br><span class="line"><span class="meta">@Before(value = &quot;pointdemo()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before......&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.有多个增强类对同一个方法进行增强，可以设置增强类优先级</p>
<p>在增强类上面添加注解@Order(数字类型值)，值越小优先级越高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相同切入点抽取</span></span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(* com.company.aopdemo.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointdemo</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Before注解表示作为前置通知，切入点表达式表示增强哪个方法</span></span><br><span class="line">    <span class="comment">//@Before(value=&quot;execution(* com.company.aopdemo.User.add(..))&quot;)</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;pointdemo()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;person before,order1,高优先级......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h2><h3 id="AOP操作-基于AspectJ配置文件"><a href="#AOP操作-基于AspectJ配置文件" class="headerlink" title="AOP操作-基于AspectJ配置文件"></a>AOP操作-基于AspectJ配置文件</h3><p>创建一个基本类，再创建一个增强类，然后配置文件中用<code>&lt;bean&gt;</code>创建两个对象，再在spring配置文件中配置切入点，使用<code>&lt;aop:config&gt;</code>注解，使用切入点表达式<code>&lt;aop:pointcut ...</code>，再配置切面，配置增强作用在哪个地方。</p>
<p><img src="/images/%E5%88%87%E9%9D%A2%E6%B3%A8%E8%A7%A3.png"></p>
<h3 id="完全注解开发"><a href="#完全注解开发" class="headerlink" title="完全注解开发"></a>完全注解开发</h3><p>创建配置类，不需要写xml配置文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>   <span class="comment">//作为配置类，替代xml配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.company&quot;&#125;)</span>  <span class="comment">//开启组件扫描</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass=true)</span>  <span class="comment">//代替配置切入点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDBCTemplate-概述和准备工作"><a href="#JDBCTemplate-概述和准备工作" class="headerlink" title="JDBCTemplate-概述和准备工作"></a>JDBCTemplate-概述和准备工作</h3><p>1.什么是JDBCTemplate？</p>
<p>Spring框架对JDBC进行封装，使用JDBCTemplate可以方便实现对数据库的操作。</p>
<p>2.准备工作</p>
<p>（1）引入相关的jar包</p>
<p>需要mysql包、druid德鲁伊包、spring中的jdbc包、spring中的tx的事务相关、spring中的orm包用来整合其他框架。</p>
<p>（2）在spring配置文件中配置数据库的连接池</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/userDb&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>（3）配置JDBCTemplate对象，注入DataSource，用的set方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;jdbcTemplate&quot;</span> class=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span><br><span class="line">    &lt;!-- 注入DataSource --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>（4）创建service类，创建dao类，完成注入，在dao注入jdbcTemplate对象。</p>
<p>开启组件扫描，用注解创建对象，service中注入dao，dao中注入jdbcTemplate对象。</p>
<h3 id="JDBCTemplate操作数据库（添加）"><a href="#JDBCTemplate操作数据库（添加）" class="headerlink" title="JDBCTemplate操作数据库（添加）"></a>JDBCTemplate操作数据库（添加）</h3><p>1.mac安装数据库可视化工具，最终装了DataGrip，见帖子《Mac安装mysql》</p>
<p>2.建库建表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uliuxuan -p</span><br><span class="line">create database b_jdbc;</span><br><span class="line">show databases;</span><br><span class="line">use b_jdbc;</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS `user_db`(</span><br><span class="line">   `user_id` bigint unsigned NOT NULL,</span><br><span class="line">   `username` varchar(100) NOT NULL,</span><br><span class="line">   `ustate` varchar(50) NOT NULL,</span><br><span class="line">   PRIMARY KEY(`user_id`)</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;biao&#x27;;</span><br><span class="line"></span><br><span class="line"> CREATE TABLE `kiss_share_idproducer` (</span><br><span class="line">  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增&#x27;,</span><br><span class="line">  `app_id` bigint NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;产品线id&#x27;,</span><br><span class="line">  `init_id` bigint NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;初始化id&#x27;,</span><br><span class="line">  `max_id` bigint NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;当前id&#x27;,</span><br><span class="line">  `setp` bigint NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;每次分配数&#x27;,</span><br><span class="line">  `mix_id` smallint NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;启用个位混淆因子&#x27;,</span><br><span class="line">  `desc` varchar(16) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;desc&#x27;,</span><br><span class="line">  `mtime` int NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `idx_app` (`app_id`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;发号器&#x27;;</span><br></pre></td></tr></table></figure>

<p>3.entity包里对应数据库创建实体类</p>
<p>4.编写serveic和dao</p>
<p>（1）在dao中操作数据库添加方法</p>
<p>（2）调用JdbcTemplate对象里面update方法实现添加操作：两个参数：第一个参数是sql语句，第二个参数是可变参数，设置sql语句值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  <span class="comment">//创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//注入Dao</span></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">//使用注解方式实现注入</span></span><br><span class="line">    <span class="keyword">private</span> BookDao userDao;  <span class="comment">//使用dao中的方法得创建BookDao（接口？）的对象，疑惑：为什么是接口？？？</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        userDao.add(user);  <span class="comment">//用dao里的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span>  <span class="comment">//创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="comment">//注入JDBCTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">//注入配置文件中的JdbcTemplate</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库添加方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建sql语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into user_db values(?,?,?)&quot;</span>;</span><br><span class="line">        <span class="comment">//2.调用方法实现</span></span><br><span class="line">        <span class="comment">//可变参数就是一个数组型，可以用Object</span></span><br><span class="line">        Object[] args = &#123;user.getUserId(), user.getUserName(), user.getUstate()&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, args);  <span class="comment">//update表示影响行数</span></span><br><span class="line">        System.out.println(update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.编写测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJDBC</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.加载spring配置文件</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取配置创建的对象</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;bookService&quot;</span>, BookService.class);</span><br><span class="line">        <span class="comment">//getBean的第一个参数表示bean的名称，xml配置文件中的id，如果是注解创建，则小写第一位</span></span><br><span class="line">        <span class="comment">//新建一个User对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        u.setUserId(<span class="number">2</span>);</span><br><span class="line">        u.setUserName(<span class="string">&quot;lucky&quot;</span>);</span><br><span class="line">        u.setUstate(<span class="string">&quot;online&quot;</span>);</span><br><span class="line">        <span class="comment">//调用service中的方法</span></span><br><span class="line">        service.addUser(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.发生错误：</p>
<p><code>严重: create connection SQLException, url: jdbc:mysql://localhost:3306/b_jdbc, errorCode 1251, state 08004</code></p>
<p>mysql-connector的jar包版本太低，原来是5.几，改为8.几，改过之后，需要加jc，<code>value=&quot;com.mysql.cj.jdbc.Driver</code>，以及，url后面要加时区，<code>value=&quot;jdbc:mysql://localhost:3306/b_jdbc?serverTimezone=UTC&quot;</code></p>
<p>后来又发生错误：<code> create connection SQLException, url: jdbc:mysql://localhost:3306/b_jdbc?serverTimezone=UTC, errorCode 1045, state 28000</code> 这个是因为用户名和密码都是root，连接不上。root的密码为空，是可以的连接成功的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/b_jdbc?serverTimezone=UTC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个jdbc连接数据库的方法（通过配置文件），和《java开发入门jdbc》里面的连接数据库方法不同。</p>
</blockquote>
<h2 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h2><h3 id="JDBCTemplate操作数据库（修改、删除）"><a href="#JDBCTemplate操作数据库（修改、删除）" class="headerlink" title="JDBCTemplate操作数据库（修改、删除）"></a>JDBCTemplate操作数据库（修改、删除）</h3><p>1.首先dao接口创建两个方法，dao实现类里重写这两个方法。</p>
<p>2.service层里创建dao实现类对象，创建方法，里面调用对象的dao层方法。service和dao的方法传入必要参数，user对象或是id之类的。</p>
<p>3.重点写dao层内操作数据库的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user_db set username=?, ustate=? where user_id=?&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, user.getUserName(), user.getUstate(), user.getUserId());</span><br><span class="line">    System.out.println(update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from user_db where user_id=?&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, id);</span><br><span class="line">    System.out.println(update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.测试方法</p>
<h3 id="JDBCTemplate操作数据库（查询返回某个值）"><a href="#JDBCTemplate操作数据库（查询返回某个值）" class="headerlink" title="JDBCTemplate操作数据库（查询返回某个值）"></a>JDBCTemplate操作数据库（查询返回某个值）</h3><p>例如返回多少行数据。<code>select count(*) from user_db;</code></p>
<p>例如：查询表里有多少条记录。</p>
<p>首先写一个service方法findCount，调用dao里的方法，写dao方法。dao方法里写select语句，并返回。使用jdbc方法queryForObject(sql语句, 返回类型的class例如Integer.class)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from user_db&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDBCTemplate操作数据库（查询返回对象）"><a href="#JDBCTemplate操作数据库（查询返回对象）" class="headerlink" title="JDBCTemplate操作数据库（查询返回对象）"></a>JDBCTemplate操作数据库（查询返回对象）</h3><p>例如：查询用户的详情页面。</p>
<p>根据id返回一个对象，service写一个findUser方法，dao写一个find方法。dao内采用jdbc模版中的queryForObject方法，第一个参数：sql语句；第二个参数：RowMapper接口，spring提供，做到一些封装，使用这个接口里面的实现类可以完成数据的封装；第三个参数：sql语句?值。</p>
<p>第二个参数：<code>new BeanPropertyRowMapper&lt;返回类型的名字&gt;(返回类型的class)</code> 。提供好的实现类，直接用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    String sql= <span class="string">&quot;select * from user_db where user_id=?&quot;</span>;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;User&gt;(User.class), id);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了显示User对象，重写里面的tostring方法。</p>
<h3 id="JDBCTemplate操作数据库（查询返回集合）"><a href="#JDBCTemplate操作数据库（查询返回集合）" class="headerlink" title="JDBCTemplate操作数据库（查询返回集合）"></a>JDBCTemplate操作数据库（查询返回集合）</h3><p>场景：查询用户列表，返回一个集合。返回<code>List&lt;User&gt;</code></p>
<p> 首先service调用dao的方法，编写dao方法。dao内用query方法操作数据库。query三个参数，第一个参数sql语句；第二个参数和上面一样；第三个可有可无？参数值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user_db&quot;</span>;</span><br><span class="line">    List&lt;User&gt;res = jdbcTemplate.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;User&gt;(User.class));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDBCTemplate操作数据库（批量添加操作）"><a href="#JDBCTemplate操作数据库（批量添加操作）" class="headerlink" title="JDBCTemplate操作数据库（批量添加操作）"></a>JDBCTemplate操作数据库（批量添加操作）</h3><p>批量操作指操作表里的多条记录</p>
<p>批量添加，使用 jdbc的<code>batchUpdate(sql语句, List&lt;Object[]&gt;batchArgs)</code>方法。返回的是int[]类型。底层是对集合进行遍历，挨个添加。数组输出要用Arrays.toString(数组名)。</p>
<p>service层建一个batchAdd方法，传入List&lt;Object[]&gt;batchArgs。dao中创建方法，实现操作数据库，<code>insert into user_db values(?,?,?)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchAdd</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into user_db values(?,?,?)&quot;</span>;</span><br><span class="line">    <span class="type">int</span>[] update = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">    System.out.println(<span class="string">&quot;影响行数：&quot;</span>+ Arrays.toString(update));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDBCTemplate操作数据库（批量修改操作）"><a href="#JDBCTemplate操作数据库（批量修改操作）" class="headerlink" title="JDBCTemplate操作数据库（批量修改操作）"></a>JDBCTemplate操作数据库（批量修改操作）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchUpdate</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user_db set username=?,ustate=? where user_id=?&quot;</span>;</span><br><span class="line">    <span class="type">int</span>[] update = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">    System.out.println(<span class="string">&quot;批量更新影响行数：&quot;</span>+ Arrays.toString(update));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自建List</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Object[] o3 = &#123;<span class="string">&quot;java&quot;</span>, <span class="string">&quot;on&quot;</span>, <span class="number">1</span>&#125;;</span><br><span class="line">Object[] o4 = &#123;<span class="string">&quot;c++&quot;</span>, <span class="string">&quot;off&quot;</span>, <span class="number">2</span>&#125;;</span><br><span class="line">batchArgs2.add(o3);</span><br><span class="line">batchArgs2.add(o4);</span><br><span class="line">service.batchUpdate(batchArgs2);</span><br></pre></td></tr></table></figure>

<h3 id="JDBCTemplate操作数据库（批量删除操作）"><a href="#JDBCTemplate操作数据库（批量删除操作）" class="headerlink" title="JDBCTemplate操作数据库（批量删除操作）"></a>JDBCTemplate操作数据库（批量删除操作）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchDelete</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from user_db where user_id=?&quot;</span>;</span><br><span class="line">    <span class="type">int</span>[] update = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">    System.out.println(<span class="string">&quot;批量删除影响行数：&quot;</span>+ Arrays.toString(update));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自建List</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Object[] o5= &#123;<span class="number">17</span>&#125;;</span><br><span class="line">Object[] o6 = &#123;<span class="number">18</span>&#125;;</span><br><span class="line">batchArgs3.add(o5);</span><br><span class="line">batchArgs3.add(o6);</span><br><span class="line">service.batchDelete(batchArgs3);</span><br></pre></td></tr></table></figure>

<h2 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9"></a>Day 9</h2><h3 id="事务操作-事务概念"><a href="#事务操作-事务概念" class="headerlink" title="事务操作-事务概念"></a>事务操作-事务概念</h3><p>1、什么是事务？</p>
<p>事务是数据库操作的最基本单元，逻辑上的一组操作，要么都成功，要么都失败。</p>
<p>2、事务的四个特性：ACID：原子性、一致性、隔离性、持久性。</p>
<h3 id="事务操作-搭建事务操作环境"><a href="#事务操作-搭建事务操作环境" class="headerlink" title="事务操作-搭建事务操作环境"></a>事务操作-搭建事务操作环境</h3><p>场景：转账环境</p>
<p>javaee有三层：web层、service业务逻辑层、dao对数据库操作层不写业务操作。</p>
<p>dao层创建两个方法：（1）少钱的方法（2）多钱的方法。</p>
<p>service层创建方法：转账方法中调用dao的两个方法。</p>
<p>1.创建数据库表，添加记录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `acount`(</span><br><span class="line">   `id` int unsigned NOT NULL,</span><br><span class="line">   `username` varchar(100) NOT NULL,</span><br><span class="line">   `money` bigint NOT NULL,</span><br><span class="line">   PRIMARY KEY(`id`)</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;acount&#x27;;</span><br><span class="line"></span><br><span class="line">insert into acount values(1, &quot;liu&quot;, 1000);</span><br><span class="line">insert into acount values(2, &quot;hao&quot;, 1000);</span><br></pre></td></tr></table></figure>

<p>2.创建service，搭建dao，完成对象创建和注入关系。</p>
<p>service注入dao，在dao注入JdbcTemplate，在JdbcTemplate注入DataSource。</p>
<p>service类，使用注解@Service方式创建对象，@Autowired注入dao。同样在dao用@Autowired注入jdbc。</p>
<p>3.在dao中创建两个方法，多钱addMoney和少钱reduceMoney的方法，在service中创建方法，转账的方法。dao中用update方法。</p>
<p>4.测试</p>
<p>5.发现问题，如果先执行完dao中的第一个方法，发生异常，第二个方法将不执行，产生数据异常。如何解决？使用事务。</p>
<p>在service的方法中，try catch捕获异常。首先开启事务，然后进行事务操作，没有发现异常则提交事务，出现异常则事务回滚。</p>
<h3 id="事务操作-Spring事务管理介绍"><a href="#事务操作-Spring事务管理介绍" class="headerlink" title="事务操作-Spring事务管理介绍"></a>事务操作-Spring事务管理介绍</h3><p>1.事务管理加到哪个层？建议加到业务逻辑层service。</p>
<p>2.在Spring进行事务管理操作</p>
<p>（1）有两种方式：编程式事务管理和声明式事务管理（一般使用声明式）</p>
<p>编程式指的是用代码实现第一步第二步第三步。。。try catch捕获异常之类的。</p>
<p>3.声明式事务管理两种方式</p>
<p>（1）基于注解方式（使用）</p>
<p>（2）基于xml配置文件方式</p>
<p>4.在Spring进行声明式事务管理，底层使用AOP。</p>
<p>5.Spring事务管理API</p>
<p>提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类。</p>
<p>PlatformTransactionManager接口。DatasourceTransactionManager实现类针对jdbc。</p>
<h3 id="事务操作-注解声明式事务管理"><a href="#事务操作-注解声明式事务管理" class="headerlink" title="事务操作-注解声明式事务管理"></a>事务操作-注解声明式事务管理</h3><p>1.在spring配置文件中配置事务管理器。本质上就是创建PlatformTransactionManager接口实现类的对象。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入DataSource数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.在spring配置文件中，开启事务注解</p>
<p>（1）在Spring配置文件中引入名称空间tx. <code>xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</code></p>
<p>（2）开启事务注解</p>
<p><code>&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;</code></p>
<p>3.在service类上面（或者service类里面的方法上面）添加注解 @Transactional</p>
<p>如果添加到类上面，表示这个类里的所有方法都添加事务。</p>
<h3 id="事务操作-声明式事务管理参数配置"><a href="#事务操作-声明式事务管理参数配置" class="headerlink" title="事务操作-声明式事务管理参数配置-"></a>事务操作-声明式事务管理参数配置-</h3><p>1.在service类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数。</p>
<p><strong>第一个参数</strong>：propagation 表示事务传播行为，多事务方法直接进行调用，这个过程中事务是如何进行管理的。</p>
<p>事务方法：对数据库表数据进行变化的操作。</p>
<p>Spring框架事务传播行为有七种，列出最常见的两种：<br>（1）required：add方法中有事务，update没有，add方法内调用update方法，则update方法使用add方法内的事务。如果add方法没有事务，调用update方法之后，add创建一个新的事务，并在事务内运行。也是默认的传播行为。</p>
<p>（2）required_new：使用add方法调用update方法，无论add方法是否有事务，add方法都会新建一个事务。</p>
<p><strong>第二个参数</strong>：ioslation 表示事务隔离级别</p>
<p>事务的隔离性：多事务操作之间不会产生影响。有三个读的问题：脏读、不可重复读、虚（幻）读。</p>
<p>脏读：多个事物之间，一个未提交的事务读取到另一个未提交的事务。例如两个人都要操作一条记录，原来1000，事务a改了这条记录，变为2000，事务b读取到事务a修改的2000，但是事务a回滚了。算是一个致命问题，不能出现。</p>
<p>不可重复读：一个未提交的事务读取到另一个提交事务修改的数据。例如，事务a读取到原数据100，事务b读取到原数据100，并将其修改为200，事务b提交，事务a读取到数据200，这样事务b对事务a产生了影响。是一种现象，不能算作问题。</p>
<p>幻读：一个未提交事务读取到另一个提交事务添加数据。</p>
<p>通过设置隔离级别可以解决上述问题。read uncommitted 读未提交；read committed 读已提交；repeatable read 可重复读（默认的）；serializable 串行化。</p>
<p><strong>第三个参数</strong>：timeout 表示事务超时时间，事务需要在一定时间内提交，超时不提交则进行回滚。默认值是 -1，不超时。设置时间是以秒为单位。</p>
<p><strong>第四个参数</strong>：readOnly 是否只读，读是查询操作，readOnly默认为false，表示可以查询可以添加修改删除，设置为true，则只能查询。</p>
<p><strong>第五个参数</strong>：rollbackFor 回滚，设置出现哪些异常进行事务回滚。</p>
<p><strong>第六个参数</strong>：noRollbackFor 不回滚，设置出现哪些异常不进行事务回滚。</p>
<h3 id="事务操作-xml声明式事务管理"><a href="#事务操作-xml声明式事务管理" class="headerlink" title="事务操作-xml声明式事务管理"></a>事务操作-xml声明式事务管理</h3><p>1.在Spring配置文件中进行配置。</p>
<p>第一步 配置事务管理器</p>
<p>第二步 配置通知，aop中增强的那部分，这里就是事务。</p>
<p>第三步 配置切入点和切面，要将事务加到哪个类的哪个方法中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.创建事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入DataSource数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启事务注解， xml方式中 不需要了</span></span><br><span class="line"><span class="comment">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2.配置通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txadvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务的一些相关参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定哪种规则的方法上面添加事务，例如 add* 表示add开头的添加事务 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;jiaoyi&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3.配置切入点和切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切入点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;qierudiansname&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.company.service.UserService.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切入点, 将事务的通知设置到上面的切入点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;qierudiansname&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看出，事务的底层使用aop实现。</p>
<p>测试时，把注解注释掉。</p>
<h3 id="事务操作-完全注解声明式事务管理"><a href="#事务操作-完全注解声明式事务管理" class="headerlink" title="事务操作-完全注解声明式事务管理"></a>事务操作-完全注解声明式事务管理</h3><p>1.创建配置类，使用配置类替代xml配置文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.company&quot;)</span>  <span class="comment">//开启组件扫描</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span>  <span class="comment">//开启事务注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxConfig</span> &#123;</span><br><span class="line">    <span class="comment">//创建数据库连接池</span></span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">//配置文件中就是在ioc容器中创建一个bean实例 写方法返回一个DataSource德鲁伊连接池对象</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">getDuridDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/b_jdbc?serverTimezone=UTC&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//创建jdbc模版对象</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">getJdbcTemplate</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        <span class="comment">//需要注入datasSurce, xml中是使用set方法进行配置注入的</span></span><br><span class="line">        <span class="comment">//set方法里面如果用上面的getDuridDataSource方法，就会创建两个对象</span></span><br><span class="line">        <span class="comment">//使用参数方法，可以在ioc容器中根据类型找到对象进行注入，就像@autowired根据类型自动装配</span></span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建事务管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">getDataSourceTransactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">dataSourceTransactionManager</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        dataSourceTransactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> dataSourceTransactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.测试时，开启注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wanquanzhujietrans</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.加载配置类</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(TxConfig.class);</span><br><span class="line">    <span class="comment">//2.获取配置创建的对象</span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    <span class="comment">//getBean的第一个参数表示bean的名称，xml配置文件中的id，如果是注解创建，则小写第一位</span></span><br><span class="line">    service.jiaoyi();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际开发中，用springboot进行开发，替代spring基础上的完全注解开发，springboot是对spring做的封装。</p>
<h2 id="总结-未完"><a href="#总结-未完" class="headerlink" title="总结&amp;&amp;未完"></a>总结&amp;&amp;未完</h2><p>1.Spring框架概述</p>
<p>（1）轻量级开源JavaEE框架，为了解决企业复杂性。两个核心组成部分：ioc、aop。</p>
<p>（2）Spring5.2.6版本</p>
<p>2.IOC容器</p>
<p>（1）IOC底层原理：xml配置文件、工厂、反射等</p>
<p>（2）IOC接口（BeanFactory）</p>
<p>（3）bean管理操作：基于xml进行对象创建注入属性；基于注解进行对象创建注入属性</p>
<p>3.AOP</p>
<p>（1）AOP底层原理：动态代理，有接口（JDK动态代理），没有接口（CGLIB动态代理）</p>
<p>（2）术语：切入点、增强（通知）、切面</p>
<p>（3）基于AspectJ实现AOP操作：基于注解方式；基于配置文件</p>
<p>4.JdbcTemplate</p>
<p>（1）使用JdbcTemplate对数据库的curd操作</p>
<p>（2）使用JdbcTemplate实现数据库批量操作</p>
<p>5.事务操作</p>
<p>（1）事务概念</p>
<p>（2）重要概念（传播行为和隔离级别）</p>
<p>（3）基于注解实现声明式事务管理</p>
<p>（4）基于xml配置文件实现事务管理</p>
<p>（5）完全注解方式实现事务管理</p>
<p>6.Spring5新特性：</p>
<p>（1）整合日志框架</p>
<p>（2）@Nullable注解</p>
<p>（3）函数式注册对象</p>
<p>（4）整合JUnit5单元测试框架</p>
<p>（5）SpringWebflux使用</p>
<p><a href="https://www.bilibili.com/video/BV1Vf4y127N5?p=49&spm_id_from=pageDriver">https://www.bilibili.com/video/BV1Vf4y127N5?p=49&amp;spm_id_from=pageDriver</a></p>
<h2 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h2><p>b_study中。</p>
<p>xml：基于xml配置文件实现控制反转，管理bean对象，创建对象，依赖注入（注入属性）。</p>
<p>zhujie：基于注解的bean管理。</p>
<p>aop：面向切面编程</p>
<p>jdbc：操作数据库</p>
<p>transaction：事务相关</p>
<hr>
<p><em><strong>学习笔记，侵权请联系，一定立刻删除。</strong></em></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring aop总结</title>
    <url>/2022/04/09/myblog/spring/spring-aop/</url>
    <content><![CDATA[<p>工作中遇到个aop的问题，jdk代理换cglib代理还不过来，以及jdk代理存在的一个问题。总结并实战一下。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="aop相关术语"><a href="#aop相关术语" class="headerlink" title="aop相关术语"></a>aop相关术语</h4><ul>
<li>Target：代理的目标对象</li>
<li>Proxy：代理对象</li>
<li>Joinpoint：连接点，指那些被拦截到的点。在Spring中，这些点指方法，因为Spring只支持方法类型的连接点（可以被增强的方法）</li>
<li>Pointcut：切入点是指我们要对哪些Joinpoint进行拦截的定义</li>
<li>Advice：（通知&#x2F;增强）是指拦截到Joinpoint之后要做的事情就是通知</li>
<li>Aspect：切面是切入点和通知（增强）的结合</li>
<li>Weaving：织入实质把将切点和增强结合的过程是织入过程，Spring是动态代理织入，AspectJ是采用编译期织入和类装载期织入</li>
</ul>
<p>*连接点是可以被增强的方法，切点是实际上被增强过的方法，连接点范围更大</p>
<h4 id="aop开发过程"><a href="#aop开发过程" class="headerlink" title="aop开发过程"></a>aop开发过程</h4><ol>
<li><p>编写核心业务代码（Target的目标方法-切点）</p>
</li>
<li><p>编写切面类，切面类中有通知（增强功能方法）</p>
</li>
<li><p>在配置文件&#x2F;注解当中，配置织入关系，即将那些通知与哪些连接点进行结合</p>
</li>
</ol>
<p>AOP技术实现的内容：<br>Spring框架会监控切入点方法的执行–通过配置文件决定哪些方法是切点；一旦监控到切入点方法被运行，即使用代理机制，动态创建目标对象（切点）的代理对象。然后根据配置文件配置的增强类型（通知），在代理对象（切点）对应的位置，将通知对应的功能织入，完成完整的代码逻辑运行。<br>配置文件-执行切点方法-监控到并动态创建代理对象，调用代理对象同名方法-内部调用目标方法，进行增强方法的介入。</p>
<p>AOP底层使用哪种代理方式：<br>Spring会根据目标类是否实现了接口来决定采用哪种动态代理。</p>
<h3 id="实践-配置文件"><a href="#实践-配置文件" class="headerlink" title="实践-配置文件"></a>实践-配置文件</h3><p>新建个spring项目</p>
<ol>
<li><p>导入相关依赖：spring-context、spring-core、spring-beans，还有切面的包 Aspectjweaver</p>
</li>
<li><p>新建service接口，新建实现类Impl</p>
</li>
<li><p>新建切面类，定义切面方法</p>
</li>
<li><p>编写配置文件</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启注解扫描  --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.aop.demo&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;aop:config proxy-target-class=&quot;false&quot;&gt;</span><br><span class="line">    &lt;aop:pointcut id=&quot;userServiceImplPointcut&quot; expression=&quot;execution(* com.aop.demo.UserServiceImpl.addUser(..))&quot; /&gt;</span><br><span class="line">    &lt;aop:aspect id=&quot;aopClass&quot; ref=&quot;aopMethods&quot;&gt;</span><br><span class="line">        &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;userServiceImplPointcut&quot; /&gt;</span><br><span class="line">        &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;userServiceImplPointcut&quot; /&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>测试方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AopTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void testUserServiceAop()&#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-aop.xml&quot;);</span><br><span class="line">        // proxy-target-class=&quot;false&quot; 时，使用jdk代理</span><br><span class="line">        // 强制转换必须用父类接口来定义</span><br><span class="line">        UserService userService = (UserService)context.getBean(&quot;userServiceImpl&quot;);</span><br><span class="line">        userService.addUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️ proxy-target-class&#x3D;”false” 或默认表示使用jdk代理，获取对象需要用父类接口，用实现类会报<code>java.lang.ClassCastException: com.sun.proxy.$Proxy* cannot be cast to***</code> 的错误。</p>
<p>⚠️ proxy-target-class&#x3D;”true”时，使用cglib代理，使用父类接口也可以，使用实现类定义对象也可以。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//UserService userService = (UserService)context.getBean(&quot;userServiceImpl&quot;);</span><br><span class="line">UserServiceImpl userService = (UserServiceImpl)context.getBean(&quot;userServiceImpl&quot;);</span><br><span class="line">userService.addUser();</span><br></pre></td></tr></table></figure>

<p>⚠️ 另外，还有个现象是在jdk代理时存在的bug：<br>原本的： <code>UserService userService = (UserService)context.getBean(&quot;userServiceImpl&quot;);</code> 可以获得bean，没问题。<br>但是： <code>UserService userService = (UserService)context.getBean(UserServiceImpl.class);</code>  通过类的全路径获得bean就会出现<code>No qualifying bean of type</code> 的问题。<br>总结：jdk代理方式不用实现类，所以也不会用实现类的bean，即使配了实现类的bean，也不行。</p>
<p>原因：spring aop默认是使用jdk动态代理的，也就是我通过getBean(ServiceImpl.class)，表达出的意思是希望程序通过jdk动态代理给我一个ServiceImpl类。而jdk的动态代理是基于接口实现的，因为它本身要继承一个Proxy类，而java是单继承（接口可以多继承），所以它通过实现接口进行代理。它通过实现我们给它的接口和继承Proxy类实现jdk动态代理。而我们给它的是一个ServiceImpl类，这个时候jdk动态代理就没有办法了。<br>jdk动态代理产生的对象属于Proxy类型，属于给定的接口（Service）类型，但不属于我们要代理的那个对象的类型，也就是本代码中ServiceImpl类型<br>因此，使用接口的类路径：<code>UserService userService = (UserService)context.getBean(UserService.class);</code> 也是可以的。这也解释了工作中遇到的问题。<br>但是，换成cglib，实现类&#x2F;父类接口，获取bean的方式：id&#x2F;类路径，都可以，没解释工作中为什么不能直接换成cglib的问题。</p>
<p>总结：<br>jdk代理：必须父类接口获得bean，括号内可以是实现类的bean id，也可以是父类接口的全路径。<br>cglib代理：怎么都行。</p>
<h3 id="实践-注解"><a href="#实践-注解" class="headerlink" title="实践-注解"></a>实践-注解</h3><ol>
<li><p>使用@Aspect注解，出了aspectweaver包之外，还需要aspectjrt包</p>
</li>
<li><p>新建service接口，新建实现类Impl</p>
</li>
<li><p>新建切面类，定义切面方法</p>
</li>
<li><p>编写配置类</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &#123;&quot;com.aop.demo.zhujie&quot;&#125;)</span><br><span class="line">@EnableAspectJAutoProxy(proxyTargetClass = false)</span><br><span class="line">public class SpringCfg &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>测试</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = new AnnotationConfigApplicationContext(SpringCfg.class);  //加载配置类</span><br></pre></td></tr></table></figure>

<p>效果和配置文件一样。</p>
<h3 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h3><p><a href="https://github.com/jadeliuliu/aop-demo">https://github.com/jadeliuliu/aop-demo</a></p>
<p>参考：<br>知识点：<br><a href="https://www.cnblogs.com/Zhang-DevelopingPlatform/p/14723490.html">https://www.cnblogs.com/Zhang-DevelopingPlatform/p/14723490.html</a></p>
<p>jdk代理找不到bean：<a href="https://blog.csdn.net/qq_32080243/article/details/90261768">https://blog.csdn.net/qq_32080243/article/details/90261768</a></p>
<p>cglib实现：<a href="https://blog.csdn.net/shaoweijava/article/details/76474652">https://blog.csdn.net/shaoweijava/article/details/76474652</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot学习</title>
    <url>/2022/12/22/myblog/spring/springboot%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="springboot创建工程"><a href="#springboot创建工程" class="headerlink" title="springboot创建工程"></a>springboot创建工程</h2><p>微服务体系下不可或缺。<br>ssm(spring+springMvc+mybatis) -&gt; springboot -&gt; springcloud</p>
<p>springboot：约定优于配置，不用专注于配置。2014年发布。</p>
<p>springboot的位置：是spring的顶级项目，和springFramework(ioc、aop)是同等级的。</p>
<p>springboot使用最小配置快速构建spring项目。springboot不是spring功能上的增强，而是提供一种快速开发spring项目的方式。</p>
<p>spring缺点：<br>&lt;1&gt; 写配置文件，繁琐<br>&lt;2&gt; 依赖繁琐，maven坐标版本问题</p>
<p>springboot提供的优点：<br>&lt;1&gt; 自动配置，应用程序启动时的过程<br>&lt;2&gt; 起步依赖，坐标pom打包到一起，对其他库的依赖传递<br>&lt;3&gt; 其他：嵌入式服务器，安全，健康检测</p>
<hr>
<p>✅ 用springboot搭建一个web项目：<br>&lt;1&gt; 创建maven项目<br>&lt;2&gt; 引入起步依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--springboot工程需要继承的父工程   --&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.1&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--  web开发的起步依赖  --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>&lt;3&gt; 写一个controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.liuxuan.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-12-22 23:28</span><br><span class="line"> **/</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/h&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;hello!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;4&gt; 写引导类，springboot项目入口，然后运行main方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.liuxuan;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-12-22 23:38</span><br><span class="line"> **/</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class StartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(StartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>✅ 快速构建</p>
<p>用idea，选Spring Initializr，选maven project，选jar打包方式，勾选依赖。</p>
<h2 id="springboot起步依赖"><a href="#springboot起步依赖" class="headerlink" title="springboot起步依赖"></a>springboot起步依赖</h2><p>spring-boot-starter-parent，往里看源码，最终是spring-boot-dependency包，其中pom文件中<code>&lt;dependencyManagement&gt;</code> 是版本锁定，父工程中定义的版本信息，自己工程中就可以不写版本号。</p>
<p>spring-boot-starter-web，往里看，发现引入了spring-web、spring-webmvc。</p>
<p>总结：<br>1.在spring-boot-starter-parent中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。<br>2.在各种starter中，定义了完成该功能的坐标合集，其中大部分版本信息来自于父工程。<br>3.我们工程继承自parent，引入starter，通过依赖传递，就可以简单方便获取需要的jar包，并且不会存在版本冲突问题。</p>
<h2 id="springboot配置"><a href="#springboot配置" class="headerlink" title="springboot配置"></a>springboot配置</h2><p>配置文件分类：properties文件、yaml&#x2F;yml文件。<br>profile文件，三种环境动态切换。</p>
<p>springboot基于约定，配置有默认值，替换的话，用application.properties&#x2F;application.yml文件来配置。resource根目录下，application.properties&#x2F;yml&#x2F;yaml 文件里面放程序自动识别的内容，也可以写自己定义的内容。</p>
<p>同一级目录下，配置文件的加载顺序：properties &gt; yml &gt; yaml</p>
<p>yaml：不是一个标记语言，是直观的能被电脑识别的数据序列化格式，以数据为核心，比xml更加简洁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xml:</span><br><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;port&gt;8080&lt;/port&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line"></span><br><span class="line">yml:</span><br><span class="line">server:</span><br><span class="line">    port: 8080</span><br><span class="line"></span><br><span class="line">properties:</span><br><span class="line">server.port=8080</span><br></pre></td></tr></table></figure>

<p>yaml语法：大小写敏感、数据值前必须有空格（至少一个）、缩进表示层级关系，缩进空格个数不重要，但要左对齐、#注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line"></span><br><span class="line">person:</span><br><span class="line">  name: liu</span><br><span class="line">  address: [beijing, shanghai]</span><br><span class="line"></span><br><span class="line">msg1: &quot;hello \n world&quot;  #双引号识别转义字符</span><br><span class="line">msg2: &#x27;hello \n world&#x27;  #单引号原样输出</span><br><span class="line"></span><br><span class="line">参数引用：$&#123;name&#125;</span><br></pre></td></tr></table></figure>


<p>读取配置文件内容：</p>
<p>1.@Value方法，单个属性注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Value(&quot;$&#123;person.name&#125;&quot;)</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">@Value(&quot;$&#123;person.address[0]&#125;&quot;)</span><br><span class="line">private String address;</span><br></pre></td></tr></table></figure>

<p>2.Environment</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private Environment env;    </span><br><span class="line"></span><br><span class="line">env.getProperty(&quot;person.name&quot;)</span><br></pre></td></tr></table></figure>

<p>3.@ConfigurationProperties，对象和配置的绑定</p>
<p>在实体类Person上加注解 <code>@ConfigurationProperties(prefix=&quot;person&quot;)</code></p>
<hr>
<p>profile：一套程序通常需要部署在不同的环境下，开发测试生产，如果每次打包都要修改配置文件，麻烦，profile提供进行动态配置切换的方式。</p>
<p>配置方式：<br>1.多profile文件方式：提供多个配置文件，每个代表一个环境<br>application-dev.properties&#x2F;yml<br>application-test.properties&#x2F;yml<br>application-pro.properties&#x2F;yml</p>
<p>2.yml单文件方式<br>用—分割不同环境配置</p>
<p>激活方式：<br>1.配置方式：<br><code>spring.profiles.active=dev</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    profiles:</span><br><span class="line">        active: dev</span><br></pre></td></tr></table></figure>

<p>2.虚拟机参数<br>在VM option中输入：<code>-Dspring.profiles.active=test</code></p>
<p>3.命令行参数<br>先package打包<br><code>java -jar ...jar --spring.profiles.active=test</code></p>
<hr>
<p>打包过程中，遇到：jar中没有主清单属性</p>
<p>原因：打包后的jar文件中的MANIFEST.MF缺少项目启动项，即没有Main-Class</p>
<p>解决方案：<br>1、指定MANIFEST.MF路径<br>项目打包前：<br>第一步 file–&gt;project structure 弹框后选中Atifacts—&gt; + —-&gt;jar—-&gt;from module with dependenceis<br>第二步 选择一个Main Class，选的StartApplication文件</p>
<p>2、项目pom.xml文件中添加插件spring-boot-maven-plugin</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>内部配置加载顺序：</p>
<p>1.项目根目录下的config文件夹下<br>2.项目根目录（idea点project files的根目录）下<br>3.classPath（resource目录下）的config文件夹下<br>4.classPath（resource目录下）下</p>
<p>前两个不会打进jar包里</p>
<hr>
<p>外部配置加载顺序：</p>
<p>1.命令行指定端口号：<code>java -jar spring-boot-study-api-1.0-SNAPSHOT.jar --server.port=8086</code><br>指定默认前缀路径：<code>--server.servlet.context-path=/default</code><br>2.指定外部配置文件路径：<code>--spring.config.location=路径</code><br>3.在jar包同目录下（target文件夹下），加一个配置文件<code>application.properties</code>，同样生效，外部配置优先生效</p>
<h2 id="springboot整合其他框架"><a href="#springboot整合其他框架" class="headerlink" title="springboot整合其他框架"></a>springboot整合其他框架</h2><h3 id="springboot整合Junit"><a href="#springboot整合Junit" class="headerlink" title="springboot整合Junit"></a>springboot整合Junit</h3><p>1.引入spring-boot-starter-test 起步依赖<br>2.在测试类上加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class) //springboot2不用加</span><br><span class="line">@SpringBootTest(classes = StartApplication.class) //如果与StartApplication在一个包下，可以不加括号里的</span><br></pre></td></tr></table></figure>


<h3 id="springboot整合redis"><a href="#springboot整合redis" class="headerlink" title="springboot整合redis"></a>springboot整合redis</h3><p>1.引入spring-boot-starter-data-redis依赖<br>2.连接本地的redis，不需要任何配置<br>3.直接用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">redisTemplate.boundValueOps(&quot;name&quot;).set(&quot;liu&quot;);</span><br><span class="line">Object o = redisTemplate.boundValueOps(&quot;name&quot;).get();</span><br></pre></td></tr></table></figure>
<p>4.其他ip的，需要配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    port: 6379</span><br></pre></td></tr></table></figure>


<h3 id="spring整合mybatis"><a href="#spring整合mybatis" class="headerlink" title="spring整合mybatis"></a>spring整合mybatis</h3><p>1.引入mybatis起步依赖 <code>mybatis-spring-boot-starter</code> （不同于其他，这个是mybatis提供的，用3.0.1的有点问题，改用2.1.0），添加mysql驱动 <code>mysql-connector-java</code><br>2.配置datasource和mybatis</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql:///test?serverTimezone=UTC</span><br><span class="line">    #db.url=jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    username: liuxuan</span><br><span class="line">    password: jade</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>
<p>3.创建表，并编写实体类<br>4.纯注解开发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">@Repository</span><br><span class="line">public interface StudentMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from student&quot;)</span><br><span class="line">    public List&lt;Student&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5 .xml映射文件形式开发<br>Mapper接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">@Repository</span><br><span class="line">public interface StudentXmlMapper &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;Student&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xml配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.liuxuan.repository.mapper.StudentXmlMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.liuxuan.repository.domain.Student&quot;</span>&gt;</span></span><br><span class="line">        select * from student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>增加mybatis配置(不在spring下)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  # Mapper映射文件路径</span><br><span class="line">  mapper-locations: classpath:mapper/*Mapper.xml</span><br><span class="line">  # 包扫描</span><br><span class="line">  type-aliases-package: com.liuxuan.repository.domain</span><br></pre></td></tr></table></figure>


<h2 id="springboot原理分析"><a href="#springboot原理分析" class="headerlink" title="springboot原理分析"></a>springboot原理分析</h2><h3 id="springboot自动配置"><a href="#springboot自动配置" class="headerlink" title="springboot自动配置"></a>springboot自动配置</h3><p>Condition是spring4.0增加的条件判断功能，可以实现选择性地创建Bean操作。</p>
<h4 id="✅需求1-创建bean增加条件"><a href="#✅需求1-创建bean增加条件" class="headerlink" title="✅需求1:创建bean增加条件"></a>✅需求1:创建bean增加条件</h4><p>1.自定义条件类，继承Condition接口，实现matches方法，方法中进行逻辑判断，参数context可以获取上下文容器等，metadata可以获取注解属性。<br>2.判断条件，初始化bean时使用@Conditional(条件类.class)注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要加注解@Conditional：</span><br><span class="line">@Configuration</span><br><span class="line">public class UserConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @Conditional(ClassCondition.class)</span><br><span class="line">    public User user() &#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">自己定义一个实现了Condition接口的类，里面实现条件判断matches方法：</span><br><span class="line">public class ClassCondition implements Condition &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        // 写创建bean的条件：导入jedis坐标后创建bean</span><br><span class="line">        try &#123;</span><br><span class="line">            Class cls = Class.forName(&quot;redis.clients.jedis.Jedis&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">获取bean：</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class StartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 启动springboot应用，获取spring的ioc容器</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br><span class="line"></span><br><span class="line">        // 获取bean</span><br><span class="line">        Object user = context.getBean(&quot;user&quot;);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="✅需求2-用自定义注解实现动态Condition"><a href="#✅需求2-用自定义注解实现动态Condition" class="headerlink" title="✅需求2:用自定义注解实现动态Condition"></a>✅需求2:用自定义注解实现动态Condition</h4><p>定义自定义注解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Conditional(ClassCondition.class)</span><br><span class="line">public @interface ConditionOnClass &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Config中加注解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class UserConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">//    @Conditional(ClassCondition.class)</span><br><span class="line">    @ConditionOnClass(&quot;redis.clients.jedis.Jedis&quot;)</span><br><span class="line">    public User user() &#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承Condition接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ClassCondition implements Condition &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param context  上下文对象。用于获取环境、Ioc容器、classLoader对象</span><br><span class="line">     * @param metadata 注解元对象，可以用于获取注解定义的属性值</span><br><span class="line">     * @return boolean</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        // 需求1：写创建bean的条件：导入jedis坐标后创建bean</span><br><span class="line">//        try &#123;</span><br><span class="line">//            Class cls = Class.forName(&quot;redis.clients.jedis.Jedis&quot;);</span><br><span class="line">//        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">//            return false;</span><br><span class="line">//        &#125;</span><br><span class="line">//        return true;</span><br><span class="line"></span><br><span class="line">        // 需求2：通过注解属性值value指定坐标后创建bean</span><br><span class="line">        Map&lt;String, Object&gt; map = metadata.getAnnotationAttributes(ConditionOnClass.class.getName());</span><br><span class="line">        String[] value = (String[])map.get(&quot;value&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            for (String className : value) &#123;</span><br><span class="line">                Class&lt;?&gt; cls = Class.forName(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看包spring-boot-anto-configuration中，springboot已经定义好了很多condition注解，例如：@ConditionalOnClass。</p>
<hr>
<h4 id="✅切换内置服务器"><a href="#✅切换内置服务器" class="headerlink" title="✅切换内置服务器"></a>✅切换内置服务器</h4><p>spring-boot-starter-web</p>
<p>spring-boot-autoconfiguration 包的web的embedded中内置了四种服务器，包括jetty、netty、tomcat、undertom。</p>
<p>里面还有个类负责选择web服务器，原理也是用了@ConditionalOnClass注解，看导入了什么坐标来选择服务器。</p>
<p>用<exclusions> 把spring-boot-starter-web 中的 spring-boot-starter-tomcat 排除掉。再引入jetty的依赖，就会切换为jetty服务器。</p>
<hr>
<h4 id="✅-Enable-注解"><a href="#✅-Enable-注解" class="headerlink" title="✅ @Enable*注解"></a>✅ @Enable*注解</h4><p>SpringBoot提供了很多@Enable开头的注解，用于动态启动某些功能(获取一些bean)，其底层原理是使用@Import注解导入一些配置类，实现Bean的动态加载。</p>
<p>看注解 @SpringBootApplication</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration --内部@Configuration可配置bean</span><br><span class="line">@EnableAutoConfiguration --重点</span><br><span class="line">@ComponentScan(   --包扫描</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public @interface SpringBootApplication</span><br><span class="line"></span><br><span class="line">其中Enable注解下：</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">重要的是Import注解</span><br></pre></td></tr></table></figure>

<p>⚠️启动子模块的启动类，无法启动父工程的controller。</p>
<p>springboot工程不可以直接获取其他jar包中定义的bean，比如redisTemplate。</p>
<p>原因：@ComponentScan 包扫描的范围是：当前引导类所在包及其子包，其他项目配置Bean的包不在该范围内。</p>
<p>尝试：另外创建一个子模块，子模块引入另一个子模块的pom，然后尝试获取另一个子模块的bean。<br>报错：NoSuchBeanDefinitionException。</p>
<p>如何获取Bean：<br>1.在启动类上加@ComponentScan注解，扫描要引入Bean的包。<br>缺点：要写包太累赘<br>2.使用@Import注解加载要导入bean的配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Import &#123;</span><br><span class="line">    Class&lt;?&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>value中的这些类会被spring创建并放入IOC容器中。<br>缺点：要记类的名字<br>3.对Import注解进行封装<br>自定义一个Enable注解，把Import注解封装进去，要想用这个bean的时候，直接用Enable注解就可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Import(UserConfig.class)</span><br><span class="line">public @interface EnableUser &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) //排除此类的AutoConfig</span><br><span class="line">//@ComponentScan(&quot;com.liuxuan.condition&quot;)</span><br><span class="line">//@Import(UserConfig.class)</span><br><span class="line">@EnableUser</span><br><span class="line">public class StartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 启动springboot应用，获取spring的ioc容器</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br><span class="line"></span><br><span class="line">        // 获取bean</span><br><span class="line">        Object user = context.getBean(&quot;user&quot;);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>😊<code>@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class&#125;)</code></p>
<p>exclude，排除此类的AutoConfig，即禁止 SpringBoot 自动注入数据源配置。</p>
<p>DataSourceAutoConfiguration.class 会自动查找 application.yml 或者 properties 文件里的 spring.datasource.* 相关属性并自动配置单数据源「注意这里提到的单数据源」。</p>
<p>那么问题来了，排除了自动配置，Spring还怎么识别到数据库配置呢？</p>
<p>答：显然接下来就需要手动配置，如果你发现项目中存在这个排除的操作，可以在项目中搜一下Java关键字@ConfigurationProperties(“spring.datasource)，你可能会发现手动配置数据源的类。</p>
<p>再来回答为何要手动配置数据源，因为要配置多数据源，上边有提到DataSourceAutoConfiguration.class默认会帮我们自动配置单数据源，所以，如果想在项目中使用多数据源就需要排除它，手动指定多数据源。</p>
<p>@SpringBootApplication注解中exclude参数使用及原理:<br><a href="https://blog.csdn.net/csdn_20150804/article/details/116104742">https://blog.csdn.net/csdn_20150804/article/details/116104742</a></p>
<h4 id="✅-Import注解"><a href="#✅-Import注解" class="headerlink" title="✅ @Import注解"></a>✅ @Import注解</h4><p>@Enable*底层依赖@Import注解导入一些类，使用@Import导入的类会被Spring加载到IOC容器中，@Import提供四种用法：</p>
<p>1.导入Bean</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StartApplication上：</span><br><span class="line">@Import(User.class)</span><br><span class="line"></span><br><span class="line">StartApplication中：</span><br><span class="line">// 根据类型获取bean</span><br><span class="line">Object user = context.getBean(User.class);</span><br><span class="line">System.out.println(user);</span><br><span class="line">// 获取bean名称</span><br><span class="line">Map&lt;String, User&gt; map = context.getBeansOfType(User.class);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>

<p>2.导入配置类<br>这种方式，配置类上的@Configuration注解可以不加</p>
<p>3.导入ImportSelect实现类。一般用于加载配置文件中的类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Import(MyImportSelector.class)</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">public class MyImportSelector implements ImportSelector &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        return new String[]&#123;&quot;com.liuxuan.condition.User&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.导入ImportBeanDefinitionRegistrar实现类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Import(MyImportBeanDefinitionRegistrar.class)</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(User.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(&quot;beanName&quot;, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="✅-EnableAutoConfiguration注解"><a href="#✅-EnableAutoConfiguration注解" class="headerlink" title="✅@EnableAutoConfiguration注解"></a>✅@EnableAutoConfiguration注解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableAutoConfiguration</span><br><span class="line"></span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line"></span><br><span class="line">AutoConfigurationImportSelector中：</span><br><span class="line">public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    if (!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        return NO_IMPORTS;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">        return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">核心代码：getAutoConfigurationEntry</span><br><span class="line">List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line"></span><br><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">    return configurations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">意思是：从spring-boot-autoconfiguration的jar包下面的META-INF/spring.factories文件中加载。</span><br><span class="line">看到这个文件中可以看到：</span><br><span class="line"> # Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">有很多配置文件类</span><br></pre></td></tr></table></figure>

<p>总结：<br>@EnableAutoConfiguration 如何实现自动配置<br>1.@EnableAutoConfiguration注解内部使用@Import({AutoConfigurationImportSelector.class}) 来加载配置类<br>2.配置文件位置：META-INF&#x2F;spring.factories，该配置文件中定义了大量的配置类，当springboot应用启动时，会自动加载这些配置类，初始化bean<br>3.并不是所有的bean都会被初始化，在配置类中使用Condition来加载满足条件的bean</p>
<h4 id="✅自定义starter实现"><a href="#✅自定义starter实现" class="headerlink" title="✅自定义starter实现"></a>✅自定义starter实现</h4><p>看mybatis-spring-boot-starter如何实现：<br>1.看到mybatis-spring-boot-starter包下没什么，只有一个pom文件，里面引入mybatis-spring-boot-autoconfigure包<br>2.mybatis-spring-boot-autoconfigure包的META-INF&#x2F;spring.factories文件中定义了MybatisAutoConfiguration<br>3.@EnableAutoConfiguration会自动识别到META-INF&#x2F;spring.factories文件，从而识别到MybatisAutoConfiguration，模块中初始化的bean就创建出来</p>
<p>需求：自定义redis-starter，当导入redis-starter坐标时，springboot自动创建jedis的bean。</p>
<p>1.创建一个redis-autoconfiguration模块，在里面提供jedis的bean，并实现自动配置。</p>
<p>⚠️亲测，一个模块的配置了8082端口，另一个模块没配置端口，但是运行该模块的StartApplication，要用的是8082端口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RedisAutoConfiguration.class:</span><br><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(RedisProperties.class) //RedisProperties被spring识别，创建bean</span><br><span class="line">@ConditionalOnClass(Jedis.class)  //疑问：没有Jedis坐标则不配置，创建之前不是没这个Bean吗？导入坐标和有bean的关系？</span><br><span class="line">public class RedisAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(name = &quot;jedis&quot;)  //已经定义了就不定义</span><br><span class="line">    public Jedis getJedisBean(RedisProperties redisProperties) &#123;</span><br><span class="line">        System.out.println(&quot;RedisAutoConfiguration...&quot;);</span><br><span class="line">        return new Jedis(redisProperties.getIp(), redisProperties.getPort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RedisProperties.class:</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ConfigurationProperties(prefix = &quot;redis&quot;) //与配置文件中对应</span><br><span class="line">public class RedisProperties &#123;</span><br><span class="line">    private String ip = &quot;localhost&quot;; //没提供时给默认值</span><br><span class="line">    private Integer port = 6379;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建META-INF&#x2F;spring.factories文件，其中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">    com.liuxuan.redis.configuration.RedisAutoConfiguration</span><br></pre></td></tr></table></figure>

<p>3.创建redis-starter模块，pom文件中引入redis-configuration依赖。</p>
<p>4.在另一个模块中，pom文件中引入redis-starter依赖。在StartApplication中尝试获取bean。这个模块中导入了Jedis依赖，但是并没有Jedis的bean的配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br><span class="line">Jedis jedis = context.getBean(Jedis.class);</span><br><span class="line">System.out.println(jedis);</span><br><span class="line"></span><br><span class="line">jedis.set(&quot;hello&quot;, &quot;hi&quot;);</span><br><span class="line">System.out.println(jedis.get(&quot;hello&quot;));</span><br></pre></td></tr></table></figure>

<p>5.可以在使用的模块中进行配置redis的ip和host</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis.port=6379</span><br><span class="line">redis.ip=localhost</span><br></pre></td></tr></table></figure>

<p>总结：StartApplication上的@SpringBootApplication注解中的@EnableAutoConfiguration中的@Import({AutoConfigurationImportSelector.class})中会自动去找jar包中的META-INF&#x2F;spring.factories文件，识别到需要加载的配置类，再获取配置类创建的bean，从而实现自动配置bean。</p>
<p>看spring-boot-autoconfiguration包下的data下的redis下的文件中，就定义了RedisAutoConfiguration，和上面实现类似。</p>
<h3 id="springboot监听机制"><a href="#springboot监听机制" class="headerlink" title="springboot监听机制"></a>springboot监听机制</h3><p>springboot的监听机制，其实是对java提供的事件监听机制的封装。</p>
<p>java中的事件监听机制定义了以下几个角色：<br>1.事件：Event，继承java.util.EventObject类的对象<br>2.事件源：Source，任意对象Object<br>3.监听器：Listener，实现java.util.EventListener接口的对象</p>
<p>springboot不需要这么麻烦，springboot在项目启动时，会对几个监听器进行回调，我们可以实现这些监听器接口，在项目启动时完成一些操作。</p>
<p>ApplicationContextInitializer、SpringApplicationRunListener、CommandLineRunner、ApplicationRunner</p>
<p>1 .继承这些接口，重写方法，并打印对应操作，@Component注册bean。</p>
<p>2 .启动发现只有后两个有打印。<br>CommandLineRunner、ApplicationRunner在项目启动后执行run方法，可以帮助做一些事情，比如：缓存预热(提前把数据库的数据加到缓存)<br>打印这两个方法的args，发现是空数组，在配置中的environment中的program arguments中添加hello world，就会返回[hello, world]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyCommandLineRunner implements CommandLineRunner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;MyCommandLineRunner run...&quot;);</span><br><span class="line">        System.out.println(&quot;MyCommandLineRunner args:&quot; + Arrays.asList(args));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyApplicationRunner implements ApplicationRunner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(ApplicationArguments args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;MyApplicationRunner run...&quot;);</span><br><span class="line">        System.out.println(&quot;MyApplicationRunner args:&quot; + Arrays.asList(args.getSourceArgs()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3 .其他两个监听器怎么用：在META-INF&#x2F;spring.factories（固定的写法，工程启动时会被自动扫描到）中配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">  com.liuxuan.listener.MyApplicationContextInitializer</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">  com.liuxuan.listener.MySpringApplicationRunListener</span><br></pre></td></tr></table></figure>

<p>MyApplicationContextInitializer的initialize方法：项目还没有准备ioc容器之前，可以检测一些资源是否存在。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyApplicationContextInitializer implements ApplicationContextInitializer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void initialize(ConfigurableApplicationContext applicationContext) &#123;</span><br><span class="line">        System.out.println(&quot;MyApplicationContextInitializer project start..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>MySpringApplicationRunListener 报错：<code>java.lang.NoSuchMethodException: com.liuxuan.listener.MySpringApplicationRunListener.&lt;init&gt;(org.springframework.boot.SpringApplication, [Ljava.lang.String;)</code><br>表示需要一个构造方法。<br>看一下代码中提供的一个实现类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//入参SpringApplication表示项目启动时的事件源</span><br><span class="line">public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered &#123;</span><br><span class="line">    private final SpringApplication application;</span><br><span class="line">    private final String[] args;</span><br><span class="line">    private final SimpleApplicationEventMulticaster initialMulticaster;</span><br><span class="line"></span><br><span class="line">    public EventPublishingRunListener(SpringApplication application, String[] args) &#123;</span><br><span class="line">        this.application = application;</span><br><span class="line">        this.args = args;</span><br><span class="line">        this.initialMulticaster = new SimpleApplicationEventMulticaster();</span><br><span class="line">        Iterator var3 = application.getListeners().iterator();</span><br><span class="line"></span><br><span class="line">        while(var3.hasNext()) &#123;</span><br><span class="line">            ApplicationListener&lt;?&gt; listener = (ApplicationListener)var3.next();</span><br><span class="line">            this.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，加一个构造方法，并把@Component去掉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MySpringApplicationRunListener implements SpringApplicationRunListener &#123;</span><br><span class="line"></span><br><span class="line">    public MySpringApplicationRunListener(SpringApplication application, String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void starting(ConfigurableBootstrapContext bootstrapContext) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 项目启动中...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 环境对象开始准备中(还不能获取配置信息)...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextPrepared(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 上下文对象开始准备(还没加载ioc容器)...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextLoaded(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 上下文对象开始加载(创建springboot启动的bean)...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void started(ConfigurableApplicationContext context, Duration timeTaken) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 加载完成...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void started(ConfigurableApplicationContext context) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void ready(ConfigurableApplicationContext context, Duration timeTaken) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void running(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 项目启动完成开始运行...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void failed(ConfigurableApplicationContext context, Throwable exception) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 项目启动失败...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看spring-boot包下的context下的event包下的一些定义好的事件Event，往里看都是继承自java的util包下的EventObject的。所以说springboot的事件监听是对java事件监听的封装。</p>
<h3 id="springboot启动流程"><a href="#springboot启动流程" class="headerlink" title="springboot启动流程"></a>springboot启动流程</h3><p>观察者模式：观察者和被观察者，被观察者：事件和事件源，观察者：监听器。</p>
<h4 id="✅初始化"><a href="#✅初始化" class="headerlink" title="✅初始化"></a>✅初始化</h4><p>debug一下启动类StartApplication中的<code>SpringApplication.run</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123;</span><br><span class="line">    return (new SpringApplication(primarySources)).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个SpringApplication对象（事件源对象）。</p>
<p>SpringApplication构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">    this.sources = new LinkedHashSet();</span><br><span class="line">    this.bannerMode = Mode.CONSOLE;</span><br><span class="line">    this.logStartupInfo = true;</span><br><span class="line">    this.addCommandLineProperties = true;</span><br><span class="line">    this.addConversionService = true;</span><br><span class="line">    this.headless = true;</span><br><span class="line">    this.registerShutdownHook = true;</span><br><span class="line">    this.additionalProfiles = Collections.emptySet();</span><br><span class="line">    this.isCustomEnvironment = false;</span><br><span class="line">    this.lazyInitialization = false;</span><br><span class="line">    this.applicationContextFactory = ApplicationContextFactory.DEFAULT;</span><br><span class="line">    this.applicationStartup = ApplicationStartup.DEFAULT;</span><br><span class="line">    this.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);</span><br><span class="line">    this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));  //有没有主类</span><br><span class="line">    this.webApplicationType = WebApplicationType.deduceFromClasspath();   //是否是web环境</span><br><span class="line">    this.bootstrapRegistryInitializers = new ArrayList(this.getSpringFactoriesInstances(BootstrapRegistryInitializer.class));</span><br><span class="line">    this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));  //从springfactory文件中加载initializers</span><br><span class="line">    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));  //从springfactory配置文件中加载listener（放到set集合中）</span><br><span class="line">    this.mainApplicationClass = this.deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/springboot%E5%90%AF%E5%8A%A8.png"></p>
<h4 id="✅run方法"><a href="#✅run方法" class="headerlink" title="✅run方法"></a>✅run方法</h4><p>StartApplication的run方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">    long startTime = System.nanoTime();  //监控耗时，也可以用StopWatch</span><br><span class="line">    DefaultBootstrapContext bootstrapContext = this.createBootstrapContext();</span><br><span class="line">    ConfigurableApplicationContext context = null;  //定一个容器</span><br><span class="line">    this.configureHeadlessProperty();  //加载东西</span><br><span class="line">    SpringApplicationRunListeners listeners = this.getRunListeners(args);  //获取RunListener</span><br><span class="line">    listeners.starting(bootstrapContext, this.mainApplicationClass);  //调用runListener的starting方法</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">        ConfigurableEnvironment environment = this.prepareEnvironment(listeners, bootstrapContext, applicationArguments);  //准备环境，回调runListener的prepareEnvironment方法，环境对象Environment就有信息了</span><br><span class="line">        this.configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = this.printBanner(environment);  //打印spring图标，可以替换banner.txt</span><br><span class="line">        context = this.createApplicationContext();  //创建ioc容器</span><br><span class="line">        context.setApplicationStartup(this.applicationStartup);</span><br><span class="line">        this.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);  //加载ioc容器</span><br><span class="line">        // 可以看context里的beanFactory里的beanDefinitionMap，里面是真正的bean，这时还没加载bean</span><br><span class="line">        this.refreshContext(context);  //这里从配置文件里找，创建bean（耗时操作）</span><br><span class="line">        this.afterRefresh(context, applicationArguments);</span><br><span class="line">        Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">        if (this.logStartupInfo) &#123;</span><br><span class="line">            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), timeTakenToStartup);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        listeners.started(context, timeTakenToStartup);  //项目启动成功，加载成功</span><br><span class="line">        this.callRunners(context, applicationArguments);  //commandLineRunner和applicationRunner 回调执行</span><br><span class="line">    &#125; catch (Throwable var12) &#123;</span><br><span class="line">        this.handleRunFailure(context, var12, listeners);</span><br><span class="line">        throw new IllegalStateException(var12);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">        listeners.ready(context, timeTakenToReady);</span><br><span class="line">        return context;</span><br><span class="line">    &#125; catch (Throwable var11) &#123;</span><br><span class="line">        this.handleRunFailure(context, var11, (SpringApplicationRunListeners)null);</span><br><span class="line">        throw new IllegalStateException(var11);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>以上，通过debug源码的方式，探索了springboot启动流程，看了监听器方法在哪里执行回调。</p>
<h2 id="springboot监控"><a href="#springboot监控" class="headerlink" title="springboot监控"></a>springboot监控</h2><h3 id="url方式"><a href="#url方式" class="headerlink" title="url方式"></a>url方式</h3><p>SpringBoot自带监控功能Actuator，可以帮助实现对程序内部运行情况监控，比如监控状况、Bean加载情况、配置属性 、日志信息等。</p>
<p>使用步骤</p>
<p>① 导入依赖坐标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>② 访问<a href="http://localhost:8080/actuator">http://localhost:8080/actuator</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_links&quot;:&#123;</span><br><span class="line">        &quot;self&quot;:&#123;</span><br><span class="line">            &quot;href&quot;:&quot;http://localhost:8082/actuator&quot;,</span><br><span class="line">            &quot;templated&quot;:false</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;health-path&quot;:&#123;</span><br><span class="line">            &quot;href&quot;:&quot;http://localhost:8082/actuator/health/&#123;*path&#125;&quot;,</span><br><span class="line">            &quot;templated&quot;:true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;health&quot;:&#123;</span><br><span class="line">            &quot;href&quot;:&quot;http://localhost:8082/actuator/health&quot;,</span><br><span class="line">            &quot;templated&quot;:false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">路径	描述</span><br><span class="line">/beans	描述应用程序上下文里全部的Bean，以及它们的关系</span><br><span class="line">/env	获取全部环境属性</span><br><span class="line">/env/&#123;name&#125;	根据名称获取特定的环境属性值</span><br><span class="line">/health	报告应用程序的健康指标，这些值由HealthIndicator的实现类提供</span><br><span class="line">/info	获取应用程序的定制信息，这些信息由info打头的属性提供</span><br><span class="line">/mappings	描述全部的URI路径，以及它们和控制器(包含Actuator端点)的映射关系</span><br><span class="line">/metrics	报告各种应用程序度量信息，比如内存用量和HTTP请求计数</span><br><span class="line">/metrics/&#123;name&#125;	报告指定名称的应用程序度量值</span><br><span class="line">/trace	提供基本的HTTP请求跟踪信息(时间戳、HTTP头等)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info:</span><br><span class="line">  name: hello</span><br><span class="line">  age: 23</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  #开启健康检查的完整信息</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: always</span><br><span class="line">  #将所有的监控endPoints暴漏出来</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: *</span><br></pre></td></tr></table></figure>

<h3 id="Spring-Boot-Admin"><a href="#Spring-Boot-Admin" class="headerlink" title="Spring Boot Admin"></a>Spring Boot Admin</h3><p>监控的可视化界面，只不过需要自己再起个监控服务。</p>
<p>Spring Boot Admin是一个开源社区项目，用于管理和监控SpringBoot应用程序。</p>
<p>Spring Boot Admin 有两个角色，客户端(Client)和服务端(Server)。</p>
<p>应用程序作为Spring Boot Admin Client向为Spring Boot Admin Server注册</p>
<p>Spring Boot Admin Server 的UI界面将Spring Boot Admin Client的Actuator Endpoint上的一些监控信息.</p>
<p>使用步骤：</p>
<p>admin-server（监控服务）</p>
<p>① 创建 admin-server 模块</p>
<p>② 导入依赖坐标 admin-starter-server</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>③ 在引导类上启用监控功能@EnableAdminServer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableAdminServer</span><br><span class="line">public class SpringbootAdminServerApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootAdminServerApplication.class, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>admin-client（被监控服务）</p>
<p>① 创建 admin-client 模块</p>
<p>② 导入依赖坐标 admin-starter-client</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>③ 配置相关信息：server地址等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定admin.server地址，server在9000端口号，相当于向server注册</span><br><span class="line">spring.boot.admin.client.url=http://localhost:9000</span><br><span class="line">展示健康检查详细详细展示出来</span><br><span class="line">management.endpoint.health.show-details=always</span><br><span class="line">开启所有配置</span><br><span class="line">management.endpoints.web.exposure.include=*</span><br></pre></td></tr></table></figure>

<p>④ 启动server和client服务，访问server<br><a href="http://localhost:9000/applications">http://localhost:9000/applications</a></p>
<hr>
<p>出现问题：<br>Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured.</p>
<p>原因：当前项目没有配置DataSource相关配置。springboot自动配置时，检测到添加了mysql的依赖包，但是配置文件中却没添加数据库的相关配置。<br>该案例中：mysql依赖在父pom中引入，该子工程不用mysql。</p>
<p>解决办法：@SpringBootApplication(exclude &#x3D; DataSourceAutoConfiguration.class) 排除自动注入数据库配置</p>
<hr>
<p>不知道是不是包的版本不对，有的版本报错，有的版本运行了却没显示。<br>idea中点EndPoins就可以图形化界面的方式来监控，不用那么麻烦，</p>
<h2 id="springboot项目部署"><a href="#springboot项目部署" class="headerlink" title="springboot项目部署"></a>springboot项目部署</h2><p>SpringBoot 项目开发完毕后，支持两种方式部署到服务器：</p>
<p>① jar包(官方推荐) 用内置的tomcat启动</p>
<p>② war包</p>
<h3 id="jar打包方式"><a href="#jar打包方式" class="headerlink" title="jar打包方式"></a>jar打包方式</h3><p>将当前模块打包：idea右边maven中选择要打包的模块，点lifecycle，点package。</p>
<p>打好的jar包在项目的target目录下。直接<code>java -jar .\jar包名称</code>，启动成功。</p>
<h3 id="war打包方式"><a href="#war打包方式" class="headerlink" title="war打包方式"></a>war打包方式</h3><p>pom.xml里更改打包方式：<code>&lt;packaging&gt;war&lt;/packaging&gt;</code><br>如果想改war包的名字：<code>&lt;finalName&gt;</code>标签</p>
<p>在引导类继承SpringBootServletInitializer类，并重写configure方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootDeployApplication extends SpringBootServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootDeployApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123;</span><br><span class="line">        return builder.sources(SpringBootDeployApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行，打好的war包可以被外部tomcat识别，将其放在tomcat目录下的webapps目录下，启动tomcat即可（startup.bat），浏览器访问需要加项目的包名称，因为WEB-INF文件在其之下。并且，内置项目的端口号配置就不生效了。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>《Spring实战》</title>
    <url>/2021/12/15/myblog/spring/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B/</url>
    <content><![CDATA[<p>本书介绍如何使用Spring和Spring Boot开发基于Web、数据库作为后端的Java应用。如何与其他应用进行集成，使用反应式类型进行编程，以及将应用拆分成离散的微服务。最后如何准备应用的部署。</p>
<p>Spring5.0和Spring Boot2.0</p>
<h1 id="第一章-Spring起步"><a href="#第一章-Spring起步" class="headerlink" title="第一章 Spring起步"></a>第一章 Spring起步</h1><h2 id="什么是spring"><a href="#什么是spring" class="headerlink" title="什么是spring"></a>什么是spring</h2><p>spring支持：面向云的由微服务组成的应用，反应式编程，致力于通过非阻塞操作提供更好的扩展性并提升性能。通过spring boot简化自己的开发模型。</p>
<p>Spring 的核心是一个 <em>容器（container）</em>，通常称为 <em>Spring 应用程序上下文</em>，用于创建和管理应用程序组件。这些组件（或 bean）在 Spring 应用程序上下文中连接在一起以构成一个完整的应用程序，就像将砖、灰浆、木材、钉子、管道和电线绑在一起以组成房屋。</p>
<p>将 bean 连接在一起的行为是基于一种称为 <em>依赖注入</em>（dependency injection，DI）的模式。组件不会再去创建它所依赖的组件并管理它们的生命周期，使用依赖注入的应用依赖于单独的实体（容器）来创建和维护所有的组件，并将其注入到需要它们的bean中。通常通过构造函数参数或属性访问器方法完成此操作。总结：应用组件通过Spring的应用上下文来进行管理并实现互相注入。</p>
<p>距离：商品服务需要依赖于库存服务，库存服务需要注入到商品服务。</p>
<p>①从历史上看，引导 Spring 应用程序上下文将 bean 连接在一起的方式是使用一个或多个 XML 文件，这些文件描述了组件及其与其他组件的关系。例如，以下 XML 声明两个 bean，一个 <code>InventoryService bean</code> 和一个 <code>ProductService bean</code>，然后通过构造函数参数将 <code>InventoryService</code> 注入到 <code>ProductService</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;inventoryService&quot;</span> class=<span class="string">&quot;com.example.InventoryService&quot;</span> /&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;productService&quot;</span> class=<span class="string">&quot;com.example.ProductService&quot;</span> &gt;</span><br><span class="line">    &lt;constructor-arg ref=<span class="string">&quot;inventoryService&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>②但是，在最新版本的 Spring 中，基于 Java 的配置更为常见。以下基于 Java 的配置类等效于 XML 配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> InventoryService <span class="title function_">inventoryService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InventoryService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ProductService <span class="title function_">productService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductService</span>(inventoryService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Configuration</code> 注释向 Spring 表明这是一个配置类，它将为 Spring 应用程序上下文提供 beans。 配置的类方法带有 <code>@Bean</code> 注释，指示它们返回的对象应作为 beans 添加到应用程序上下文中（默认情况下，它们各自的 bean IDs 将与定义它们的方法的名称相同）。</p>
<p>与基于 XML 的配置相比，基于 Java 的配置具有多个优点，包括更高的类型安全性和改进的可重构性。即使这样，仅当 Spring 无法自动配置组件时，才需要使用 Java 或 XML 进行显式配置。</p>
<p>③自动配置起源于 Spring 技术，即 <em>自动装配</em> 和 <em>组件扫描</em>。借助组件扫描，Spring 可以自动从应用程序的类路径中发现组件，并将其创建为 Spring 应用程序上下文中的 bean。通过自动装配，Spring 能够自动为组件注入它们所依赖的其他bean。</p>
<p>最近，随着 Spring Boot 的推出，自动配置的优势已经远远超出了组件扫描和自动装配。Spring Boot 是 Spring 框架的扩展，它提供了多项生产力增强功能。这些增强功能中最著名的就是 <em>自动配置</em>，在这种配置中，Spring Boot 可以根据类路径中的条目、环境变量和其他因素，合理地猜测需要配置哪些组件，并将它们装配在一起。</p>
<p>Spring Boot 自动配置大大减少了构建应用程序所需的显式配置（无论是 XML 还是 Java）的数量。</p>
<h2 id="初始化Spring应用程序"><a href="#初始化Spring应用程序" class="headerlink" title="初始化Spring应用程序"></a>初始化Spring应用程序</h2><p>使用 Spring、Spring Boot 以及各种相关的库和框架，创建一个在线应用程序。</p>
<p>依靠 Spring Initializr 来引导应用程序的创建。Spring Initializr 既是一个基于浏览器的 Web 应用程序，又是一个 REST API，它们可以生成一个基本的 Spring 项目结构，可以使用所需的任何功能充实自己。 使用 Spring Initializr 的几种方法如下：</p>
<p>1.从 Web 应用程序 <a href="http://start.spring.io/">http://start.spring.io</a> 创建<br>2.使用 curl 命令从命令行创建<br>3.使用 Spring Boot 命令行接口从命令行创建<br>4.使用 Spring Tool Suite 创建一个新项目的时候<br>5.使用 IntelliJ IDEA 创建一个新项目的时候<br>6.使用 NetBeans 创建一个新项目的时候</p>
<h3 id="使用Intellij-IDEA初始化项目"><a href="#使用Intellij-IDEA初始化项目" class="headerlink" title="使用Intellij IDEA初始化项目"></a>使用Intellij IDEA初始化项目</h3><p>File -&gt; new -&gt; Project -&gt; Spring Initializr -&gt; next。</p>
<p>type选Maven Project -&gt; next。（和maven的构建规范有关，Maven pom.xml）</p>
<p>展示项目依赖页，依赖是按照分类来组织的，已经选中的依赖将会在最右侧。选择依赖：devtools、lombok、web、thymeleaf -&gt; next。</p>
<p>输入项目名称和存放位置。finish</p>
<p>项目从Initializr下载并加载到工作空间中。加载和构建完成，就可以开发应用功能了。</p>
<h3 id="Spring项目目录"><a href="#Spring项目目录" class="headerlink" title="Spring项目目录"></a>Spring项目目录</h3><p>典型的Maven或Gradle项目结构，应用源码在src&#x2F;main&#x2F;java中，测试代码在src&#x2F;test&#x2F;java中，非java资源在src&#x2F;main&#x2F;resources。</p>
<p><code>mvnw</code> 和 <code>mvnw.cmd</code> —— 这些是 Maven 包装器脚本。即使你的计算机上没有安装 Maven，也可以使用这些脚本构建项目。</p>
<p><code>pom.xml</code> —— 这是 Maven 构建规范。</p>
<p><code>TacoCloudApplication.java</code> —— 这是引导项目的 Spring Boot 主类。稍后，我们将在这节详细介绍。</p>
<p><code>application.properties</code> —— 该文件最初为空，但提供了一个可以指定配置属性的地方。我们将在本章中对此文件进行一些修改，但在第 5 章中将详细介绍配置属性。</p>
<p><code>static</code> —— 在此文件夹中，可以放置要提供给浏览器的任何静态内容（图像、样式表、JavaScript 等），最初为空。</p>
<p><code>templates</code> —— 在此文件夹中，放置用于向浏览器呈现内容的模板文件。最初为空，但很快会添加 Thymeleaf 模板。</p>
<p><code>TacoCloudApplicationTests.java</code> —— 这是一个简单的测试类，可确保成功加载 Spring 应用程序上下文。开发应用程序时，将添加更多的测试。</p>
<h4 id="构建规范pom-xml"><a href="#构建规范pom-xml" class="headerlink" title="构建规范pom.xml"></a>构建规范pom.xml</h4><p>填写 Initializr 表单时，指定使用 Maven 构建项目。因此，Spring Initializr 给了一个 pom.xml 文件，该文件已经填充了所做的选择。</p>
<p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring boot插件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;excludes&gt;</span><br><span class="line">                    &lt;exclude&gt;</span><br><span class="line">                        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">                    &lt;/exclude&gt;</span><br><span class="line">                &lt;/excludes&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;packaging&gt;</code>选择将应用程序构建为可执行的 JAR 文件，而不是 WAR 文件。毕竟，传统的 Java web 应用程序被打包为 WAR 文件，而 JAR 文件是库和偶尔使用的桌面 UI 应用程序的首选打包方式。虽然 WAR 文件非常适合部署到传统的 Java 应用服务器，但是它们并不适合大多数云平台。尽管一些云平台（如 Cloud Foundry）能够部署和运行 WAR 文件，但是所有的 Java 云平台都能够运行可执行的 JAR 文件。因此，Spring Initializr 默认为 JAR 打包。</p>
<p><code>&lt;parent&gt;</code> 元素，指定项目将 <code>spring-boot-starter-parent</code> 作为它的父 POM。除此之外，这个父 POM 还为 Spring 项目中常用的几个库提供依赖项管理。对于父 POM 覆盖的那些库，不必指定版本，因为它是从父 POM 继承的。</p>
<p><code>&lt;dependencies&gt;</code> 元素下声明了三个依赖项。前两个看起来应该比较熟悉。它们直接对应于在单击 Spring Tool Suite 新建项目向导中的 Finish 按钮之前选择的 Web 和 Thymeleaf 依赖项。第三个依赖项提供了许多有用的测试功能，你不必选中包含它的方框，因为 Spring Initializr 假定你将编写测试。</p>
<p>Spring Boot starter 依赖项的特殊之处在于，它们本身通常没有任何库代码，而是间接地引入其他库。这些 starter 依赖提供了三个主要的好处：</p>
<ul>
<li>构建的文件将会小得多，也更容易管理，因为不需要对每一个可能需要的库都声明一个依赖项。</li>
<li>可以根据它们提供的功能来考虑需要的依赖关系，而不是根据库名来考虑。如果正在开发一个 web 应用程序，那么将添加 web starter 依赖项，而不是一个编写 web 应用程序的各个库的清单。</li>
<li>不用担心 library 版本问题。可以相信的是，对于给定版本的 Spring Boot，可间接地引入的库的版本将是兼容的，只需要考虑使用的是哪个版本的 Spring Boot。</li>
</ul>
<p>最后，构建规范以 Spring Boot 插件结束。这个插件执行一些重要的功能：</p>
<ul>
<li>提供了一个 Maven 编译目标，让你能够使用 Maven 运行应用程序。</li>
<li>确保所有的依赖库都包含在可执行的 JAR 文件中，并且在运行时类路径中可用。</li>
<li>在 JAR 文件中生成一个 manifest 文件，将引导类（在本书例子中是 <code>TacoCloudApplication</code>）声明为可执行 JAR 的主类。</li>
</ul>
<h4 id="引导应用TacoCloudApplication"><a href="#引导应用TacoCloudApplication" class="headerlink" title="引导应用TacoCloudApplication"></a>引导应用TacoCloudApplication</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TacoCloudApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TacoCloudApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@SpringBootApplication</code> 注释清楚地表明这是一个 Spring 引导应用程序。<code>@SpringBootApplication</code> 是一个组合了其他三个注释的复合应用程序：</p>
<p>（1）<code>@SpringBootConfiguration</code> —— 指定这个类为配置类。尽管这个类中还没有太多配置，但是如果需要，可以将 Javabased Spring Framework 配置添加到这个类中。实际上，这个注释是<code>@Configuration</code> 注释的一种特殊形式。</p>
<p>（2）<code>@EnableAutoConfiguration</code> —— 启用 Spring 自动配置。稍后我们将详细讨论自动配置。现在，要知道这个注释告诉 Spring Boot 自动配置它认为需要的任何组件。</p>
<p>（3）<code>@ComponentScan</code> —— 启用组件扫描。这允许你声明其他带有 <code>@Component</code>、<code>@Controller</code>、<code>@Service</code> 等注释的类，以便让 Spring 自动发现它们并将它们注册为 Spring 应用程序上下文中的组件。</p>
<p><code>TacoCloudApplication</code> 的另一个重要部分是 <code>main()</code> 方法。这个方法将在执行 JAR 文件时运行。在大多数情况下，这种方法是样板代码；编写的每个 Spring 引导应用程序都有一个类似或相同的方法（尽管类名不同）。</p>
<p><code>main()</code> 方法调用 SpringApplication 类上的静态 <code>run()</code> 方法，该方法执行应用程序的实际引导，创建<code>Spring</code> 应用程序上下文。传递给 <code>run()</code> 方法的两个参数是一个配置类和命令行参数。虽然传递给 <code>run()</code> 的配置类不必与引导类相同，但这是最方便、最典型的选择。</p>
<p>你可能不需要更改引导类中的任何内容。对于简单的应用程序，你可能会发现在引导类中配置一两个其他组件很方便，但是对于大多数应用程序，最好为任何没有自动配置的东西创建一个单独的配置类。</p>
<h4 id="测试应用TacoCloudApplicationTests"><a href="#测试应用TacoCloudApplicationTests" class="headerlink" title="测试应用TacoCloudApplicationTests"></a>测试应用TacoCloudApplicationTests</h4><p>测试是软件开发的一个重要部分。认识到这一点后，Spring Initializr 提供了一个测试类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TacoCloudApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类中的一个测试方法是空的。尽管如此，这个测试类确实执行了必要的检查，以确保 Spring 应用程序上下文能够成功加载。如果做了任何阻止创建 Spring 应用程序上下文的更改，则此测试将失败，这样你就可以通过解决问题来应对。</p>
<p>还要注意用 <code>@RunWith(SpringRunner.class)</code> 注释的类。<code>@RunWith</code> 是一个 JUnit 注释，提供了一个测试运行器来引导 JUnit 运行测试用例。请将清单 1.3 看作是对它的基准应用程序测试，即将插件应用到 JUnit 以提供自定义测试行为。在本例中，JUnit 被赋予了 SpringRunner，这是一个由 Spring 提供的测试运行程序，它提供了创建一个 Spring 应用程序上下文的功能，以供测试运行。</p>
<p>尽管 <code>@RunWith(SpringRunner.class)</code> 和 <code>@SpringBootTest</code> 的任务是加载用于测试的 Spring 应用程序上下文，但是如果没有任何测试方法，它们将没有任何事情要做。即使没有任何断言或任何类型的代码，这个空的测试方法也会调用两个注释完成它们的工作，并加载 Spring 应用程序上下文。如果运行过程中有任何问题，测试就会失败。</p>
<h2 id="编写Spring应用程序"><a href="#编写Spring应用程序" class="headerlink" title="编写Spring应用程序"></a>编写Spring应用程序</h2><p>添加到 Taco Cloud 应用程序的第一个功能是主页，当添加主页，将创建两个代码构件：</p>
<ul>
<li>一个处理主页请求的控制器类</li>
<li>一个视图模板，定义了主页的外观</li>
</ul>
<p>因为测试很重要，所以还将编写一个简单的测试类来测试主页。但首先…来写这个控制器。</p>
<h3 id="处理web请求"><a href="#处理web请求" class="headerlink" title="处理web请求"></a>处理web请求</h3><p>Spring 附带了一个强大的 web 框架，称为 Spring MVC。Spring MVC 的核心是控制器的概念，这是一个处理请求并使用某种信息进行响应的类。对于面向浏览器的应用程序，控制器的响应方式是可选地填充模型数据并将请求传递给视图，以生成返回给浏览器的 HTML。</p>
<p>现在，将编写一个简单的控制器类来处理根路径的请求（例如 <code>/</code>），并将这些请求转发到主页视图，而不填充任何模型数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Controller</code> 注释的主要目的是将该类识别为组件扫描的组件。由于 <code>HomeController</code> 是用 <code>@Controller</code> 注释的，因此 Spring 的组件扫描会自动发现它，并在 Spring 应用程序上下文中创建一个 <code>HomeController</code> 实例作为 bean。</p>
<p>实际上，其他一些注释（包括 <code>@Component</code>、<code>@Service</code> 和 <code>@Repository</code>）的用途与 <code>@Controller</code> 类似。你可以用任何其他的注解来有效地注释 <code>HomeController</code>，它仍然可以工作。但是，选择 <code>@Controller</code> 更能描述该组件在应用程序中的角色。</p>
<p><code>home()</code> 方法与控制器方法一样简单。它使用 <code>@GetMapping</code> 进行注释，以指示如果接收到根路径 <code>/</code> 的 HTTP GET 请求，则此方法应该处理该请求。除了返回 <code>home</code> 的 <code>String</code> 值外，它什么也不做。此值被解释为视图的逻辑名称。如何实现该视图取决于几个因素，但是因为 Thymeleaf 在类路径中，所以可以使用 Thymeleaf 定义该模板。</p>
<h3 id="Thymeleaf模板引擎"><a href="#Thymeleaf模板引擎" class="headerlink" title="Thymeleaf模板引擎"></a>Thymeleaf模板引擎</h3><p>为什么不是 JSP？为什么不是 FreeMarker？</p>
<p>模板名称由逻辑视图名称派生而来，它的前缀是 &#x2F;templates&#x2F;，后缀是 .html。模板的结果路径是 &#x2F;templates&#x2F;home.html。因此，需要将模板放在项目的 &#x2F;src&#x2F;main&#x2F;resources&#x2F;templates&#x2F;home.html 中。</p>
<p>为了保持主页简洁，它做的只是欢迎用户访问网站。程序显示了定义 Taco Cloud 主页的基本 Thymeleaf 模板。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span><br><span class="line">      xmlns:th=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Taco Cloud&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;Welcome to...&lt;/h1&gt;</span><br><span class="line">        &lt;img th:src=<span class="string">&quot;@&#123;/images/TacoCloud.png&#125;&quot;</span>/&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;img&gt;</code> 标记使用一个 Thymeleaf 的 th:src 属性和一个 @{…} 表达式引用具有上下文相对路径的图片。这意味着 Taco Cloud 标志图片也必须驻留在项目的 &#x2F;src&#x2F;main&#x2F;resources&#x2F;static&#x2F;images&#x2F;TacoCloud.png 中。</p>
<h3 id="测试控制器"><a href="#测试控制器" class="headerlink" title="测试控制器"></a>测试控制器</h3><p>在对 HTML 页面的内容进行断言时，测试 web 应用程序可能比较棘手。幸运的是，Spring 提供了一些强大的测试支持，使测试 web 应用程序变得很容易。就主页而言，将编写一个与主页本身复杂度相当的测试。你的测试将对根路径 <code>/</code> 执行一个 HTTP GET 请求并期望得到一个成功的结果，其中视图名称为 home，结果内容包含短语 “Welcome to…”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.Matchers.containsString;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.view;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(HomeController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeControllerTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHomePage</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">            .andExpect(status().isOk())</span><br><span class="line">            .andExpect(view().name(<span class="string">&quot;home&quot;</span>))</span><br><span class="line">            .andExpect(content().string(containsString(<span class="string">&quot;Welcome to...&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HomeControllerTest</code> 使用 <code>@WebMvcTest</code> 注释，而不是 <code>@SpringBootTest</code> 标记。这是 Spring Boot 提供的一个特殊测试注释，它安排测试在 Spring MVC 应用程序的上下文中运行。更具体地说，在本例中，它安排 <code>HomeController</code> 在 Spring MVC 中注册，这样你就可以对它进行请求。</p>
<p><code>@WebMvcTest</code> 还为测试 Spring MVC 提供了 Spring 支持。虽然可以让它启动服务器，但模拟 Spring MVC 的机制就足以满足你的目的了。测试类被注入了一个 <code>MockMvc</code> 对象中，以此用来测试来驱动模型。</p>
<p><code>testHomePage()</code> 方法定义了要对主页执行的测试。它从 <code>MockMvc</code> 对象开始，执行针对 <code>/</code>（根路径）的 HTTP GET 请求。该请求规定了下列期望值：</p>
<ul>
<li>响应应该有一个HTTP 200（OK）状态。</li>
<li>视图应该有一个合理的主页名称。</li>
<li>呈现的视图应该包含 “Welcome to…”</li>
</ul>
<p>如果在 <code>MockMvc</code> 对象执行请求之后，这些期望中的任何一个都没有满足，那么测试就会失败。但是控制器和视图模板是为了满足这些期望而编写的，所以测试应该能够通过，或者至少能够通过一些表示测试通过的绿色提示。</p>
<p>控制器写好了，视图模板创建好了，测试通过了。看来你已经成功地实现了主页。</p>
<h3 id="构建并运行应用"><a href="#构建并运行应用" class="headerlink" title="构建并运行应用"></a>构建并运行应用</h3><p>Spring Boot Dashboard 的便利功能可以帮助你在 IDE 中运行应用程序。<strong>Spring Boot Dashboard</strong> （指示板，仪表盘）显示为一个选项卡，通常位于 IDE 窗口的左下方。</p>
<blockquote>
<p>如何在idea中启动Spring Boot Dashboard：<a href="https://jingyan.baidu.com/article/ce4366495a1df73773afd3d3.html">https://jingyan.baidu.com/article/ce4366495a1df73773afd3d3.html</a></p>
</blockquote>
<p>当应用程序启动时，将在控制台中看到一些 Spring ASCII 图飞过，然后看到一些日志条目描述应用程序启动时的步骤。在停止日志记录之前，将看到一个日志条目，其中说 Tomcat 在 port(s): 8080 (http) 上启动，这意味着已经准备好将 web 浏览器指向主页，以查看结果。</p>
<p>等一下，Tomcat 启动？何时将应用程序部署到 Tomcat？</p>
<p>Spring Boot 应用程序倾向于裹挟所有需要的东西，而不需要部署到某个应用服务器。你从未将应用程序部署到 Tomcat… 其实 Tomcat 是应用程序的一部分！(将在 1.3.6 小节中详细描述 Tomcat 如何成为应用程序的一部分的。)</p>
<p>现在应用程序已经启动，将 web 浏览器指向 <a href="http://localhost:8080/">http://localhost:8080</a>（或单击 Spring Boot Dashboard 中地球仪样子的按钮)。</p>
<p>同一共有网下，可以通过ip访问到。<code>ifconfig en0</code></p>
<h3 id="Spring-Boot-DevTools"><a href="#Spring-Boot-DevTools" class="headerlink" title="Spring Boot DevTools"></a>Spring Boot DevTools</h3><p>在初始化项目时将其作为依赖项进行选择。Spring Boot DevTools作为一个依赖项出现在生成的 pom.xml 文件中。Spring Boot Dashboard 甚至显示项目已经启用了 DevTools。但是什么是 DevTools，它能为您做什么？</p>
<p>DevTools 为 Spring 开发人员提供了一些方便的开发同步工具。这些是：</p>
<ul>
<li>当代码更改时自动重启应用程序</li>
<li>当以浏览器为目标的资源（如模板、JavaScript、样式表等）发生变化时，浏览器会自动刷新</li>
<li>自动禁用模板缓存</li>
<li>如果 H2 数据库正在使用，则在 H2 控制台中构建</li>
</ul>
<p>（1）自动重启应用程序</p>
<p>（2）自动刷新浏览器和禁用模板缓存</p>
<p>（3）内置的H2控制台</p>
<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>以下是构建基于 Spring 的 Taco Cloud 应用程序的步骤：</p>
<ol>
<li>使用 Spring Initializr 创建了一个初始项目结构。</li>
<li>写了一个控制器类来处理主页请求。</li>
<li>定义了一个视图模板来呈现主页。</li>
<li>写了一个简单的测试类来检验上诉工作。</li>
</ol>
<p>控制器类中的两行代码，而视图模板中没有 Spring 的特定代码。尽管测试类的大部分都使用了 Spring 的测试支持，但是在测试上下文中，它的侵入性似乎要小一些。</p>
<p>这是使用 Spring 开发的一个重要好处。可以关注于满足应用程序需求的代码，而不是满足框架的需求。尽管确实需要不时地编写一些特定于框架的代码，但这通常只是代码库的一小部分。如前所述，Spring （以及 Spring Boot）可以被认为是 <em>无框架的框架</em>。</p>
<p>这到底是怎么回事？Spring 在幕后做了什么来确保您的应用程序需求得到满足？为了理解 Spring 在做什么，让我们从构建规范开始。</p>
<p>在 pom.xml 文件中，声明了对 Web 和 Thymeleaf 启动器的依赖。这两个依赖关系带来了一些其他的依赖关系，包括：</p>
<ul>
<li>Spring MVC 框架</li>
<li>嵌入式 Tomcat</li>
<li>Thymeleaf 和 Thymeleaf 布局方言</li>
</ul>
<p>它还带来了 Spring Boot 的自动配置库。当应用程序启动时，Spring Boot 自动配置自动检测这些库并自动执行：</p>
<ul>
<li>在 Spring 应用程序上下文中配置 bean 以启用 Spring MVC</li>
<li>将嵌入式 Tomcat 服务器配置在 Spring 应用程序上下文中</li>
<li>为使用 Thymeleaf 模板呈现 Spring MV C视图，配置了一个 Thymeleaf 视图解析器</li>
</ul>
<p>简而言之，自动配置完成了所有繁重的工作，让你专注于编写实现应用程序功能的代码。</p>
<h2 id="俯瞰Spring风景线"><a href="#俯瞰Spring风景线" class="headerlink" title="俯瞰Spring风景线"></a>俯瞰Spring风景线</h2><p>Spring Initializr Web表单里提供了100多个可选的依赖项。</p>
<h3 id="Spring核心框架"><a href="#Spring核心框架" class="headerlink" title="Spring核心框架"></a>Spring核心框架</h3><p>Spring 核心框架是 Spring 领域中其他一切的基础。它提供了核心容器和依赖注入框架。但它也提供了一些其他的基本特性。</p>
<p>其中包括 Spring MVC 和 Spring web 框架。已经了解了如何使用 Spring MVC 编写控制器类来处理 web 请求。但是，还没有看到的是，Spring MVC 也可以用于创建产生非 HTML 输出的 REST API。将在第 2 章深入研究 Spring MVC，然后在第 6 章中讨论如何使用它来创建 REST API。</p>
<p>Spring 核心框架还提供了一些基本数据持久性支持，特别是基于模板的 JDBC 支持。将在第 3 章中看到如何使用 JdbcTemplate。</p>
<p>在 Spring 的最新版本（5.0.8）中，添加了对响应式编程的支持，包括一个新的响应式 web 框架 —— Spring WebFlux，它大量借鉴了 Spring MVC。将在第 3 部分中看到 Spring 的响应式编程模型，并在第 10 章中看到 Spring WebFlux。</p>
<h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p>已经看到了 Spring Boot 的许多好处，包括启动依赖项和自动配置。在本书中我们确实会尽可能多地使用 Spring Boot，并避免任何形式的显式配置，除非绝对必要。但除了启动依赖和自动配置，Spring Boot 还提供了一些其他有用的特性：</p>
<ul>
<li>Actuator 提供了对应用程序内部工作方式的运行时监控，包括端点、线程 dump 信息、应用程序健康状况和应用程序可用的环境属性。</li>
<li>灵活的环境属性规范。</li>
<li>在核心框架的测试辅助之外，还有额外的测试支持。</li>
</ul>
<p>此外，Spring Boot 提供了一种基于 Groovy 脚本的替代编程模型，称为 Spring Boot CLI（命令行界面）。使用 Spring Boot CLI，可以将整个应用程序编写为 Groovy 脚本的集合，并从命令行运行它们。我们不会在 Spring Boot CLI 上花太多时间，但是当它适合我们的需要时，我们会接触它。</p>
<p>Spring Boot 已经成为 Spring 开发中不可或缺的一部分；我无法想象开发一个没有它的 Spring 应用程序。因此，本书采用了以 Spring Boot 为中心的观点，当我提到 Spring Boot 正在做的事情时，你可能会发现我在使用 Spring 这个词。</p>
<h3 id="Spring-Data"><a href="#Spring-Data" class="headerlink" title="Spring Data"></a>Spring Data</h3><p>尽管 Spring 核心框架提供了基本的数据持久性支持，但 Spring Data 提供了一些非常惊人的功能：将应用程序的数据存储库抽象为简单的 Java 接口，同时当定义方法用于如何驱动数据进行存储和检索的问题时，对方法使用了命名约定。</p>
<p>更重要的是，Spring Data 能够处理几种不同类型的数据库，包括关系型（JPA）、文档型（Mongo）、图型（Neo4j）等。在第 3 章中，将使用 Spring Data 来帮助创建 Taco Cloud 应用程序的存储库。</p>
<h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><p>应用程序安全性一直是一个重要的主题，而且似乎一天比一天重要。幸运的是，Spring 在 Spring security 中有一个健壮的安全框架。</p>
<p>Spring Security 解决了广泛的应用程序安全性需求，包括身份验证、授权和 API 安全性。尽管 Spring Security 的范围太大，本书无法恰当地涵盖，但我们将在第 4 章和第 12 章中讨论一些最常见的用例。</p>
<h3 id="Spring-Integration-和-Spring-Batch"><a href="#Spring-Integration-和-Spring-Batch" class="headerlink" title="Spring Integration 和 Spring Batch"></a>Spring Integration 和 Spring Batch</h3><p>在某种程度上，大多数应用程序将需要与其他应用程序集成，甚至需要与同一应用程序的其他组件集成。为了满足这些需求，出现了几种应用程序集成模式。Spring Integration 和 Spring Batch 为基于 Spring 的应用程序提供了这些模式的实现。</p>
<p>Spring Integration 解决了实时集成，即数据在可用时进行处理。相反，Spring Batch 解决了批量集成的问题，允许在一段时间内收集数据，直到某个触发器（可能是一个时间触发器）发出信号，表示该处理一批数据了。将在第 9 章中研究 Spring Batch 和 Spring Integration。</p>
<h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><p>在我写这篇文章的时候，应用程序开发领域正在进入一个新时代，在这个时代中，我们不再将应用程序作为单个部署单元来开发，而是将由几个称为 <em>微服务</em> 的单个部署单元组成应用程序。</p>
<p>微服务是一个热门话题，解决了几个实际的开发和运行时问题。然而，在这样做的同时，他们也带来了自己的挑战。这些挑战都将由 Spring Cloud 直接面对，Spring Cloud 是一组用 Spring 开发云本地应用程序的项目。</p>
<p>Spring Cloud 覆盖了很多地方，这本书不可能涵盖所有的地方。我们将在第 13、14 和 15 章中查看 Spring Cloud 的一些最常见的组件。关于 Spring Cloud 的更完整的讨论，我建议看看 John Carnell 的 Spring Microservices in Action（Manning, 2017, <a href="http://www.manning.com/books/spring-microservices-in-action%EF%BC%89%E3%80%82">www.manning.com/books/spring-microservices-in-action）。</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>Spring 的目标是让开发人员轻松应对挑战，比如创建 web 应用程序、使用数据库、保护应用程序和使用微服务。</p>
</li>
<li><p>Spring Boot 构建在 Spring 之上，简化了依赖管理、自动配置和运行时监控，让 Spring 变得更加简单。</p>
</li>
<li><p>Spring 应用程序可以使用 Spring Initializr 进行初始化，它是基于 web 的，并且在大多数 Java 开发环境中都支持它。</p>
</li>
<li><p>在 Spring 应用程序上下文中，组件（通常称为 bean）可以用 Java 或 XML 显式地声明，可以通过组件扫描进行发现，也可以用 Spring Boot 进行自动配置。</p>
</li>
</ul>
<h1 id="第二章-开发Web应用"><a href="#第二章-开发Web应用" class="headerlink" title="第二章 开发Web应用"></a>第二章 开发Web应用</h1><p>使用 Spring 构建的应用程序将执行各种操作，包括处理数据、从数据库中读取信息以及与其他应用程序进行交互。但是应用程序用户得到的第一印象来自于用户界面。在许多应用程序中，UI 界面是在浏览器中显示的 web 应用程序。</p>
<p>在第 1 章中，创建了第一个 Spring MVC 控制器来显示应用程序主页。但是 Spring MVC 能做的远不止简单地显示静态内容。在本章中，将开发 Taco Cloud 应用程序的第一个主要功能 —— 设计自定义 Taco 的能力。在此过程中，将深入研究 Spring MVC，并了解如何显示模型数据和处理表单输入。</p>
<h2 id="展示信息"><a href="#展示信息" class="headerlink" title="展示信息"></a>展示信息</h2><p>在 Spring web 应用程序中，获取和处理数据是控制器的工作。视图的工作是将数据渲染成 HTML 并显示在浏览器中。将创建以下组件来支持 Taco 创建页面，使得用户可以自选配料：</p>
<ul>
<li>一个定义玉米卷成分特性的领域类</li>
<li>一个 Spring MVC 控制器类，它获取成分信息并将其传递给视图</li>
<li>一个视图模板，在用户的浏览器中呈现一个成分列表</li>
</ul>
<h3 id="构建领域类"><a href="#构建领域类" class="headerlink" title="构建领域类"></a>构建领域类</h3><p>在编写控制器和视图之前，让我们先确定表示配料的域类型。这将为开发 web 组件奠定基础。</p>
<p>应用程序的域是它所处理的主题领域 —— 影响应用程序理解的思想和概念。在 Taco Cloud 应用程序中，领域包括 Taco 设计、组成这些设计的成分、客户和客户下的 Taco 订单等对象。首先，我们将关注玉米饼配料。</p>
<p>在领域中，玉米饼配料是相当简单的对象。每一种都有一个名称和一个类型，这样就可以在视觉上对其进行分类（蛋白质、奶酪、酱汁等）。每一个都有一个 ID，通过这个 ID 可以轻松、明确地引用它。下面的成分类定义了需要的域对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ingredient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">        WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个普通的 Java 域类，定义了描述一个成分所需的三个属性。对于程序 中定义的 <code>Ingredient</code> 类，最不寻常的事情可能是它似乎缺少一组常用的 getter 和 setter 方法，更不用说像 <code>equals()</code>、<code>hashCode()</code>、<code>toString()</code> 等有用的方法。</p>
<p>在清单中看不到它们，部分原因是为了节省空间，但也因为使用了一个名为 Lombok 的出色库，它会在运行时自动生成这些方法。实际上，类级别的 <code>@Data</code> 注释是由 Lombok 提供的，它告诉 Lombok 生成所有缺少的方法，以及接受所有<code>final</code>属性作为参数的构造函数。通过使用 Lombok，可以让 <code>Ingredient</code> 的代码保持整洁。</p>
<p>Lombok 不是一个 Spring 库，但是它非常有用，没有它我很难开发。当我需要在一本书中保持代码示例简短明了时，它就成了我的救星。</p>
<p>要使用 Lombok，需要<strong>将其作为依赖项添加到项目</strong>中。如果正在使用 Spring Tool Suite，只需右键单击 pom.xml 文件并从 Spring 上下文菜单选项中选择 Edit Starters 即可。在第 1 章（图 1.4）中给出的依赖项的相同选择将出现，这样就有机会添加或更改所选的依赖项。找到 Lombok 选项，确保选中，然后单击 OK；Spring Tool Suite 将自动将其添加到构建规范中。</p>
<p>或者，可以使用 pom.xml 中的以下条目手动添加它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>此依赖项将在开发时提供 Lombok 注释（如 <code>@Data</code>），并在运行时提供自动方法生成。但是还需要<strong>在 IDE 中添加 Lombok 作为扩展</strong>，否则 IDE 将会报错缺少方法和没有设置的最终属性。请访问 <a href="https://projectlombok.org/%EF%BC%8C%E4%BB%A5%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E5%9C%A8">https://projectlombok.org/，以了解如何在</a> IDE 中安装 Lombok。</p>
<p>你会发现 Lombok 非常有用，但它是可选的。如果不希望使用它，或是不需要它来开发 Spring 应用程序，那么请随意手动编写那些缺少的方法。继续……我将等待。完成后，将添加一些控制器来处理应用程序中的 web 请求。</p>
<blockquote>
<p>笔记：IDEA如何为pom.xml导入依赖？</p>
<p><a href="https://www.jb51.net/article/193912.htm">https://www.jb51.net/article/193912.htm</a></p>
<p>虽然项目里本身就有，不知道reimport是不是真的有效果，没有找到重新选择依赖的方法。</p>
</blockquote>
<blockquote>
<p>笔记：在 IDE 中添加 Lombok 作为扩展？</p>
<p>Lombok是一个可以通过简单的注解形式来帮助我们简化消除一些必须有但显得很臃肿的Java代码的工具，通过使用对应的注解，可以在编译源码的时候生成对应的方法。</p>
<p>1.plugin中下载lombok插件  <a href="https://www.jb51.net/article/214041.htm">https://www.jb51.net/article/214041.htm</a></p>
<p>2.配置一下，enable annotation processing 启用注释处理  <a href="https://blog.csdn.net/xiaoxiamimm/article/details/113882655">https://blog.csdn.net/xiaoxiamimm/article/details/113882655</a></p>
<p>3.pom.xml中添加lombok依赖</p>
</blockquote>
<h3 id="创建控制器类"><a href="#创建控制器类" class="headerlink" title="创建控制器类"></a>创建控制器类</h3><p>控制器是 Spring MVC 框架的主要参与者。它们的主要工作是处理 HTTP 请求，或者将请求传递给视图以呈现 HTML（浏览器显示），或者直接将数据写入响应体（RESTful）。在本章中，将重点讨论使用视图为 web 浏览器生成内容的控制器的类型。在第 6 章中，我们将讨论如何在 REST API 中编写处理请求的控制器。</p>
<p>对于 Taco Cloud 应用程序，需要一个简单的控制器来执行以下操作，一个显示配料的控制器：</p>
<ul>
<li>处理请求路径为 <code>/design</code> 的 HTTP GET 请求</li>
<li>构建成分列表</li>
<li>将请求和成分数据提交给视图模板，以 HTML 的形式呈现并发送给请求的 web 浏览器</li>
</ul>
<p>下面的 DesignTacoController 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.web;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Valid;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.Errors;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> tacos.Taco;</span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient;</span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient.Type;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/design&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DesignTacoController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">showDesignForm</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        List&lt;Ingredient&gt; ingredients = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Ingredient</span>(<span class="string">&quot;FLTO&quot;</span>, <span class="string">&quot;Flour Tortilla&quot;</span>, Type.WRAP),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Ingredient</span>(<span class="string">&quot;COTO&quot;</span>, <span class="string">&quot;Corn Tortilla&quot;</span>, Type.WRAP),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Ingredient</span>(<span class="string">&quot;GRBF&quot;</span>, <span class="string">&quot;Ground Beef&quot;</span>, Type.PROTEIN),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Ingredient</span>(<span class="string">&quot;CARN&quot;</span>, <span class="string">&quot;Carnitas&quot;</span>, Type.PROTEIN),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Ingredient</span>(<span class="string">&quot;TMTO&quot;</span>, <span class="string">&quot;Diced Tomatoes&quot;</span>, Type.VEGGIES),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Ingredient</span>(<span class="string">&quot;LETC&quot;</span>, <span class="string">&quot;Lettuce&quot;</span>, Type.VEGGIES),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Ingredient</span>(<span class="string">&quot;CHED&quot;</span>, <span class="string">&quot;Cheddar&quot;</span>, Type.CHEESE),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Ingredient</span>(<span class="string">&quot;JACK&quot;</span>, <span class="string">&quot;Monterrey Jack&quot;</span>, Type.CHEESE),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Ingredient</span>(<span class="string">&quot;SLSA&quot;</span>, <span class="string">&quot;Salsa&quot;</span>, Type.SAUCE),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Ingredient</span>(<span class="string">&quot;SRCR&quot;</span>, <span class="string">&quot;Sour Cream&quot;</span>, Type.SAUCE)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        Type[] types = Ingredient.Type.values();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            model.addAttribute(type.toString().toLowerCase(),</span><br><span class="line">                filterByType(ingredients, type));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">&quot;design&quot;</span>, <span class="keyword">new</span> <span class="title class_">Taco</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;design&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// provided by &#x27;aexiaosong&#x27;</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Ingredient&gt; <span class="title function_">filterByType</span><span class="params">(List&lt;Ingredient&gt; ingredients, Type type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ingredients.stream().filter(x -&gt; x.getType().equals(type)).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Slf4j，它是 Lombok 提供的注释，在运行时将自动生成类中的 SLF4J（Java 的简单日志门面，<a href="https://www.slf4j.org/%EF%BC%89%E8%AE%B0%E5%BD%95%E5%99%A8%E3%80%82%E8%BF%99%E4%B8%AA%E9%80%82%E5%BD%93%E7%9A%84%E6%B3%A8%E9%87%8A%E5%85%B7%E6%9C%89%E4%B8%8E%E6%98%BE%E5%BC%8F%E5%9C%B0%E5%9C%A8%E7%B1%BB%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BB%A5%E4%B8%8B%E8%A1%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%88%E6%9E%9C%EF%BC%9A">https://www.slf4j.org/）记录器。这个适当的注释具有与显式地在类中添加以下行相同的效果：</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.slf4j.<span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> </span><br><span class="line">       org.slf4j.LoggerFactory.getLogger(DesignTacoController.class);</span><br></pre></td></tr></table></figure>

<p>@Controller。此注释用于将该类标识为控制器并将其标记为组件扫描的候选对象，以便 Spring 将发现该类并在 Spring 应用程序上下文中自动创建 DesignTacoController 实例作为 bean。</p>
<p>@RequestMapping 注释在类级应用时，指定该控制器处理的请求的类型。在本例中，它指定 DesignTacoController 将处理路径以 <code>/design</code> 开头的请求。</p>
<p>@GetMapping 与类级别的 @RequestMapping 配对使用，指定何时接收 <code>/design</code> 的 HTTP GET 请求，showDesignForm() 将用来处理请求。@GetMapping 是一个相对较新的注释，是在 Spring 4.3 中引入的。在 Spring 4.3 之前，可能使用了一个方法级别的 @RequestMapping 注释作为替代<code>@RequestMapping(method=RequestMethod.GET) </code>。</p>
<p>showDesignForm() 方法将处理请求，让我们来看看方法体，看看它是如何工作的。该方法的大部分构造了一个成份对象列表。这个列表现在是硬编码的。当我们讲到第 3 章的时候，你会从数据库中找到玉米饼的原料列表。一旦准备好了原料列表，接下来的几行 showDesignForm() 将根据原料类型过滤该列表。然后将成分类型列表作为属性添加Model对象上，这个对象是以参数的形式传递给 showDesignForm() 方法的。Model 是一个对象，它在控制器和负责呈现数据的视图之间传输数据。最后，放置在 Model 类属性中的数据被复制到 servlet 响应属性中，视图可以在其中找到它们。showDesignForm() 方法最后返回 “design”，这是将用于向浏览器呈现 Model 的视图的逻辑名称。</p>
<p>DesignTacoController 真的开始成形了。如果您现在运行应用程序并将您的浏览器指向 <code>/design</code> 路径，DesignTacoController 的 showDesignForm() 将被占用，它从存储库中获取数据并将其放在 Model 中，然后将请求传递给视图。但是因为还没有定义视图，所以请求会发生可怕的转变，导致 HTTP 404（Not Found）错误。为了解决这个问题，让我们将注意力转移到视图上，其中的数据将用 HTML 进行修饰，并在用户的 web 浏览器中显示。</p>
<h3 id="设计视图"><a href="#设计视图" class="headerlink" title="设计视图"></a>设计视图</h3><p>控制器创建完成后，就该开始设计视图了。Spring 为定义视图提供了几个很好的选项，包括 JavaServer Pages（JSP）、Thymeleaf、FreeMarker、Mustache 和基于 Groovy 的模板。现在，我们将使用 Thymeleaf，这是我们在第 1 章开始项目时所做的选择。</p>
<p>像 Thymeleaf 这样的视图库被设计成与任何特定的 web 框架解耦。因此，他们不知道 Spring 的模型抽象，并且无法处理控制器放置在模型中的数据。但是它们可以处理 servlet 请求属性。因此，在 Spring 将请求提交给视图之前，它将模型数据复制到请求属性中，而 Thymeleaf 和其他视图模板选项可以随时访问这些属性。</p>
<p>Thymeleaf 模板只是 HTML 与一些额外的元素属性，指导模板在渲染请求数据。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Taco Cloud<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/styles.css&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Design your taco!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/images/TacoCloud.png&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;design&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ingredient-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;wraps&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Designate your wrap:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;ingredient : $&#123;wrap&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;ingredients&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;ingredient.id&#125;&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ingredient.name&#125;&quot;</span>&gt;</span>INGREDIENT<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ingredient-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;proteins&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Pick your protein:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;ingredient : $&#123;protein&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;ingredients&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;ingredient.id&#125;&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ingredient.name&#125;&quot;</span>&gt;</span>INGREDIENT<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ingredient-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cheeses&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Choose your cheese:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;ingredient : $&#123;cheese&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;ingredients&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;ingredient.id&#125;&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ingredient.name&#125;&quot;</span>&gt;</span>INGREDIENT<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ingredient-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;veggies&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Determine your veggies:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;ingredient : $&#123;veggies&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;ingredients&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;ingredient.id&#125;&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ingredient.name&#125;&quot;</span>&gt;</span>INGREDIENT<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ingredient-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sauces&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Select your sauce:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;ingredient : $&#123;sauce&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;ingredients&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;ingredient.id&#125;&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ingredient.name&#125;&quot;</span>&gt;</span>INGREDIENT<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Name your taco creation:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;name&#125;&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span>&gt;</span>Submit your taco<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，对于每种类型的配料，都要重复 <code>&lt;div&gt;</code> 片段。还包括一个提交按钮和一个字段，用户可以在其中命名他们的创建。</p>
<p>值得注意的是，完整的模板包括 Taco Cloud 图标图片和一个指向样式表的 <code>&lt;link&gt;</code> 引用。在这两种情况下，Thymeleaf 的 <code>@&#123;&#125;</code> 操作符被用来产生一个上下文相关路径的静态工件，它们正在引用。正如在第 1 章中了解到的，Spring 启动应用程序中的静态内容是从类路径根目录的 &#x2F;static 目录提供的。</p>
<p>现在控制器和视图已经完成，可以启动应用程序了。运行 Spring Boot 应用程序有许多方法。在第 1 章中，展示了如何运行这个应用程序，首先将它构建到一个可执行的 JAR 文件中，然后使用 <code>java -jar</code> 运行这个 JAR。展示了如何使用 <code>mvn spring-boot:run</code> 从构建中直接运行应用程序。</p>
<p>无论如何启动 Taco Cloud 应用程序，一旦启动，使用浏览器访问 <a href="http://localhost:8080/design%E3%80%82%E5%BA%94%E8%AF%A5%E7%9C%8B%E5%88%B0%E7%B1%BB%E4%BC%BC%E5%9B%BE">http://localhost:8080/design。应该看到类似图</a> 2.2 的页面。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><blockquote>
<p>笔记：IDEA自动import？</p>
<p>打开 IDEA 的首选项，找到 Editor | General | Auto Import。勾选上 <code>Add unambiguous imports on the fly</code> 和 <code>Optimize imports on the fly (for current project)</code>。</p>
</blockquote>
<p>出现问题：Springboot项目javax.validation找不到：</p>
<p>使用方法：<a href="https://www.jb51.net/article/185660.htm">https://www.jb51.net/article/185660.htm</a></p>
<p>找不到包：<a href="https://www.cnblogs.com/keadd/p/13652629.html">https://www.cnblogs.com/keadd/p/13652629.html</a></p>
<p>未解决，注释Taco类部分行。</p>
<p>运行不正确，应该是design.html中代码的问题，无法显示网页。</p>
<p>添加了一个webconfig.java文件，依然不行。</p>
<p>运行网上代码，是可以的。</p>
<h2 id="处理表单提交"><a href="#处理表单提交" class="headerlink" title="处理表单提交"></a>处理表单提交</h2><p>第一章显示taco首页，第二章显示配料选取页&#x2F;design，服务端指定可选的配料，传递给客户端，客户端访问design页面通过get请求。客户端选择之后，需要进行表单提交，post请求，传递回服务端，路径相同，都是design。</p>
<p>需要在该 POST 请求的接收端上有一个控制器处理程序方法。需要在 DesignTacoController 中编写一个新的处理程序方法来处理 <code>/design</code> 接口的 POST 请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processDesign</span><span class="params">(Taco design)</span> &#123;</span><br><span class="line">    <span class="comment">// Save the taco design...</span></span><br><span class="line">    <span class="comment">// We&#x27;ll do this in chapter 3</span></span><br><span class="line">    log.info(<span class="string">&quot;Processing design: &quot;</span> + design);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/orders/current&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当应用到 processDesign() 方法时，@PostMapping 与类级别 @RequestMapping 相协调，以表明 processDesign() 应该处理 <code>/design</code> 接口的 POST 请求。这正是需要处理的一个玉米饼艺术家提交的作品。</p>
<p>该方法需要传递一个Taco对象，里面包含了配料和名字等，方法中对taco对象进行处理。在第 3 章中，将添加一些持久性逻辑，将提交的 Taco 保存到数据库中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Taco</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; ingredients;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Taco 是一个简单的 Java 域对象，具有两个属性。与 Ingredient 类似，Taco 类也使用 @Data 进行注释，以便在运行时自动生成基本的 JavaBean 方法。</p>
<p>与 showDesignForm() 方法一样，processDesign() 通过返回一个 String 结束。与 showDesignForm() 类似，返回的值指示将显示给用户的视图。但是不同的是，从 processDesign() 返回的值的前缀是 “redirect:”，表示这是一个重定向视图。更具体地说，它表明在 processDesign() 完成之后，用户的浏览器应该被重定向到相对路径 &#x2F;order&#x2F;current。</p>
<p>意思是重定向到另一个路径？ &#x2F;order&#x2F;current 相当于是&#x2F;design一样的路径，因此需要用 @Controller、@RequestMapping 和 @GetMapping创建一个控制器。</p>
<p>展现订单表单的控制器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package tacos.web;</span><br><span class="line">​</span><br><span class="line">import javax.validation.Valid;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.ui.Model;</span><br><span class="line">import org.springframework.validation.Errors;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import tacos.Order;</span><br><span class="line">​</span><br><span class="line">@Slf4j</span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/orders&quot;)</span><br><span class="line">public class OrderController &#123;</span><br><span class="line">    @GetMapping(&quot;/current&quot;)</span><br><span class="line">    public String orderForm(Model model) &#123;</span><br><span class="line">        model.addAttribute(&quot;order&quot;, new Order());</span><br><span class="line">        return &quot;orderForm&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Lombok 的 @Slf4j 注释在运行时创建一个 SLF4J Logger 对象。稍后，将使用这个 Logger 来记录提交的订单的详细信息。</p>
<p>类级别的 @RequestMapping 指定该控制器中的任何请求处理方法都将处理路径以 &#x2F;orders 开头的请求。当与方法级 @GetMapping 结合使用时，它指定 orderForm() 方法将处理 &#x2F;orders&#x2F;current 的 HTTP GET 请求。</p>
<p>至于 orderForm() 方法本身，它非常简单，只返回 orderForm 的逻辑视图名。在第 3 章中，一旦有了把创建的 taco 持久化到数据库的方法，将重新访问该方法并修改它，以使用 taco 对象的列表填充模型，这些对象将按顺序放置。</p>
<p>orderForm 视图由一个名为 orderForm.html 的 Thymeleaf 模板提供，如下面显示的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Taco Cloud<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/styles.css&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/orders&#125;&quot;</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;order&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Order your taco creations!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/images/TacoCloud.png&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/design&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;another&quot;</span>&gt;</span>Design another taco<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;#fields.hasErrors()&#125;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;validationError&quot;</span>&gt;</span></span><br><span class="line">                    Please correct the problems below and resubmit.</span><br><span class="line">                <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Deliver my taco masterpieces to...<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>Name: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;name&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;street&quot;</span>&gt;</span>Street address: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;street&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;city&quot;</span>&gt;</span>City: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;city&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;state&quot;</span>&gt;</span>State: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;state&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;zip&quot;</span>&gt;</span>Zip code: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;zip&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Here&#x27;s how I&#x27;ll pay...<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;ccNumber&quot;</span>&gt;</span>Credit Card #: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;ccNumber&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;ccExpiration&quot;</span>&gt;</span>Expiration: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;ccExpiration&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;ccCVV&quot;</span>&gt;</span>CVV: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;ccCVV&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit order&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>&lt;form&gt; </code>标记与design 中使用的 <code>&lt;form&gt; </code>标记不同，因为它还指定了一个表单操作。如果没有指定操作，表单将向呈现表单的相同 URL 提交 HTTP POST 请求。但是在这里，指定表单应该提交到 &#x2F;orders（使用 Thymeleaf 的 <code>@&#123;…&#125;</code> 操作符作为上下文相关路径）。</p>
<blockquote>
<p>与design提交的post不同，那个url一样，而这个url本来是order&#x2F;current，应该变为order。</p>
</blockquote>
<p>因此，需要添加另外一个方法到 OrderController 类中，去处理 &#x2F;orders 接口的 POST 请求。在进行到下一章之前，还没有办法将订单持久化，因此在这里简化它 —— 类似于在下一个程序清单中看到的内容。</p>
<blockquote>
<p>重定向到订单，显示订单页，订单表单中，有订单提交，post请求，需要一个控制器。返回首页。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping</span><br><span class="line">public String processOrder(Order order) &#123;</span><br><span class="line">    log.info(&quot;Order submitted: &quot; + order);</span><br><span class="line">    return &quot;redirect:/&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用 processOrder() 方法来处理提交的订单时，它将获得一个 order 对象，其属性绑定到提交的表单字段。Order 非常像 Taco，是一个相当简单的类，它携带订单信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Digits;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Pattern;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.CreditCardNumber;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.NotBlank;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="keyword">private</span> String zip;</span><br><span class="line">    <span class="keyword">private</span> String ccNumber;</span><br><span class="line">    <span class="keyword">private</span> String ccExpiration;</span><br><span class="line">    <span class="keyword">private</span> String ccCVV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="校验表单输入"><a href="#校验表单输入" class="headerlink" title="校验表单输入"></a>校验表单输入</h2><p>执行表单验证的一种方法是在 processDesign() 和 processOrder() 方法中加入一堆 if&#x2F;then 块，检查每个字段以确保它满足适当的验证规则。但是这样做会很麻烦，并且难于阅读和调试。</p>
<p>幸运的是，Spring 支持 Java’s Bean Validation API（也称为 JSR-303；<a href="https://jcp.org/en/jsr/detail?id=303%EF%BC%89%E3%80%82%E8%BF%99%E4%BD%BF%E5%BE%97%E5%A3%B0%E6%98%8E%E9%AA%8C%E8%AF%81%E8%A7%84%E5%88%99%E6%AF%94%E5%9C%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%98%BE%E5%BC%8F%E5%9C%B0%E7%BC%96%E5%86%99%E5%A3%B0%E6%98%8E%E9%80%BB%E8%BE%91%E6%9B%B4%E5%AE%B9%E6%98%93%E3%80%82%E4%BD%BF%E7%94%A8">https://jcp.org/en/jsr/detail?id=303）。这使得声明验证规则比在应用程序代码中显式地编写声明逻辑更容易。使用</a> Spring Boot，不需要做任何特殊的事情来将验证库添加到项目中，因为 Validation API 和 Validation API 的 Hibernate 实现作为Spring Boot web 启动程序的临时依赖项自动添加到了项目中。</p>
<p>要在 Spring MVC 中应用验证，需要这样做：</p>
<ul>
<li>对要验证的类声明验证规则：特别是 Taco 类。</li>
<li>指定验证应该在需要验证的控制器方法中执行，具体来说就是：DesignTacoController 的 processDesign() 方法和 OrderController 的 processOrder() 方法。</li>
<li>修改表单视图以显示验证错误。</li>
</ul>
<h3 id="声明验证规则"><a href="#声明验证规则" class="headerlink" title="声明验证规则"></a>声明验证规则</h3><p>对于 Taco 类，希望确保 name 属性不是空的或 null 的，并且所选配料列表中至少有一项。下面的程序清单显示了一个更新后的 Taco 类，它使用 @NotNull 和 @Size 来声明这些验证规则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Size;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Taco</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size(min=5, message=&quot;Name must be at least 5 characters long&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Size(min=1, message=&quot;You must choose at least 1 ingredient&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; ingredients;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当涉及到对提交玉米饼订单进行验证声明时，必须对 Order 类应用注解。对于地址的属性，只需要确保用户没有留下任何空白字段。对于这一点，将使用 Hibernate Validator 的 @NotBlank 注解。</p>
<p>支付领域的验证是一个比较奇特的存在。你不仅需要确保 ccNumber 属性不为空，还要确保它包含的是一个有效的信用卡号码的值。该 ccExpiration 属性必须符合 MM&#x2F;YY（两位数的年&#x2F;月）格式。而 ccCVV 属性必须是一个三位的数字。为了实现这种验证，需要使用一些其他的 Java Bean Validation API 注释，同时需要从 Hibernate Validator 集合中借用一些验证注解。下面程序清单列出了验证 Order 类所需要的改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Digits;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Pattern;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.CreditCardNumber;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotBlank;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message=&quot;Name is required&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message=&quot;Street is required&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message=&quot;City is required&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message=&quot;State is required&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message=&quot;Zip code is required&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String zip;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CreditCardNumber(message=&quot;Not a valid credit card number&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ccNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pattern(regexp=&quot;^(0[1-9]|1[0-2])([\\/])([1-9][0-9])$&quot;,</span></span><br><span class="line"><span class="meta">             message=&quot;Must be formatted MM/YY&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ccExpiration;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Digits(integer=3, fraction=0, message=&quot;Invalid CVV&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ccCVV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，ccNumber 属性用 @CreditCardNumber 进行了注释。该注释声明属性的值必须是通过 Luhn 算法（<a href="https://en.wikipedia.org/wiki/Luhn_algorithm%EF%BC%89%E6%A3%80%E6%9F%A5%E8%BF%87%E7%9A%84%E6%9C%89%E6%95%88%E4%BF%A1%E7%94%A8%E5%8D%A1%E5%8F%B7%E3%80%82%E8%BF%99%E5%8F%AF%E4%BB%A5%E9%98%B2%E6%AD%A2%E7%94%A8%E6%88%B7%E5%87%BA%E9%94%99%E7%9A%84%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%85%E6%84%8F%E9%94%99%E8%AF%AF%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%86%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BF%A1%E7%94%A8%E5%8D%A1%E5%8F%B7%E7%A0%81%E5%AE%9E%E9%99%85%E4%B8%8A%E8%A2%AB%E5%88%86%E9%85%8D%E5%88%B0%E4%B8%80%E4%B8%AA%E5%B8%90%E6%88%B7%EF%BC%8C%E6%88%96%E8%AF%A5%E5%B8%90%E6%88%B7%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E4%BA%A4%E6%98%93%E3%80%82">https://en.wikipedia.org/wiki/Luhn_algorithm）检查过的有效信用卡号。这可以防止用户出错的数据和故意错误的数据，但不能保证信用卡号码实际上被分配到一个帐户，或该帐户可以用于交易。</a></p>
<p>不幸的是，没有现成的注释来验证 ccExpiration 属性的 MM&#x2F;YY 格式。我已经应用了 @Pattern 注释，为它提供了一个正则表达式，以确保属性值符合所需的格式。</p>
<p>最后，用 @Digits 注释 ccCVV 属性，以确保值恰好包含三个数字。</p>
<p>所有的验证注释都包含一个消息属性，该属性定义了如果用户输入的信息不符合声明的验证规则的要求时将显示给用户的消息。</p>
<h3 id="表单绑定时执行校验"><a href="#表单绑定时执行校验" class="headerlink" title="表单绑定时执行校验"></a>表单绑定时执行校验</h3><p>上一节在领域类中制定了验证规则，现在需要重新修改每个控制器，让表单在POST提交至对应的控制器方法时执行对应的校验。</p>
<p>要验证提交的 Taco，需要将 Java Bean Validation API 的 @Valid 注释添加到 DesignTacoController 的 processDesign() 方法的 Taco 参数中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processDesign</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@ModelAttribute(&quot;design&quot;)</span> Taco design, Errors errors)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (errors.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;design&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Save the taco design...</span></span><br><span class="line">    <span class="comment">// We&#x27;ll do this in chapter 3</span></span><br><span class="line">    log.info(<span class="string">&quot;Processing design: &quot;</span> + design);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/orders/current&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Valid 注释告诉 Spring MVC 在提交的 Taco 对象绑定到提交的表单数据之后，以及调用 processDesign() 方法之前，对提交的 Taco 对象执行验证。如果存在任何验证错误，这些错误的详细信息将在传递到 processDesign() 的错误对象中捕获。processDesign() 的前几行查询 Errors 对象，询问它的 hasErrors() 方法是否存在任何验证错误。如果有，该方法结束时不处理 Taco，并返回 “design” 视图名，以便重新显示表单。</p>
<p>要对提交的 Order 对象执行验证，还需要对 OrderController 的 processOrder() 方法进行类似的更改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processOrder</span><span class="params">(<span class="meta">@Valid</span> Order order, Errors errors)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (errors.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;orderForm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    log.info(<span class="string">&quot;Order submitted: &quot;</span> + order);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这两种情况下，如果没有验证错误，则允许该方法处理提交的数据。如果存在验证错误，则请求将被转发到表单视图，以便用户有机会纠正其错误。</p>
<h3 id="显示验证错误"><a href="#显示验证错误" class="headerlink" title="显示验证错误"></a>显示验证错误</h3><p>前面会在传入控制器之前进行验证，验证有误，则返回之前页面。</p>
<p>但是用户如何知道哪些错误需要改正呢？除非调出表单上的错误，否则用户将只能猜测如何成功提交表单。</p>
<p>Thymeleaf 通过 fields 属性及其 <code>th:errors</code> 属性提供了对 Errors 对象的便捷访问。例如，要在信用卡号字段上显示验证错误，可以添加一个 <code>&lt;span&gt; </code>元素，该元素将这些错误引用用于订单模板，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">&quot;ccNumber&quot;</span>&gt;Credit Card #: &lt;/label&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> th:field=<span class="string">&quot;*&#123;ccNumber&#125;&quot;</span>/&gt;</span><br><span class="line">&lt;span class=<span class="string">&quot;validationError&quot;</span></span><br><span class="line">      th:<span class="keyword">if</span>=<span class="string">&quot;$&#123;#fields.hasErrors(&#x27;ccNumber&#x27;)&#125;&quot;</span></span><br><span class="line">      th:errors=<span class="string">&quot;*&#123;ccNumber&#125;&quot;</span>&gt;CC Num Error&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>除了可以用来设置错误样式以引起用户注意的 class 属性外，<span> 元素还使用 <code>th:if</code> 属性来决定是否显示 <span>。fields 属性的 hasErrors() 方法检查 ccNumber 字段中是否有任何错误。如果有错误，<span> 将被渲染。</p>
<p><code>th:errors</code> 属性引用 ccNumber 字段，并且假设该字段存在错误，它将用验证消息替换 <span> 元素的占位符内容。</p>
<h2 id="使用视图控制器"><a href="#使用视图控制器" class="headerlink" title="使用视图控制器"></a>使用视图控制器</h2><p>到目前为止，已经为 Taco Cloud 应用程序编写了三个控制器。尽管每个控制器在应用程序的功能上都有不同的用途，但它们几乎都遵循相同的编程模型：</p>
<ul>
<li>它们都用 @Controller 进行了注释，以表明它们是控制器类，应该由 Spring 组件扫描自动发现，并在 Spring 应用程序上下文中作为 bean 进行实例化。</li>
<li>除了 HomeController 之外，所有的控制器都在类级别上使用 @RequestMapping 进行注释，以定义控制器将处理的基本请求模式。</li>
<li>它们都有一个或多个方法，这些方法都用 @GetMapping 或 @PostMapping 进行了注释，以提供关于哪些方法应该处理哪些请求的细节。</li>
</ul>
<p>即将编写的大多数控制器都将遵循这种模式。但是，如果一个控制器足够简单，不填充模型或流程输入（就像 HomeController 一样），那么还有另一种定义控制器的方法。请查看下一个程序清单，了解如何声明视图控制器 —— 一个只将请求转发给视图的控制器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.web;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ViewControllerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;home&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 @WebConfig 最值得注意的是它实现了 WebMvcConfigurer 接口。WebMvcConfigurer 定义了几个配置 Spring MVC 的方法。尽管它是一个接口，但它提供了所有方法的默认实现，因此只需覆盖所需的方法。在本例中，覆盖了 addViewControllers() 方法。</p>
<p>addViewControllers() 方法提供了一个 ViewControllerRegistry，可以使用它来注册一个或多个视图控制器。在这里，在注册表上调用 addViewController()，传入 “&#x2F;”，这是视图控制器处理 GET 请求的路径。该方法返回一个 ViewControllerRegistration 对象，在该对象上立即调用 setViewName() 来指定 home 作为应该转发 “&#x2F;” 请求的视图。</p>
<p>就像这样，已经能够用配置类中的几行代码替换 HomeController。现在可以删除 HomeController，应用程序的行为应该与以前一样。惟一需要做的其他更改是重新访问第 1 章中的 HomeControllerTest，从 @WebMvcTest 注释中删除对 HomeController 的引用，这样测试类就可以无错误地编译了。</p>
<p>这里，已经创建了一个新的 WebConfig 配置类来存放视图控制器声明。但是任何配置类都可以实现 WebMvcConfigurer 并覆盖 addViewController() 方法。例如，可以将相同的视图控制器声明添加到引导 TacoCloudApplication 类中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TacoCloudApplication</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TacoCloudApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;home&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过扩展现有的配置类，可以避免创建新的配置类，从而降低项目工件数量。但是我倾向于为每种配置（web、数据、安全性等等）创建一个新的配置类，保持应用程序引导配置的简洁。</p>
<p>说到视图控制器，更一般地说，是控制器将请求转发给的视图。</p>
<h2 id="视图模板库"><a href="#视图模板库" class="headerlink" title="视图模板库"></a>视图模板库</h2><p>一般来说，可以选择想要的视图模板库，将其作为依赖项添加到构建中，然后开始在 &#x2F;templates 目录中（在 Maven 或 Gradl 构建项目的 src&#x2F;main&#x2F;resources 目录下）编写模板。Spring Boot 将检测选择的模板库，并自动配置所需的组件来为 Spring MVC 控制器提供视图。</p>
<p>已经在 Taco Cloud 应用程序中用 Thymeleaf 实现了这一点。在第 1 章中，在初始化项目时选择了 Thymeleaf 复选框。这导致 Spring Boot 的 Thymeleaf starter 被包含在 pom.xml 文件中。当应用程序启动时，Spring Boot 自动配置会检测到 Thymeleaf 的存在，并自动配置 Thymeleaf bean。现在要做的就是开始在 &#x2F;templates 中编写模板。</p>
<p>如果希望使用不同的模板库，只需在项目初始化时选择它，或者编辑现有的项目构建以包含新选择的模板库。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>Spring 提供了一个强大的 web 框架，称为 Spring MVC，可以用于开发 Spring 应用程序的 web 前端。</li>
<li>Spring MVC 是基于注解的，可以使用 @RequestMapping、@GetMapping 和 @PostMapping 等注解来声明请求处理方法。</li>
<li>大多数请求处理方法通过返回视图的逻辑名称来结束，例如一个 Thymeleaf 模板，请求（以及任何模型数据）被转发到该模板。</li>
<li>Spring MVC 通过 Java Bean Validation API 和 Hibernate Validator 等验证 API 的实现来支持验证。</li>
<li>视图控制器可以用来处理不需要模型数据或处理的 HTTP GET 请求。</li>
<li>除了 Thymeleaf，Spring 还支持多种视图选项，包括 FreeMarker、Groovy Templates 和 Mustache。</li>
</ul>
<h1 id="第三章-使用数据"><a href="#第三章-使用数据" class="headerlink" title="第三章 使用数据"></a>第三章 使用数据</h1><p>本章内容：</p>
<ul>
<li>使用 Spring JdbcTemplate</li>
<li>使用 SimpleJdbcInsert 插入数据</li>
<li>使用 Spring Data 声明 JPA repositories</li>
</ul>
<p>在 Taco Cloud 应用程序中，需要能够维护关于 ingredients、tacos 和 orders 的信息。如果没有一个数据库来存储这些信息，应用程序将无法比在第 2 章中开发的应用程序取得更大的进展。</p>
<p>在本章中，将向 Taco Cloud 应用程序添加数据持久化操作。首先使用 Spring 对 JDBC（Java Database Connectivity）的支持来消除样板代码。然后，将重新使用 JPA（Java Persistence API）处理数据存储库，从而消除更多代码。</p>
<p>在处理关系数据时，Java 开发人员有多个选择。两个最常见的选择是 JDBC 和 JPA。Spring 通过抽象支持这两种方式，这使得使用 JDBC 或 JPA 比不使用 Spring 更容易。</p>
<h2 id="使用-JDBC-读写数据"><a href="#使用-JDBC-读写数据" class="headerlink" title="使用 JDBC 读写数据"></a>使用 JDBC 读写数据</h2><p>Spring JDBC 支持起源于 JdbcTemplate 类。JdbcTemplate 提供了一种方法，通过这种方法，开发人员可以对关系数据库执行 SQL 操作，与通常使用 JDBC 不同的是，这里不需要满足所有的条件和样板代码。</p>
<p>在没有 JdbcTemplate 的情况下用 Java 执行一个简单的查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Ingredient <span class="title function_">findOne</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connection = dataSource.getConnection();</span><br><span class="line">        statement = connection.prepareStatement(</span><br><span class="line">            <span class="string">&quot;select id, name, type from Ingredient&quot;</span>);</span><br><span class="line">        statement.setString(<span class="number">1</span>, id);</span><br><span class="line">        resultSet = statement.executeQuery();</span><br><span class="line">        <span class="type">Ingredient</span> <span class="variable">ingredient</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(resultSet.next()) &#123;</span><br><span class="line">            ingredient = <span class="keyword">new</span> <span class="title class_">Ingredient</span>(</span><br><span class="line">                resultSet.getString(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">                resultSet.getString(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">                Ingredient.Type.valueOf(resultSet.getString(<span class="string">&quot;type&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ingredient;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// ??? What should be done here ???</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultSet != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (statement != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询语句被创建连接、创建语句和通过关闭连接、语句和结果集来清理的代码所包围。</p>
<p>更糟糕的是，在创建连接或语句或执行查询时，可能会出现许多问题。这要求捕获一个 SQLException，这可能有助于（也可能无助于）找出问题出在哪里或如何解决问题。</p>
<p>SQLException 是一个被检查的异常，它需要在 catch 块中进行处理。但是最常见的问题，如未能创建到数据库的连接或输入错误的查询，不可能在 catch 块中得到解决，可能会重新向上抛出以求处理。相反，要是考虑使用 JdbcTemplate 的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> JdbcTemplate jdbc;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Ingredient <span class="title function_">findOne</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jdbc.queryForObject(</span><br><span class="line">        <span class="string">&quot;select id, name, type from Ingredient where id=?&quot;</span>,</span><br><span class="line">        <span class="built_in">this</span>::mapRowToIngredient, id);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span> Ingredient <span class="title function_">mapRowToIngredient</span><span class="params">(ResultSet rs, <span class="type">int</span> rowNum)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Ingredient</span>(</span><br><span class="line">        rs.getString(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">        rs.getString(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">        Ingredient.Type.valueOf(rs.getString(<span class="string">&quot;type&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有创建任何语句或连接。而且，在方法完成之后，不会对那些对象进行任何清理。最后，这样做不会存在任何在 catch 块中不能处理的异常。剩下的代码只专注于执行查询（调用 JdbcTemplate 的 queryForObject() 方法）并将结果映射到 Ingredient 对象（在 mapRowToIngredient() 方法中）。</p>
<h3 id="为域适配持久化"><a href="#为域适配持久化" class="headerlink" title="为域适配持久化"></a>为域适配持久化</h3><p>在将对象持久化到数据库时，通常最好有一个惟一标识对象的字段。Ingredient 类已经有一个 id 字段，但是需要向 Taco 和 Order 添加 id 字段。还需要向每个对象添加一个字段，以捕获保存对象的日期和时间。</p>
<p>新的taco：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Taco</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Date createdAt;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新的order：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Date placedAt;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为使用 Lombok 在运行时自动生成访问器方法，所以除了声明 id 和 createdAt 属性外，不需要做任何事情。它们将在运行时根据需要生成适当的 getter 和 setter 方法。</p>
<h3 id="使用-JdbcTemplate"><a href="#使用-JdbcTemplate" class="headerlink" title="使用 JdbcTemplate"></a><strong>使用 JdbcTemplate</strong></h3><p>在开始使用 JdbcTemplate 之前，需要将它添加到项目类路径中。这很容易通过添加 Spring Boot 的 JDBC starter 依赖来实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还需要一个存储数据的数据库。出于开发目的，嵌入式数据库足矣。我喜欢 H2 嵌入式数据库，所以我添加了以下依赖进行构建：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em><strong>写一个获取和保存 Ingredient 数据的存储库：</strong></em></p>
<h4 id="（1）定义-JDBC-数据库接口"><a href="#（1）定义-JDBC-数据库接口" class="headerlink" title="（1）定义 JDBC 数据库接口"></a>（1）定义 JDBC 数据库接口</h4><p>Ingredient repository 需要执行以下操作：</p>
<ul>
<li>查询所有的 Ingredient 使之变成一个 Ingredient 的集合对象</li>
<li>通过它的 id 查询单个 Ingredient</li>
<li>保存一个 Ingredient 对象</li>
</ul>
<p>以下 IngredientRepository 接口以方法声明的方式定义了这三种操作：<strong>每一个库一个单独接口文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IngredientRepository</span> &#123;</span><br><span class="line">    </span><br><span class="line">    Iterable&lt;Ingredient&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    Ingredient <span class="title function_">findOne</span><span class="params">(String id)</span>;</span><br><span class="line">    </span><br><span class="line">    Ingredient <span class="title function_">save</span><span class="params">(Ingredient ingredient)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（2）使用-JdbcTemplate-编写具体操作，读取"><a href="#（2）使用-JdbcTemplate-编写具体操作，读取" class="headerlink" title="（2）使用 JdbcTemplate 编写具体操作，读取"></a>（2）使用 JdbcTemplate 编写具体操作，读取</h4><p>编写一个使用 JdbcTemplate 来查询数据库的 IngredientRepository 的实现。<strong>每一个库一个具体操作类文件，方法代表查询插入等。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcIngredientRepository</span> <span class="keyword">implements</span> <span class="title class_">IngredientRepository</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbc;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JdbcIngredientRepository</span><span class="params">(JdbcTemplate jdbc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jdbc = jdbc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">​</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JdbcIngredientRepository 使用 @Repository 进行了注解。这个注解是 Spring 定义的少数几个原型注解之一，包括 @Controller 和 @Component。通过使用 @Repository 对 JdbcIngredientRepository 进行注解，这样它就会由 Spring 组件在扫描时自动发现，并在 Spring 应用程序上下文中生成 bean 实例。</p>
<p>当 Spring 创建 JdbcIngredientRepository bean 时，通过 @Autowired 注解将 JdbcTemplate 注入到 bean 中。构造函数将 JdbcTemplate 分配给一个实例变量，该变量将在其他方法中用于查询和插入数据库。谈到那些其他方法，让我们来看看 findAll() 和 findOne() 的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Iterable&lt;Ingredient&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jdbc.query(<span class="string">&quot;select id, name, type from Ingredient&quot;</span>,</span><br><span class="line">              <span class="built_in">this</span>::mapRowToIngredient);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Ingredient <span class="title function_">findOne</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jdbc.queryForObject(</span><br><span class="line">        <span class="string">&quot;select id, name, type from Ingredient where id=?&quot;</span>,</span><br><span class="line">        <span class="built_in">this</span>::mapRowToIngredient, id);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span> Ingredient <span class="title function_">mapRowToIngredient</span><span class="params">(ResultSet rs, <span class="type">int</span> rowNum)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Ingredient</span>(</span><br><span class="line">        rs.getString(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">        rs.getString(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">        Ingredient.Type.valueOf(rs.getString(<span class="string">&quot;type&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>findAll() 和 findOne() 都以类似的方式使用 JdbcTemplate。期望返回对象集合的 findAll() 方法使用了 JdbcTemplate 的 query() 方法。query() 方法接受查询的 SQL 以及 Spring 的 RowMapper 实现，以便将结果集中的每一行映射到一个对象。findAll() 还接受查询中所需的所有参数的列表作为它的最后一个参数。但是，在本例中，没有任何必需的参数。</p>
<p>findOne() 方法只期望返回单个成分对象，因此它使用 JdbcTemplate 的 queryForObject() 方法而不是 query()。queryForObject() 的工作原理与 query() 非常相似，只是它返回的是单个对象，而不是对象列表。在本例中，它给出了要执行的查询、一个 RowMapper 和要获取的 Ingredient 的 id，后者用于代替查询 SQL 中 的 <code>?</code>。</p>
<p>findAll() 和 findOne() 的 RowMapper 参数作为 mapRowToIngredient() 方法的方法引用。当使用 JdbcTemplate 作为显式 RowMapper 实现的替代方案时，使用 Java 8 的方法引用和 lambda 非常方便。但是，如果出于某种原因，想要或是需要一个显式的 RowMapper，那么 findOne() 的以下实现将展示如何做到这一点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Ingredient <span class="title function_">findOne</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jdbc.queryForObject(</span><br><span class="line">        <span class="string">&quot;select id, name, type from Ingredient where id=?&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RowMapper</span>&lt;Ingredient&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Ingredient <span class="title function_">mapRow</span><span class="params">(ResultSet rs, <span class="type">int</span> rowNum)</span></span><br><span class="line">                <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Ingredient</span>(</span><br><span class="line">                    rs.getString(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">                    rs.getString(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">                    Ingredient.Type.valueOf(rs.getString(<span class="string">&quot;type&quot;</span>)));</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（3）插入一行数据"><a href="#（3）插入一行数据" class="headerlink" title="（3）插入一行数据"></a>（3）插入一行数据</h4><p>JdbcTemplate 的 update() 方法可用于在数据库中写入或更新数据的任何查询。</p>
<p>使用JdbcTemplate插入数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Ingredient <span class="title function_">save</span><span class="params">(Ingredient ingredient)</span> &#123;</span><br><span class="line">    jdbc.update(</span><br><span class="line">        <span class="string">&quot;insert into Ingredient (id, name, type) values (?, ?, ?)&quot;</span>,</span><br><span class="line">        ingredient.getId(),</span><br><span class="line">        ingredient.getName(),</span><br><span class="line">        ingredient.getType().toString());</span><br><span class="line">    <span class="keyword">return</span> ingredient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为没有必要将 ResultSet 数据映射到对象，所以 update() 方法要比 query() 或 queryForObject() 简单得多。它只需要一个包含 SQL 的字符串来执行，以及为任何查询参数赋值。在本例中，查询有三个参数，它们对应于 save() 方法的最后三个参数，提供了 Ingredient 的 id、name 和 type。</p>
<p>完成了 JdbcIngredientRepository后，现在可以将其注入到 DesignTacoController 中，并使用它来提供一个 Ingredient 对象列表，而不是使用硬编码的值（正如第 2 章中所做的那样）。DesignTacoController 的变化如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/design&quot;)</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DesignTacoController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IngredientRepository ingredientRepo;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DesignTacoController</span><span class="params">(IngredientRepository ingredientRepo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ingredientRepo = ingredientRepo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">showDesignForm</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        List&lt;Ingredient&gt; ingredients = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ingredientRepo.findAll().forEach(i -&gt; ingredients.add(i));</span><br><span class="line">        Type[] types = Ingredient.Type.values();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            model.addAttribute(type.toString().toLowerCase(),</span><br><span class="line">                               filterByType(ingredients, type));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;design&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>showDesignForm() 方法的第 2 行现在调用了注入的 IngredientRepository 的 findAll() 方法。findAll() 方法从数据库中提取所有 Ingredient，然后将它们对应到到模型的不同类型中。</p>
<h3 id="写表并预加载数据"><a href="#写表并预加载数据" class="headerlink" title="写表并预加载数据"></a>写表并预加载数据</h3><p>在开始从查询中引用的 Ingredient 表读取数据之前，应该创建这个表并写一些 Ingredient 数据进去。</p>
<p>除了 Ingredient 表之外，还需要一些保存订单和设计信息的表。也就是要定义数据库数据规则。create语句。</p>
<ul>
<li>Ingredient - 保存着原料信息</li>
<li>Taco - 保存着关于 taco 设计的重要信息</li>
<li>Taco_Ingredient - 包含 Taco 表中每一行的一个或多行数据，将 Taco 映射到该 Taco 的 Ingredient（如果一个taco有多个配料，就插入多行）</li>
<li>Taco_Order - 保存着重要的订单细节</li>
<li>Taco_Order_Tacos - 包含 Taco_Order 表中的每一行的一个或多行数据，将 Order 映射到 Order 中的Tacos</li>
</ul>
<p>创建表的sql语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> Ingredient (</span><br><span class="line">    id <span class="type">varchar</span>(<span class="number">4</span>) <span class="keyword">not null</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">25</span>) <span class="keyword">not null</span>,</span><br><span class="line">    type <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not null</span></span><br><span class="line">);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">create table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> Taco (</span><br><span class="line">    id <span class="keyword">identity</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not null</span>,</span><br><span class="line">    createdAt <span class="type">timestamp</span> <span class="keyword">not null</span></span><br><span class="line">);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">create table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> Taco_Ingredients (</span><br><span class="line">    taco <span class="type">bigint</span> <span class="keyword">not null</span>,</span><br><span class="line">    ingredient <span class="type">varchar</span>(<span class="number">4</span>) <span class="keyword">not null</span></span><br><span class="line">);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">alter table</span> Taco_Ingredients <span class="keyword">add</span> <span class="keyword">foreign key</span> (taco) <span class="keyword">references</span> Taco(id);</span><br><span class="line"><span class="keyword">alter table</span> Taco_Ingredients <span class="keyword">add</span> <span class="keyword">foreign key</span> (ingredient) <span class="keyword">references</span> Ingredient(id);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">create table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> Taco_Order (</span><br><span class="line">    id <span class="keyword">identity</span>,</span><br><span class="line">    deliveryName <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not null</span>,</span><br><span class="line">    deliveryStreet <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not null</span>,</span><br><span class="line">    deliveryCity <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not null</span>,</span><br><span class="line">    deliveryState <span class="type">varchar</span>(<span class="number">2</span>) <span class="keyword">not null</span>,</span><br><span class="line">    deliveryZip <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not null</span>,</span><br><span class="line">    ccNumber <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">not null</span>,</span><br><span class="line">    ccExpiration <span class="type">varchar</span>(<span class="number">5</span>) <span class="keyword">not null</span>,</span><br><span class="line">    ccCVV <span class="type">varchar</span>(<span class="number">3</span>) <span class="keyword">not null</span>,</span><br><span class="line">    placedAt <span class="type">timestamp</span> <span class="keyword">not null</span></span><br><span class="line">);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">create table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> Taco_Order_Tacos (</span><br><span class="line">    tacoOrder <span class="type">bigint</span> <span class="keyword">not null</span>,</span><br><span class="line">    taco <span class="type">bigint</span> <span class="keyword">not null</span></span><br><span class="line">);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">alter table</span> Taco_Order_Tacos <span class="keyword">add</span> <span class="keyword">foreign key</span> (tacoOrder) <span class="keyword">references</span> Taco_Order(id);</span><br><span class="line"><span class="keyword">alter table</span> Taco_Order_Tacos <span class="keyword">add</span> <span class="keyword">foreign key</span> (taco) <span class="keyword">references</span> Taco(id);</span><br></pre></td></tr></table></figure>

<p>最大的问题是把这个模式定义放在哪里。事实证明，Spring Boot 回答了这个问题。</p>
<p>如果有一个名为 schema.sql 的文件。在应用程序的类路径根目录下执行 sql，然后在应用程序启动时对数据库执行该文件中的 SQL。因此，应该将定义数据库 的内容写入一个名为 schema.sql 的文件中，然后放在项目的 src&#x2F;main&#x2F;resources 文件夹下。</p>
<p>还需要用一些 Ingredient 数据来预加载数据库。幸运的是，Spring Boot 还将执行一个名为 data.sql 的文件，这个文件位于根路径下。因此，可以使用 src&#x2F;main&#x2F;resources&#x2F;data.sql 中的预加载数据库程序中的 insert 语句来加载包含 Ingredient 数据的数据库。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Taco_Order_Tacos;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Taco_Ingredients;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Taco;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Taco_Order;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Ingredient;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">insert into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;FLTO&#x27;</span>, <span class="string">&#x27;Flour Tortilla&#x27;</span>, <span class="string">&#x27;WRAP&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;COTO&#x27;</span>, <span class="string">&#x27;Corn Tortilla&#x27;</span>, <span class="string">&#x27;WRAP&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;GRBF&#x27;</span>, <span class="string">&#x27;Ground Beef&#x27;</span>, <span class="string">&#x27;PROTEIN&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;CARN&#x27;</span>, <span class="string">&#x27;Carnitas&#x27;</span>, <span class="string">&#x27;PROTEIN&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;TMTO&#x27;</span>, <span class="string">&#x27;Diced Tomatoes&#x27;</span>, <span class="string">&#x27;VEGGIES&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;LETC&#x27;</span>, <span class="string">&#x27;Lettuce&#x27;</span>, <span class="string">&#x27;VEGGIES&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;CHED&#x27;</span>, <span class="string">&#x27;Cheddar&#x27;</span>, <span class="string">&#x27;CHEESE&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;JACK&#x27;</span>, <span class="string">&#x27;Monterrey Jack&#x27;</span>, <span class="string">&#x27;CHEESE&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;SLSA&#x27;</span>, <span class="string">&#x27;Salsa&#x27;</span>, <span class="string">&#x27;SAUCE&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;SRCR&#x27;</span>, <span class="string">&#x27;Sour Cream&#x27;</span>, <span class="string">&#x27;SAUCE&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>以上只开发了 Ingredient 数据的存储库，还需要继续编写用于持久化 Taco、Order 的存储库和相应的数据。</p>
<h3 id="具体持久化方法"><a href="#具体持久化方法" class="headerlink" title="具体持久化方法"></a>具体持久化方法</h3><p>到此，已经了解了如何使用 JdbcTemplate 向数据库写入数据。JdbcIngredientRepository 中的 save() 方法使用 JdbcTemplate 的 update() 方法将 Ingredient 对象保存到数据库中。</p>
<p>虽然这是第一个很好的例子，但是它可能有点太简单了。保存数据可能比 JdbcIngredientRepository 所需要的更复杂。使用 JdbcTemplate 保存数据的两种方法包括：</p>
<ul>
<li>直接使用 update() 方法</li>
<li>使用 SimpleJdbcInsert 包装类</li>
</ul>
<p>让我们首先看看，当持久话需求比保存一个 Ingredient 所需要的更复杂时，如何使用 update() 方法。</p>
<h4 id="使用-JdbcTemplate-保存数据"><a href="#使用-JdbcTemplate-保存数据" class="headerlink" title="使用 JdbcTemplate 保存数据"></a>使用 JdbcTemplate 保存数据</h4><p>目前，Taco 和 Order 存储库需要做的惟一一件事是保存它们各自的对象。为了保存 Taco 对象，TacoRepository 声明了一个 save() 方法，接口如下所示：OrderRepository接口 也声明了一个 save() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tacos.Taco;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TacoRepository</span> &#123;</span><br><span class="line">    Taco <span class="title function_">save</span><span class="params">(Taco design)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tacos.Order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderRepository</span> &#123;</span><br><span class="line">    Order <span class="title function_">save</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存一个 Taco 设计需要将与该 Taco 关联的 Ingredient 保存到 Taco_Ingredient 表中。同样，保存 Order 也需要将与 Order 关联的 Taco 保存到 Taco_Order_Tacos 表中。这使得保存 Taco 和 Order 比 保存 Ingredient 更有挑战性。</p>
<p>要实现 TacoRepository，需要一个 save() 方法，该方法首先保存基本的 Taco 设计细节（例如，名称和创建时间），然后为 Taco 对象中的每个 Ingredient 在 Taco_Ingredients 中插入一行。下面的程序显示了完整的 JdbcTacoRepository 类。</p>
<p>使用 JdbcTemplate 实现 TacoRepository：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Timestamp;</span><br><span class="line"><span class="keyword">import</span> java.sql.Types;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.PreparedStatementCreator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.PreparedStatementCreatorFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.support.GeneratedKeyHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.support.KeyHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient;</span><br><span class="line"><span class="keyword">import</span> tacos.Taco;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTacoRepository</span> <span class="keyword">implements</span> <span class="title class_">TacoRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JdbcTacoRepository</span><span class="params">(JdbcTemplate jdbc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jdbc = jdbc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Taco <span class="title function_">save</span><span class="params">(Taco taco)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">tacoId</span> <span class="operator">=</span> saveTacoInfo(taco);</span><br><span class="line">        taco.setId(tacoId);</span><br><span class="line">        <span class="keyword">for</span> (Ingredient ingredient : taco.getIngredients()) &#123;</span><br><span class="line">            saveIngredientToTaco(ingredient, tacoId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> taco;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">saveTacoInfo</span><span class="params">(Taco taco)</span> &#123;</span><br><span class="line">        taco.setCreatedAt(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">PreparedStatementCreator</span> <span class="variable">psc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PreparedStatementCreatorFactory</span>(</span><br><span class="line">            <span class="string">&quot;insert into Taco (name, createdAt) values (?, ?)&quot;</span>,</span><br><span class="line">            Types.VARCHAR, Types.TIMESTAMP</span><br><span class="line">        ).newPreparedStatementCreator(</span><br><span class="line">            Arrays.asList(</span><br><span class="line">                taco.getName(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Timestamp</span>(taco.getCreatedAt().getTime())));</span><br><span class="line"></span><br><span class="line">        <span class="type">KeyHolder</span> <span class="variable">keyHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneratedKeyHolder</span>();</span><br><span class="line">        jdbc.update(psc, keyHolder);</span><br><span class="line">        <span class="keyword">return</span> keyHolder.getKey().longValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveIngredientToTaco</span><span class="params">(Ingredient ingredient, <span class="type">long</span> tacoId)</span> &#123;</span><br><span class="line">        jdbc.update(</span><br><span class="line">            <span class="string">&quot;insert into Taco_Ingredients (taco, ingredient) &quot;</span> +<span class="string">&quot;values (?, ?)&quot;</span>,</span><br><span class="line">            tacoId, ingredient.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>save() 方法首先调用私有的 saveTacoInfo() 方法，然后使用该方法返回的 Taco id 调用 saveIngredientToTaco()，它保存每个配料。在 Taco 中插入一行时，需要知道数据库生成的 id，以便在每个 Ingredient 中引用它。保存 Ingredient 数据时使用的 update() 方法不能获得生成的 id，因此这里需要一个不同的 update() 方法。</p>
<p>需要的 update() 方法接受 PreparedStatementCreator 和 KeyHolder。KeyHolder 将提供生成的 Taco id，但是为了使用它，还必须创建一个 PreparedStatementCreator。创建 PreparedStatementCreator 非常重要。首先创建一个 PreparedStatementCreatorFactory，为它提供想要执行的 SQL，以及每个查询参数的类型。然后在该工厂上调用 newPreparedStatementCreator()，在查询参数中传递所需的值以生成 PreparedStatementCreator。通过使用 PreparedStatementCreator，可以调用 update()，传入 PreparedStatementCreator 和 KeyHolder（在本例中是 GeneratedKeyHolder 实例）。update() 完成后，可以通过返回 keyHolder.getKey().longValue() 来返回 Taco id。</p>
<p>回到 save() 方法，循环遍历 Taco 中的每个成分，调用 saveIngredientToTaco() 方法。saveIngredientToTaco() 方法使用更简单的 update() 形式来保存对到Taco_Ingredient 表中。</p>
<p>TacoRepository 剩下所要做的就是在 DesignTacoController 中进行持久化操作，将订单保存到数据库中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/design&quot;)</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DesignTacoController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IngredientRepository ingredientRepo;</span><br><span class="line">    <span class="keyword">private</span> TacoRepository designRepo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DesignTacoController</span><span class="params">(</span></span><br><span class="line"><span class="params">        IngredientRepository ingredientRepo,</span></span><br><span class="line"><span class="params">        TacoRepository designRepo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ingredientRepo = ingredientRepo;</span><br><span class="line">        <span class="built_in">this</span>.designRepo = designRepo;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数包含一个 IngredientRepository 和一个TacoRepository。它将这两个变量都赋值给实例变量，以便它们可以在 showDesignForm() 和 processDesign() 方法中使用。</p>
<p>新的 processDesign() 方法，保存 Taco 设计并链接到 Order：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/design&quot;)</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DesignTacoController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute(name = &quot;order&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">order</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute(name = &quot;taco&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Taco <span class="title function_">taco</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Taco</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">processDesign</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Valid</span> Taco design, Errors errors,</span></span><br><span class="line"><span class="params">        <span class="meta">@ModelAttribute</span> Order order)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (errors.hasErrors()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;design&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Taco</span> <span class="variable">saved</span> <span class="operator">=</span> designRepo.save(design);</span><br><span class="line">        order.addDesign(saved);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/orders/current&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> DesignTacoController 使用 @SessionAttributes(“order”) 进行了注解，并且在 order() 方法上有一个新的注解 @ModelAttribute。与 taco() 方法一样，order() 方法上的 @ModelAttribute 注解确保在模型中能够创建 Order 对象。但是与 <strong>session</strong> 中的 Taco 对象不同，这里<strong>需要在多个请求间显示订单，因此可以创建多个 Taco 并将它们添加到订单中</strong>。类级别的 @SessionAttributes 注解指定了任何模型对象，比如应该保存在会话中的 order 属性，并且可以<strong>跨多个请求使用</strong>。</p>
<p>taco 设计的实际处理发生在 processDesign() 方法中，除了 Taco 和 Errors 对象外，该方法现在还接受 Order 对象作为参数。Order 参数使用 @ModelAttribute 进行注解，以指示其值应该来自模型，而 Spring MVC 不应该尝试给它绑定请求参数。</p>
<p>在检查验证错误之后，processDesign() 使用注入的 TacoRepository 来保存 Taco。然后，<strong>它将 Taco 对象添加到保存于 session 中 Order 对象中</strong>。实际上，Order 对象仍然保留在 session 中，直到用户完成并提交 Order 表单才会保存到数据库中。此时，OrderController 需要调用 OrderRepository 的实现来保存订单。下面来写一下这个实现。</p>
<h4 id="使用-SimpleJdbcInsert-保存数据"><a href="#使用-SimpleJdbcInsert-保存数据" class="headerlink" title="使用 SimpleJdbcInsert 保存数据"></a>使用 SimpleJdbcInsert 保存数据</h4><p>在保存订单方面，也存在类似的情况。不仅必须将订单数据保存到 Taco_Order 表中，还必须引用 Taco_Order_Tacos 表中的每个 taco。但是不是使用繁琐的 PreparedStatementCreator, 而是使用SimpleJdbcInsert， SimpleJdbcInsert 是一个包装了 JdbcTemplate 的对象，它让向表插入数据的操作变得更容易。</p>
<p>首先创建一个 JdbcOrderRepository，它是 OrderRepository 的一个实现。但是在编写 save() 方法实现之前，让我们先关注构造函数，在构造函数中，将创建两个 SimpleJdbcInsert 实例，用于将值插入 Taco_Order 和 Taco_Order_Tacos 表中。下面的程序清单显示了 JdbcOrderRepository（没有 save() 方法）。从 JdbcTemplate 创建一个 SimpleJdbcTemplate：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.simple.SimpleJdbcInsert;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> tacos.Taco;</span><br><span class="line"><span class="keyword">import</span> tacos.Order;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcOrderRepository</span> <span class="keyword">implements</span> <span class="title class_">OrderRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SimpleJdbcInsert orderInserter;</span><br><span class="line">    <span class="keyword">private</span> SimpleJdbcInsert orderTacoInserter;</span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JdbcOrderRepository</span><span class="params">(JdbcTemplate jdbc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderInserter = <span class="keyword">new</span> <span class="title class_">SimpleJdbcInsert</span>(jdbc)</span><br><span class="line">            .withTableName(<span class="string">&quot;Taco_Order&quot;</span>)</span><br><span class="line">            .usingGeneratedKeyColumns(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.orderTacoInserter = <span class="keyword">new</span> <span class="title class_">SimpleJdbcInsert</span>(jdbc)</span><br><span class="line">            .withTableName(<span class="string">&quot;Taco_Order_Tacos&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.objectMapper = <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 JdbcTacoRepository 一样，JdbcOrderRepository 也通过其构造函数注入了 JdbcTemplate。但是，构造函数并没有将 JdbcTemplate 直接分配给一个实例变量，而是使用它来构造两个 SimpleJdbcInsert 实例。</p>
<p>第一个实例被分配给 orderInserter 实例变量，它被配置为使用 Taco_Order 表，并假定 id 属性将由数据库提供或生成。分配给 orderTacoInserter 的第二个实例被配置为使用 Taco_Order_Tacos 表，但是没有声明如何在该表中生成任何 id。</p>
<p>构造函数还创建 ObjectMapper 实例，并将其分配给实例变量。尽管 Jackson 用于 JSON 处理，但稍后将看到如何重新使用它来帮助保存订单及其关联的 tacos。</p>
<p>现在让我们看看 save() 方法如何使用 SimpleJdbcInsert 实例。下一个程序清单显示了 save() 方法，以及几个用于实际工作的 save() 委托的私有方法。</p>
<p>使用 SimpleJdbcInsert 插入数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">save</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    order.setPlacedAt(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> saveOrderDetails(order);</span><br><span class="line">    order.setId(orderId);</span><br><span class="line"></span><br><span class="line">    List&lt;Taco&gt; tacos = order.getTacos();</span><br><span class="line">    <span class="keyword">for</span> (Taco taco : tacos) &#123;</span><br><span class="line">        saveTacoToOrder(taco, orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">saveOrderDetails</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Map&lt;String, Object&gt; values = objectMapper.convertValue(order, Map.class);</span><br><span class="line">    values.put(<span class="string">&quot;placedAt&quot;</span>, order.getPlacedAt());</span><br><span class="line">​</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> orderInserter.executeAndReturnKey(values).longValue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> orderId;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveTacoToOrder</span><span class="params">(Taco taco, <span class="type">long</span> orderId)</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; values = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    values.put(<span class="string">&quot;tacoOrder&quot;</span>, orderId);</span><br><span class="line">    values.put(<span class="string">&quot;taco&quot;</span>, taco.getId());</span><br><span class="line"></span><br><span class="line">    orderTacoInserter.execute(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>save() 方法实际上并不保存任何东西。它定义了保存订单及其关联 Taco 对象的流，并将持久性工作委托给 saveOrderDetails() 和 saveTacoToOrder()。</p>
<p>SimpleJdbcInsert 有两个执行插入的有用方法：execute() 和 executeAndReturnKey()。两者都接受 Map&lt;String, Object&gt;，其中 Map 键对应于数据插入的表中的列名，映射的值被插入到这些列中。</p>
<p>通过将 Order 中的值复制到 Map 的条目中，很容易创建这样的 Map。但是 Order 有几个属性，这些属性和它们要进入的列有相同的名字。因此，在 saveOrderDetails() 中，我决定使用 Jackson 的 ObjectMapper 及其 convertValue() 方法将 Order 转换为 Map。这是必要的，否则 ObjectMapper 会将 Date 属性转换为 long，这与 Taco_Order 表中的 placedAt 字段不兼容。</p>
<p>随着 Map 中填充完成订单数据，我们可以在 orderInserter 上调用 executeAndReturnKey() 方法了。这会将订单信息保存到 Taco_Order 表中，并将数据库生成的 id 作为一个 Number 对象返回，调用 longValue() 方法将其转换为从方法返回的 long 值。</p>
<p>saveTacoToOrder() 方法要简单得多。不是使用 ObjectMapper 将对象转换为 Map，而是创建 Map 并设置适当的值。同样，映射键对应于表中的列名。对 orderTacoInserter 的 execute() 方法的简单调用就能执行插入操作。</p>
<p>现在可以将 OrderRepository 注入到 OrderController 中并开始使用它。下面的程序清单显示了完整的 OrderController，包括因使用注入的 OrderRepository 而做的更改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.web;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> javax.validation.Valid;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.Errors;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.SessionAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.support.SessionStatus;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> tacos.Order;</span><br><span class="line"><span class="keyword">import</span> tacos.data.OrderRepository;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/orders&quot;)</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderController</span><span class="params">(OrderRepository orderRepo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderRepo = orderRepo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/current&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">orderForm</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;orderForm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">processOrder</span><span class="params">(<span class="meta">@Valid</span> Order order, Errors errors,</span></span><br><span class="line"><span class="params">                               SessionStatus sessionStatus)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (errors.hasErrors()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;orderForm&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        orderRepo.save(order);</span><br><span class="line">        sessionStatus.setComplete();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了将 OrderRepository 注入控制器之外，OrderController 中惟一重要的更改是 processOrder() 方法。在这里，表单中提交的 Order 对象（恰好也是在 session 中维护的 Order 对象）通过注入的 OrderRepository 上的 save() 方法保存。</p>
<p>一旦订单被保存，就不再需要它存在于 session 中了。事实上，如果不清除它，订单将保持在 session 中，包括其关联的 tacos，下一个订单将从旧订单中包含的任何 tacos 开始。因此需要 processOrder() 方法请求 SessionStatus 参数并调用其 setComplete() 方法来重置会话。</p>
<p>所有的 JDBC 持久化代码都准备好了。现在，可以启动 Taco Cloud 应用程序并进行测试。你想要多少 tacos 和多少 orders 都可以。</p>
<p>可能还会发现在数据库中进行挖掘是很有帮助的。因为使用 H2 作为嵌入式数据库，而且 Spring Boot DevTools 已经就位，所以应该能够用浏览器访问 <a href="http://localhost:8080/h2-console">http://localhost:8080/h2-console</a> 来查看 H2 控制台。虽然需要确保 JDBC URL 字段被设置为 JDBC:h2:mem:testdb，但是默认的凭证应该可以让你进入。登录后，应该能够对 Taco Cloud 模式中的表发起查询。</p>
<p>Spring 的 JdbcTemplate 和 SimpleJdbcInsert 使得使用关系数据库比普通 JDBC 简单得多。但是可能会发现 JPA 使它更加简单。3.2将展示JPA如何使用 Spring 数据使数据持久化更加容易。</p>
<h2 id="使用-Spring-Data-JPA-读写数据"><a href="#使用-Spring-Data-JPA-读写数据" class="headerlink" title="使用 Spring Data JPA 读写数据"></a>使用 Spring Data JPA 读写数据</h2><p>Spring Data 项目是一个相当大的伞形项目，几个子项目组成，其中大多数子项目关注于具有各种不同数据库类型的数据持久化。一些最流行的 Spring 数据项目包括：</p>
<ul>
<li>Spring Data JPA* - 针对关系数据库的持久化</li>
<li><em>Spring Data Mongo</em> - 针对 Mongo 文档数据库的持久化</li>
<li><em>Spring Data Neo4j</em> - 针对 Neo4j 图形数据库的持久化</li>
<li><em>Spring Data Redis</em> - 针对 Redis 键值存储的持久化</li>
<li><em>Spring Data Cassandra</em> - 针对 Cassandra 数据库的持久化</li>
</ul>
<p>Spring Data 为所有这些项目提供的最有意思和最有用的特性之一是能够<strong>基于存储库规范接口自动创建存储库</strong>。</p>
<p>为了了解 Spring Data 是如何工作的，需要将本章前面介绍的基于 jdbc 的存储库替换为 Spring Data JPA 创建的存储库。但是首先，需要将 Spring Data JPA 添加到项目构建中。</p>
<h3 id="添加Spring-Data-JPA依赖"><a href="#添加Spring-Data-JPA依赖" class="headerlink" title="添加Spring Data JPA依赖"></a>添加<strong>Spring Data JPA</strong>依赖</h3><p>Spring Data JPA 可用于具有 JPA starter 的 Spring Boot 应用程序。这个 starter 依赖不仅带来了 Spring Data JPA，还包括 Hibernate 作为 JPA 的实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="对领域类添加注解成为实体"><a href="#对领域类添加注解成为实体" class="headerlink" title="对领域类添加注解成为实体"></a>对领域类添加注解成为实体</h3><p>在创建存储库方面，Spring Data 做了一些惊人的事情。但不幸的是，在使用 JPA 映射注解域对象时，它并没有太大的帮助。需要打开 Ingredient、Taco 和 Order 类，并添加一些注解。首先是 Ingredient 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor(access=AccessLevel.PRIVATE, force=true)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ingredient</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">        WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了将其声明为 JPA 实体，必须使用 @Entity 注解。它的 id 属性必须使用 @Id 进行注解，以便将其指定为惟一标识数据库中实体的属性。</p>
<p>除了特定于 JPA 的注解之外，还在类级别上添加了 @NoArgsConstructor 注解。JPA 要求实体有一个无参构造函数，所以 Lombok 的 @NoArgsConstructor 实现了这一点。但是要是不希望使用它，可以通过将 access 属性设置为 AccessLevel.PRIVATE 来将其设置为私有。因为必须设置 final 属性，所以还要将 force 属性设置为 true，这将导致 Lombok 生成的构造函数将它们设置为 null。</p>
<p>还添加了一个 @RequiredArgsConstructor。@Data 隐式地添加了一个必需的有参构造函数，但是当使用 @NoArgsConstructor 时，该构造函数将被删除。显式的 @RequiredArgsConstructor 确保除了私有无参数构造函数外，仍然有一个必需有参构造函数。</p>
<p>Taco类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.ManyToMany;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.OneToMany;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.PrePersist;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Size;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Taco</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy=GenerationType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size(min=5, message=&quot;Name must be at least 5 characters long&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Date createdAt;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ManyToMany(targetEntity=Ingredient.class)</span></span><br><span class="line">    <span class="meta">@Size(min=1, message=&quot;You must choose at least 1 ingredient&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Ingredient&gt; ingredients;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PrePersist</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createdAt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createdAt = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 Ingredient 一样，Taco 类现在使用 @Entity 注解，其 id 属性使用 @Id 注解。因为依赖于数据库自动生成 id 值，所以还使用 @GeneratedValue 注解 id 属性，指定自动策略。</p>
<p>要声明 Taco 及其相关 Ingredient 列表之间的关系，可以使用 @ManyToMany 注解 ingredient 属性。一个 Taco 可以有很多 Ingredient，一个 Ingredient 可以是很多 Taco 的一部分。</p>
<p>还有一个新方法 createdAt()，它用 @PrePersist 注解。将使用它将 createdAt 属性设置为保存 Taco 之前的当前日期和时间。</p>
<p>Order类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.ManyToMany;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.OneToMany;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.PrePersist;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Digits;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Pattern;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.CreditCardNumber;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.NotBlank;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name=&quot;Taco_Order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy=GenerationType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Date placedAt;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ManyToMany(targetEntity=Taco.class)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Taco&gt; tacos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDesign</span><span class="params">(Taco design)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tacos.add(design);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PrePersist</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">placedAt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.placedAt = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 Order 的更改与对 Taco 的更改非常相似。但是在类级别有一个新的注解：@Table。这指定订单实体应该持久化到数据库中名为 Taco_Order 的表中。</p>
<p>尽管可以在任何实体上使用这个注解，但它对于 Order 是必需的。没有它，JPA 将默认将实体持久化到一个名为 Order 的表中，但是 Order 在 SQL 中是一个保留字，会导致问题。</p>
<h3 id="声明-JPA-repository接口"><a href="#声明-JPA-repository接口" class="headerlink" title="声明 JPA repository接口"></a>声明 JPA repository接口</h3><p>在存储库的 JDBC 版本中，显式地声明了希望 repository 提供的方法。但是使用 Spring Data，扩展 CrudRepository 接口。例如，这是一个新的 IngredientRepository 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.CrudRepository;</span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IngredientRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;Ingredient, String&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CrudRepository 为 CRUD（创建、读取、更新、删除）操作声明了十几个方法。注意，它是参数化的，第一个参数是存储库要持久化的实体类型，第二个参数是实体 id 属性的类型。对于 IngredientRepository，参数应该是 Ingredient 和 String 类型。</p>
<p>定义 TacoRepository：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.CrudRepository;</span><br><span class="line"><span class="keyword">import</span> tacos.Taco;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TacoRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;Taco, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IngredientRepository 和 TacoRepository 之间唯一显著的区别是对于 CrudRepository 的参数不同。在这里，它们被设置为 Taco 和 Long 去指定 Taco 实体（及其 id 类型）作为这个 respository 接口的持久化单元。最后，同样的更改可以应用到 OrderRepository：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.CrudRepository;</span><br><span class="line"><span class="keyword">import</span> tacos.Order;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;Order, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在有了这三个 repository，可能认为需要为这三个 repository 编写实现，还包括每种实现的十几个方法。但这就是 Spring Data JPA 优秀的地方 —— 不需要编写实现！当应用程序启动时，Spring Data JPA 会动态地自动生成一个实现。这意味着 repository 可以从一开始就使用。只需将它们注入到控制器中，就像在基于 JDBC 的实现中所做的那样。</p>
<p>CrudRepository 提供的方法非常适合用于实体的通用持久化。但是如果有一些基本持久化之外的需求呢？让我们看看如何自定义 repository 来执行域特有的查询。</p>
<h3 id="自定义-JPA-repository实现"><a href="#自定义-JPA-repository实现" class="headerlink" title="自定义 JPA repository实现"></a>自定义 JPA repository实现</h3><p>想象一下，除了 CrudRepository 提供的基本 CRUD 操作之外，还需要获取投递给指定邮政编码的所有订单。事实证明，通过在 OrderRepository 中添加以下方法声明可以很容易地解决这个问题：</p>
<p><code>List&lt;Order&gt; findByDeliveryZip(String deliveryZip);</code></p>
<p>在生成 repository 实现时，Spring Data 检查存储库接口中的任何方法，解析方法名称，并<strong>尝试在持久化对象的上下文中理解方法的用途</strong>（在本例中是 Order）。本质上，Spring Data 定义了一种小型的领域特定语言（DSL），其中持久化细节用 repository 中的方法签名表示。</p>
<p>让我们考虑另一个更复杂的例子。假设需要查询在给定日期范围内投递给指定邮政编码的所有订单。在这种情况下，当添加到 OrderRepository 时，下面的方法可能会被证明是有用的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Order&gt; <span class="title function_">readOrdersByDeliveryZipAndPlacedAtBetween</span><span class="params">(</span></span><br><span class="line"><span class="params">    String deliveryZip, Date startDate, Date endDate)</span>;</span><br></pre></td></tr></table></figure>

<p><em><strong><u>自动识别方法名猜测功能，方法命名约定</u></strong></em></p>
<p>虽然命名约定对于相对简单的查询很有用，但是对于更复杂的查询，不需要太多的想象就可以看出方法名称可能会失控。在这种情况下，可以随意将方法命名为任何想要的名称，并使用 @Query 对其进行注解，以显式地指定调用方法时要执行的查询，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;Order o where o.deliveryCity=&#x27;Seattle&#x27;&quot;)</span></span><br><span class="line">List&lt;Order&gt; <span class="title function_">readOrdersDeliveredInSeattle</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><ul>
<li>JdbcTemplate 大大简化了 JDBC 的工作。</li>
<li>当需要知道数据库生成的 id 时，可以同时使用 PreparedStatementCreator 和 KeyHolder。</li>
<li>为了方便执行数据插入，使用 SimpleJdbcInsert。</li>
<li>Spring Data JPA 使得 JPA 持久化就像编写存储库接口一样简单。</li>
</ul>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring框架@Bean注解、拦截器、监听器</title>
    <url>/2022/04/22/myblog/spring/spring%E6%A1%86%E6%9E%B6%E4%B9%8Bbean%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="Bean注解"><a href="#Bean注解" class="headerlink" title="@Bean注解"></a>@Bean注解</h3><p>作用在方法上的注解，Spring的@Bean注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。(和xml配置中的bean标签的作用是一样的)</p>
<p>@Bean主要用在@Configuration注解的类中，也可以用在@Component注解的类中。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"> </span><br><span class="line">    // 使用@Bean 注解表明myBean需要交给Spring进行管理</span><br><span class="line">    // 未指定bean 的名称，默认采用的是方法名的配置方式</span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean buildMyBean()&#123;</span><br><span class="line">        return new MyBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class MyBean &#123;</span><br><span class="line"> </span><br><span class="line">    public MyBean()&#123;</span><br><span class="line">        System.out.println(&quot;MyBean Initializing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个测试类SpringBeanApplicationTests，测试上述代码的正确性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SpringBeanApplicationTests &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        context.getBean(&quot;buildMyBean&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Bean的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value：bean别名和name是相互依赖关联的，value,name如果都使用的话值必须要一致；</span><br><span class="line"></span><br><span class="line">name：bean名称，如果不写会默认为注解的方法名称；</span><br><span class="line"></span><br><span class="line">autowire：自定装配默认是不开启的，建议尽量不要开启，因为自动装配不能装配基本数据类型、字符串、数组等，这是自动装配设计的局限性，并且自动装配不如依赖注入精确；</span><br><span class="line"></span><br><span class="line">initMethod：bean的初始化之前的执行方法，该参数一般不怎么用，因为完全可以在代码中实现；</span><br><span class="line"></span><br><span class="line">destroyMethod：默认使用javaConfig配置的bean，如果存在close或者shutdown方法，则在bean销毁时会自动执行该方法，如果你不想执行该方法，则添加@Bean(destroyMethod=&quot;&quot;)来防止出发销毁方法；</span><br></pre></td></tr></table></figure>

<p>Spring中的@Bean注解：<a href="https://blog.csdn.net/weixin_36380516/article/details/119194065">https://blog.csdn.net/weixin_36380516/article/details/119194065</a></p>
<h3 id="Bean和-Component"><a href="#Bean和-Component" class="headerlink" title="@Bean和@Component"></a>@Bean和@Component</h3><ul>
<li>@Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。</li>
<li>@Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑。</li>
</ul>
<p>相同点：两者的结果都是为spring容器注册Bean.<br>不同点：@Component 通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中。<br>　　　　@Bean 注解通常是我们在标有该注解的方法中定义产生这个bean的逻辑。</p>
<blockquote>
<p>@Component （@Controller @Service @Respository）作用于类上，只有在我们的SpringBoot应用程序启用了组件扫描并且包含了被注解的类时才有效。通过组件扫描，Spring将扫描整个类路径，并将所有@Component注释类添加到Spring Context，这里有的不足就是会把整个类当成bean注册到spring 容器上，如果这个类中并不是所有方法都需要注册为bean的话，会出现不需要的方法都注册成为bean，这时候必须确保这些不需要的方法也能注册为bean或者在扫描中加filter 过滤这些不需要的bean,否者spring将无法成功启动。</p>
</blockquote>
<blockquote>
<p>@Bean相对来说就更加灵活了，它可以独立加在方法上，按需注册到spring容器，而且如果你要用到第三方类库里面某个方法的时候（或者类？），你就只能用@Bean把这个方法注册到spring容器，因为用@Component你需要配置组件扫描到这个第三方类路径而且还要在别人源代码加上这个注解，很明显是不现实的。</p>
</blockquote>
<p>❤️当我们引用第三方库中的类需要装配到Spring容器时，则只能通过@Bean来实现<br>总结：@Component和@Bean都是用来注册Bean并装配到Spring容器中，但是Bean比Component的自定义性更强。可以实现一些Component实现不了的自定义加载类。特别是二方库或三方库的类装配为bean，只能用@Bean。</p>
<h3 id="实现FactoryBean接口"><a href="#实现FactoryBean接口" class="headerlink" title="实现FactoryBean接口"></a>实现FactoryBean接口</h3><p>org.springframework.beans.factory中</p>
<p>FactoryBean是一个工厂Bean，可以生成某一个类型Bean实例，它最大的一个作用是：可以让我们自定义Bean的创建过程。BeanFactory是Spring容器中的一个基本类也是很重要的一个类，在BeanFactory中可以创建和管理Spring容器中的Bean，它对于Bean的创建有一个统一的流程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface FactoryBean&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //返回的对象实例</span><br><span class="line">    T getObject() throws Exception;</span><br><span class="line">    //Bean的类型</span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line">    //true是单例，false是非单例  在Spring5.0中此方法利用了JDK1.8的新特性变成了default方法，返回true</span><br><span class="line">    boolean isSingleton();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FactoryBean中定义了一个Spring Bean的很重要的三个特性：是否单例、Bean类型、Bean实例。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//FactoryBean接口的实现类</span><br><span class="line">@Component</span><br><span class="line">public class FactoryBeanLearn implements FactoryBean &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object getObject() throws Exception &#123;</span><br><span class="line">        //这个Bean是我们自己new的，这里我们就可以控制Bean的创建过程了</span><br><span class="line">        return new FactoryBeanServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        return FactoryBeanService.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isSingleton() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//接口</span><br><span class="line">public interface FactoryBeanService &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 测试FactoryBean</span><br><span class="line">     */</span><br><span class="line">    void testFactoryBean();</span><br><span class="line">&#125;</span><br><span class="line">//实现类</span><br><span class="line">public class FactoryBeanServiceImpl implements FactoryBeanService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 测试FactoryBean</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void testFactoryBean() &#123;</span><br><span class="line">        System.out.println(&quot;我是FactoryBean的一个测试类。。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//单测</span><br><span class="line">@Test</span><br><span class="line">public void test() &#123;</span><br><span class="line">        ClassPathXmlApplicationContext cac = new ClassPathXmlApplicationContext(&quot;classpath:com/zkn/spring/learn/base/applicationContext.xml&quot;);</span><br><span class="line">        FactoryBeanService beanService = cac.getBean(FactoryBeanService.class);</span><br><span class="line">        beanService.testFactoryBean();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>❤️FactoryBean是自定义了一种注入Bean的方法，在类中没有加注解，也没有xml中配置，但是实现FactoryBean接口，重写getObject方法来返回对象，表示注入了bean，重写getObjectType表示获取bean时bean的类型。然后就可以通过getBean(类型.class)获取bean实例了。<br>至于，如何通过ApplicationContext.getBean()，见：<a href="https://blog.csdn.net/zknxx/article/details/79572387">https://blog.csdn.net/zknxx/article/details/79572387</a></p>
<h3 id="ApplicationContextAware接口"><a href="#ApplicationContextAware接口" class="headerlink" title="ApplicationContextAware接口"></a>ApplicationContextAware接口</h3><p>org.springframework.context中</p>
<p>当一个类实现了这个接口之后，这个类就可以方便的获得ApplicationContext对象（spring上下文），Spring发现某个Bean实现了ApplicationContextAware接口，Spring容器会在创建该Bean之后，自动调用该Bean的setApplicationContext（参数）方法，调用该方法时，会将容器本身ApplicationContext对象作为参数传递给该方法。</p>
<p>❤️之前获取ApplicationContext需要加载配置文件从而创建应用上下文，但是实现了ApplicationContextAware接口，spring自动将容器本身ApplicationContext对象传递给其中的方法setApplicationContext。实现它的类，可以在类中创建私有的ApplicationContext变量，在setApplicationContext中this. &#x3D; 进行传递。</p>
<p>实现ApplicationContextAware接口可以方便获取ApplicationContext，即spring容器，获取容器之后就可以方便获取bean。</p>
<p>例子：<br>获取一个排序工厂：</p>
<p>排序接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Sort &#123;</span><br><span class="line">    SortType getSortType();</span><br><span class="line">    int[] sorting(int[] sourceArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排序算法实现接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SelectionSort implements Sort &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public SortType getSortType() &#123;</span><br><span class="line">        return SortType.SELECTION;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public int[] sorting(int[] sourceArray) &#123;</span><br><span class="line">        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"> </span><br><span class="line">        // 总共要经过 N-1 轮比较</span><br><span class="line">        for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            int min = i;</span><br><span class="line"> </span><br><span class="line">            // 每轮需要比较的次数 N-i</span><br><span class="line">            for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                if (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                    // 记录目前能找到的最小值元素的下标</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // 将找到的最小值和i位置所在的值进行交换</span><br><span class="line">            if (i != min) &#123;</span><br><span class="line">                int temp = arr[i];</span><br><span class="line">                arr[i] = arr[min];</span><br><span class="line">                arr[min] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举排序类型:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum SortType &#123;</span><br><span class="line">    SELECTION,</span><br><span class="line">    BUBBLE,</span><br><span class="line">    INSERT,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排序工厂，实现 ApplicationContextAware 接口:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SortFactory implements ApplicationContextAware &#123;</span><br><span class="line">    private static Map&lt;SortType, Sort&gt; sortBeanMap = new ConcurrentHashMap&lt;&gt;(16);</span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        Map&lt;String, Sort&gt; map = applicationContext.getBeansOfType(Sort.class);</span><br><span class="line">        map.forEach((key, value) -&gt; sortBeanMap.put(value.getSortType(), value));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int[] sorting(SortType sortType, int[] sourceArray) &#123;</span><br><span class="line">        Sort sort = sortBeanMap.get(sortType);</span><br><span class="line">        return sort.sorting(sourceArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class SortController &#123;</span><br><span class="line"> </span><br><span class="line">    private final SortFactory sortFactory;</span><br><span class="line"> </span><br><span class="line">    public SortController(SortFactory sortFactory) &#123;</span><br><span class="line">        this.sortFactory = sortFactory;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @PostMapping(value = &quot;factory/sort&quot;)</span><br><span class="line">    public Object sortFactory(SortType sortType, int[] sourceArr) &#123;</span><br><span class="line">        return sortFactory.sorting(sortType, sourceArr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考自：<a href="https://blog.csdn.net/weixin_33898233/article/details/91414228">https://blog.csdn.net/weixin_33898233/article/details/91414228</a></p>
<h3 id="InitialzingBean接口"><a href="#InitialzingBean接口" class="headerlink" title="InitialzingBean接口"></a>InitialzingBean接口</h3><p>当一个类实现这个接口之后，Spring启动后，初始化Bean时，若该Bean实现InitialzingBean接口，会自动调用afterPropertiesSet()方法，完成一些用户自定义的初始化操作。</p>
<p>同样配置Bean的时候使用init-method也可以实现类似的操作。（不需要实现InitialzingBean接口）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void afterPropertiesSet() throws Exception &#123;&#125;</span><br><span class="line"></span><br><span class="line">&lt;bean id = &quot;springBeanInit02&quot; class = &quot;com.lyj.studySpringBoot.init.SpringBeanInit&quot; init-method=&quot;testInit&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;id&quot; value=&quot;#&#123;1111111&#125;&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;$&#123;test.springEL&#125;&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;age&quot; value=&quot;#&#123;10+8&#125;&quot; /&gt; // SpringEL表达式</span><br><span class="line">	&lt;property name=&quot;sex&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">系统是先调用afterPropertiesSet方法，然后在调用init-method中指定的方法。</span><br></pre></td></tr></table></figure>

<p>Spring是通过反射来调用init-method指定方法，而实现InitializingBean接口是直接调用afterPropertiesSet方法，所以后者效率高，但使用init-method方式减少了对Spring的依赖。</p>
<p>参考：<a href="https://blog.csdn.net/qq_40093255/article/details/117318760">https://blog.csdn.net/qq_40093255/article/details/117318760</a></p>
<h3 id="MethodInterceptor接口-拦截器"><a href="#MethodInterceptor接口-拦截器" class="headerlink" title="MethodInterceptor接口-拦截器"></a>MethodInterceptor接口-拦截器</h3><p>org.aopalliance.intercept中<br>MethodInterceptor接口继承了Interceptor接口，Intercepto接口又继承了Advice接口，因此我个将这拦截器称为一个通知。</p>
<p>实现MethodInterceptor 接口，在调用目标对象的方法时，就可以实现在调用方法之前、调用方法过程中、调用方法之后对其进行控制。</p>
<p>拦截器就像是建立了一个通知。用切面做增强一样。</p>
<p>简单的例子：<a href="https://blog.csdn.net/u012834750/article/details/71773887">https://blog.csdn.net/u012834750/article/details/71773887</a><br>1.实现接口重写invoke方法，做增强<br>2.写一个简单方法<br>3.测试中，用代理工厂设置代理对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TestMethodInterceptor  &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 初始化一个代理工厂</span><br><span class="line">        ProxyFactory proxyFactory=new ProxyFactory();</span><br><span class="line"></span><br><span class="line">        // 设置目标类，以便于Cglib工具包动态生成目标类的子类，即我们所需的代理类</span><br><span class="line">        // 最好把实现类单独写，这里设置的是实现类（业务）</span><br><span class="line">        proxyFactory.setTarget(new TestMethodInterceptor());</span><br><span class="line"></span><br><span class="line">        // 设置拦截器，而拦截器的&quot;public Object invoke(MethodInvocation mi)&quot;定义了代理类（实际是UserDaoImpl的子类）的方法生成策略。</span><br><span class="line">        proxyFactory.addAdvice(new adviseMethodInterceptor());</span><br><span class="line"></span><br><span class="line">        // 获取代理类</span><br><span class="line">        Object proxy = proxyFactory.getProxy();</span><br><span class="line">         // 向上转型，转型为父类类型</span><br><span class="line">        TestMethodInterceptor methodInterceptor = (TestMethodInterceptor) proxy;</span><br><span class="line"></span><br><span class="line">        methodInterceptor.doSomeThing(&quot;通过代理工厂设置代理对象，拦截代理方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class adviseMethodInterceptor implements MethodInterceptor&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">            Object result=null;</span><br><span class="line">            try&#123;</span><br><span class="line">                System.out.println(&quot;方法执行之前：&quot;+methodInvocation.getMethod().toString());</span><br><span class="line"></span><br><span class="line">                result= methodInvocation.proceed();</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;方法执行之后：&quot;+methodInvocation.getMethod().toString());</span><br><span class="line">                System.out.println(&quot;方法正常运行结果：&quot;+result);</span><br><span class="line"></span><br><span class="line">                return result;</span><br><span class="line"></span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                System.out.println(&quot;方法出现异常:&quot;+e.toString());</span><br><span class="line">                System.out.println(&quot;方法运行Exception结果：&quot;+result);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String doSomeThing(String someThing)&#123;</span><br><span class="line"></span><br><span class="line">        //int i=5/0;</span><br><span class="line">        return &quot;执行被拦截的方法：&quot;+someThing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AOP都是基于（Cglib）代理模式实现的，其中的关键点在于实现MethodInterceptor接口，在其“public Object invoke(MethodInvocation mi)”方法中制定代理方法的生成策略，而从此方法的MethodInvocation类型参数mi中可以获得目标对象、目标方法、方法的参数等信息，根据这些信息可以精确地控制增强效果。</p>
<p>invoke方法的传参是MethodInvocation，表示方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取方法名</span><br><span class="line">String methodName = mi.getMethod().getName();</span><br><span class="line">if (methodName.startsWith(&quot;add&quot;))</span><br><span class="line"></span><br><span class="line">// 执行目标方法</span><br><span class="line">result= methodInvocation.proceed();</span><br><span class="line"></span><br><span class="line">// 获取方法参数</span><br><span class="line">Object[] args = methodInvocation.getArguments();</span><br></pre></td></tr></table></figure>

<p>另一个比较复杂的例子：<br><a href="https://www.cnblogs.com/gocode/p/aop-in-spring.html">https://www.cnblogs.com/gocode/p/aop-in-spring.html</a></p>
<p>❤️总结：拦截器，可以以动态代理的方式执行方法，另一个作用是创建一个切面，具体的通知在invoke中加，传入参数可以获取目标对象、方法、方法参数，从而选择对不同切入点进行不同的通知&#x2F;增强。也可以不加通知，只是proceed执行本方法。</p>
<p>✅拦截器为什么一定要加@Component？</p>
<p>在Spring 框架中，使用 @Component注解将一个类标记为组件，表示这个类可以被 Spring 容器扫描并创建实例。<br>在AOP中，切面类需要被 Spring 容器管理，所以需要将这个类加上@Component注解，以便被Spring 容器扫描并创建实例。如果不加@Component注解，这个切面类就不会被Spring 容器管理，也就无法执行拦截的逻辑。<br>另外，如果这个切面类需要注入其他依赖，比如数据源、缓存等，也需要加上 @Component注解，以便被 Spring容器管理。如果不加 @Component 注解，这些依赖也无法被注入，会导致代码出现错误。<br>总之，加上@Component注解可以让这个切面类被 Spring 容器管理，以便执行拦截的逻辑，并注入其他依赖，确保代码的正确性和可维护性。</p>
<h3 id="ApplicationListener接口-监听器"><a href="#ApplicationListener接口-监听器" class="headerlink" title="ApplicationListener接口-监听器"></a>ApplicationListener接口-监听器</h3><p>ApplicationContext事件机制是观察者设计模式的实现，通过ApplicationEvent类和ApplicationListener接口，可以实现ApplicationContext事件处理。</p>
<p>如果容器中有一个ApplicationListener Bean，每当ApplicationContext发布ApplicationEvent时，ApplicationListener Bean将自动被触发。这种事件机制都必须需要程序显示publish的触发。</p>
<p>事件可以自定义、监听也可以自定义，完全根据自己的业务逻辑来处理。</p>
<p>1.定义事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class EmailEvent extends ApplicationEvent&#123;</span><br><span class="line">　　 private String address;</span><br><span class="line">　　 private String text;</span><br><span class="line">　　 public EmailEvent(Object source, String address, String text)&#123;</span><br><span class="line">　　 super(source);</span><br><span class="line">　　　　　 this.address = address;</span><br><span class="line">　　　　　 this.text = text;</span><br><span class="line">　　 &#125;</span><br><span class="line">　　 public EmailEvent(Object source) &#123;</span><br><span class="line">　　　　　super(source);</span><br><span class="line">　　 &#125;</span><br><span class="line">　　 //......address和text的setter、getter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.监听事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class EmailNotifier implements ApplicationListener&#123;</span><br><span class="line">    // 监听后事件处理的方法，可以对事件做一些判断</span><br><span class="line">　　 public void onApplicationEvent(ApplicationEvent event) &#123;</span><br><span class="line">　　　　　if (event instanceof EmailEvent) &#123;</span><br><span class="line">　　　　　　　 EmailEvent emailEvent = (EmailEvent)event;</span><br><span class="line">　　　　　　　 System.out.println(&quot;邮件地址：&quot; + emailEvent.getAddress());</span><br><span class="line">　　　　　　　 System.our.println(&quot;邮件内容：&quot; + emailEvent.getText());</span><br><span class="line">　　　　　&#125; else &#123;</span><br><span class="line">　　　　　　　 System.our.println(&quot;容器本身事件：&quot; + event);</span><br><span class="line">　　　　　&#125;</span><br><span class="line">　　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.触发事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SpringTest &#123;</span><br><span class="line">　　 public static void main(String args[])&#123;</span><br><span class="line">　　　　　ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</span><br><span class="line">　　　　　//创建一个ApplicationEvent对象</span><br><span class="line">　　　　　EmailEvent event = new EmailEvent(&quot;hello&quot;,&quot;abc@163.com&quot;,&quot;This is a test&quot;);</span><br><span class="line">　　　　　//主动触发该事件</span><br><span class="line">　　　　　context.publishEvent(event);</span><br><span class="line">　　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在拦截器中做增强触发。</p>
<p>不管是内置监听还是外部自定义监听一定要把实现ApplicationListener的类定义成一个bean才行，可以是通过注解@Component等也可以通过xml的方式去执行。</p>
<p>监听器实现类实现的ApplicationListener接口中，可以加范型，事件类型。</p>
<h3 id="接口防刷"><a href="#接口防刷" class="headerlink" title="接口防刷"></a>接口防刷</h3><p>写一个通用类用redis锁来实现，需要前段传一个东西来表示redis的key：<br><a href="https://blog.csdn.net/qq_32871365/article/details/122113652">https://blog.csdn.net/qq_32871365/article/details/122113652</a></p>
<p>在前段访问前，先从后端申请一个token，然后拿这tocken访问，后端校验tocken：<br><a href="https://blog.csdn.net/weixin_42071874/article/details/90402099">https://blog.csdn.net/weixin_42071874/article/details/90402099</a></p>
<p>自定义注解+redis+拦截器的方法：<br><a href="https://blog.csdn.net/weixin_40918145/article/details/108734614">https://blog.csdn.net/weixin_40918145/article/details/108734614</a><br><a href="https://blog.csdn.net/qq_45637260/article/details/127692497">https://blog.csdn.net/qq_45637260/article/details/127692497</a><br>1.写一个自定义注解传可访问次数<br>2.写一个拦截器，获取自定义注解，并且获取HttpServletRequest，从中获取ip，然后redis记录访问次数<br>3.配置拦截器WebMvcConfigurerAdapter<br>4.controller接口方法上加自定义注解</p>
<p>同样是以ip为维度，拦截器&#x2F;aop：<br><a href="https://www.jb51.net/article/205093.htm">https://www.jb51.net/article/205093.htm</a></p>
<p>自定义注解：切面aop：<br><a href="https://blog.csdn.net/qq_34033209/article/details/118601590">https://blog.csdn.net/qq_34033209/article/details/118601590</a></p>
<p>tocken：<a href="https://www.cnblogs.com/LilLazy/p/14708539.html">https://www.cnblogs.com/LilLazy/p/14708539.html</a></p>
]]></content>
      <categories>
        <category>spring理解</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>《Spring实战》笔记</title>
    <url>/2021/12/23/myblog/spring/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="springboot在idea的RunDashboard如何显示出来"><a href="#springboot在idea的RunDashboard如何显示出来" class="headerlink" title="springboot在idea的RunDashboard如何显示出来"></a>springboot在idea的RunDashboard如何显示出来</h3><p>运用spring cloud框架基于spring boot构建微服务，一般需要启动多个应用程序，在idea开发工具中，多个同时启动的应用需要在RunDashboard运行仪表盘中可以更好的管理，但有时候idea中的RunDashboard窗口没有显示出来，也找不到直接的开启按钮。</p>
<p>选择Edit Configurations，在运行配置窗口，选择一条springboot的运行配置，然后点击上方的复制按钮进行复制副本，复制完成之后，点击OK确定按钮，然后在屏幕右下角可以看到一个弹框提示，点击弹框右下角的向下的小箭头，展开弹框详情信息，然后点击Show run configurations in Run Dashboard，在Run Dashboard中可以看到当前所有的启动配置，直接点击可以方便的启动和停止。</p>
<p>以上方法还没有显示出来的话，则可以通过修改idea的workspace.xml的方式来快速打开Run Dashboard窗口。</p>
<p>打开workspace.xml文件之后，找到component为RunDashboard的节点处，然后在component标签里添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;option name=&quot;configurationTypes&quot;&gt;</span><br><span class="line">   &lt;set&gt;</span><br><span class="line">​    &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt;</span><br><span class="line">   &lt;/set&gt;</span><br><span class="line">  &lt;/option&gt;</span><br></pre></td></tr></table></figure>

<p>最后保存即可，保存完成之后立即自动弹出Run Dashboard窗口了。</p>
<h3 id="Taco商店"><a href="#Taco商店" class="headerlink" title="Taco商店"></a>Taco商店</h3><p>路径、领域类、控制器、控制器返回的是表单。控制器也可重定向到另一个路径。每个控制器类处理一个路径，一个路径可以处理get、post，一次可以有不同的方法。表单post请求到控制器。</p>
<p>目前的领域类：taco、order、ingredient</p>
<p>控制类：designcontrol、ordercontrol</p>
<p>表单：home、design、order</p>
<h3 id="第二章调试"><a href="#第二章调试" class="headerlink" title="第二章调试"></a>第二章调试</h3><p>1.只有home，只显示主页。</p>
<p>2.有design，显示design页面，没有表单验证，配料是自己写的，点了submit错误了，405 Request method ‘POST’ not supported。</p>
<p>3.加post方法，重定向（跳转）到订单处理控制器，显示order页面，注意ordercontrol里也是一个get一个post。</p>
<p>4.添加表单验证，两个领域类添加规则，两个控制类的post提交表单方法进行验证，两个表单也要做相应变化，加span。（不加@ModelAttribute(“design”) 是错的，只是designcontrol，另外，空白框旁的true&#x2F;false不知道哪来的，）。</p>
<p>5.使用视图控制器，删除homecontrol，修改homecontroltest。</p>
<h3 id="第三章中"><a href="#第三章中" class="headerlink" title="第三章中"></a>第三章中</h3><p>两个方法3.1和3.2是并列的，可以用这个两种方法，JDBC和JPA，JPA比JDBC简单。</p>
<p>3.1中，ingredient库插入数据比较简单，只插入一个库，但是taco和order比较难，都有两个库要插入，插入一个库之后需要获得一个id才能插入第二个库，3.1.4具体持久化方法中提供了两种方法，第二种比第一种简单。</p>
<p>对于ingredient，需要预插入数据。</p>
<p>对designcontrol、ordercontrol的修改，第一在于构造方法将数据库注入到控制器中，第二在于post方法提交表单需要将数据存入数据库。</p>
<p>其中涉及到session，用于保存在会话中的 order 属性，并且可以<strong>跨多个请求使用</strong>。因为存入order数据库的数据里有taco相关的数据，需要session暂存一下。</p>
<h3 id="第三章第一节JDBC调试"><a href="#第三章第一节JDBC调试" class="headerlink" title="第三章第一节JDBC调试"></a>第三章第一节JDBC调试</h3><p><code>lsof -i:8080</code>查看端口占用   关闭进程 <code>kill pid</code></p>
<p>1.为领域类taco、order添加id和日期。</p>
<p>2.pom.xml里添加jdbc、h2依赖</p>
<p>3.关于ingredient的改变：data文件夹下ingredientrepo接口和jdbcingredientrepo类，类下find方法和save方法。改造DesignTacoController的构造方法和showDesignForm，将固定配料改为从数据库中读取配料。</p>
<p>4.写表，预加载数据，schema.sql  data.sql</p>
<p>5.设置TacoRepository、OrderRepository接口</p>
<p>6.关于taco，jdbc实现的JdbcTacoRepository类。designtacocontrol中持久化的过程，构造函数为post方法添加一个参数。改造post函数，添加持久化到数据库的过程。还要一个taco和order方法。order领域类内添加一个adddesign方法。</p>
<p>7.关于order的改变，使用SimpleJdbcInsert方法，实现JdbcOrderRepository类，ordercontrol中的持久化过程，构造函数和post函数做改变。</p>
<h3 id="错误记录1"><a href="#错误记录1" class="headerlink" title="错误记录1"></a>错误记录1</h3><p>错误输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error starting ApplicationContext. To display the conditions report re-run your application with <span class="string">&#x27;debug&#x27;</span> enabled.</span><br><span class="line"><span class="number">2021</span>-<span class="number">12</span>-<span class="number">27</span> <span class="number">13</span>:<span class="number">46</span>:<span class="number">56.526</span> ERROR <span class="number">1306</span> --- [  restartedMain] o.s.boot.SpringApplication               : Application run failed</span><br></pre></td></tr></table></figure>

<p>这个问题是因为在pom文件里面加入了mybatis（某）模块 却没有在config配置里面增加mybatis（它）的上下文导致启动报错的<br>starting ApplicationContext. To display the conditions report re-run your application with ‘debug’ enabled（这句话其实已经说得很明白了 在启动的时候 上下文错误 导致启动失败）<br>在配置文件里面加上mybatis的配置就行了</p>
<p>但是不知道说的配置文件是什么，尝试注释掉不用的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jetbrains<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>没用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;jdbcIngredientRepository&#x27;</span><br></pre></td></tr></table></figure>

<p> 这个问题一般是mapper里面的SQL语句写错了。可能是本来select，却写成了insert</p>
<p>找了半天，原来是schema.sql文件中语句的错误。</p>
<p>干！！！是因为复制过来有无效空格，没显示错误。</p>
<h3 id="错误记录2"><a href="#错误记录2" class="headerlink" title="错误记录2"></a>错误记录2</h3><p>也不知哪一步有问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">12</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">40</span>:<span class="number">36.800</span> ERROR <span class="number">1822</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">6</span>] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() <span class="keyword">for</span> servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.NullPointerException] with root cause</span><br><span class="line"></span><br><span class="line">java.lang.NullPointerException: <span class="literal">null</span></span><br><span class="line">	at tacos.data.JdbcTacoRepository.saveTacoInfo(JdbcTacoRepository.java:<span class="number">51</span>) ~[classes/:na]</span><br><span class="line">	at tacos.data.JdbcTacoRepository.save(JdbcTacoRepository.java:<span class="number">28</span>) ~[classes/:na]</span><br></pre></td></tr></table></figure>

<p>在提交taco的时候，就会有500错误。</p>
<p>表单html文件就需要修改的，tomorrow看下表单做啥变化了。再换一下外面的文件，看是不是就能正常。</p>
<p>只是有一个design变成了taco，从数据库中拿配料种类，难道表单不需要连接数据库或者是控制器吗？？？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Failed to convert property value of type java.lang.String to required type java.util.List for property ingredients; nested exception is java.lang.IllegalStateException: Cannot convert value of type java.lang.String to required type tacos.Ingredient for property ingredients[0]: no matching editors or conversion strategy found</span><br><span class="line"></span><br><span class="line">将java.lang.String类型的属性值转换为所需类型java.util.List属性成分失败;java.lang.IllegalStateException:不能转换java.lang.String类型的值到所需类型tacos。属性成分[0]的成分:没有找到匹配的编辑器或转换策略</span><br></pre></td></tr></table></figure>

<p>1.designcontrol和ordercontrol两个控制器，需要加session，<code>@SessionAttributes(&quot;order&quot;)</code></p>
<p>2.原来的pom.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>taco-cloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>taco-cloud<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Taco Cloud Example<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jetbrains<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>taco-cloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xml-apis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xml-apis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.04<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.bytebuddy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>byte-buddy<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>替换了视图控制器、表单、pom文件，才变对的。</p>
<h3 id="第三章第二节JPA调试"><a href="#第三章第二节JPA调试" class="headerlink" title="第三章第二节JPA调试"></a>第三章第二节JPA调试</h3><p>1.在pom.xml中添加依赖starter<br>疑问：add … to classpath 是什么意思，往pom里添加依赖吗？</p>
<p>问题：</p>
<p><code>Dependency &#39;org.springframework.boot:spring-boot-starter-data-jpa:2.6.1&#39; not found </code></p>
<p>案例中的代码无configuration。<code>错误: 找不到或无法加载主类 tacos.TacoCloudApplication</code></p>
<p>2.库接口定义</p>
<p>3.可自动实现，可自定义实现</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat入门教程</title>
    <url>/2022/03/12/myblog/java/Tomcat%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a><strong>tomcat</strong></h3><p>为什么有tomcat？</p>
<p>一个项目：客户端+后端+数据库。</p>
<p>如何访问到服务？需要在web应用服务器里进行部署。</p>
<p>tomcat就是一个web应用服务器，就是一个服务，里面放java程序。</p>
<p>web应用服务器：tomcat、Jboos、Weblogic、Jetty。</p>
<p>有了tomcat可以实现两个电脑之间的互相访问，前提是在一个局域网里。</p>
<h3 id="1⃣️安装tomcat。"><a href="#1⃣️安装tomcat。" class="headerlink" title="1⃣️安装tomcat。"></a>1⃣️安装tomcat。</h3><p>apache出的，进入官网，选择tomcat9，下载压缩文件tar.gz</p>
<p>解压缩，放library里。</p>
<p>bin：存放各个平台下启动和停止tomcat服务的脚本文件。bat是windows系统下的脚本文件，sh是mac和linux的。</p>
<p>conf：存放各种tomcat服务器的配置文件，可以配置端口，server.xml。</p>
<p>lib：存放tomcat服务器需要的jar包。</p>
<p>logs：存放tomcat服务运行的日志。</p>
<p>temp：tomcat运行时的临时文件，文件上传下载io流的时候用，大文件放在java虚拟机内存里占用资源大，先放在temp文件夹里。</p>
<p>webapps：存放允许客户端访问的资源（java程序）。</p>
<p>work：存放tomcat将jsp转换之后的servlet文件。</p>
<h3 id="2⃣️idea集成tomcat"><a href="#2⃣️idea集成tomcat" class="headerlink" title="2⃣️idea集成tomcat"></a>2⃣️idea集成tomcat</h3><p>create new project –&gt; java enterprise –&gt; web application –&gt; 完成</p>
<p>index.jsp：写html的</p>
<p>web.xml：配置应用的</p>
<p>添加tomcat配置：右上角add configuration，点加号，tomcal，选local，配一个本地的tomcat，设置，写名字，选tomcat路径（主要就用tomcat的两个jar包：jsp、servlet）。相当于是把idea和tomcat映射起来了。设置url：默认浏览器，after launch是启动后自动打开浏览器，url是访问路径，访问到tomcat服务。然后选deployment添加java工程，点加号，选artifact，自动加进来了。相当于是把java工程放在test里了。然后apply，ok。</p>
<p>点右上角虫子图标。自动跳出来页面。关掉idea，就没了。</p>
<p>url由三部分组成：ip:port&#x2F;application name</p>
<p>可以改应用的名字，在右上角edit application，选deployment，下面context改名字。重启就可以了。</p>
<p>也可以没有名字，只是一个&#x2F;。</p>
<h3 id="3⃣️打包在tomcat运行"><a href="#3⃣️打包在tomcat运行" class="headerlink" title="3⃣️打包在tomcat运行"></a>3⃣️打包在tomcat运行</h3><p>1.首先基于maven进行打包，将war包复制到某个路径（不改配置的话放在webapps文件夹下）<br>2.对于放在其他文件夹的war包，在tomcat包下的conf文件夹下的server.xml文件增加配置（war包路径启动）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Host&gt; 标签下</span><br><span class="line">&lt;Context docBase=&quot;/Users/liuxuan/MyProject/java/log-maven-package.war&quot; </span><br><span class="line">        path=&quot;/log&quot; </span><br><span class="line">        reloadable=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>path:指定访问该Web应用的URL入口<br>docBase:指定Web应用的文件路径，可以给定绝对路径，也可以给定相对于<code>&lt;Host&gt;</code>的appBase属性的相对路径，如果Web应用采用开放目录结构，则指定Web应用的 根目录，如果Web应用是个war文件，则指定war文件的路径。<br>reloadable:如果这个属性设为true，tomcat服务器在运行状态下会监视在WEB-INF&#x2F;classes和WEB-INF&#x2F;lib目录下class文件的改动，如果监测到有class文件被更新的，服务器会自动重新加载Web应用。<br>Tomcat本身设置了Reloadable的属性，故Tomcat在检测到class文件发生变化之后，对WebApp的应用进行了重新加载：先卸载，再重新加载。<br>在开发阶段将reloadable属性设为true，有助于调试servlet和其它的class文件，但这样用加重服务器运行负荷，建议在Web应用的发存阶段将reloadable设为false。</p>
</blockquote>
<p>3.启动tomcat，之前配置过环境变量，所以不用区tomcat的bin目录下启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">启动：startup.sh</span><br><span class="line">关闭：shutdown.sh</span><br><span class="line">查看运行状态：ps -ef|grep tomcat</span><br><span class="line">查看启动日志：</span><br><span class="line">cd /usr/local/tomcat/apache-tomcat-8.5.51/logs/</span><br><span class="line">tail -200f catalina.out</span><br></pre></td></tr></table></figure>
<p>4.访问：<a href="http://localhost:8080/log/">http://localhost:8080/log/</a><br>5.外网如何访问：<a href="https://blog.csdn.net/weixin_30596023/article/details/98539676">https://blog.csdn.net/weixin_30596023/article/details/98539676</a><br>6.如何在服务器上部署：<a href="https://blog.csdn.net/qq_53324833/article/details/123802881">https://blog.csdn.net/qq_53324833/article/details/123802881</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Geometry和Coordinate</title>
    <url>/2022/05/21/myblog/java/Geometry%E5%92%8CCoordinate/</url>
    <content><![CDATA[<h3 id="LineString与Coordinate"><a href="#LineString与Coordinate" class="headerlink" title="LineString与Coordinate"></a>LineString与Coordinate</h3><p>Geometry对象转换为LineString对象，前面加(LineString)强转。</p>
<p><code>Coordinate coor = new Coordinate(lng, lat);</code><br>&#x2F;&#x2F;lng、lat是Double类型经度纬度</p>
<p>LineString转换为Coordinate数组：<br><code>Coordinate[] coor = road.getCoordinates();</code></p>
<h3 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h3><p>com.vividsolutions.jts.geom下<br>Geometry可以是一系列的点组成的线。<br>数据库中查看需要加：select st_astext(geo) from table;</p>
<p>Geometry里的点：<br><code>Coordinate[] coordinates = geo.getCoordinates();</code></p>
<h3 id="GeometryUtils工具类"><a href="#GeometryUtils工具类" class="headerlink" title="GeometryUtils工具类"></a>GeometryUtils工具类</h3><p>GeometryUtils类属于mil.nga.giat.geowave.core.geotime包。</p>
<p><a href="https://vimsky.com/examples/detail/java-class-mil.nga.giat.geowave.core.geotime.GeometryUtils.html">https://vimsky.com/examples/detail/java-class-mil.nga.giat.geowave.core.geotime.GeometryUtils.html</a></p>
<h3 id="redisTemplate的GEO-API："><a href="#redisTemplate的GEO-API：" class="headerlink" title="redisTemplate的GEO API："></a>redisTemplate的GEO API：</h3><p><a href="https://blog.csdn.net/weixin_39274753/article/details/107783674">https://blog.csdn.net/weixin_39274753/article/details/107783674</a></p>
<h3 id="string和geometry的转换"><a href="#string和geometry的转换" class="headerlink" title="string和geometry的转换"></a>string和geometry的转换</h3><p>需要导入jts包。（vividsolution）</p>
<p>WKT，是一种文本标记语言，用于表示矢量几何对象、空间参照系统及空间参照系统之间的转换。它的二进制表示方式，亦即WKB(well-known binary)则胜于在传输和在数据库中存储相同的信息。该格式由开放地理空间联盟(OGC)制定。</p>
<p>WKT可以表示的几何对象包括：点，线，多边形，TIN（不规则三角网）及多面体。可以通过几何集合的方式来表示不同维度的几何对象。<br>几何物体的坐标可以是2D(x,y),3D(x,y,z),4D(x,y,z,m),加上一个属于线性参照系统的m值。<br>以下为几何WKT字串样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POINT(6 10)</span><br><span class="line">LINESTRING(3 4,10 50,20 25)</span><br><span class="line">POLYGON((1 1,5 1,5 5,1 5,1 1),(2 2,2 3,3 3,3 2,2 2))</span><br><span class="line">MULTIPOINT(3.5 5.6, 4.8 10.5)</span><br><span class="line">MULTILINESTRING((3 4,10 50,20 25),(-5 -8,-10 -8,-15 -4))</span><br><span class="line">MULTIPOLYGON(((1 1,5 1,5 5,1 5,1 1),(2 2,2 3,3 3,3 2,2 2)),((6 3,9 2,9 4,6 3)))</span><br><span class="line">GEOMETRYCOLLECTION(POINT(4 6),LINESTRING(4 6,7 10))</span><br><span class="line">POINT ZM (1 1 5 60)</span><br><span class="line">POINT M (1 1 80)</span><br><span class="line">POINT EMPTY</span><br><span class="line">MULTIPOLYGON EMPTY</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void geoTest() throws ParseException, com.vividsolutions.jts.io.ParseException &#123;</span><br><span class="line">    //1.string类型转为geometry</span><br><span class="line">    //GeometryFactory工厂，参数一：数据精度 参数二空间参考系SRID</span><br><span class="line">    GeometryFactory geometryFactory = new GeometryFactory(new PrecisionModel(PrecisionModel.FLOATING), 4326);</span><br><span class="line"></span><br><span class="line">    //熟知文本WKT阅读器，可以将WKT文本转换为Geometry对象</span><br><span class="line">    WKTReader wktReader = new WKTReader(geometryFactory);</span><br><span class="line"></span><br><span class="line">    //Geometry对象，包含Point、LineString、Polygon等子类</span><br><span class="line">    Geometry geometry = wktReader.read(&quot;POINT (113.53896635 22.36429837)&quot;);</span><br><span class="line">    System.out.println(&quot;geometry:&quot; + geometry);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //2.geometry对象转为string</span><br><span class="line">    //单纯的一个坐标点，单点可以创建Point，多点可以创建LineString、Polygon等</span><br><span class="line">    Coordinate coordinate = new Coordinate(113.53896635, 22.36429837);</span><br><span class="line">    Point point = geometryFactory.createPoint(coordinate);</span><br><span class="line"></span><br><span class="line">    Polygon polygon = geometryFactory.createPolygon(new Coordinate[]&#123;</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">    &#125;);</span><br><span class="line">    Geometry geometry1 = point;</span><br><span class="line">    Geometry geometry2 = polygon;</span><br><span class="line"></span><br><span class="line">    //WKT输出器，将Geometry对象写出为WKT文本</span><br><span class="line">    WKTWriter wktWriter = new WKTWriter();</span><br><span class="line">    String pointString = wktWriter.write(point);</span><br><span class="line">    System.out.println(&quot;point string: &quot; + pointString);</span><br><span class="line">    String geoString = wktWriter.write(geometry1);</span><br><span class="line">    System.out.println(&quot;geo string: &quot; + geoString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<br>Java Geometry空间几何数据的处理应用：<a href="https://blog.csdn.net/An1090239782/article/details/123509504">https://blog.csdn.net/An1090239782/article/details/123509504</a></p>
<p>Geometry在数据库和Java中的应用：<a href="https://www.jianshu.com/p/76343e71d6f1">https://www.jianshu.com/p/76343e71d6f1</a></p>
<h3 id="两个geometry拼接"><a href="#两个geometry拼接" class="headerlink" title="两个geometry拼接"></a>两个geometry拼接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() throws com.vividsolutions.jts.io.ParseException &#123;</span><br><span class="line">    WKTReader wktReader = new WKTReader();</span><br><span class="line">    Geometry geometry1 = wktReader.read(&quot;LineString(113.53896635 22.36429837, 113.53896645 22.36429847)&quot;);</span><br><span class="line">    Geometry geometry2 = wktReader.read(&quot;LineString(113.53896645 22.36429847, 113.53896655 22.36429857)&quot;);</span><br><span class="line">    Geometry geometry3 = geometry1.union(geometry2);</span><br><span class="line">    System.out.println(geometry3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：MULTILINESTRING ((113.53896635 22.36429837, 113.53896645 22.36429847), (113.53896645 22.36429847, 113.53896655 22.36429857))</p>
<h3 id="jts里的geometry的一些操作"><a href="#jts里的geometry的一些操作" class="headerlink" title="jts里的geometry的一些操作"></a>jts里的geometry的一些操作</h3><p>✅<code>org.locationtech.jts.geom.Geometry.isValid()</code></p>
<p>验证此Geometry是否在拓扑上有效。</p>
<p>✅<code>geo.buffer(distance)</code></p>
<p>buffer(double distance): 加buffer缓冲区<br>buffer(double distance, int quadrantSegments): 加buffer,边界样式</p>
<p>✅<code>geometry1.equals(geometry2)</code> 是否完全重叠</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void equalsGeometry() throws com.vividsolutions.jts.io.ParseException &#123;</span><br><span class="line">    GeometryFactory geometryFactory = new GeometryFactory(new PrecisionModel(PrecisionModel.FLOATING), 4326);</span><br><span class="line">    WKTReader reader = new WKTReader( geometryFactory );</span><br><span class="line">    String wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    String wkt2 = &quot;LINESTRING(3 0, 1 0)&quot;;</span><br><span class="line">    LineString geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    LineString geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b1 = geometry1.equals(geometry2);//false</span><br><span class="line">    System.out.println(b1);</span><br><span class="line"></span><br><span class="line">    wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    wkt2 = &quot;LINESTRING(10 0, 0 0)&quot;;</span><br><span class="line">    geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b2 = geometry1.equals(geometry2);//true</span><br><span class="line">    System.out.println(b2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅geometry1.crosses(geometry2) 是否交叉</p>
<p>得有交点。但交点不能是线的起点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void crossGeometry() throws com.vividsolutions.jts.io.ParseException &#123;</span><br><span class="line">    GeometryFactory geometryFactory = new GeometryFactory();</span><br><span class="line">    //情景1</span><br><span class="line">    WKTReader reader = new WKTReader(geometryFactory);</span><br><span class="line">    String wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    String wkt2 = &quot;LINESTRING(3 0, 1 0)&quot;;</span><br><span class="line">    LineString geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    LineString geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b1 = geometry1.crosses(geometry2);//false</span><br><span class="line">    System.out.println(b1);</span><br><span class="line">    //情景2</span><br><span class="line">    wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    wkt2 = &quot;LINESTRING(3 0, 1 1)&quot;;</span><br><span class="line">    geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b2 = geometry1.crosses(geometry2);//false</span><br><span class="line">    System.out.println(b2);</span><br><span class="line">    //情景3</span><br><span class="line">    wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    wkt2 = &quot;LINESTRING(4 0, -1 -1)&quot;;</span><br><span class="line">    geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b3 = geometry1.crosses(geometry2);//false</span><br><span class="line">    System.out.println(b3);</span><br><span class="line">    //情景4</span><br><span class="line">    wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    wkt2 = &quot;LINESTRING(0 4, 3 0, -1 -1)&quot;;</span><br><span class="line">    geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b4 = geometry1.crosses(geometry2);//true</span><br><span class="line">    System.out.println(b4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅intersects ：两个对象是否空间相交（至少有一个点）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">wkt2 = &quot;LINESTRING(3 0, 1 1)&quot;;</span><br><span class="line">geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">boolean b2 = geometry1.intersects(geometry2);//true</span><br></pre></td></tr></table></figure>

<p>geometry的更多用法：<a href="https://blog.csdn.net/qiaobing1226/article/details/124467098">https://blog.csdn.net/qiaobing1226/article/details/124467098</a></p>
<p>常用的Geometry数据结构和GeometryFactory：<a href="https://www.jianshu.com/p/3add14bdee7b">https://www.jianshu.com/p/3add14bdee7b</a></p>
<p>jts使用：<a href="https://blog.csdn.net/weixin_40294332/article/details/124124361">https://blog.csdn.net/weixin_40294332/article/details/124124361</a><br><a href="https://blog.csdn.net/qiaobing1226/article/details/127204644">https://blog.csdn.net/qiaobing1226/article/details/127204644</a></p>
<h3 id="数据库相关的geo操作"><a href="#数据库相关的geo操作" class="headerlink" title="数据库相关的geo操作"></a>数据库相关的geo操作</h3><p>✅mysql空间数据有哪些</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Geometry  空间数据	任意一种空间类型	</span><br><span class="line">Point	点	坐标值	POINT(104.00924 30.46872)</span><br><span class="line">LineString	线	线，由一系列点连接而成	LINESTRING(1 1,  1 1, 1 1)</span><br><span class="line">Polygon	多边形	由多条线组成	POLYGON((1 1, 2 2, 3 3,  4 4, 5 5))</span><br><span class="line">MultiPoint	点集合	集合类，包含多个点	MULTIPOINT(1 1, 2 2, 1 1)</span><br><span class="line">MultiLineString	线集合	集合类，包含多条线	MULTILINESTRING((1 1, 2 2), (1 1, 1 1))</span><br><span class="line">MultiPolygon	多边形集合	集合类，包含多个多边形	MULTIPOLYGON(((0 0, 1 0, 1 1, 0 1, 0 0)), ((1 1, 1 1, 1 1, 1 1, 1 1)))</span><br><span class="line">GeometryCollection	空间数据集合	集合类，可以包括多个点、线、多边形	GEOMETRYCOLLECTION(POINT(1 1), POINT(3 3), LINESTRING(1 1, 2 2))</span><br></pre></td></tr></table></figure>

<p>mysql中几何对象的表达格式：<br>WKT：（Well-known Text）可以通过文本来描述几何对象。<br>WKB（Well-known Binary）通过序列化的字节对象来描述几何对象（一般在数据库中使用）。</p>
<p>常用函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ST_GEOMFROMTEXT</span><br><span class="line">用于将几何数据从可读的文本类型转换成内部存储的二进制类型。</span><br><span class="line">ST_ASTEXT</span><br><span class="line">将几何数据转换成可读的文本类型。</span><br><span class="line"></span><br><span class="line">st_union(g1, g2) 将g1和g2合并为一个集合类对象</span><br><span class="line">st_difference(g1, g2)  返回几何对象，该对象表示了几何值g1与g2的点集合差异</span><br><span class="line">st_intersection(g1,g2)  返回几何对象，该对象表示了几何值g1与g2的点集合交集</span><br><span class="line"></span><br><span class="line">st_contains(g1, g2)</span><br><span class="line">g1完全包含g2；返回0: g1未包含g2</span><br><span class="line"></span><br><span class="line">st_crosses(g1, g2), st_intersects(g1, g2)</span><br><span class="line">返回1: g1与g2相交；返回0:g1与g2未相交</span><br><span class="line"></span><br><span class="line">st_disjoint(g1, g2)</span><br><span class="line">是st_crosses的反函数</span><br><span class="line"></span><br><span class="line">st_within(g1, g2)</span><br><span class="line">g1在g2内则返回1，否则返回0</span><br></pre></td></tr></table></figure>

<p>创建索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对表中的geometry类型的字段进行索引可以优化搜索，mysql中通过对geometry对象的mbr创建索引</span><br><span class="line">创建：</span><br><span class="line">create spatial index i_shape on `t_geo_test`(shape);</span><br><span class="line">删除：</span><br><span class="line">drop index i_shape on `t_geo_test`;</span><br><span class="line"></span><br><span class="line">目前mysql中支持的空间坐标系统没有gcj02,bd09等国内坐标系，</span><br><span class="line">默认使用wgs84地球坐标系，所以在创建几何对象时输入的坐标值尽量使用wgs84坐标，以避免误差。</span><br><span class="line"></span><br><span class="line">mysql中的计算距离，长度，面积等绝对数值的空间计算函数（area(), glength(), st_distance()）存在一定的误差，尽量不要使用。</span><br></pre></td></tr></table></figure>

<p>mysql的geometry相关的函数：<a href="https://jiuaidu.com/jianzhan/906169/">https://jiuaidu.com/jianzhan/906169/</a></p>
<p>✅创建表时带geometry字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`geo` geometry default null comment &#x27;坐标点&#x27;,</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table if not exists `geo_table`(</span><br><span class="line">    `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增&#x27;,</span><br><span class="line">    `geo` geometry default null comment &#x27;坐标点&#x27;,</span><br><span class="line">    PRIMARY KEY ( `id` )</span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=100 DEFAULT CHARSET=utf8mb4 COMMENT=&quot;geo&quot;;</span><br><span class="line"></span><br><span class="line">set @geo = st_geomfromtext(&quot;LineString(104.009241 30.468972,104.009229 30.468961)&quot;);</span><br><span class="line">insert into geo_table values(0, @geo);</span><br><span class="line">select st_astext(geo) from geo_table;</span><br></pre></td></tr></table></figure>

<p>✅Intersects相交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table where Intersects(geome1, geo2);</span><br></pre></td></tr></table></figure>

<p>✅mysql根据经纬度计算距离</p>
<p>st_distance_sphere函数返回以米为单位.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select st_distance_sphere(point(113.264435, 23.129163), point(113.274436, 23.129164));</span><br></pre></td></tr></table></figure>

<p>st_distance返回的度<br>st_distance 计算的结果单位是度，需要乘111195（地球半径6371000*PI&#x2F;180）是将值转化为米。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select st_distance(point(113.264435, 23.129163), point(113.274436, 23.129164));</span><br></pre></td></tr></table></figure>

<p>直接计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">*,ROUND(</span><br><span class="line">6378.138 * 2 * ASIN(</span><br><span class="line">SQRT(</span><br><span class="line">POW( SIN(( 23.129163 * PI()/ 180-latitudes * PI()/ 180 )/ 2 ), 2 )+ COS( 23.129163 * PI()/ 180 )* COS( latitudes * PI()/ 180 )* POW( SIN(( 113.264435 * PI()/ 180-longitudes * PI()/ 180 )/ 2 ), 2 )))* 1000 </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="几个坐标系"><a href="#几个坐标系" class="headerlink" title="几个坐标系"></a>几个坐标系</h3><p>总的来说，坐标系可以分为两大类：地理坐标系（Geographic Coordinate System, GCS）和投影坐标系（Projected Coordinate System, PCS），地理坐标系进行地图投影后就变成了投影坐标系。例如我们常见的世界地图，使用的就是一种 墨卡托投影。</p>
<p>其中地理坐标系又可分为 参心坐标系 和 地心坐标系，常见的地心坐标系有WGS84、GCJ-02、BD-09、GCS2000。</p>
<p>✅WGS84（World Geodetic System 1984）</p>
<p>WGS84是为 GPS 全球定位系统建立的坐标系统，是世界上第一个统一的地心坐标系，因此也被称为大地坐标系、原始坐标系。一般通过GPS记录仪记录下来的经纬度，就是基于WGS84坐标系的数据。</p>
<p>✅GCJ-02（国家测量局02号标准）</p>
<p>GCJ-02 是由中国国家测绘局（G表示Guojia国家，C表示Cehui测绘，J表示Ju局）制订的地理信息系统的坐标系统，是在WGS84经纬度的基础上执行加密算法而成（为了数据安全和保密，通过地形图非线性保密处理算法（俗称火星加密）加密）。因为GPS得到的经纬度直接在 GCJ-02 坐标系下会定位到错误的地点，有种到了火星的感觉，因此在坊间也将 GCJ-02 戏称为火星坐标系。</p>
<p>国测局规定，国内出版的各种地图系统（包括电子形式），必须至少采用 GCJ-02 对地理位置进行首次加密的坐标系，高德和Google在国内都是使用 GCJ－02 坐标系，而百度使用的是在 GCJ-02 基础上再一次加密的 BD-09 坐标系。</p>
<p>举个例子，北京天安门中心的GPS经纬度是39°54’26.2”N，116°23’28.4”E，转化为度的单位就是39.907270, 116.391213（提示：小数部分 &#x3D; 分 &#x2F; 60 + 秒 &#x2F; 3600）<br>将 GPS 坐标转换为 GCJ-02 坐标：116.397454,39.908671，才能在高德地图上找到正确的位置。<br>需要注意的是，如果切换到谷歌地图的卫星地图模式，它使用的是WGS84坐标系。</p>
<p>参考：<br>几种坐标系：<a href="https://www.jianshu.com/p/559029832a67">https://www.jianshu.com/p/559029832a67</a><br>地心坐标系和投影坐标系：<a href="https://zhuanlan.zhihu.com/p/62864791">https://zhuanlan.zhihu.com/p/62864791</a></p>
<p>三个坐标总结：WGS84是大地坐标系，这是一种国际通用的坐标，一般的终端设备，如果自己有定位功能，比如车载系统，他们发出的gps坐标就是原始坐标。我们在一些地图应用中使用的定位，比如打车软件，其他自带地图的软件，他们一般都是火星坐标系GCJ02，需要进行一个坐标转换。而百度地图相关的应用，基本都是使用的百度坐标，这个是在火星坐标基础上进行的再次加密，所以它还是与火星坐标有关系。</p>
<p>✅坐标转换</p>
<p>从WGS84坐标系不能直接转BD09，中间需要跨越一个GCJ02，反过来，需要将GCJ02或者BD09转为WGS84就是纠偏算法，相当于逆向解密。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">克拉索索夫斯基椭球系数:</span><br><span class="line">public static double pi = 3.1415926535897932384626;</span><br><span class="line">public static double a = 6378245.0;</span><br><span class="line">public static double ee = 0.00669342162296594323;</span><br><span class="line">经纬度偏移值：&#123;105,35&#125;。这个其实是中华人民共和国大地原点坐标。位置在中国陕西省咸阳市下的泾阳县。</span><br></pre></td></tr></table></figure>

<p>转换代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.geometry;</span><br><span class="line"></span><br><span class="line">/***</span><br><span class="line"> * wgs84 84年提出，大地坐标，也是原始坐标。</span><br><span class="line"> * gcj02 02年提出，火星坐标，经过加密算法。大多数非百度中国地图厂商基本都是使用的火星坐标：高德，腾讯，谷歌中国cn</span><br><span class="line"> * bd09  09年提出，百度坐标，经过火星坐标再次加密，相当于对大地坐标经过了二次加密。百度自己使用</span><br><span class="line"> * 一般的算法，没有直接bd09-&gt;wgs84或者wgs84-&gt;bd09，都需要借助wgs84-&gt;gcj02或者gcj02-&gt;wgs84算法推导。</span><br><span class="line"> */</span><br><span class="line">public class GpsTransfer &#123;</span><br><span class="line">    //π的定义</span><br><span class="line">    public static double pi = 3.1415926535897932384626;</span><br><span class="line">    //椭球长半径，依据克拉索索夫斯基椭球系数计算</span><br><span class="line">    public static double a = 6378245.0;</span><br><span class="line">    //第一偏心率的平方</span><br><span class="line">    public static double ee = 0.00669342162296594323;</span><br><span class="line"></span><br><span class="line">    public static double transformLat(double x, double y) &#123;</span><br><span class="line">        double ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y</span><br><span class="line">                + 0.2 * Math.sqrt(Math.abs(x));</span><br><span class="line">        ret += (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 / 3.0;</span><br><span class="line">        ret += (20.0 * Math.sin(y * pi) + 40.0 * Math.sin(y / 3.0 * pi)) * 2.0 / 3.0;</span><br><span class="line">        ret += (160.0 * Math.sin(y / 12.0 * pi) + 320 * Math.sin(y * pi / 30.0)) * 2.0 / 3.0;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static double transformLon(double x, double y) &#123;</span><br><span class="line">        double ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1</span><br><span class="line">                * Math.sqrt(Math.abs(x));</span><br><span class="line">        ret += (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 / 3.0;</span><br><span class="line">        ret += (20.0 * Math.sin(x * pi) + 40.0 * Math.sin(x / 3.0 * pi)) * 2.0 / 3.0;</span><br><span class="line">        ret += (150.0 * Math.sin(x / 12.0 * pi) + 300.0 * Math.sin(x / 30.0</span><br><span class="line">                * pi)) * 2.0 / 3.0;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 判断是否在中国范围之内</span><br><span class="line">     * @param lat</span><br><span class="line">     * @param lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean outOfChina(double lat, double lon) &#123;</span><br><span class="line">        if (lon &lt; 72.004 || lon &gt; 137.8347)</span><br><span class="line">            return true;</span><br><span class="line">        if (lat &lt; 0.8293 || lat &gt; 55.8271)</span><br><span class="line">            return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 把公式部分抽取出来</span><br><span class="line">     * @param lat</span><br><span class="line">     * @param lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps transform(double lat, double lon) &#123;</span><br><span class="line">        if (outOfChina(lat, lon)) &#123;</span><br><span class="line">            return new Gps(lat, lon);</span><br><span class="line">        &#125;</span><br><span class="line">        double dLat = transformLat(lon - 105.0, lat - 35.0);</span><br><span class="line">        double dLon = transformLon(lon - 105.0, lat - 35.0);</span><br><span class="line">        double radLat = lat / 180.0 * pi;</span><br><span class="line">        double magic = Math.sin(radLat);</span><br><span class="line">        magic = 1 - ee * magic * magic;</span><br><span class="line">        double sqrtMagic = Math.sqrt(magic);</span><br><span class="line">        dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * pi);</span><br><span class="line">        dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * pi);</span><br><span class="line">        double mgLat = lat + dLat;</span><br><span class="line">        double mgLon = lon + dLon;</span><br><span class="line">        return new Gps(mgLat, mgLon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * wgs84到gcj02转换</span><br><span class="line">     * @param lat</span><br><span class="line">     * @param lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps wgs84_To_Gcj02(double lat, double lon) &#123;</span><br><span class="line">        return transform(lat, lon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 简单的gcj02到wgs84坐标类型转换，只做了一次迭代</span><br><span class="line">     */</span><br><span class="line">    public static Gps gcj02_To_Wgs84(double lat, double lon) &#123;</span><br><span class="line">        Gps gps = transform(lat, lon);</span><br><span class="line">        double lontitude = lon * 2 - gps.lon;</span><br><span class="line">        double latitude = lat * 2 - gps.lat;</span><br><span class="line">        return new Gps(latitude, lontitude);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 稍微精确一点的gcj02到wgs84转换</span><br><span class="line">     * @param lat</span><br><span class="line">     * @param lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps gcj02_To_Wgs84_exact(double lat,double lon) &#123;</span><br><span class="line">        if (outOfChina(lat, lon)) &#123;</span><br><span class="line">            return gcj02_To_Wgs84(lat, lon);</span><br><span class="line">        &#125;</span><br><span class="line">        double initDelta = 0.01;</span><br><span class="line">        double threshold = 0.000001;</span><br><span class="line">        double dLat = initDelta;</span><br><span class="line">        double dLon = initDelta;</span><br><span class="line">        double mLat = lat - dLat;</span><br><span class="line">        double mLon = lon - dLon;</span><br><span class="line">        double pLat = lat + dLat;</span><br><span class="line">        double pLon = lon + dLon;</span><br><span class="line">        double wgsLat = 0;</span><br><span class="line">        double wgsLon = 0;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            wgsLat = (mLat + pLat) / 2;</span><br><span class="line">            wgsLon = (mLon + pLon) / 2;</span><br><span class="line">            Gps tmp = wgs84_To_Gcj02(wgsLat, wgsLon);</span><br><span class="line">            dLat = tmp.lat - lat;</span><br><span class="line">            dLon = tmp.lon - lon;</span><br><span class="line">            if ((Math.abs(dLat) &lt; threshold) &amp;&amp; (Math.abs(dLon) &lt; threshold)) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dLat &gt; 0) &#123; pLat = wgsLat; &#125; else &#123; mLat = wgsLat;&#125;</span><br><span class="line">            if (dLon &gt; 0) &#123; pLon = wgsLon; &#125; else &#123; mLon = wgsLon;&#125;</span><br><span class="line"></span><br><span class="line">            if (++i &gt; 1000) break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new Gps(wgsLat, wgsLon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 百度坐标是在火星坐标基础上做的二次加密</span><br><span class="line">     * @param gg_lat</span><br><span class="line">     * @param gg_lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps gcj02_To_Bd09(double gg_lat, double gg_lon) &#123;</span><br><span class="line">        double x = gg_lon, y = gg_lat;</span><br><span class="line">        double z = Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * pi);</span><br><span class="line">        double theta = Math.atan2(y, x) + 0.000003 * Math.cos(x * pi);</span><br><span class="line">        double bd_lon = z * Math.cos(theta) + 0.0065;</span><br><span class="line">        double bd_lat = z * Math.sin(theta) + 0.006;</span><br><span class="line">        return new Gps(bd_lat, bd_lon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 百度坐标与火星坐标逆向转换</span><br><span class="line">     * @param bd_lat</span><br><span class="line">     * @param bd_lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps bd09_To_Gcj02(double bd_lat, double bd_lon) &#123;</span><br><span class="line">        double x = bd_lon - 0.0065, y = bd_lat - 0.006;</span><br><span class="line">        double z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * pi);</span><br><span class="line">        double theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * pi);</span><br><span class="line">        double gg_lon = z * Math.cos(theta);</span><br><span class="line">        double gg_lat = z * Math.sin(theta);</span><br><span class="line">        return new Gps(gg_lat, gg_lon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Gps gps = new Gps(39.907270, 116.391213);</span><br><span class="line">        System.out.println(gps);//&#123;39.90727,116.391213&#125;</span><br><span class="line">        Gps gps2 = wgs84_To_Gcj02(gps.lat, gps.lon);</span><br><span class="line">        System.out.println(gps2);//&#123;39.90867122432153,116.39745410656687&#125;</span><br><span class="line">        Gps gps3 = gcj02_To_Wgs84(gps2.lat, gps2.lon);</span><br><span class="line">        System.out.println(gps3);//&#123;39.907267736339556,116.3912105466475&#125;</span><br><span class="line">        Gps gps4 = gcj02_To_Wgs84_exact(gps2.lat, gps2.lon);</span><br><span class="line">        System.out.println(gps4);//&#123;39.90727046748559,116.39121326184032&#125; 相对一次迭代是精确了，但是好像也不是完全还原</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Gps&#123;</span><br><span class="line">    double lat,lon;</span><br><span class="line">    public Gps() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public Gps(double lat,double lon)&#123;</span><br><span class="line">        this.lat = lat;</span><br><span class="line">        this.lon = lon;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;&#123;&quot;+lat+&quot;,&quot;+lon+&quot;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://blog.csdn.net/feinifi/article/details/120547127">https://blog.csdn.net/feinifi/article/details/120547127</a></p>
<h3 id="mysql-java-redis三种地理位置算法"><a href="#mysql-java-redis三种地理位置算法" class="headerlink" title="mysql,java,redis三种地理位置算法"></a>mysql,java,redis三种地理位置算法</h3><p>获取附近信息，以用户当前位置为中心点，指定范围为半径，查询出在该圆圈内的所有信息。</p>
<h4 id="MySQL-基于st-distance函数"><a href="#MySQL-基于st-distance函数" class="headerlink" title="MySQL 基于st_distance函数"></a>MySQL 基于st_distance函数</h4><p>mysql 5.6.1 加入了空间数据支持功能，新增了st_*相关函数，可以非常方便的计算两个地理坐标点的距离。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	p.* </span><br><span class="line">FROM</span><br><span class="line">	(</span><br><span class="line">	SELECT</span><br><span class="line">		park_info.*,</span><br><span class="line">		st_distance (</span><br><span class="line">			point ( park_info.lng, park_info.lat ),</span><br><span class="line">		point ( 116.403694, 39.913828 ))* 111195 AS distance </span><br><span class="line">	FROM</span><br><span class="line">		park_info park_info </span><br><span class="line">	) p </span><br><span class="line">WHERE</span><br><span class="line">	p.distance &lt; 10000</span><br></pre></td></tr></table></figure>


<h4 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class DistanceUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 地球半径,单位 km</span><br><span class="line">     */</span><br><span class="line">    private static final double EARTH_RADIUS = 6378137;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据经纬度，计算两点间的距离</span><br><span class="line">     *</span><br><span class="line">     * @param longitude1 第一个点的经度</span><br><span class="line">     * @param latitude1  第一个点的纬度</span><br><span class="line">     * @param longitude2 第二个点的经度</span><br><span class="line">     * @param latitude2  第二个点的纬度</span><br><span class="line">     * @return 返回距离 单位米</span><br><span class="line">     */</span><br><span class="line">    public static double getDistance(double longitude1, double latitude1, double longitude2, double latitude2) &#123;</span><br><span class="line">        // 纬度</span><br><span class="line">        double lat1 = Math.toRadians(latitude1);</span><br><span class="line">        double lat2 = Math.toRadians(latitude2);</span><br><span class="line">        // 经度</span><br><span class="line">        double lng1 = Math.toRadians(longitude1);</span><br><span class="line">        double lng2 = Math.toRadians(longitude2);</span><br><span class="line">        // 纬度之差</span><br><span class="line">        double a = lat1 - lat2;</span><br><span class="line">        // 经度之差</span><br><span class="line">        double b = lng1 - lng2;</span><br><span class="line">        // 计算两点距离的公式</span><br><span class="line">        double s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) +</span><br><span class="line">                Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(b / 2), 2)));</span><br><span class="line">        // 弧长乘地球半径, 返回单位: 米</span><br><span class="line">        s =  s * EARTH_RADIUS;</span><br><span class="line">        return Math.round(s * 10000) / 10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double distance = DistanceUtils.getDistance(109.49081, 36.596537, 111.128971, 37.524041);</span><br><span class="line">        log.info(&quot;distance=&#123;&#125;&quot;, distance);</span><br><span class="line">        double distance1 = DistanceUtils.getDistance(109.500603,36.594125, 111.151761,37.52671);</span><br><span class="line">        log.info(&quot;distance=&#123;&#125;&quot;, distance1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="redis实现"><a href="#redis实现" class="headerlink" title="redis实现"></a>redis实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 添加经纬度</span><br><span class="line"> *</span><br><span class="line"> * @param key 停车场地理位置键</span><br><span class="line"> * @param lng 坐标</span><br><span class="line"> * @param lat 坐标</span><br><span class="line"> * @param t 停车场标示</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Long addGeo(String key, Double lng, Double lat, T t) &#123;</span><br><span class="line">    RedisGeoCommands.GeoLocation&lt;T&gt; geoLocation = new RedisGeoCommands.GeoLocation&lt;&gt;(t, new Point(lng, lat));</span><br><span class="line">    return redisTemplate.opsForGeo().add(key, geoLocation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 批量添加</span><br><span class="line"> * @param key</span><br><span class="line"> * @param list</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Long batchAddGeo(String key, List&lt;RedisGeoCommands.GeoLocation&lt;T&gt;&gt; list) &#123;</span><br><span class="line">    return redisTemplate.opsForGeo().add(key, list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除经纬度</span><br><span class="line"> *</span><br><span class="line"> * @param key</span><br><span class="line"> */</span><br><span class="line">public void removeGeo(String key, T... t) &#123;</span><br><span class="line">    redisTemplate.opsForGeo().remove(key, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取经纬度指定距离内的数据</span><br><span class="line"> *</span><br><span class="line"> * @param lng</span><br><span class="line"> * @param lat</span><br><span class="line"> * @param distance</span><br><span class="line"> * @param key</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;T&gt;&gt;&gt;</span><br><span class="line">getCacheListByPointAndDistance(Double lng, Double lat, Double distance, String key) &#123;</span><br><span class="line">    Circle circle = new Circle(new Point(lng, lat), new Distance(distance, Metrics.KILOMETERS));</span><br><span class="line">    RedisGeoCommands.GeoRadiusCommandArgs args =</span><br><span class="line">            // includeCoordinates：返回结果包含坐标信息</span><br><span class="line">            // includeDistance：返回结果包含具中心坐标距离信息</span><br><span class="line">            // sortAscending：按照距离升序排序</span><br><span class="line">            // sortDescending：按照距离降序排序</span><br><span class="line">            // limit：返回结果数量限制</span><br><span class="line">            RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs().includeDistance().includeCoordinates()</span><br><span class="line">                    .sortAscending();</span><br><span class="line">    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;T&gt;&gt;&gt; content =</span><br><span class="line">            redisTemplate.opsForGeo().radius(key, circle, args).getContent();</span><br><span class="line">    return content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Elasticsearch-Geo"><a href="#Elasticsearch-Geo" class="headerlink" title="Elasticsearch Geo"></a>Elasticsearch Geo</h4><p>【toStudy】</p>
<p>转自：<a href="https://blog.csdn.net/m0_37923316/article/details/108978101">https://blog.csdn.net/m0_37923316/article/details/108978101</a></p>
<h3 id="点到线的最近线段"><a href="#点到线的最近线段" class="headerlink" title="点到线的最近线段"></a>点到线的最近线段</h3><p>使用JTSFactoryFinder 创建GeometryFactory，是在org.geotools.geometry.jts下的。</p>
<p>需要导入的包：gt-main、gt-metadata</p>
<p><code>GeometryFactory geometryFactory = JTSFactoryFinder.getGeometryFactory(null);</code></p>
<p>返回点到线段的最近线段，可能是垂线，不能垂直的话，是点到线段两端点的连线。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testNearest() throws ParseException &#123;</span><br><span class="line">    GeometryFactory geometryFactory = new GeometryFactory();</span><br><span class="line">    Coordinate coordinate = new Coordinate(1, 1);</span><br><span class="line">    WKTReader reader = new WKTReader(geometryFactory);</span><br><span class="line">    String wkt = &quot;LINESTRING(0 0, 1 0, 2 0)&quot;;</span><br><span class="line">    LineString road = (LineString) reader.read(wkt);</span><br><span class="line">    Coordinate[] shadow = com.vividsolutions.jts.operation.distance.DistanceOp.nearestPoints(road,</span><br><span class="line">            geometryFactory.createPoint(coordinate));</span><br><span class="line">    System.out.println(Arrays.toString(shadow)); //[(1.0, 0.0, NaN), (1.0, 1.0, NaN)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="道格拉斯抽稀"><a href="#道格拉斯抽稀" class="headerlink" title="道格拉斯抽稀"></a>道格拉斯抽稀</h3><p>道格拉斯-普克算法（Douglas-Peuker算法）是我们常用的一种轨迹点的抽稀算法，抽稀出来的点可以尽可能的维持原先轨迹点的大体轮廓，剔除一些非必要的点。</p>
<p>道格拉斯-普克原理：<br>（1）在曲线首尾两点A，B之间连接一条直线AB，该直线为曲线的弦；<br>（2）得到曲线上离该直线段距离最大的点C，计算其与AB的距离d；<br>（3）比较该距离与预先给定的阈值threshold的大小，如果小于threshold，则该直线段作为曲线的近似，该段曲线处理完毕。<br>（4）如果距离大于阈值，则用C将曲线分为两段AC和BC，并分别对两段取信进行1~3的处理。<br>（5）当所有曲线都处理完毕时，依次连接各个分割点形成的折线，即可以作为曲线的近似。</p>
<p>java使用方法：jts是一套用于处理几何要素拓扑关系的函数库，提供了基本二位平面线形图形运算算法实现。</p>
<p>mvn依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.vividsolutions&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jts&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.13&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GeometryFactory geometryFactory = new GeometryFactory(new PrecisionModel(PrecisionModel.FLOATING), 4326);</span><br><span class="line">WKTReader wktReader = new WKTReader(geometryFactory);</span><br><span class="line">Geometry geometry1 = wktReader.read(&quot;lineString(0 0, 1 1, 2 0)&quot;);</span><br><span class="line">Geometry geometry2 = DouglasPeuckerSimplifier.simplify(geometry1, 0.9);</span><br><span class="line">WKTWriter wktWriter = new WKTWriter();</span><br><span class="line">String res = wktWriter.write(geometry2);</span><br><span class="line">System.out.println(res);  //LINESTRING (0 0, 1 1, 2 0)</span><br></pre></td></tr></table></figure>

<p><code>Geometry simplify(Geometry geom, double distanceTolerance)</code>中的参数distanceTolerance是跟首尾点距离比(单纯平方间的距离，不是实际m的距离)。</p>
<p>自己实现道格拉斯抽稀(python)：<br><a href="https://www.jianshu.com/p/046bcaeb2cb6">https://www.jianshu.com/p/046bcaeb2cb6</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>spring boot入门教程</title>
    <url>/2022/03/07/myblog/spring/springboot%20b%E7%AB%99/</url>
    <content><![CDATA[<h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p>spring boot是一个快速开发框架，可以迅速搭建一套基于spring框架体系的应用，是spring cloud的基础。</p>
<p>springMVC虽然简化了配置，减少了很多类的数量，一个控制器当中多个方法可以对应不同的业务，但是SpringMVC的配置还是比较多，搭建工程有很多重复步骤，开发速度不够快。</p>
<p>spring boot开启了各种自动装配，从而简化代码的开发，不需要编写各种配置文件，只需要引入相关依赖就可以迅速搭建一个应用。</p>
<p>特点：</p>
<ul>
<li><p>不需要web.xml</p>
</li>
<li><p>不需要springmvc.xml</p>
</li>
<li><p>不需要tomcat，Spring Boot内嵌了tomcat</p>
</li>
<li><p>不需要配置json解析（fastjson），支持REST架构</p>
</li>
<li><p>个性化配置非常简单，至少需要端口啥的</p>
</li>
</ul>
<p>它是一个快速开发框架，不像mybatis是一个orm映射的应用。相当于一个脚手架，使得其他工种快速进行工作，搭建一个整体的环境。</p>
<h3 id="springboot概念"><a href="#springboot概念" class="headerlink" title="springboot概念"></a>springboot概念</h3><p>spring boot的设计目的是用来简化spring应用的初始搭建以及开发过程，该框架使用了特定的方式进行配置，从而使开发人员不再需要定义样板化的配置，</p>
<p>spring boot默认配置了很多框架的使用方式，就像Maven整合了所有的Jar包，spring boot整合了所有的框架，通过少量的代码就能创建一个独立的、产品级别的spring应用。</p>
<p>简而言之，spring boot是一个集成了spring各种组件的快速开发框架，作为一个用户和spring之间的连接者。</p>
<p>spring boot是基础，spring cloud是基于spring boot的，用来做分布式微服务的。</p>
<h4 id="spring-boot特点"><a href="#spring-boot特点" class="headerlink" title="spring boot特点"></a>spring boot特点</h4><ul>
<li>使用spring项目引导页面可以在几秒构建一个项目。</li>
<li>方便对外输出各种形式的服务，如REST API、WebSocket、Web、Streaming、Tasks</li>
<li>非常简洁的安全策略集成</li>
<li>支持关系数据库和非关系数据库</li>
<li>支持运行期内嵌容器，如tomcat、jetty</li>
<li>自动管理依赖</li>
</ul>
<h4 id="spring-boot与微服务"><a href="#spring-boot与微服务" class="headerlink" title="spring boot与微服务"></a>spring boot与微服务</h4><ul>
<li>spring boot的一系列特性有助于实现微服务架构的落地，从目前众多的技术栈对比来看它是java领域微服务架构最优落地技术，没有之一。</li>
<li>spring cloud依赖于spring boot。</li>
<li>spring boot专注于快速开发个体微服务，spring cloud是关注全局的微服务协调治理框架。spring boot提供组建，spring cloud来管理组件。</li>
</ul>
<h3 id="创建第一个工程"><a href="#创建第一个工程" class="headerlink" title="创建第一个工程"></a>创建第一个工程</h3><h4 id="第一步：创建maven工程，导入相关的依赖"><a href="#第一步：创建maven工程，导入相关的依赖" class="headerlink" title="第一步：创建maven工程，导入相关的依赖"></a>第一步：创建maven工程，导入相关的依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 继承父包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- dependencies下面再引相关的子包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- web启动的jar包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="第二步：创建实体类，加lombok"><a href="#第二步：创建实体类，加lombok" class="headerlink" title="第二步：创建实体类，加lombok"></a>第二步：创建实体类，加lombok</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.demo.springboot.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-12 10:42</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="第三步：创建StudentRepository"><a href="#第三步：创建StudentRepository" class="headerlink" title="第三步：创建StudentRepository"></a>第三步：创建StudentRepository</h4><p>之前，需要配置文件去扫dao实现类的包，但是springboot环境启动之后，会自动进行扫描。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.demo.springboot.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liuxuan.demo.springboot.entity.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-12 10:45</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Collection&lt;Student&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveOrUpdate</span><span class="params">(Student stu)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.demo.springboot.repository.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liuxuan.demo.springboot.entity.Student;</span><br><span class="line"><span class="keyword">import</span> com.liuxuan.demo.springboot.repository.StudentDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-12 10:49</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用静态map代替数据库</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Long, Student&gt; studentMap;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        studentMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        studentMap.put(<span class="number">1L</span>, <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1L</span>, <span class="string">&quot;lili&quot;</span>, <span class="number">22</span>));</span><br><span class="line">        studentMap.put(<span class="number">2L</span>, <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1L</span>, <span class="string">&quot;mary&quot;</span>, <span class="number">12</span>));</span><br><span class="line">        studentMap.put(<span class="number">3L</span>, <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1L</span>, <span class="string">&quot;jade&quot;</span>, <span class="number">24</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;Student&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> studentMap.values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> studentMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveOrUpdate</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        studentMap.put(student.getId(), student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        studentMap.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第四步：创建control层（跳过了service层）"><a href="#第四步：创建control层（跳过了service层）" class="headerlink" title="第四步：创建control层（跳过了service层）"></a>第四步：创建control层（跳过了service层）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.demo.springboot.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liuxuan.demo.springboot.entity.Student;</span><br><span class="line"><span class="keyword">import</span> com.liuxuan.demo.springboot.repository.StudentDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-12 11:00</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/student&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 自动注入，dao实现类要加@Repository注解</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/findAll&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;Student&gt; <span class="title function_">findAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/findById/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// post请求，前端返回的是json格式的字符串对象，需要映射成对象</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/sav&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span>&#123;</span><br><span class="line">        studentDao.saveOrUpdate(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新用put方法</span></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/update&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span>&#123;</span><br><span class="line">        studentDao.saveOrUpdate(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/delete/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span>&#123;</span><br><span class="line">        studentDao.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第五步：创建启动类"><a href="#第五步：创建启动类" class="headerlink" title="第五步：创建启动类"></a>第五步：创建启动类</h4><p>平常的web工程需要在tomcat部署。springboot有自己内置的tomcat，只需要创建一个启动类，作为整个springboot的入口.</p>
<p>application.java需要在其他组件包的父包下，要不然扫描不到。名字叫什么无所谓。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.demo.springboot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-12 11:17</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 参数是启动类的运行时类，还有main方法里的args</span></span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p> Tomcat started on port(s): 8080 (http) with context path ‘’</p>
<p>Started Application in 2.772 seconds (JVM running for 3.857)</p>
<p>表示部署成功，可以直接访问了。<a href="http://localhost:8080/student/findAll">http://localhost:8080/student/findAll</a></p>
<p>因为是基于rest的，所以可以用postman工具来测试。（post请求发json，选body–raw–json）</p>
<h4 id="第六步：如果想要更改端口号：在配置文件中更改。"><a href="#第六步：如果想要更改端口号：在配置文件中更改。" class="headerlink" title="第六步：如果想要更改端口号：在配置文件中更改。"></a>第六步：如果想要更改端口号：在配置文件中更改。</h4><p>resource里新建一个application.yml文件。文件名不能变。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9090</span></span><br></pre></td></tr></table></figure>

<p>注意9090前有个空格。</p>
<h3 id="springboot整合JSP"><a href="#springboot整合JSP" class="headerlink" title="springboot整合JSP"></a>springboot整合JSP</h3><p>新建maven工程，选择archetype，选择webapp（web模版，用来访问JSP.）</p>
<p>上一个工程只展示了数据，但是没有视图view。</p>
<p>JSP（全称JavaServer Pages）是由Sun Microsystems公司主导创建的一种动态网页技术标准。JSP部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成HTML、XML或其他格式文档的Web网页，然后返回给请求者。JSP技术以Java语言作为脚本语言，为用户的HTTP请求提供服务，并能与服务器上的其它Java程序共同处理复杂的业务需求。</p>
<p>前后端分离，jsp更像前端的组件，略。</p>
<p>java程序的对象，序列化为json字符串，传递给html进行显示。jsp就是提供视图的。controller用ModeAndView。</p>
<h3 id="spring-boot-html"><a href="#spring-boot-html" class="headerlink" title="spring boot html"></a>spring boot html</h3><p>spring mvc采用异步的方式展示java对象，需要通过json字符串进行读取，但是spring boot可以在html中读取java对象。</p>
<p>spring boot可以结合thymeleaf模版来整合html，使用原生的html作为视图。</p>
<p>Thymeleaf模版是面向Web和独立环境的java模版引擎，能够处理html、xml、javascript、css等。</p>
<p>前端，略。</p>
<h3 id="spring-boot数据校验"><a href="#spring-boot数据校验" class="headerlink" title="spring boot数据校验"></a>spring boot数据校验</h3><p>用来确保客户端输入的数据是有效的。</p>
<p>为什么要用包装类类型？因为前台有可能没穿值，就会是null值，需要包装类类型来接收。</p>
<p>notnull是压根没穿值，notempty是传的空。</p>
<p>这些校验可以交给前端，但是后端有的原因是防止攻击。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotEmpty;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;id不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;姓名不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Length(min = 2,message = &quot;姓名长度不能小于2位&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Min(value = 16,message = &quot;年龄必须大于16岁&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/validator&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validatorUser</span><span class="params">(<span class="meta">@Valid</span> User user,BindingResult bindingResult)</span>&#123;</span><br><span class="line">  System.out.println(user);</span><br><span class="line">  <span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">    List&lt;ObjectError&gt; list = bindingResult.getAllErrors();</span><br><span class="line">    <span class="keyword">for</span>(ObjectError objectError:list)&#123;</span><br><span class="line">      System.out.println(objectError.getCode()+<span class="string">&quot;-&quot;</span>+objectError.getDefaultMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用@Valid表示自动去校验，将错误传给BindingResult。getCode是注解名称。</p>
<h3 id="spring-boot整合jdbc"><a href="#spring-boot整合jdbc" class="headerlink" title="spring boot整合jdbc"></a>spring boot整合jdbc</h3><ul>
<li>pom.xml：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>application.yml</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">prefix:</span> <span class="string">classpath:/templates/</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">.html</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">HTML5</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">  <span class="attr">datasource:</span> <span class="string">//连接数据库相关</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>User</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotEmpty;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;id不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;姓名不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Length(min = 2,message = &quot;姓名长度不能小于2位&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Min(value = 60,message = &quot;成绩必须大于60分&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>UserRepository</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.southwind.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>UserRepositoryImpl，jdbcTemplate两种方法：query、update。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.repository.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.southwind.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.southwind.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(<span class="string">&quot;select * from user&quot;</span>,<span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class));</span><br><span class="line">    &#125;       <span class="comment">// 解析实体类，括号内传入要解析成为的实体类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="string">&quot;select * from user where id = ?&quot;</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;id&#125;,<span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;insert into user(name,score) values(?,?)&quot;</span>,user.getName(),user.getScore());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;update user set name = ?,score = ? where id = ?&quot;</span>,user.getName(),user.getScore(),user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;delete from user where id = ?&quot;</span>,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Handler</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.southwind.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.southwind.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/findAll&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/findById/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/update&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        userRepository.update(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/deleteById/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span>&#123;</span><br><span class="line">        userRepository.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="spring-boot整合mybatis"><a href="#spring-boot整合mybatis" class="headerlink" title="spring boot整合mybatis"></a>spring boot整合mybatis</h3><p>mybatis是半自动化的，意思是得自己写sql语句，也就是说需要mapper.xml</p>
<h4 id="第一步：新建maven工程"><a href="#第一步：新建maven工程" class="headerlink" title="第一步：新建maven工程"></a>第一步：新建maven工程</h4><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 继承父包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- dependencies下面再引相关的子包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- web启动的jar包，不用写版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- mybatis跟springboot整合的，mybatis自己出的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--mysql的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line">			 <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="第二步：创建数据表"><a href="#第二步：创建数据表" class="headerlink" title="第二步：创建数据表"></a>第二步：创建数据表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> student&#123;</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line">	score <span class="keyword">double</span>,</span><br><span class="line">	birthday <span class="type">date</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三步：创建实体类"><a href="#第三步：创建实体类" class="headerlink" title="第三步：创建实体类"></a>第三步：创建实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotEmpty;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;id不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;姓名不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Length(min = 2,message = &quot;姓名长度不能小于2位&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Min(value = 60,message = &quot;成绩必须大于60分&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第四步：创建repository接口"><a href="#第四步：创建repository接口" class="headerlink" title="第四步：创建repository接口"></a>第四步：创建repository接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.southwind.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> limit)</span>;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第五步：创建接口对应的mapper-xml"><a href="#第五步：创建接口对应的mapper-xml" class="headerlink" title="第五步：创建接口对应的mapper.xml"></a>第五步：创建接口对应的mapper.xml</h4><p>放在resource文件夹下的mapping文件夹下。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line">        <span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.southwind.mapper.UserRepository&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from user limit #&#123;param1&#125;,#&#123;param2&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;count&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select count(id) from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;save&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        insert into user(name,score) values(#&#123;name&#125;,#&#123;score&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        update user set name = #&#123;name&#125;,score = #&#123;score&#125; where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span>&gt;</span>   //如果是包装类类型，“java.lang.Long”</span><br><span class="line">        delete from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="第六步：创建controller层"><a href="#第六步：创建controller层" class="headerlink" title="第六步：创建controller层"></a>第六步：创建controller层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.controller;</span><br><span class="line"><span class="keyword">import</span> com.southwind.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.southwind.mapper.UserRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>   <span class="comment">//视频中是 @RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMapperHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/findAll/&#123;page&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">findAll</span><span class="params">(<span class="meta">@PathVariable(&quot;page&quot;)</span> <span class="type">int</span> page)</span>&#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (page-<span class="number">1</span>)*limit;</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;list&quot;</span>,userRepository.findAll(index,limit));</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;page&quot;</span>,page);</span><br><span class="line">        <span class="comment">//计算总页数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> userRepository.count();</span><br><span class="line">        <span class="type">int</span> <span class="variable">pages</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(count%limit == <span class="number">0</span>)&#123;</span><br><span class="line">            pages = count/limit;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pages = count/limit+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;pages&quot;</span>,pages);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/deleteById/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span>&#123;</span><br><span class="line">        userRepository.deleteById(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/mapper/findAll/1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/findById&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">findById</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> <span class="type">long</span> id)</span>&#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;user&quot;</span>,userRepository.findById(id));</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;update&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/update&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        userRepository.update(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/mapper/findAll/1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/mapper/findAll/1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/redirect/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">redirect</span><span class="params">(<span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@RequestBody是把请求里的json转换成java对象</p>
<p>@RequestBody是把java对象转成json</p>
<p>@PathVariable直接从对象中传数据的</p>
<p>@RequestParam也是从对象中取数据？</p>
</blockquote>
<h4 id="第七步：配置yml"><a href="#第七步：配置yml" class="headerlink" title="第七步：配置yml"></a>第七步：配置yml</h4><p>resource文件夹下application.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">prefix:</span> <span class="string">classpath:/templates/</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">.html</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">HTML5</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapping/*.xml</span>   <span class="string">//注入mapper</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.southwind.entity</span>    <span class="string">//自动将包名提出来，所以mapper里不用写包名了。</span></span><br></pre></td></tr></table></figure>

<h4 id="第八步：创建启动类"><a href="#第八步：创建启动类" class="headerlink" title="第八步：创建启动类"></a>第八步：创建启动类</h4><p>在controller、entity的外部文件夹下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.liuxuan.demo.springboot;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-03-12 11:17</span><br><span class="line"> **/</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@MapperScan(com.liuxuan.repository)  //因为mapper接口是mybatis的，所以加这个注解用来扫描，把它的实例化对象加到ioc容器中。</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 参数是启动类的运行时类，还有main方法里的args</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第九步：HTML"><a href="#第九步：HTML" class="headerlink" title="第九步：HTML"></a>第九步：HTML</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/mapper/save&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        用户姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        用户成绩：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;score&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/mapper/update&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        用户ID：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;user.id&#125;&quot;</span> <span class="attr">readonly</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        用户姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;user.name&#125;&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        用户成绩：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;score&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;user.score&#125;&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/jquery-3.3.1.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#first&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> page = $(<span class="string">&quot;#page&quot;</span>).<span class="title function_">text</span>();</span></span><br><span class="line"><span class="language-javascript">                page = <span class="built_in">parseInt</span>(page);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(page == <span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&quot;/mapper/findAll/1&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#previous&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> page = $(<span class="string">&quot;#page&quot;</span>).<span class="title function_">text</span>();</span></span><br><span class="line"><span class="language-javascript">                page = <span class="built_in">parseInt</span>(page);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(page == <span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                page = page-<span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&quot;/mapper/findAll/&quot;</span>+page;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#next&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> page = $(<span class="string">&quot;#page&quot;</span>).<span class="title function_">text</span>();</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> pages = $(<span class="string">&quot;#pages&quot;</span>).<span class="title function_">text</span>();</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(page == pages)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                page = <span class="built_in">parseInt</span>(page);</span></span><br><span class="line"><span class="language-javascript">                page = page+<span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&quot;/mapper/findAll/&quot;</span>+page;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#last&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> page = $(<span class="string">&quot;#page&quot;</span>).<span class="title function_">text</span>();</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> pages = $(<span class="string">&quot;#pages&quot;</span>).<span class="title function_">text</span>();</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(page == pages)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&quot;/mapper/findAll/&quot;</span>+pages;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>用户信息<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>用户ID<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>成绩<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;user:$&#123;list&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.score&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/mapper/deleteById/&#123;id&#125;(id=$&#123;user.id&#125;)&#125;&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/mapper/findById(id=$&#123;user.id&#125;)&#125;&quot;</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;first&quot;</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;previous&quot;</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span>&gt;</span>上一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;page&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;page&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>/<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;pages&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;pages&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;next&quot;</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span>&gt;</span>下一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;last&quot;</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span>&gt;</span>尾页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/mapper/redirect/save&quot;</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="spring-boot整合spring-data-jpa"><a href="#spring-boot整合spring-data-jpa" class="headerlink" title="spring boot整合spring data jpa"></a>spring boot整合spring data jpa</h3><p>JPA是一套持久层规范，定义了一系列orm接口，需要实现才能使用。</p>
<p>Hibernate框架就是一个jpa实现。</p>
<p>spring data jpa不是对jpa规范的具体实现，本身是一个抽象层，底层通过Hibernate实现。</p>
<h3 id="spring-boot整合spring-data-mongoDB"><a href="#spring-boot整合spring-data-mongoDB" class="headerlink" title="spring boot整合spring data mongoDB"></a>spring boot整合spring data mongoDB</h3><h3 id="spring-boot整合spring-data-redis"><a href="#spring-boot整合spring-data-redis" class="headerlink" title="spring boot整合spring data redis"></a>spring boot整合spring data redis</h3><h3 id="spring-boot整合spring-security"><a href="#spring-boot整合spring-security" class="headerlink" title="spring boot整合spring security"></a>spring boot整合spring security</h3><p>来源：<a href="https://www.bilibili.com/video/BV1v4411G72q?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1v4411G72q?spm_id_from=333.999.0.0</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>基于tensorflow的深度学习</title>
    <url>/2023/08/20/myblog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E4%BA%8Etensorflow%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="第一章-Numpy常用操作"><a href="#第一章-Numpy常用操作" class="headerlink" title="第一章 Numpy常用操作"></a>第一章 Numpy常用操作</h2><p>tensorflow：深度学习框架<br>python本身含有列表list和数组array。<br>list列表的元素可以是任何对象，因此列表中保存的是对象的指针，浪费内存和CPU计算时间。<br>array不支持多维，没有各种运算函数。</p>
<p>numpy提供ndarray（存储单一数据类型的多维数组）和ufunc（对数组进行处理的函数）</p>
<p>1.将列表转换为ndarray。<br>2.np函数，截取ndarray<br>3.numpy中的random函数<br>4.numpy中的矩阵操作<br>5.ndarray的合并和展平<br>6.使用numpy和math的比较，使用向量化矩阵运算可以避免循环语句<br>7.numpy的广播机制：方便不同shape的数组进行数学运算。原则是对齐维度，对数组进行扩充到可以进行运算，利用自动复制等方法把低维数据补齐。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">print(np.arange(10))</span><br><span class="line">print(np.arange(0, 10))</span><br><span class="line">print(np.arange(1, 4, 0.5))</span><br><span class="line">print(np.arange(9, -1, -1))</span><br><span class="line"></span><br><span class="line">nd1 = np.arange(10)</span><br><span class="line">print(nd1)</span><br><span class="line">print(nd1[3:6])</span><br><span class="line">print(nd1[1:6:2])</span><br><span class="line">print(nd1[::-2])</span><br><span class="line"></span><br><span class="line">np2 = np.arange(25).reshape([5,5])</span><br><span class="line">print(np2)</span><br><span class="line">print(np2[[1,2]]) #1、2行</span><br><span class="line">print(np2[1:3, :])</span><br><span class="line">print(np2[:, 1:3])</span><br><span class="line">import numpy as np</span><br><span class="line">from numpy import random</span><br><span class="line"></span><br><span class="line">a = np.arange(1, 25, dtype=float)</span><br><span class="line">print(a)</span><br><span class="line">c1 = random.choice(a, size=(3,4))</span><br><span class="line">print(c1)</span><br><span class="line">print(np.sum(a))</span><br><span class="line">print(a / np.sum(a))</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">nd3 = np.arange(9).reshape([3,3])</span><br><span class="line">print(np.transpose(nd3))</span><br><span class="line">print(nd3.trace)</span><br><span class="line">print(np.linalg.det(nd3))</span><br><span class="line">print(np.linalg.solve(nd3, np.eye(3)))</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">print(time.process_time())</span><br></pre></td></tr></table></figure>

<h2 id="第二章-Theano基础"><a href="#第二章-Theano基础" class="headerlink" title="第二章 Theano基础"></a>第二章 Theano基础</h2><p>Theano是python的一个库，对于解决大量数据的问题，使用Theano可以获取与手工用C实现差不多的性能。符号计算图。<br>conda install theano<br>符号变量&#x3D;张量Tensor。<br>张量是标量、向量、矩阵的统称。<br>Theano是一个通用的符号计算框架，将复杂的符号表达式编译成函数模型。<br>1.定义符号变量<br>import theano<br>from theano import tensor<br>2.符号计算图模型来描述变量间的运算关系，把符号表达式转换为一个计算图来处理。<br>3.函数：提供一个接口，把函数计算图编译为可调用的函数对象。Theano进行了编译优化，执行的是优化后保存在图结构中的模型，提升速度，不好调试。<br>自动求导：对于每个op都定义了根据输入计算出偏导数，使用链式法则，就可以计算出梯度了。<br>更新共享变量参数：深度学习中通常需要迭代多次，每次迭代都需要更新参数。theano.function中的updates参数就是包含两个元素的列表或tuple。<br>条件：ifelse、switch<br>循环：scan用来构建循环Graph的方法<br>4.共享变量：是实现机器学习算法参数更新的重要机制。shared函数会返回共享变量，这种变量的值可以在多个函数中直接使用。用function中的updates参数进行更新。</p>
<h2 id="第三章-线性代数"><a href="#第三章-线性代数" class="headerlink" title="第三章 线性代数"></a>第三章 线性代数</h2><p>1.标量、向量、矩阵、张量<br>2.可逆矩阵、对角矩阵、对称矩阵、单位向量、正交向量、正交矩阵<br>0范数(L0范数)-向量中非0元素的个数。<br>1范数(L1范数)-向量中各个元素绝对值之和。<br>2范数(L2范数)-向量的模长。<br>无穷范数(最大范数)-向量中各个元素绝对值的最大值。</p>
<p>3.向量组、线性组合、向量空间。向量组线性相关。最大线性无关组、向量组的秩。矩阵的行秩和列秩相等。<br>4.向量的大小用范数来表示。<br>5.特征值分解，特征值，特征向量。<br>6.奇异值分解：分解成三个矩阵的乘积。可以拓展矩阵求逆到非方矩阵上。SVD<br>7.迹运算：矩阵对角元素的和 Tr<br>8.主成分分析：PCA：通过正交变换将一组可能存在相关性的变量转换为一组线性不相关的变量，转换后的这组变量叫做主成分。属于特征降维。<br>在减少需要分析的指标或维度的同时，尽量减少原指标所含信息的损失，以达到对所收集数据进行全面分析的目的。<br>for i in range(10):<br>    print(i)</p>
<h2 id="第四章-概率与信息论"><a href="#第四章-概率与信息论" class="headerlink" title="第四章 概率与信息论"></a>第四章 概率与信息论</h2><p>机器学习、深度学习的三大基石：线性代数、概率与信息论、数值分析。<br>机器学习大部分时候处理的都是不确定量或随机量。</p>
<p>1.信息论主要研究对一个信号包含信息的多少进行量化。<br>样本空间：一个实验或随机试验所有可能结果的集合，每个可能结果为一个样本点。<br>随机变量：随机事件的结果：离散随机变量、连续随机变量。n维随机变量&#x2F;随机向量。</p>
<p>2.概率分布<br>通常关心随机变量落在某一区间的概率：分布函数F<br>离散型随机变量：两点分布、二项分布、poisson分布<br>连续型随机变量：用概率密度函数来描述变量的概率分布fx。正态分布&#x3D;高斯分布，钟形曲线，平均值和标准差，标准差大的更分散。正态分布是一种理想分布。<br>scipy库进行统计</p>
<p>3.边缘概率：定义在多维随机变量的子集上的概率分布称为边缘概率分布。对于连续型随机变量，可以通过联合密度函数来得到边缘密度函数。<br>4.条件概率，条件概率的链式法则<br>5.独立性与条件独立性<br>6.期望、方差、协方差。<br>期望描述数据的大小，但无法描述数据的离散程度。<br>方差可以用来衡量随机变量取值的离散程度。<br>协方差可以衡量随机变量间的相关性强度。如果X和Y独立，那么它们的协方差为0.反之不一定成立，独立性比协方差为0的条件更强。如果X和Y都是正态分布，此时独立和协方差为0是一个概念。<br>相关系数将每个变量的贡献进行归一化，在协方差的基础上进行正则化，把相关系数限制在-1到1之间。如果等于1，表示线性正相关。<br>协方差推广到n个随机或n维随机变量的情况，对于n维，就是n*n的协方差矩阵。协方差矩阵是对称矩阵，协方差矩阵的对角元素为方差。<br>用numpy的相关函数、数据分析库pandas、画图库matplotlib、sns。<br>7.贝叶斯定理<br>与条件概率和边缘概率有关，通过已知的三个概率函数推出第四个。<br>分类器：近邻分类器、线性分类器、支撑向量机分类器、神经网络分类器、随机森林分类器<br>损失函数：多类支撑向量机损失、交叉熵损失、L1损失、L2损失<br>线性分类器，层级结构形成神经网络，高纬映射形成支撑向量机 - 非线性模型<br>线性分类器的权值：可以看作是一种模版，分界面（决策边界）<br>分类器的损失函数：搭建了模型性能与模型参数之间的桥梁。<br>多类支撑向量机损失：正确类别的得分比不正确类别的得分高出1分，就无损失，否则产生损失。</p>
<h2 id="第五章-概率图模型"><a href="#第五章-概率图模型" class="headerlink" title="第五章 概率图模型"></a>第五章 概率图模型</h2><p>1.概率图模型是一种用图的形式表示随机变量之间条件依赖关系的概率模型，是概率论与图论的结合。<br>有向概率图模型：贝叶斯网络：表达随机变量间的依赖关系和相互关系<br>无向概率图模型：马尔可夫网络：表达随机变量间的相互关系</p>
<p>2.贝叶斯网络分为静态贝叶斯网络和动态贝叶斯网络<br>动态贝叶斯网络可用于处理随时间变化的动态系统中的推断和预测等问题。其中隐马尔可夫模型HMM，被广泛用于语音识别、自动分词与词性标注和统计机器翻译等领域。</p>
<p>3.隐马尔可夫模型<br>初始状态项链、状态转移概率矩阵、观测概率矩阵<br>状态序列（标记序列）和观测序列。<br>隐马尔可夫模型可解决三个基本问题：评估问题、解码问题、学习问题<br>实例：掷骰子，多种骰子<br>解码问题：知道骰子有几种（隐含状态数量），每种骰子是什么（转换概率），根据掷骰子的结果（可见状态链），想知道每次掷出来的都是哪种骰子（隐含状态链）。</p>
<p>4.马尔可夫网络<br>无向概率图模型，关于一组有马尔可夫性质随机变量X的全联合概率分布模型。<br>重点是其中的一种：马尔可夫随机场MRF。<br>马尔可夫随机场有一组势函数，也称因子，是定义在变量子集上的非负函数。<br>条件随机场。</p>
<h2 id="第六章-机器学习基础"><a href="#第六章-机器学习基础" class="headerlink" title="第六章 机器学习基础"></a>第六章 机器学习基础</h2><p>机器学习分为监督学习、无监督学习、半监督学习（强化学习）。</p>
<h3 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h3>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习与深度学习入门</title>
    <url>/2022/01/09/myblog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="机器学习与深度学习的区别"><a href="#机器学习与深度学习的区别" class="headerlink" title="机器学习与深度学习的区别"></a>机器学习与深度学习的区别</h2><p>机器学习—拥有找一个函数的能力，根据输出的不同，分为regression回归、分类classification，以及很少提及的结构化学习structured learning（输出图像，文本）。</p>
<p>1.找一个带有未知参数的函数：y&#x3D;b+wx，b偏置，w权重，机器学习中，未知的参数是通过数据来学习的。带有未知参数的函数称为model模型。</p>
<p>2.从训练数据中定义Loss（损失），Loss是关于参数b、w的函数，用来判断一组参数值好还是不好。<br>用训练集计算误差，可以是绝对值误差MAE，也可以是均方误差MSE。<br>如果y值是基于概率分布的，一般采取cross-entropy交叉熵，可以绘制误差等高线图error surface。</p>
<p>3.优化，找一组最好的参数w，b使得误差最小。<br>Gradient Descent 梯度下降。举例先只有一个参数w，绘制横坐标为w对应的损失函数曲线，初始时取一个点，随机取的，也可以用遗传算法给出一个较优的模型初始参数。选定一个随机初始值，求该点的偏导值，即该点曲线切线的斜率。然后进行移动点，跨度多少取决于斜率大小，斜率越大，跨度越大，此外，还有一个η，称为learning rate 学习率，自己设定，η越大跨度越大，训练越快。机器学习中需要自己设定的值称为超参数hyperparameters。以此类推，求下一个点下下个点。停止的时机：看预设的迭代次数，或者某一组参数计算出的微分值刚好是0，则停止训练，是个局部最优，不保证全部最优解。</p>
<p>对模型的修改需要对问题的具体理解，考虑前七天比只考虑前一天的误差要小。x是前一天的，y是预测的后一天的。考虑前七天的话，就有七个w。训练数据集是已知的，测试数据集是本来假装不知道的，也就是要预测的y。</p>
<p>输入x乘权重，再加上一个偏置的模型，称为线性模型。</p>
<p>线性模型具有局限性，模型偏差。</p>
<p>有时是分段线性折线函数&#x3D;常数+一些列的分段斜线。</p>
<p>有时是曲线：可以用分段线性折线逼近连续曲线，需要足够的切分。（也可以用max(0,斜线)叠加表示）</p>
<p>分段斜线可以用sigmoid函数来逼近。</p>
<p><img src="/images/sigmoid.png"></p>
<p>改变w，可以改变坡度。改变b可以左右移动。改变c可以改变高度。</p>
<p><img src="/images/sigmoid2.png"></p>
<p>来源：<a href="https://www.bilibili.com/video/BV1qP4y147PJ/?spm_id_from=333.788.recommend_more_video.-1">https://www.bilibili.com/video/BV1qP4y147PJ/?spm_id_from=333.788.recommend_more_video.-1</a></p>
<p>总结来讲：首先选择模型，线性模型或者复杂逼近曲线，最小化损失函数，用梯度下降法，选择初始值迭代计算进行逼近。</p>
<p>Sigmold函数和ReLU在机器学习中，称为激活函数。可以将激活函数过程重复几次，来优化模型。激活函数的部分叫做神经元，很多神经元组成神经网络。每一列神经元称为隐藏层，很多层影藏层形成深度学习。</p>
<p>AlexNet16层。VGG19层。GoogleNet22层。ResidualNet152层。并不是层数越多网络越深预测的效果就更好，会发生过拟合Overfitting。</p>
<h2 id="机器学习入门"><a href="#机器学习入门" class="headerlink" title="机器学习入门"></a>机器学习入门</h2><h3 id="1-机器学习概述"><a href="#1-机器学习概述" class="headerlink" title="1.机器学习概述"></a>1.机器学习概述</h3><h4 id="1-1-人工智能概述"><a href="#1-1-人工智能概述" class="headerlink" title="1.1.人工智能概述"></a>1.1.人工智能概述</h4><p>1956年达特茅斯会议，人工智能元年。最初是用来搞统计的。</p>
<p>人工智能包括机器学习，机器学习包括深度学习。<br>机器学习是人工智能的实现途径（1980s开始）<br>深度学习（人工神经网络）是机器学习的方法（2020开始）</p>
<h4 id="1-2-人工智能的几个方向："><a href="#1-2-人工智能的几个方向：" class="headerlink" title="1.2.人工智能的几个方向："></a>1.2.人工智能的几个方向：</h4><p>传统预测（量化投资、广告推荐等）<br>图像cv（人脸识别、图像检测）<br>自然语言处理nlp（翻译、智能客服）</p>
<h4 id="1-3-机器学习概述"><a href="#1-3-机器学习概述" class="headerlink" title="1.3.机器学习概述"></a>1.3.机器学习概述</h4><p>机器学习是从数据中自动分析获得模型，并利用模型对未知数据进行预测。</p>
<p>机器学习：数据 -（训练）- 模型 - 预测<br>人：经验 - （归纳）- 规律 - 预测</p>
<h4 id="1-4-数据集构成"><a href="#1-4-数据集构成" class="headerlink" title="1.4.数据集构成"></a>1.4.数据集构成</h4><p>特征值（房子面积、位置、楼层） + 目标值（房价）</p>
<p>每一行是一个样本。<br>数据集可以没有目标值。</p>
<h4 id="1-5-机器学习算法分类"><a href="#1-5-机器学习算法分类" class="headerlink" title="1.5.机器学习算法分类"></a>1.5.机器学习算法分类</h4><p>目标值：类别 - 分类问题（人脸识别）<br>目标值：连续型数据 - 回归问题<br>目标值：无 - 无监督学习</p>
<ul>
<li>监督学习(supervised learning)（预测）<br>定义：输入数据是由输入特征值和目标值所组成。函数的输出可以是一个连续的值(称为回归），或是输出是有限个离散值（称作分类）。<br>分类： k-近邻算法、贝叶斯分类、决策树与随机森林、逻辑回归、神经网络<br>回归： 线性回归、岭回归</li>
<li>无监督学习(unsupervised learning)<br>定义：输入数据是由输入特征值所组成。<br>聚类： k-means</li>
</ul>
<p>还有半监督学习，强化学习。</p>
<h4 id="1-6-机器学习开发流程"><a href="#1-6-机器学习开发流程" class="headerlink" title="1.6.机器学习开发流程"></a>1.6.机器学习开发流程</h4><p>获取数据 -&gt; 数据预处理 -&gt; 特征工程 -&gt; 机器学习算法与训练 -&gt; 模型评估 -&gt; 应用</p>
<p>算法是核心，数据、计算是基础。</p>
<p>从入门到实际，再到理论。</p>
<p>库和框架：Scikit-learn、Tensflow（深度学习框架）</p>
<h3 id="2-特征工程"><a href="#2-特征工程" class="headerlink" title="2.特征工程"></a>2.特征工程</h3><h4 id="2-1-数据集"><a href="#2-1-数据集" class="headerlink" title="2.1.数据集"></a>2.1.数据集</h4><p>✅可用数据集：<br>scikitlearn特点：1、数据量较小  2、方便学习<br>scikit-learn网址：<a href="http://scikit-learn.org/stable/datasets/index.html#datasets">http://scikit-learn.org/stable/datasets/index.html#datasets</a></p>
<p>Kaggle特点：1、大数据竞赛平合   2、80万科学家   3、真实数据     4、数据量巨大<br>Kaggle网址：<a href="https://www.kaggle.com/datasets">https://www.kaggle.com/datasets</a></p>
<p>Uc特点：1、收录了360个数据集    2、覆盖科学、生活、经济等领域   3、数据量几十万<br>UCI数据集网址： <a href="http://archive.ics.uci.edu/ml/">http://archive.ics.uci.edu/ml/</a></p>
<p>✅Scikit-learn：<br>Python语言的机器学习工具<br>Scikit-learn包括许多知名的机器学习算法的实现<br>Scikit-learn文档完善，容易上手，丰富的API</p>
<p>✅安装：<br><code>pip3 install sklearn</code>  安装<br><code>pip3 list</code>   查看一下<br><code>python3</code>  进入python<br><code>import sklearn</code>  验证一下</p>
<p>✅获取数据集api：<br>sklearn.datasets 加载获取流行数据集<br>1、datasets.load_*()<br>获取小规模数据集，数据包含在datasets里<br>2、datasets.fetch_*(data_home&#x3D;None)<br>获取大规模数据集，需要从网络上下载，函数的第一个参数是data_home，表示数据集下载的目录,默认是 ~&#x2F;scikit_learn_data&#x2F;<br>datasets.fetch_20newsgroups(data_home&#x3D;None,subset&#x3D;‘train’)<br>subset：’train’或者’test’，’all’，可选，选择要加载的数据集。<br>训练集的“训练”，测试集的“测试”，两者的“全部”</p>
<blockquote>
<p>load和fetch返回的数据类型datasets.base.Bunch(字典格式)<br>data：特征数据数组，是 [n_samples * n_features] 的二维 numpy.ndarray 数组<br>target：标签数组，是 n_samples 的一维 numpy.ndarray 数组<br>DESCR：数据描述<br>feature_names：特征名,新闻数据，手写数字、回归数据集没有<br>target_names：标签名</p>
</blockquote>
<p><strong>Bunch(字典格式)</strong>，继承自字典的数据结构，可以键值对，也可以点属性。</p>
<p>✅数据集的划分api：划分为训练数据和测试数据</p>
<p>训练数据：用于训练，构建模型    70% 80% 75%<br>测试数据：在模型检验时使用，用于评估模型是否有效    30% 20% 30%</p>
<p>sklearn.model_selection.train_test_split(arrays, *options)</p>
<blockquote>
<p>x 数据集的特征值<br>y 数据集的标签值<br>test_size 测试集的大小，一般为float<br>random_state 随机数种子,不同的种子会造成不同的随机采样结果。相同的种子采样结果相同。<br>return 测试集特征训练集特征值值，训练标签，测试标签(默认随机取)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn .datasets import load_iris</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line"></span><br><span class="line">def datasets_demo():</span><br><span class="line">    # 获取数据集</span><br><span class="line">    iris = load_iris()</span><br><span class="line">    print(&quot;鸢尾花数据集：\n&quot;, iris)</span><br><span class="line">    print(&quot;查看数据集描述：\n&quot;, iris[&quot;DESCR&quot;])</span><br><span class="line">    print(&quot;查看特征值名字：\n&quot;, iris.feature_names)</span><br><span class="line">    print(&quot;查看样本数：\n&quot;, iris.data.shape)</span><br><span class="line"></span><br><span class="line">    # 数据集划分</span><br><span class="line">    # 训练集的特征值x_train 测试集的特征值x_test 训练集的目标值y_train 测试集的目标值y_test</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=0.2, random_state=22)</span><br><span class="line">    print(&quot;x_train:\n&quot;, x_train.shape)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # sklearn数据集使用</span><br><span class="line">    datasets_demo()</span><br></pre></td></tr></table></figure>

<h4 id="2-2-特征工程"><a href="#2-2-特征工程" class="headerlink" title="2.2.特征工程"></a>2.2.特征工程</h4><p>什么是特征工程：<br>特征工程是使用专业背景知识和技巧处理数据，使得特征能在机器学习算法上发挥更好的作用的过程。<br>意义：会直接影响机器学习的效果</p>
<p>重要性：<br>数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。</p>
<p>pandas:一个数据读取非常方便以及基本的处理格式的工具（数据清洗、数据处理）<br>sklearn:对于特征的处理提供了强大的接口</p>
<p>特征工程包括：<br>特征抽取、特征预处理、特征降维</p>
<h5 id="✅特征抽取"><a href="#✅特征抽取" class="headerlink" title="✅特征抽取"></a>✅特征抽取</h5><p>将任意数据（如文本或图像）转换为可用于机器学习的数字特征<br>也叫特征值化，是为了计算机更好的去理解数据<br>分为：<br>1.字典特征提取(特征离散化)<br>2.文本特征提取<br>3.图像特征提取（深度学习将介绍）</p>
<p>特征提取的API：<br><code>sklearn.feature_extraction</code></p>
<p><strong>字典特征提取</strong>：对字典数据进行特征值化<br><code>sklearn.feature_extraction.DictVectorizer(sparse=True,…)</code><br><code>DictVectorizer.fit_transform(X)</code> X:字典或者包含字典的迭代器返回值：返回sparse矩阵<br><code>CountVectorizer.get_feature_names()</code> 返回值:单词列表<br>字典 -&gt; 矩阵（二维数组）（其中字典每一行是一个矢量，也就是一维数组）<br>其中属于类别的，会用onehot编码，比如有三类，会变成三列。<br>对于特征当中存在类别信息的我们都会做one-hot编码处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.feature_extraction import DictVectorizer</span><br><span class="line"></span><br><span class="line">def dict_demo():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    对字典类型的数据进行特征抽取</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data = [&#123;&#x27;city&#x27;: &#x27;北京&#x27;,&#x27;temperature&#x27;:100&#125;, &#123;&#x27;city&#x27;: &#x27;上海&#x27;,&#x27;temperature&#x27;:60&#125;, &#123;&#x27;city&#x27;: &#x27;深圳&#x27;,&#x27;temperature&#x27;:30&#125;]</span><br><span class="line">    # 1、实例化一个转换器类</span><br><span class="line">    transfer = DictVectorizer(sparse=False)</span><br><span class="line">    # 2、调用fit_transform</span><br><span class="line">    data = transfer.fit_transform(data)</span><br><span class="line">    print(&quot;返回的结果:\n&quot;, data)</span><br><span class="line">    # 打印特征名字</span><br><span class="line">    print(&quot;特征名字：\n&quot;, transfer.get_feature_names())</span><br><span class="line"></span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">返回的结果:</span><br><span class="line"> [[  0.   1.   0. 100.]</span><br><span class="line"> [  1.   0.   0.  60.]</span><br><span class="line"> [  0.   0.   1.  30.]]</span><br></pre></td></tr></table></figure>
<p>没有加上sparse&#x3D;False参数的结果是矩阵1的位置，<strong>稀疏矩阵</strong>，优点：节省内存，提高加载速度。</p>
<p>字典特征提取的使用场景：<br>1、数据集中类别特征比较多<br>2、本身拿到的就是字典类型</p>
<p><strong>文本特征提取</strong>：对文本数据进行特征值化<br>单词作为特征最合适。</p>
<p><strong>1.countVectorizer文本特征提取 - 出现个数</strong></p>
<p>api：<br><code>sklearn.feature_extraction.text.CountVectorizer(stop_words=[])</code>      返回词频矩阵（统计每个样本特征词出现的个数），stop_words是停用词，没有用的词，比如to，以列表形式传入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CountVectorizer.fit_transform(X)    X:文本或者包含文本字符串的可迭代对象 返回值：返回sparse矩阵</span><br><span class="line">CountVectorizer.inverse_transform(X)    X:array数组或者sparse矩阵 返回值:转换之前数据格</span><br><span class="line">CountVectorizer.get_feature_names()     返回值:单词列表</span><br></pre></td></tr></table></figure>
<p>标点和字母不作为特征词列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def text_count_demo():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    对文本进行特征抽取，countvetorizer</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data = [&quot;life is short,i like like python&quot;, &quot;life is too long,i dislike python&quot;]</span><br><span class="line">    # 1、实例化一个转换器类</span><br><span class="line">    # transfer = CountVectorizer(sparse=False)</span><br><span class="line">    transfer = CountVectorizer()</span><br><span class="line">    # 2、调用fit_transform （（注意返回格式，利用toarray()方法进行sparse矩阵转换array数组））</span><br><span class="line">    data = transfer.fit_transform(data)</span><br><span class="line">    print(&quot;文本特征抽取的结果：\n&quot;, data.toarray())</span><br><span class="line">    print(&quot;返回特征名字：\n&quot;, transfer.get_feature_names())</span><br><span class="line"></span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 3、文本特征提取</span><br><span class="line">    text_count_demo()</span><br></pre></td></tr></table></figure>

<p>[“life is short,i like like python”, “life is too long,i dislike python”]<br>结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回特征名字：</span><br><span class="line"> [&#x27;dislike&#x27;, &#x27;is&#x27;, &#x27;life&#x27;, &#x27;like&#x27;, &#x27;long&#x27;, &#x27;python&#x27;, &#x27;short&#x27;, &#x27;too&#x27;]</span><br><span class="line">文本特征抽取的结果：</span><br><span class="line"> [[0 1 1 2 0 1 1 0]</span><br><span class="line"> [1 1 1 0 1 1 0 1]]</span><br></pre></td></tr></table></figure>

<p><strong>jieba分词</strong><br>如果样本是中文，整个短语变成特征词了，得用空格隔开。用jieba分词可以分开。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.feature_extraction.text import CountVectorizer</span><br><span class="line">import jieba</span><br><span class="line"></span><br><span class="line">def cut_word(text):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    对中文进行分词</span><br><span class="line">    &quot;我爱北京天安门&quot;————&gt;&quot;我 爱 北京 天安门&quot;</span><br><span class="line">    :param text:</span><br><span class="line">    :return: text</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 用结巴对中文字符串进行分词，想要字符串</span><br><span class="line">    text = &quot; &quot;.join(list(jieba.cut(text)))</span><br><span class="line"></span><br><span class="line">    return text</span><br><span class="line"></span><br><span class="line">def text_chinese_count_demo2():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    对中文进行特征抽取</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data = [&quot;今天很残酷，明天更残酷，后天很美好，但绝对大部分是死在明天晚上，所以每个人不要放弃今天。&quot;,</span><br><span class="line">            &quot;我们看到的从很远星系来的光是在几百万年之前发出的，这样当我们看到宇宙时，我们是在看它的过去。&quot;,</span><br><span class="line">            &quot;如果只用一种方式了解某样事物，你就不会真正了解它。了解事物真正含义的秘密取决于如何将其与我们所了解的事物相联系。&quot;]</span><br><span class="line">    # 将原始数据转换成分好词的形式</span><br><span class="line">    text_list = []</span><br><span class="line">    for sent in data:</span><br><span class="line">        text_list.append(cut_word(sent))</span><br><span class="line">    print(text_list)</span><br><span class="line"></span><br><span class="line">    # 1、实例化一个转换器类</span><br><span class="line">    # transfer = CountVectorizer(sparse=False)</span><br><span class="line">    transfer = CountVectorizer(stop_words=[&quot;一种&quot;])</span><br><span class="line">    # 2、调用fit_transform</span><br><span class="line">    data = transfer.fit_transform(text_list)</span><br><span class="line">    print(&quot;文本特征抽取的结果：\n&quot;, data.toarray())</span><br><span class="line">    print(&quot;返回特征名字：\n&quot;, transfer.get_feature_names())</span><br><span class="line"></span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 4、中文文本特征提取</span><br><span class="line">    text_chinese_count_demo2()</span><br></pre></td></tr></table></figure>

<p>但是这样有个问题：想找的关键词其实是在某一个类别的文章中出现的次数很多，但是在其他类别的文章中出现次数很少，不要我们这些词。</p>
<p><strong>2.Tf-idf文本特征提取 - 重要程度</strong></p>
<p>TF-IDF的主要思想是：如果某个词或短语在一篇文章中出现的概率高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。<br>TF-IDF作用：用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。<br>分类机器学习算法进行文章分类中前期数据处理方式</p>
<p>公式：<br>词频（term frequency，tf）指的是某一个给定的词语在该文件中出现的频率<br>逆向文档频率（inverse document frequency，idf）是一个词语普遍重要性的度量。某一特定词语的idf，可以由总文件数目除以包含该词语之文件的数目，再将得到的商取以10为底的对数得到</p>
<p>例子：<br>注：假如一篇文件的总词语数是100个，而词语”非常”出现了5次，那么”非常”一词在该文件中的词频就是5&#x2F;100&#x3D;0.05。而计算文件频率（IDF）的方法是以文件集的文件总数，除以出现”非常”一词的文件数。所以，如果”非常”一词在1,000份文件出现过，而文件总数是10,000,000份的话，其逆向文件频率就是lg（10,000,000 &#x2F; 1,0000）&#x3D;3。最后”非常”对于这篇文档的tf-idf的分数为0.05 * 3&#x3D;0.15。</p>
<p>API：<br><code>transfer = TfidfVectorizer(stop_words=[&#39;一种&#39;, &#39;不会&#39;, &#39;不要&#39;])</code><br><code>data = transfer.fit_transform(text_list)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def text_chinese_tfidf_demo():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    对中文进行特征抽取</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data = [&quot;一种还是一种今天很残酷，明天更残酷，后天很美好，但绝对大部分是死在明天晚上，所以每个人不要放弃今天。&quot;,</span><br><span class="line">            &quot;我们看到的从很远星系来的光是在几百万年之前发出的，这样当我们看到宇宙时，我们是在看它的过去。&quot;,</span><br><span class="line">            &quot;如果只用一种方式了解某样事物，你就不会真正了解它。了解事物真正含义的秘密取决于如何将其与我们所了解的事物相联系。&quot;]</span><br><span class="line">    # 将原始数据转换成分好词的形式</span><br><span class="line">    text_list = []</span><br><span class="line">    for sent in data:</span><br><span class="line">        text_list.append(cut_word(sent))</span><br><span class="line">    print(text_list)</span><br><span class="line"></span><br><span class="line">    # 1、实例化一个转换器类</span><br><span class="line">    # transfer = CountVectorizer(sparse=False)</span><br><span class="line">    transfer = TfidfVectorizer(stop_words=[&#x27;一种&#x27;, &#x27;不会&#x27;, &#x27;不要&#x27;])</span><br><span class="line">    # 2、调用fit_transform</span><br><span class="line">    data = transfer.fit_transform(text_list)</span><br><span class="line">    print(&quot;文本特征抽取的结果：\n&quot;, data.toarray())</span><br><span class="line">    print(&quot;返回特征名字：\n&quot;, transfer.get_feature_names())</span><br><span class="line"></span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 5、tfidf文本提取</span><br><span class="line">    text_chinese_tfidf_demo()</span><br></pre></td></tr></table></figure>


<h5 id="✅特征预处理"><a href="#✅特征预处理" class="headerlink" title="✅特征预处理"></a>✅特征预处理</h5><p>scikit-learn的解释：<br><code>provides several common utility functions and transformer classes to change raw feature vectors into a representation that is more suitable for the downstream estimators.</code><br>翻译过来：通过一些转换函数将特征数据转换成更加适合算法模型的特征数据的过程</p>
<p>数值型数据的<strong>无量纲化</strong>：<br>归一化<br>标准化</p>
<p>api：<br><code>sklearn.preprocessing</code></p>
<p>为什么我们要进行归一化&#x2F;标准化(无量纲化)？<br>特征的单位或者大小相差较大，或者某特征的方差相比其他的特征要大出几个数量级，容易影响（支配）目标结果，使得一些算法无法学习到其它的特征。<br>量纲不统一<br>所以，需要用到一些方法进行无量纲化，使不同规格的数据转换到同一规格。</p>
<p><strong>归一化</strong><br>通过对原始数据进行变换把数据映射到(默认为[0,1])之间<br>api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.preprocessing.MinMaxScaler (feature_range=(0,1)… )</span><br><span class="line">MinMaxScalar.fit_transform(X)</span><br><span class="line">X:numpy array格式的数据[n_samples,n_features]</span><br><span class="line">返回值：转换后的形状相同的array</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">from sklearn.preprocessing import MinMaxScaler</span><br><span class="line"></span><br><span class="line">def minmax_demo():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    归一化演示</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 0、pandas读取文本</span><br><span class="line">    data = pd.read_csv(&quot;dating.txt&quot;)</span><br><span class="line">    # 不要目标值每一行都要，要前三列</span><br><span class="line">    data = data.iloc[:, :3]</span><br><span class="line">    print(data)</span><br><span class="line">    # 1、实例化一个转换器类</span><br><span class="line">    transfer = MinMaxScaler(feature_range=(2, 3))</span><br><span class="line">    # 2、调用fit_transform</span><br><span class="line">    data = transfer.fit_transform(data[[&#x27;milage&#x27;,&#x27;Liters&#x27;,&#x27;Consumtime&#x27;]])</span><br><span class="line">    print(&quot;最小值最大值归一化处理的结果：\n&quot;, data)</span><br><span class="line"></span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 6、特征预处理-归一化</span><br><span class="line">    minmax_demo()</span><br></pre></td></tr></table></figure>

<p>归一化缺点：最大值最小值是变化的，另外，最大值与最小值（可能是异常值）非常容易受异常点影响，所以这种方法鲁棒性较差，只适合传统精确小数据场景。</p>
<p><strong>标准化</strong><br>通过对原始数据进行变换把数据变换到均值为0,标准差为1范围内<br>公式：<br>(原值 - 平均值) &#x2F; 标准差<br>优点：<br>对于归一化来说：如果出现异常点，影响了最大值和最小值，那么结果显然会发生改变<br>对于标准化来说：如果出现异常点，由于具有一定数据量，少量的异常点对于平均值的影响并不大，从而方差改变较小。<br>api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.preprocessing.StandardScaler( )</span><br><span class="line">处理之后每列来说所有数据都聚集在均值0附近标准差差为1</span><br><span class="line">StandardScaler.fit_transform(X)</span><br><span class="line">X:numpy array格式的数据[n_samples,n_features]</span><br><span class="line">返回值：转换后的形状相同的array</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line"></span><br><span class="line">def stand_demo():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    标准化演示</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data = pd.read_csv(&quot;dating.txt&quot;)</span><br><span class="line">    print(data)</span><br><span class="line">    # 1、实例化一个转换器类</span><br><span class="line">    transfer = StandardScaler()</span><br><span class="line">    # 2、调用fit_transform</span><br><span class="line">    data = transfer.fit_transform(data[[&#x27;milage&#x27;,&#x27;Liters&#x27;,&#x27;Consumtime&#x27;]])</span><br><span class="line">    print(&quot;标准化的结果:\n&quot;, data)</span><br><span class="line">    print(&quot;每一列特征的平均值：\n&quot;, transfer.mean_)</span><br><span class="line">    print(&quot;每一列特征的方差：\n&quot;, transfer.var_)</span><br><span class="line"></span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>
<p>在已有样本足够多的情况下比较稳定，适合现代嘈杂大数据场景。</p>
<h5 id="✅特征降维"><a href="#✅特征降维" class="headerlink" title="✅特征降维"></a>✅特征降维</h5><p>ndarray<br>维数：嵌套的层数<br>0维：标量<br>1维：向量<br>2维：矩阵<br>3维：</p>
<p>此处的降维的对象是二维数组（几行表示几个样本，几列表示几个特征），目标是<strong>降低特征的个数</strong>。</p>
<p>降维是指在某些限定条件下，降低随机变量(特征)个数，得到一组“不相关”主变量的过程。</p>
<p>相关的特征：比如湿度与降雨量</p>
<p>为什么要特征降维？<br>正是因为在进行训练的时候，我们都是使用特征进行学习。如果特征本身存在问题或者特征之间相关性较强，对于算法学习预测会影响较大。</p>
<p><strong>第一部分：特征选择</strong><br>数据中包含冗余或无关变量（或称特征、属性、指标等），旨在从原有特征中找出主要特征。（例如鸟是否有爪子就是冗余特征）<br><strong>Filter(过滤式)</strong>：主要探究特征本身特点、特征与特征和目标值之间关联<br>方差选择法：低方差特征过滤<br>相关系数：衡量某两个特征之间的相关程度<br><strong>Embedded (嵌入式)</strong>：算法自动选择特征（特征与目标值之间的关联）<br>决策树:信息熵、信息增益<br>正则化：L1、L2<br>深度学习：卷积等</p>
<p>模块：<br><code>sklearn.feature_selection</code></p>
<p>过滤式：<br><strong>低方差特征过滤</strong>：删除低方差的一些特征<br>特征方差小：某个特征大多样本的值比较相近，比如都是有爪子，就是0<br>特征方差大：某个特征很多样本的值都有差别<br>api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.feature_selection.VarianceThreshold(threshold = 0.0)</span><br><span class="line">删除所有低方差特征</span><br><span class="line">Variance.fit_transform(X)</span><br><span class="line">X:numpy array格式的数据[n_samples,n_features]</span><br><span class="line">返回值：训练集差异低于threshold的特征将被删除。默认值是保留所有非零方差特征，即删除所有样本中具有相同值的特征。</span><br></pre></td></tr></table></figure>

<p>低方差特征过滤例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def variance_demo():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    删除低方差特征——特征选择</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data = pd.read_csv(&quot;factor_returns.csv&quot;)</span><br><span class="line">    print(data)</span><br><span class="line">    # 1、实例化一个转换器类</span><br><span class="line">    transfer = VarianceThreshold(threshold=1)</span><br><span class="line">    # 2、调用fit_transform，iloc去掉一些无用的列</span><br><span class="line">    data = transfer.fit_transform(data.iloc[:, 1:10])</span><br><span class="line">    print(&quot;删除低方差特征的结果：\n&quot;, data)</span><br><span class="line">    print(&quot;形状：\n&quot;, data.shape)</span><br><span class="line"></span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>
<p>效果：去掉了一些没用的冗余的特征</p>
<p><strong>相关系数</strong>：<br>皮尔逊相关系数(Pearson Correlation Coefficient)<br>反映变量之间相关关系密切程度的统计指标，公式略。<br>相关系数解读：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相关系数的值介于–1与+1之间，即–1≤ r ≤+1。其性质如下：</span><br><span class="line"></span><br><span class="line">当r&gt;0时，表示两变量正相关，r&lt;0时，两变量为负相关</span><br><span class="line">当|r|=1时，表示两变量为完全相关，当r=0时，表示两变量间无相关关系</span><br><span class="line">当0&lt;|r|&lt;1时，表示两变量存在一定程度的相关。且|r|越接近1，两变量间线性关系越密切；|r|越接近于0，表示两变量的线性相关越弱</span><br><span class="line">一般可按三级划分：|r|&lt;0.4为低度相关；0.4≤|r|&lt;0.7为显著性相关；0.7≤|r|&lt;1为高度线性相关</span><br></pre></td></tr></table></figure>
<p>api:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from scipy.stats import pearsonr</span><br><span class="line">x : (N,) array_like</span><br><span class="line">y : (N,) array_like Returns: (Pearson’s correlation coefficient, p-value)</span><br></pre></td></tr></table></figure>

<p>相关系数的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">from scipy.stats import pearsonr</span><br><span class="line"></span><br><span class="line">def pearsonr_demo():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    相关系数计算</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data = pd.read_csv(&quot;factor_returns.csv&quot;)</span><br><span class="line"></span><br><span class="line">    factor = [&#x27;pe_ratio&#x27;, &#x27;pb_ratio&#x27;, &#x27;market_cap&#x27;, &#x27;return_on_asset_net_profit&#x27;, &#x27;du_return_on_equity&#x27;, &#x27;ev&#x27;,</span><br><span class="line">              &#x27;earnings_per_share&#x27;, &#x27;revenue&#x27;, &#x27;total_expense&#x27;]</span><br><span class="line"></span><br><span class="line">    for i in range(len(factor)):</span><br><span class="line">        for j in range(i, len(factor) - 1):</span><br><span class="line">            print(</span><br><span class="line">                &quot;指标%s与指标%s之间的相关性大小为%f&quot; % (factor[i], factor[j + 1], pearsonr(data[factor[i]], data[factor[j + 1]])[0]))</span><br><span class="line"></span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>

<p>也可以通过画图来观察结果，散点图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">plt.figure(figsize=(20, 8), dpi=100)</span><br><span class="line">plt.scatter(data[&#x27;revenue&#x27;], data[&#x27;total_expense&#x27;])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>如果两个特征相关性很高：<br>1.可以选取其中一个<br>2.可以按一定权重加权两个特征<br>3.主成分分析，自动将相关性很强的特征合成</p>
<p><strong>第二部分：主成分分析</strong><br>定义：高维数据转化为低维数据的过程，在此过程中可能会舍弃原有数据、创造新的变量。PCA：主成分分析<br>作用：是数据维数压缩，尽可能降低原数据的维数（复杂度），损失少量信息。<br>应用：回归分析或者聚类分析当中<br>抽象理解：将一个三维的东西拍成一个二维的照片，尽可能保留更多的信息，保持原有的特征。<br>再比如：二维的几个点降到一维（一条线），想投影到一条线之后，五个点也还在，且距离直接之和更少。找到一个合适的直线，通过一个矩阵运算得出主成分分析的结果。</p>
<p>api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.decomposition.PCA(n_components=None)</span><br><span class="line">将数据分解为较低维数空间</span><br><span class="line">n_components:</span><br><span class="line">小数：表示保留百分之多少的信息</span><br><span class="line">整数：减少到多少特征</span><br><span class="line">PCA.fit_transform(X) X:numpy array格式的数据[n_samples,n_features]</span><br><span class="line">返回值：转换后指定维度的array</span><br></pre></td></tr></table></figure>

<p>三个特征降维的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.decomposition import PCA</span><br><span class="line"></span><br><span class="line">def pca_demo():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    对数据进行PCA降维</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data = [[2,8,4,5], [6,3,0,8], [5,4,9,1]]</span><br><span class="line"></span><br><span class="line">    # 1、实例化PCA, 小数——保留多少信息</span><br><span class="line">    transfer = PCA(n_components=0.9)</span><br><span class="line">    # 2、调用fit_transform</span><br><span class="line">    data1 = transfer.fit_transform(data)</span><br><span class="line"></span><br><span class="line">    print(&quot;保留90%的信息，降维结果为：\n&quot;, data1)</span><br><span class="line"></span><br><span class="line">    # 1、实例化PCA, 整数——指定降维到的维数</span><br><span class="line">    transfer2 = PCA(n_components=3)</span><br><span class="line">    # 2、调用fit_transform</span><br><span class="line">    data2 = transfer2.fit_transform(data)</span><br><span class="line">    print(&quot;降维到3维的结果：\n&quot;, data2)</span><br><span class="line"></span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">保留90%的信息，降维结果为：</span><br><span class="line"> [[ -3.13587302e-16   3.82970843e+00]</span><br><span class="line"> [ -5.74456265e+00  -1.91485422e+00]</span><br><span class="line"> [  5.74456265e+00  -1.91485422e+00]]</span><br><span class="line">降维到3维的结果：</span><br><span class="line"> [[ -3.13587302e-16   3.82970843e+00   4.59544715e-16]</span><br><span class="line"> [ -5.74456265e+00  -1.91485422e+00   4.59544715e-16]</span><br><span class="line"> [  5.74456265e+00  -1.91485422e+00   4.59544715e-16]]</span><br></pre></td></tr></table></figure>

<p><strong>第三部分：案例：探究用户对物品类别的喜好细分降维</strong></p>
<p>1）合并表，使得user_id与aisle在一张表当中<br>2）进行交叉表变换-交叉表透视表<br>3）特征冗余过多-PCA降维</p>
<p>pandas可以读取csv文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">data = pd.read_csv(“./route”)</span><br><span class="line">table3 = pd.merge(table1, table2, on=[“uid”, “uid”]) //用来合并表，默认内连接</span><br><span class="line"></span><br><span class="line">3、交叉表处理，把user_id和aisle进行分组</span><br><span class="line">table = pd.crosstab(tab3[&quot;user_id&quot;], tab3[&quot;aisle&quot;])</span><br><span class="line"></span><br><span class="line">4、主成分分析的方法进行降维</span><br><span class="line"> 1）实例化一个转换器类PCA</span><br><span class="line">transfer = PCA(n_components=0.95)</span><br><span class="line"> 2）fit_transform</span><br><span class="line">data = transfer.fit_transform(table)</span><br><span class="line"></span><br><span class="line">data.shape</span><br></pre></td></tr></table></figure>
<p>Jupiter 处理数据的工具，可视化数据。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0.png"></p>
<h3 id="3-分类算法"><a href="#3-分类算法" class="headerlink" title="3.分类算法"></a>3.分类算法</h3><p>目标值：类别</p>
<h4 id="3-1-sklearn转换器和预估器-estimator"><a href="#3-1-sklearn转换器和预估器-estimator" class="headerlink" title="3.1 sklearn转换器和预估器(estimator)"></a>3.1 sklearn转换器和预估器(estimator)</h4><p>  3.1.1 转换器-特征工程的父类<br>    1 实例化（实例化的是一个转换器类（Transformer））<br>    2 调用fit_transform 标准化，是fit计算每一列平均值和标准差 transform进行计算转换</p>
<p>  3.1.2 估计器-sklearn机器学习算法的实现<br>    1 实例化一个eatimator<br>    2 estimator.fit(x_train, y_train) 计算 — 调用完毕，模型生成<br>    3 模型评估<br>      1）直接对比真实值和预测值<br>        y_predict &#x3D; estimator.predictor(x_test)<br>        y_test &#x3D; y_predict<br>      2）计算准确率<br>	  accuracy &#x3D; estimator.score(x_test, y_test)</p>
<h4 id="3-2-K-近邻算法-KNN算法"><a href="#3-2-K-近邻算法-KNN算法" class="headerlink" title="3.2 K-近邻算法(KNN算法)"></a>3.2 K-近邻算法(KNN算法)</h4><p>  核心思想：根据邻居来推断出类别<br>  3.2.1 KNN算法原理<br>     如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。<br>    k&#x3D;1 容易收到异常点的影响<br>    如何确定谁是邻居，计算距离 eg：欧氏距离（默认），曼哈顿距离（绝对值距离），明可夫斯基距离<br>    例子：电影分类：先求距离，再取k。<br>    K值取得过大：容易收到样本不均衡的影响。</p>
<p>  3.2.2 k-近邻算法api</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.neighbors.KNeighborsClassifier(n_neighbors=5,algorithm=&#x27;auto&#x27;)</span><br><span class="line">	◦	n_neighbors：k值，int,可选（默认= 5），k_neighbors查询默认使用的邻居数</span><br><span class="line">	◦	algorithm：&#123;‘auto’，‘ball_tree’，‘kd_tree’，‘brute’&#125;，可选用于计算最近邻居的算法：‘ball_tree’将会使用 BallTree，‘kd_tree’将使用 KDTree。‘auto’将尝试根据传递给fit方法的值来决定最合适的算法。 (不同实现方式影响效率)</span><br></pre></td></tr></table></figure>

<p>  3.2.3 案例：鸢尾花种类预测<br>    1）获取数据，四个特征<br>    2）数据集划分<br>    3）特征工程：标准化<br>    4）KNN预估器流程<br>    5）模型评估</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.datasets import load_iris</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.neighbors import KNeighborsClassifier</span><br><span class="line"></span><br><span class="line">def knn_iris():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    案例：鸢尾花种类预测</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 1）获取数据，四个特征</span><br><span class="line">    iris = load_iris()</span><br><span class="line">    # 2）数据集划分</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=6)</span><br><span class="line">    # 3）特征工程：标准化 1.实例化一个转换器类 2.对训练集和测试集标准化（测试集用训练集fit的结果）</span><br><span class="line">    transform = StandardScaler()</span><br><span class="line">    x_train = transform.fit_transform(x_train)</span><br><span class="line">    x_test = transform.transform(x_test)</span><br><span class="line">    # 4）KNN预估器流程：1.实例化一个预估器对象 2.将训练集的特征值和目标值传入进行训练</span><br><span class="line">    estimator = KNeighborsClassifier(n_neighbors=3)</span><br><span class="line">    estimator.fit(x_train, y_train)</span><br><span class="line">    # 5）模型评估  1.直接比对真实值和预估值 2.计算准确率</span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    print(&quot;y_predict:\n&quot;, y_predict)</span><br><span class="line">    print(&quot;预测值和真实值:\n&quot;, y_predict == y_test)</span><br><span class="line">    score = estimator.score(x_test, y_test)</span><br><span class="line">    print(&quot;score:\n&quot;, score)</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 代码1.knn算法对iris进行分类</span><br><span class="line">    knn_iris()</span><br></pre></td></tr></table></figure>

<p>  3.2.4 knn优缺点<br>	•	优点：<br>	◦	简单，易于理解，易于实现，无需训练<br>	•	缺点：<br>	◦	懒惰算法，对测试样本分类时的计算量大，内存开销大<br>	◦	必须指定K值，K值选择不当则分类精度不能保证<br>	•	使用场景：小数据场景，几千～几万样本，具体场景具体业务去测试</p>
<h4 id="3-3-模型选择与调优"><a href="#3-3-模型选择与调优" class="headerlink" title="3.3 模型选择与调优"></a>3.3 模型选择与调优</h4><p>  3.3.1 什么是交叉验证<br>交叉验证：将拿到的训练数据，分为训练和验证集。例如：将数据分成5份，其中一份作为验证集。然后经过5次(组)的测试，每次都更换不同的验证集。即得到5组模型的结果，取平均值作为最终结果。又称5折交叉验证。目的：让被评估的模型更加准确可信<br>  •	训练集：训练集+验证集<br>	•	测试集：测试集</p>
<p>  3.3.2 超参数搜索-网格搜索<br>  通常情况下，有很多参数是需要手动指定的（如k-近邻算法中的K值），这种叫超参数。但是手动过程繁杂，所以需要对模型预设几种超参数组合。每组超参数都采用交叉验证来进行评估。最后选出最优参数组合建立模型</p>
<p>  3.3.3 模型选择与调优api</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.model_selection.GridSearchCV(estimator, param_grid=None,cv=None)</span><br><span class="line">◦	对估计器的指定参数值进行详尽搜索</span><br><span class="line">◦	estimator：估计器对象</span><br><span class="line">◦	param_grid：估计器参数(dict)&#123;“n_neighbors”:[1,3,5]&#125;，将想要用的参数值以字典格式传入</span><br><span class="line">◦	cv：指定几折交叉验证，常用10折</span><br><span class="line">◦	fit：输入训练数据</span><br><span class="line">◦	score：准确率</span><br><span class="line">◦	结果分析：</span><br><span class="line">▪	best_param：最佳参数</span><br><span class="line">▪	bestscore：最佳结果</span><br><span class="line">▪	best_estimator：最佳估计器</span><br><span class="line">▪	cv_results：交叉验证结果-每次交叉验证后的验证集准确率结果和训练集准确率结果</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def knn_iris_gscv():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    案例：鸢尾花种类预测knn,添加网格搜索和交叉验证</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 1）获取数据，四个特征</span><br><span class="line">    iris = load_iris()</span><br><span class="line">    # 2）数据集划分</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=6)</span><br><span class="line">    # 3）特征工程：标准化 1.实例化一个转换器类 2.对训练集和测试集标准化（测试集用训练集fit的结果）</span><br><span class="line">    transform = StandardScaler()</span><br><span class="line">    x_train = transform.fit_transform(x_train)</span><br><span class="line">    x_test = transform.transform(x_test)</span><br><span class="line">    # 4）KNN预估器流程：1.实例化一个预估器对象 2.将训练集的特征值和目标值传入进行训练</span><br><span class="line">    estimator = KNeighborsClassifier()</span><br><span class="line">    # 加入网格搜索和交叉验证</span><br><span class="line">    # 参数准备</span><br><span class="line">    param_dict = &#123;&quot;n_neighbors&quot;: [3, 5, 10]&#125;</span><br><span class="line">    estimator = GridSearchCV(estimator, param_grid=param_dict, cv=10)</span><br><span class="line">    estimator.fit(x_train, y_train)</span><br><span class="line">    # 5）模型评估  1.直接比对真实值和预估值 2.计算准确率</span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    print(&quot;y_predict:\n&quot;, y_predict)</span><br><span class="line">    print(&quot;预测值和真实值:\n&quot;, y_predict == y_test)</span><br><span class="line">    score = estimator.score(x_test, y_test)</span><br><span class="line">    print(&quot;score:\n&quot;, score)  # 测试集的结果</span><br><span class="line">    print(&quot;最佳参数:\n&quot;, estimator.best_params_)</span><br><span class="line">    print(&quot;最佳结果:\n&quot;, estimator.best_score_)  # 验证集的结果</span><br><span class="line">    print(&quot;最佳估计器:\n&quot;, estimator.best_estimator_)</span><br><span class="line">    print(&quot;交叉验证结果:\n&quot;, estimator.cv_results_)</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>


<p>  3.3.4 案例-Facebook签到位置预测K值调优</p>
<pre><code>处理数据，反复调试，如果用pycharm，每次调试都要加载一次。所以用jupyter。

流程：
  1）获取数据
  2）数据处理：过滤无用数据，筛选特征值x和目标值y，数据集划分
</code></pre>
<p><code>data.head() data=data.query(“x&lt;2 &amp; x&gt;1”)</code><br><code>处理时间数据：time_value = pd.to_data_time(data[“time”], unit=“s”)  date = pd.DateTimeIndex(time_value)</code><br><code>对数据进行分组： data.groupby(“place”).count()</code><br>      3）特征工程：标准化<br>      4）KNN算法预估流程<br>      5）模型选择与调优<br>      6）模型评估</p>
<h4 id="3-4-朴素贝叶斯算法"><a href="#3-4-朴素贝叶斯算法" class="headerlink" title="3.4 朴素贝叶斯算法"></a>3.4 朴素贝叶斯算法</h4><p>3.4.1 什么是朴素贝叶斯算法：<br>给出分类事件每个类别的概率。</p>
<p>•	联合概率：包含多个条件，且所有条件同时成立的概率<br>◦	记作：P(A,B)<br>◦	特性：P(A, B) &#x3D; P(A)P(B) &lt;&#x3D;&gt; 事件AB相互独立<br>•	条件概率：就是事件A在另外一个事件B已经发生条件下的发生概率<br>◦	记作：P(A|B)</p>
<p>贝叶斯公式：<code>p(c|w) = [p(w|c)p(c)]/p(w)</code>。w为特征值，c为目标值。</p>
<p>朴素是什么：假定特征与特征之间相互独立。</p>
<p>应用场景：文本分类(单词作为特征，假设相互独立) </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P(C)：每个文档类别的概率(某文档类别数／总文档数量)</span><br><span class="line">P(W│C)：给定类别下特征（被预测文档中出现的词）的概率（某类别词1数量/某类别所有次数量）</span><br><span class="line">计算方法：P(F1│C)=Ni/N （训练文档中去计算）</span><br><span class="line">Ni为该F1词在C类别所有文档中出现的次数</span><br><span class="line">N为所属类别C下的文档所有词出现的次数和</span><br><span class="line">P(F1,F2,…) 预测文档中每个词的概率</span><br></pre></td></tr></table></figure>

<p>计算出来某个概率为0，怎么办？<br>拉普拉斯平滑系:  <code>p(w|c) = (ni+a)/(n+am)</code><br>目的：防止计算出的分类概率为0<br>a为指定的系数一般为1，m为训练文档中统计出的特征词有多少种</p>
<p>3.4.2 朴素贝叶斯api</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.naive_bayes.MultinomialNB(alpha = 1.0)</span><br><span class="line">朴素贝叶斯分类</span><br><span class="line">alpha：拉普拉斯平滑系数</span><br></pre></td></tr></table></figure>

<p>3.4.3 案例：20类新闻分类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def nbcls():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    朴素贝叶斯对新闻数据集进行预测</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 获取新闻的数据，20个类别</span><br><span class="line">    news = fetch_20newsgroups(data_home=&#x27;/Users/liuxuan/MyProject/pypro/python-learn&#x27;, subset=&#x27;all&#x27;)</span><br><span class="line">    # 划分数据集</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(news.data, news.target, test_size=0.3)</span><br><span class="line">    # 对于文本数据，进行特征抽取 1.获取实例化对象 2.转换</span><br><span class="line">    tf = TfidfVectorizer()</span><br><span class="line">    x_train = tf.fit_transform(x_train)</span><br><span class="line">    # 这里打印出来的列表是：训练集当中的所有不同词的组成的一个列表</span><br><span class="line">    print(tf.get_feature_names())</span><br><span class="line">    # print(x_train.toarray())</span><br><span class="line">    # 不能调用fit_transform</span><br><span class="line">    x_test = tf.transform(x_test)</span><br><span class="line">    # estimator估计器流程,并训练</span><br><span class="line">    mlb = MultinomialNB(alpha=1.0)</span><br><span class="line">    mlb.fit(x_train, y_train)</span><br><span class="line">    # 进行预测，验证</span><br><span class="line">    y_predict = mlb.predict(x_test)</span><br><span class="line">    print(&quot;预测每篇文章的类别：&quot;, y_predict[:100])</span><br><span class="line">    print(&quot;真实类别为：&quot;, y_test[:100])</span><br><span class="line">    print(&quot;预测准确率为：&quot;, mlb.score(x_test, y_test))</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>

<p>3.4.4 优缺点<br>优点：<br>朴素贝叶斯模型发源于古典数学理论，有稳定的分类效率。<br>对缺失数据不太敏感，算法也比较简单，常用于文本分类。<br>分类准确度高，速度快<br>缺点：<br>由于使用了样本属性独立性的假设，所以如果特征属性有关联时其效果不好</p>
<h4 id="3-5-决策树"><a href="#3-5-决策树" class="headerlink" title="3.5 决策树"></a>3.5 决策树</h4><p>决策树思想的来源非常朴素，程序设计中的条件分支结构就是if-then结构，最早的决策树就是利用这类结构分割数据的一种分类学习方法<br>思想：如何高效地进行决策，先看哪个再看哪个，决定特征的先后顺序。</p>
<p>3.5.1 决策树分类原理<br>用数学的方法来得到，应该先看哪个特征再看哪个特征。<br>信息论基础<br>信息：消除随机不定性的东西<br>信息的衡量 - 信息量 - 信息墒<br>p为每个球队获胜的概率（假设概率相等，都为1&#x2F;32）<br>信息墒 H &#x3D; -(p1logp1 + p2logp2 + … + p32logp32)&#x3D;5bit<br>决策树的划分依据之一——信息增益<br>信息增益：特征A对训练数据集D的信息增益g(D,A),定义为集合D的信息熵H(D)与特征A给定条件下D的信息条件熵H(D|A)之差<br>（知道哪个特征之后，不确定性减少的量）<br><code>g(D,A)= H(D) - 条件墒H(D|A)</code><br>条件墒怎么算：特征A有多少种，每种分别计算信息墒，然后根据样本特征类种类比例累加。</p>
<p>3.5.2 决策树api</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">•	class sklearn.tree.DecisionTreeClassifier(criterion=’gini’, max_depth=None,random_state=None)</span><br><span class="line">◦	决策树分类器</span><br><span class="line">◦	criterion:默认是’gini’系数，也可以选择信息增益的熵’entropy’</span><br><span class="line">◦	max_depth:树的深度大小，太深容易过拟合</span><br><span class="line">◦	random_state:随机数种子</span><br><span class="line">•	其中会有些超参数：max_depth:树的深度大小</span><br><span class="line">◦	其它超参数我们会结合随机森林讲解</span><br></pre></td></tr></table></figure>
<p>步骤：<br>1）获取数据集<br>2）划分数据集，决策树不用做标准化<br>3）决策树预估器进行分类<br>4）模型评估</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def decision_iris():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用决策树对鸢尾花进行分类</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 1）获取数据集</span><br><span class="line">    iris = load_iris()</span><br><span class="line">    # 2）划分数据集，决策树不用做标准化</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=6)</span><br><span class="line">    # 3）决策树预估器进行分类</span><br><span class="line">    estimator = DecisionTreeClassifier(criterion=&#x27;entropy&#x27;)</span><br><span class="line">    estimator.fit(x_train,y_train)</span><br><span class="line">    # 4）模型评估</span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    print(&quot;y_predict:\n&quot;, y_predict)</span><br><span class="line">    print(&quot;预测值和真实值:\n&quot;, y_predict == y_test)</span><br><span class="line">    score = estimator.score(x_test, y_test)</span><br><span class="line">    print(&quot;score:\n&quot;, score)</span><br></pre></td></tr></table></figure>

<p>3.5.3 决策树可视化</p>
<p>1.保存树的结构到dot文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、sklearn.tree.export_graphviz() 该函数能够导出DOT格式</span><br><span class="line">	◦tree.export_graphviz(estimator,out_file=&#x27;tree.dot’,feature_names=[‘’,’’])</span><br><span class="line">2、复制文件内容到网站：http://www.webgraphviz.com</span><br><span class="line"></span><br><span class="line"> 可视化决策树</span><br><span class="line">export_graphviz(estimator, out_file=&#x27;iris_tree.dot&#x27;)</span><br></pre></td></tr></table></figure>

<p>3.5.4 决策树优缺点<br>	•	优点：<br>	◦	简单的理解和解释，树木可视化。可理解性强，反观神经网络是个黑盒。<br>	•	缺点：<br>	◦	容易产生过拟合。<br>	•	改进：<br>	◦	减枝cart算法(决策树API当中已经实现，随机森林参数调优有相关介绍)<br>	◦	随机森林<br>注：企业重要决策，由于决策树很好的分析能力，在决策过程应用较多， 可以选择特征</p>
<p>⚠️：特征转换为字典，进行字典特征抽取，因为one-hot编码特征变多，用get_feature_names，获取特征。</p>
<h4 id="3-6-随机森林"><a href="#3-6-随机森林" class="headerlink" title="3.6 随机森林"></a>3.6 随机森林</h4><p>什么是集成学习方法：<br>集成学习通过建立几个模型组合的来解决单一预测问题。它的工作原理是生成多个分类器&#x2F;模型，各自独立地学习和作出预测。这些预测最后结合成组合预测，因此优于任何一个单分类的做出预测。三个臭皮匠，顶一个诸葛亮。由分类结果的众数来决定目标值。</p>
<p>什么是随机森林：<br>在机器学习中，随机森林是一个包含多个决策树的分类器，并且其输出的类别是由个别树输出的类别的众数而定。<br>3.6.1 随机森林原理过程<br>如何建造每棵树：两个随机：<br>N个样本，M个特征<br>1）训练集随机<br>采取bootstrap抽样（随机有放回抽样）<br>用N来表示训练用例（样本）的个数，M表示特征数目。<br>	◦	1、一次随机选出一个样本，重复N次， （有可能出现重复的样本）<br>	◦	2、随机去选出m个特征, m &lt;&lt;M，建立决策树，起到降维的效果，运算快。可以让正确的结果脱颖而出（真理掌握在少数人手里）</p>
<p>2）特征随机。</p>
<p>为什么采用BootStrap抽样<br>	•	为什么要随机抽样训练集？　　<br>	◦	如果不进行随机抽样，每棵树的训练集都一样，那么最终训练出的树分类结果也是完全一样的<br>	•	为什么要有放回地抽样？<br>	◦	如果不是有放回的抽样，那么每棵树的训练样本都是不同的，都是没有交集的，这样每棵树都是“有偏的”，都是绝对“片面的”（当然这样说可能不对），也就是说每棵树训练出来都是有很大的差异的；而随机森林最后分类取决于多棵树（弱分类器）的投票表决。</p>
<p>3.6.2 随机森林api</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">•	class sklearn.ensemble.RandomForestClassifier(n_estimators=10, criterion=’gini’, max_depth=None, bootstrap=True, random_state=None, min_samples_split=2)</span><br><span class="line">◦	随机森林分类器</span><br><span class="line">◦	n_estimators：integer，optional（default = 10）森林里的树木数量</span><br><span class="line">◦	criterion：string，可选（default =“gini”）分割特征的测量方法</span><br><span class="line">◦	max_depth：integer或None，可选（默认=无）树的最大深度 5,8,15,25,30</span><br><span class="line">◦	max_features=&quot;auto”,每个决策树的最大特征数量(m怎么选)</span><br><span class="line">▪	If &quot;auto&quot;, then max_features=sqrt(n_features).</span><br><span class="line">▪	If &quot;sqrt&quot;, then max_features=sqrt(n_features) (same as &quot;auto&quot;).</span><br><span class="line">▪	If &quot;log2&quot;, then max_features=log2(n_features).</span><br><span class="line">▪	If None, then max_features=n_features.</span><br><span class="line">◦	bootstrap：boolean，optional（default = True）是否在构建树时使用放回抽样</span><br><span class="line">◦	min_samples_split:节点划分最少样本数</span><br><span class="line">◦	min_samples_leaf:叶子节点的最小样本数</span><br><span class="line">•	超参数：n_estimator, max_depth, min_samples_split,min_samples_leaf</span><br></pre></td></tr></table></figure>

<p>3.6.3 鸢尾花实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def random_decision_iris():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用决策树对鸢尾花进行分类</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 1）获取数据集</span><br><span class="line">    iris = load_iris()</span><br><span class="line">    # 2）划分数据集，决策树不用做标准化</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=6)</span><br><span class="line">    # 3）随机森林预估器进行分类</span><br><span class="line">    estimator = RandomForestClassifier(criterion=&#x27;entropy&#x27;)</span><br><span class="line">    # 加入网格搜索和交叉验证</span><br><span class="line">    # 参数准备</span><br><span class="line">    param_dict = &#123;&quot;n_estimators&quot;: [120, 200, 300, 500, 800, 1200], &quot;max_depth&quot;: [5, 8, 15, 25, 30]&#125;</span><br><span class="line">    # 超参数调优</span><br><span class="line">    estimator = GridSearchCV(estimator, param_grid=param_dict, cv=2)</span><br><span class="line">    estimator.fit(x_train,y_train)</span><br><span class="line">    # 4）模型评估</span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    print(&quot;y_predict:\n&quot;, y_predict)</span><br><span class="line">    print(&quot;预测值和真实值:\n&quot;, y_predict == y_test)</span><br><span class="line">    score = estimator.score(x_test, y_test)</span><br><span class="line">    print(&quot;score:\n&quot;, score)</span><br><span class="line">    # 可视化决策树</span><br><span class="line">    # export_graphviz(estimator, out_file=&#x27;iris_tree.dot&#x27;)</span><br><span class="line">    print(&quot;score:\n&quot;, score)  # 测试集的结果</span><br><span class="line">    print(&quot;最佳参数:\n&quot;, estimator.best_params_)</span><br><span class="line">    print(&quot;最佳结果:\n&quot;, estimator.best_score_)  # 验证集的结果</span><br><span class="line">    print(&quot;最佳估计器:\n&quot;, estimator.best_estimator_)</span><br><span class="line">    print(&quot;交叉验证结果:\n&quot;, estimator.cv_results_)</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>

<p>3.6.4 优缺点<br>	•	在当前所有算法中，具有极好的准确率（没有免费的午餐）<br>	•	能够有效地运行在大数据集上，处理具有高维特征的输入样本，而且不需要降维（M&gt;&gt;m相当于是降维了）<br>	•	能够评估各个特征在分类问题上的重要性</p>
<h4 id="3-7-总结"><a href="#3-7-总结" class="headerlink" title="3.7 总结"></a>3.7 总结</h4><p>1.转换器和预估器：转换器在特征工程里用，预估器在机器学习算法训练模型里用。封装在同一父类里面，调同一个方法（fit_transform、fit）</p>
<p>2.KNN算法：核心思想是根据邻居确定类别，谁是邻居：距离公式，k的取值：找几个邻居，太小容易受异常值影响，过大容易受样本不均衡影响。缺陷是时间复杂度高，应用场景是少量数据。</p>
<p>3.朴素贝叶斯算法：朴素：假定特征与特征之间独立。样本量不够导致出现0的情况：引入拉普拉斯平滑系数。优点：对缺失数据不敏感，计算快。缺点：特征之间关联影响效果。应用场景：文本分类。</p>
<p>4.决策树：以何种顺序决策是最高效的，用信息增益来决定决策顺序。信息增益&#x3D;信息墒-条件墒。优点是可以可视化，可解释能力强。缺点容易过拟合。</p>
<p>5.随机森林：随机：训练集随机和特征随机，森林：多个决策树。优点容易取得比较好的效果，有降维的效果，降低模型复杂度。应用场景：高维度特征大数据场景。</p>
<h3 id="4-回归与聚类算法"><a href="#4-回归与聚类算法" class="headerlink" title="4.回归与聚类算法"></a>4.回归与聚类算法</h3><h4 id="4-1-线性回归"><a href="#4-1-线性回归" class="headerlink" title="4.1 线性回归"></a>4.1 线性回归</h4><p>4.1.1 线性回归原理<br>回归问题 - 目标值是连续性的。<br>线性回归(Linear regression)是利用回归方程(函数)对一个或多个自变量(特征值)和因变量(目标值)之间关系进行建模的一种分析方式。<br>通俗：找到一个特定的函数关系，描述特征值和目标值的关系。<br>满足线性关系的：<br>h(w) &#x3D; w1x1+w2x2+…+b &#x3D; wTx+b<br>W是权重值&#x2F;回归系数。b是偏置。<br>这个函数关系就叫做线性模型。<br>广义的线性模型，可以是非线性关系。<br>线性模型，当函数关系当中，满足自变量一次&#x2F;参数一次的，都叫线性模型。<br>自变量一次：h(w) &#x3D; w1x1+w2x2+…+b &#x3D; wTx+b<br>参数一次：y&#x3D;w1x1 + w2x1^2 + w3x1^3 + w4x2^3 +…+b （没有log&#x2F;e）<br>线性关系一定是线性模型，但是线性模型不一定是线性关系。</p>
<p>4.1.2 线性回归的损失和优化原理<br>权重和偏置（模型参数）是未知的，求解，使得预测准确。<br>首先，随意假定一组模型参数，带入一组特征值。<br>预测值和真实值的差值在迭代中缩小。<br>衡量预测值和真实值的误差：损失函数&#x2F;cost&#x2F;成本函数&#x2F;目标函数<br>损失函数&#x3D;累加(预测值-真实值)^2<br>减少这个损失，使得预测更准确，又称最小二乘法。</p>
<p>优化损失的方法：<br>1.正规方程（天才）-用正规方程直接求解w<br>当特征过多过复杂时，求解速度太慢并且得不到结果（特别是求逆），只能在线性回归中使用。</p>
<p>2.梯度下降（勤奋努力的普通人）-不断地试错、改进<br>数据量很大的情况下，梯度下降可以取得更好的结果。<br>先给初使的权重，迭代来获取新的权重，沿着切线的方向移动<br>α为学习速率，需要手动指定（超参数），表示步长，α旁边的整体表示方向<br>沿着这个函数下降的方向找，最后就能找到山谷的最低点，然后更新W值<br>使用：面对训练数据规模十分庞大的任务 ，能够找到较好的结果。<br>线性回归的损失函数图像有一个唯一的最小值点。<br>但不是线性回归的损失函数，可能到一个局部最小点。<br>机器学习中的学习过程就可以理解为梯度下降的试错改进。</p>
<p>4.1.3 线性回归API<br>sklearn提供给我们两种实现的API， 可以根据选择使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.linear_model.LinearRegression(fit_intercept=True)</span><br><span class="line">  通过正规方程优化</span><br><span class="line">  fit_intercept：是否计算偏置，一般true，不然只能是过原点的，局限性</span><br><span class="line">  LinearRegression.coef_：看回归系数</span><br><span class="line">  LinearRegression.intercept_：看偏置</span><br><span class="line">sklearn.linear_model.SGDRegressor(loss=&quot;squared_loss&quot;, fit_intercept=True, learning_rate =&#x27;invscaling&#x27;, eta0=0.01)</span><br><span class="line">  SGDRegressor类实现了随机梯度下降学习，它支持不同的loss函数和正则化惩罚项来拟合线性回归模型。</span><br><span class="line">  loss:损失函数类型</span><br><span class="line">  loss=”squared_loss”: 普通最小二乘法</span><br><span class="line">  fit_intercept：是否计算偏置</span><br><span class="line">  learning_rate : string, optional</span><br><span class="line">    学习率算法</span><br><span class="line">    &#x27;constant&#x27;: eta = eta0 （默认0.01）</span><br><span class="line">    &#x27;optimal&#x27;: eta = 1.0 / (alpha * (t + t0)) [default]随着迭代次数变多学习率变小</span><br><span class="line">    &#x27;invscaling&#x27;: eta = eta0 / pow(t, power_t)  power_t=0.25:存在父类当中</span><br><span class="line">    对于一个常数值的学习率来说，可以使用learning_rate=’constant’ ，并使用eta0来指定学习率。</span><br><span class="line">  SGDRegressor.coef_：回归系数</span><br><span class="line">  SGDRegressor.intercept_：偏置</span><br></pre></td></tr></table></figure>


<p>4.1.4 波士顿房价预测<br>流程：<br>1）获取数据集<br>2）划分数据集<br>3）特征工程：无量纲化-标准化<br>4）预估器流程 fit() -&gt; 模型 coef_ intercept_<br>5）模型评估 </p>
<p>回归性能评估: 均方误差MSE（上面的损失函数+平均）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.metrics.mean_squared_error(y_true, y_pred)</span><br><span class="line">均方误差回归损失</span><br><span class="line">y_true:真实目标值</span><br><span class="line">y_pred:预测目标值</span><br><span class="line">return:浮点数结果</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.datasets import load_boston</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.linear_model import LinearRegression,SGDRegressor</span><br><span class="line">from sklearn.metrics import mean_squared_error</span><br><span class="line"></span><br><span class="line">def linear1():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    线性回归正规方程优化方法预测房子价格</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 1）获取数据集</span><br><span class="line">    lb = load_boston()</span><br><span class="line">    # print(lb.data)</span><br><span class="line">    # print(lb.target)</span><br><span class="line">    print(&quot;特征数量&quot;, lb.data.shape)</span><br><span class="line"></span><br><span class="line">    # 2)对数据集进行划分</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(lb.data, lb.target, test_size=0.3, random_state=24)</span><br><span class="line"></span><br><span class="line">    # 3）特征工程：无量纲化 - 标准化</span><br><span class="line">    transfer = StandardScaler()</span><br><span class="line">    x_train = transfer.fit_transform(x_train)</span><br><span class="line">    x_test = transfer.fit_transform(x_test)</span><br><span class="line">    # print(x_train)</span><br><span class="line"></span><br><span class="line">    # 4）预估器流程 fit() -&gt; 模型</span><br><span class="line">    # 使用正规方程求解</span><br><span class="line">    lr = LinearRegression()</span><br><span class="line">    lr.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">    # 5）得出模型</span><br><span class="line">    print(&quot;权重系数：&quot;, lr.coef_)</span><br><span class="line">    print(&quot;偏置：&quot;, lr.intercept_)</span><br><span class="line"></span><br><span class="line">    # 6）模型评估</span><br><span class="line">    y_predict = lr.predict(x_test)</span><br><span class="line">    print(&quot;预测房价：&quot;, y_predict)</span><br><span class="line">    print(&quot;正规方程的均方误差为：&quot;, mean_squared_error(y_test, y_predict))</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">def linear2():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    线性回归梯度下降优化方法预测房子价格</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 1）获取数据集</span><br><span class="line">    lb = load_boston()</span><br><span class="line">    # print(lb.data)</span><br><span class="line">    # print(lb.target)</span><br><span class="line"></span><br><span class="line">    # 2)对数据集进行划分</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(lb.data, lb.target, test_size=0.3, random_state=24)</span><br><span class="line"></span><br><span class="line">    # 3）特征工程：无量纲化 - 标准化</span><br><span class="line">    transfer = StandardScaler()</span><br><span class="line">    x_train = transfer.fit_transform(x_train)</span><br><span class="line">    x_test = transfer.fit_transform(x_test)</span><br><span class="line">    # print(x_train)</span><br><span class="line"></span><br><span class="line">    # 4）梯度下降进行预测，调参</span><br><span class="line">    sgd = SGDRegressor(max_iter=10000, eta0=0.0001, learning_rate=&quot;constant&quot;)</span><br><span class="line">    sgd.fit(x_train, y_train)</span><br><span class="line">    print(&quot;SGD的权重参数为：&quot;, sgd.coef_)</span><br><span class="line">    print(&quot;偏置：&quot;, sgd.intercept_)</span><br><span class="line"></span><br><span class="line">    # 6）模型评估</span><br><span class="line">    y_predict = sgd.predict(x_test)</span><br><span class="line">    print(&quot;预测房价：&quot;, y_predict)</span><br><span class="line">    print(&quot;梯度下降的均方误差为：&quot;, mean_squared_error(y_test, y_predict))</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    linear1()</span><br><span class="line">    linear2()</span><br></pre></td></tr></table></figure>

<p>4.1.5 正规方程和梯度下降的对比</p>
<p>梯度下降	        正规方程<br>需要选择学习率	不需要<br>需要迭代求解	 一次运算得出<br>特征数量较大可以使用  需要计算方程，时间复杂度高O(n3)</p>
<p>选择：<br>小规模数据：LinearRegression(不能解决拟合问题)、岭回归<br>大规模数据：SGDRegressor</p>
<p>4.1.6 梯度下降优化方法GD、SGD、SAG</p>
<p>GD<br>梯度下降(Gradient Descent)，原始的梯度下降法需要计算所有样本的值才能够得出梯度，计算量大，所以后面才有会一系列的改进。</p>
<p>SGD<br>随机梯度下降(Stochastic gradient descent)是一个优化方法。它在一次迭代时只考虑一个训练样本。<br>SGD的优点是：高效容易实现<br>SGD的缺点是：SGD需要许多超参数：比如正则项参数、迭代数。SGD对于特征标准化是敏感的。</p>
<p>SAG<br>随机平均梯度法(Stochasitc Average Gradient)，由于收敛的速度太慢，有人提出SAG等基于梯度下降的算法<br>Scikit-learn：SGDRegressor、岭回归、逻辑回归等当中都会有SAG优化</p>
<h4 id="4-2-过拟合和欠拟合"><a href="#4-2-过拟合和欠拟合" class="headerlink" title="4.2 过拟合和欠拟合"></a>4.2 过拟合和欠拟合</h4><p>训练集上表现得好，测试集上表现不好 - 过拟合。<br>学习到的特征太小，导致区分标准太粗糙，不能准确识别。-欠拟合<br>学的特征太多了 - 过拟合。</p>
<p>过拟合：一个假设在训练数据上能够获得比其他假设更好的拟合， 但是在测试数据集上却不能很好地拟合数据，此时认为这个假设出现了过拟合的现象。(模型过于复杂)<br>欠拟合：一个假设在训练数据上不能获得更好的拟合，并且在测试数据集上也不能很好地拟合数据，此时认为这个假设出现了欠拟合的现象。(模型过于简单)</p>
<p>用一个曲线来表示：随着模型复杂度的增大，训练集的损失值越来越少，但是测试集的损失值先变小再变大。临界值左边是欠拟合，右边是过拟合。</p>
<p>欠拟合原因以及解决办法<br>原因：学习到数据的特征过少<br>解决办法：增加数据的特征数量</p>
<p>过拟合原因以及解决办法<br>原因：原始特征过多，存在一些嘈杂特征， 模型过于复杂是因为模型尝试去兼顾各个测试数据点，泛化能力比较差。<br>解决办法：<br>正则化，尽量减小高次项特征的影响<br>（这里针对回归，我们选择了正则化。但是对于其他机器学习算法如分类算法来说也会出现这样的问题，除了一些算法本身作用之外（决策树、神经网络），我们更多的也是去自己做特征选择，包括之前说的删除、合并一些特征）</p>
<p>在学习的时候，数据提供的特征有些影响模型复杂度或者这个特征的数据点异常较多，所以算法在学习的时候尽量减少这个特征的影响（甚至删除某个特征的影响），这就是正则化</p>
<p>注：调整时候，算法并不知道某个特征影响，而是去调整参数得出优化的结果</p>
<p>正则化类别：<br>L2正则化<br>作用：可以使得模型其中一些W权重系数都很小，都接近于0，削弱某个特征的影响<br>优点：越小的参数说明模型越简单，越简单的模型则越不容易产生过拟合现象<br>Ridge回归（岭回归）<br>加入L2正则化后的损失函数：<br>损失函数&#x3D;(累加(预测值-真实值)^2)*(1&#x2F;2m) + 惩罚系数(超参，惩罚的补偿) * 惩罚项(权重系数的平方和)<br>目的是：不仅使得损失变小，还让权重系数变小。达到不仅让模型更加准确，还消除高次项的影响。</p>
<p>L1正则化<br>作用：可以使得其中一些W的值直接为0，删除这个特征的影响<br>LASSO回归<br>惩罚项是w的绝对值。</p>
<p>线性回归的损失函数用最小二乘法，等价于当预测值与真实值的误差满足正态分布时的极大似然估计；岭回归的损失函数，是最小二乘法+L2范数，等价于当预测值与真实值的误差满足正态分布，且权重值也满足正态分布（先验分布）时的最大后验估计；LASSO的损失函数，是最小二乘法+L1范数，等价于等价于当预测值与真实值的误差满足正态分布，且且权重值满足拉普拉斯分布（先验分布）时的最大后验估计。</p>
<h4 id="4-3-线性回归的改进-岭回归"><a href="#4-3-线性回归的改进-岭回归" class="headerlink" title="4.3 线性回归的改进 - 岭回归"></a>4.3 线性回归的改进 - 岭回归</h4><p>岭回归，其实也是一种线性回归。只不过在算法建立回归方程时候，加上L2正则化的限制，从而达到解决过拟合的效果</p>
<p>api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.linear_model.Ridge(alpha=1.0, fit_intercept=True,solver=&quot;auto&quot;, normalize=False)</span><br><span class="line">具有l2正则化的线性回归</span><br><span class="line">alpha:正则化力度=惩罚项系数，也叫 λ</span><br><span class="line">λ取值：0~1 1~10</span><br><span class="line">-fit_intercept：是否添加偏置</span><br><span class="line">solver:会根据数据自动选择优化方法</span><br><span class="line">-sag:如果数据集、特征都比较大，选择该随机梯度下降优化</span><br><span class="line">normalize:数据是否进行标准化</span><br><span class="line">-normalize=False:可以在fit之前调用preprocessing.StandardScaler标准化数据</span><br><span class="line"></span><br><span class="line">模型参数：</span><br><span class="line">Ridge.coef_:回归权重</span><br><span class="line">Ridge.intercept_:回归偏置</span><br></pre></td></tr></table></figure>

<p>Ridge方法相当于SGDRegressor(penalty&#x3D;’l2’, loss&#x3D;”squared_loss”),默认l2,只不过SGDRegressor实现了一个普通的随机梯度下降学习，推荐使用Ridge(实现了SAG)</p>
<p>正则化力度越大，权重系数会越小<br>正则化力度越小，权重系数会越大</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rd = Ridge(alpha=1.0)</span><br><span class="line"></span><br><span class="line">rd.fit(x_train, y_train)</span><br><span class="line">print(&quot;岭回归的权重参数为：&quot;, rd.coef_)</span><br><span class="line"></span><br><span class="line">y_rd_predict = std_y.inverse_transform(rd.predict(x_test))</span><br><span class="line"></span><br><span class="line">print(&quot;岭回归的预测的结果为：&quot;, y_rd_predict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&quot;岭回归的均方误差为：&quot;, mean_squared_error(y_test, y_rd_predict))</span><br></pre></td></tr></table></figure>

<h4 id="4-4-分类；分类算法-逻辑回归与二分类"><a href="#4-4-分类；分类算法-逻辑回归与二分类" class="headerlink" title="4.4 分类；分类算法-逻辑回归与二分类"></a>4.4 分类；分类算法-逻辑回归与二分类</h4><p>逻辑回归（Logistic Regression）是机器学习中的一种分类模型，逻辑回归是一种分类算法，虽然名字中带有回归，但是它与回归之间有一定的联系。由于算法的简单和高效，在实际中应用非常广泛。</p>
<p>应用场景：<br>广告点击率<br>是否为垃圾邮件<br>是否患病<br>金融诈骗<br>虚假账号<br>都属于两个类别之间的判断。逻辑回归就是解决二分类问题的利器</p>
<p>线性回归的输出 就是 逻辑回归（激活函数）的输入。</p>
<p>激活函数sigmoid函数：<code>1/(1 + e^(-x))</code><br>将某个函数映射到0-1区间。<br>回归的结果输入到sigmoid函数当中<br>输出结果：[0, 1]区间中的一个概率值，默认为0.5为阈值.</p>
<p>逻辑回归最终的分类是通过属于某个类别的概率值来判断是否属于某个类别，并且这个类别默认标记为1(正例),另外的一个类别会标记为0(反例)。</p>
<p>需要构建损失函数：（先线性回归，再sigmiod映射为逻辑回归结果，再计算损失函数）<br>线性回归的损失函数： (y_predict - y_true)平方和&#x2F;总数<br>逻辑回归的真实值&#x2F;预测值：是否属于某个类别<br>所以用：<strong>对数似然损失</strong>，定义为一个分段函数（根据真实值），真实值为1时，预测越接近1损失越小。</p>
<p>优化：<br>同样使用梯度下降优化算法，去减少损失函数的值。这样去更新逻辑回归前面对应算法的权重参数，提升原本属于1类别的概率，降低原本是0类别的概率。</p>
<p>api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.linear_model.LogisticRegression(solver=&#x27;liblinear&#x27;, penalty=‘l2’, C = 1.0)</span><br><span class="line">solver:优化求解方式（默认开源的liblinear库实现，内部使用了坐标轴下降法来迭代优化损失函数）</span><br><span class="line">-sag：根据数据集自动选择，随机平均梯度下降</span><br><span class="line">penalty：正则化的种类(l2)</span><br><span class="line">C：正则化力度</span><br></pre></td></tr></table></figure>

<p>LogisticRegression方法相当于 SGDClassifier(loss&#x3D;”log”, penalty&#x3D;” “),SGDClassifier实现了一个普通的随机梯度下降学习，也支持平均随机梯度下降法（ASGD），可以通过设置average&#x3D;True。而使用LogisticRegression(实现了SAG)</p>
<p>案例：<br>流程：<br>1）获取数据<br>2）数据处理-处理缺失值<br>3）数据集划分<br>4）特征工程：无量纲化处理-标准化<br>5）逻辑回归预估器<br>6）模型评估</p>
<p>用jupyter可视化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def logisticregression():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    逻辑回归进行癌症预测</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 1、读取数据，处理缺失值以及标准化</span><br><span class="line">    column_name = [&#x27;Sample code number&#x27;, &#x27;Clump Thickness&#x27;, &#x27;Uniformity of Cell Size&#x27;, &#x27;Uniformity of Cell Shape&#x27;,</span><br><span class="line">                   &#x27;Marginal Adhesion&#x27;, &#x27;Single Epithelial Cell Size&#x27;, &#x27;Bare Nuclei&#x27;, &#x27;Bland Chromatin&#x27;,</span><br><span class="line">                   &#x27;Normal Nucleoli&#x27;, &#x27;Mitoses&#x27;, &#x27;Class&#x27;]</span><br><span class="line"></span><br><span class="line">    data = pd.read_csv(&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data&quot;,</span><br><span class="line">                       names=column_name)</span><br><span class="line"></span><br><span class="line">    # 删除缺失值</span><br><span class="line">    data = data.replace(to_replace=&#x27;?&#x27;, value=np.nan)</span><br><span class="line"></span><br><span class="line">    data = data.dropna()</span><br><span class="line"></span><br><span class="line">    # 取出特征值</span><br><span class="line">    x = data[column_name[1:10]]</span><br><span class="line"></span><br><span class="line">    y = data[column_name[10]]</span><br><span class="line"></span><br><span class="line">    # 分割数据集</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3)</span><br><span class="line"></span><br><span class="line">    # 进行标准化</span><br><span class="line">    std = StandardScaler()</span><br><span class="line"></span><br><span class="line">    x_train = std.fit_transform(x_train)</span><br><span class="line"></span><br><span class="line">    x_test = std.transform(x_test)</span><br><span class="line"></span><br><span class="line">    # 使用逻辑回归</span><br><span class="line">    lr = LogisticRegression()</span><br><span class="line"></span><br><span class="line">    lr.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">    print(&quot;得出来的权重,几个特征有几个：&quot;, lr.coef_)</span><br><span class="line"></span><br><span class="line">    # 预测类别</span><br><span class="line">    print(&quot;预测的类别：&quot;, lr.predict(x_test))</span><br><span class="line"></span><br><span class="line">    # 得出准确率</span><br><span class="line">    print(&quot;预测的准确率:&quot;, lr.score(x_test, y_test))</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>

<p>在很多分类场景当中我们不一定只关注预测的准确率，比如以这个癌症举例子！！！我们并不关注预测的准确率，而是关注在所有的样本当中，癌症患者有没有被全部预测（检测）出来。</p>
<p>想要关注的：真的患癌症的，能够被检测出来。</p>
<p>✅精确率和召回率：<br>混淆矩阵：<br>在分类任务下，预测结果(Predicted Condition)与正确标记(True Condition)之间存在四种不同的组合，构成混淆矩阵(适用于多分类)<br>真实结果是正例，预测结果是正例：真正例TP<br>真实结果是正例，预测结果是假例：伪反例FN<br>真实结果是假例，预测结果是正例：伪正例FP<br>真实结果是假例，预测结果是假例：真反例TN</p>
<p>精确率：预测结果为正例样本中真实为正例的比例 （TP&#x2F;TP+FP）<br>召回率：真实为正例的样本中预测结果为正例的比例（查的全，对正样本的区分能力）（TP&#x2F;TP+FN）</p>
<hr>
<p>总结：<br>1.准确率（Accuracy）。顾名思义，就是所有预测正确的（包括正类和负类）占总的的比例。</p>
<p>2.精确率（Precision），查准率。即正确预测为正类的占全部预测为正类的的比例。个人理解：在所有预测为正类中真正为正类的占所有预测为正类的的比例。</p>
<p>3.召回率（Recall），查全率。即正确预测为正类的占全部实际为正类的的比例。个人理解：在所有预测为正类中真正为正类的占总体实际为正类的的比例。</p>
<p>对于精确率和召唤率，其实就是分母不同，一个分母是预测为正类的样本数，另一个是原始样本中所有的正类样本数。</p>
<p>召回率 (Recall)：该类样本有多少被找出来了（召回了多少）。</p>
<p>精确率 (Precision)：你认为的该类样本，有多少猜对了（猜的精确性如何）。</p>
<p>召回率：<a href="https://blog.csdn.net/PingBryant/article/details/115561777">https://blog.csdn.net/PingBryant/article/details/115561777</a></p>
<hr>
<p>还有其他的评估标准，F1-score，反映了模型的稳健型<br>F1 &#x3D; 2TP&#x2F;(2TP + FN + FP) &#x3D; （2<em>准确率</em>召回率）&#x2F;（准确率+召回率）</p>
<p>分类评估报告api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.metrics.classification_report(y_true, y_pred, labels=[], target_names=None )</span><br><span class="line">y_true：真实目标值</span><br><span class="line">y_pred：估计器预测目标值</span><br><span class="line">labels:指定类别对应的数字</span><br><span class="line">target_names：目标类别名称</span><br><span class="line">return：每个类别精确率与召回率</span><br><span class="line"></span><br><span class="line">print(&quot;每个特征的精确率和召回率为：&quot;, classification_report(y_test, lr.predict(x_test), labels=[2, 4], target_names=[&#x27;良性&#x27;, &#x27;恶性&#x27;]))</span><br></pre></td></tr></table></figure>

<p>假设这样一个情况，如果99个样本癌症，1个样本非癌症，不管怎样我全都预测正例(默认癌症为正例),准确率就为99%，召回率100%但是这样效果并不好，这就是样本不均衡下的评估问题。</p>
<p>ROC曲线与AUC指标：</p>
<p>TPR &#x3D; TP &#x2F; (TP + FN)<br>所有真实类别为1的样本中，预测类别为1的比例 - 召回率<br>FPR &#x3D; FP &#x2F; (FP + FN)<br>所有真实类别为0的样本中，预测类别为1的比例</p>
<p>ROC曲线的横轴就是FPRate，纵轴就是TPRate，当二者相等时，表示的意义则是：对于不论真实类别是1还是0的样本，分类器预测为1的概率是相等的，此时AUC为0.5。</p>
<p>AUC如何计算：ROC曲线和坐标轴包围的面积，如果是0，1，那就是1.</p>
<p>AUC的概率意义是随机取一对正负样本，正样本得分大于负样本的概率<br>AUC的最小值为0.5，最大值为1，取值越高越好<br>AUC&#x3D;1，完美分类器，采用这个预测模型时，不管设定什么阈值都能得出完美预测。绝大多数预测的场合，不存在完美分类器。<br>0.5&lt;AUC&lt;1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。<br>最终AUC的范围在[0.5, 1]之间，并且越接近1越好</p>
<p>AUC计算api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.metrics import roc_auc_score</span><br><span class="line">sklearn.metrics.roc_auc_score(y_true, y_score)</span><br><span class="line">计算ROC曲线面积，即AUC值</span><br><span class="line">y_true:每个样本的真实类别，必须为0(反例),1(正例)标记</span><br><span class="line">y_score:每个样本预测的概率值</span><br><span class="line"></span><br><span class="line">0.5~1之间，越接近于1约好</span><br><span class="line">y_test = np.where(y_test &gt; 2.5, 1, 0)</span><br><span class="line"></span><br><span class="line">print(&quot;AUC指标：&quot;, roc_auc_score(y_test, lr.predict(x_test)))</span><br></pre></td></tr></table></figure>

<p>AUC只能用来评价二分类<br>AUC非常适合评价样本不平衡中的分类器性能.</p>
<h4 id="4-5-模型保存和加载"><a href="#4-5-模型保存和加载" class="headerlink" title="4.5 模型保存和加载"></a>4.5 模型保存和加载</h4><p>当训练或者计算好一个模型之后，那么如果别人需要我们提供结果预测，就需要保存模型（主要是保存算法的参数）</p>
<p>sklearn模型的保存和加载API:(模型序列化到本地)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.externals import joblib</span><br><span class="line">保存：joblib.dump(rf, &#x27;test.pkl&#x27;)</span><br><span class="line">加载：estimator = joblib.load(&#x27;test.pkl&#x27;)</span><br></pre></td></tr></table></figure>

<p>保存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 使用线性模型进行预测</span><br><span class="line"> 使用正规方程求解</span><br><span class="line">lr = LinearRegression()</span><br><span class="line">lr.fit(x_train, y_train)</span><br><span class="line">保存训练完结束的模型</span><br><span class="line">joblib.dump(lr, &quot;test.pkl&quot;)</span><br></pre></td></tr></table></figure>

<p>加载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过已有的模型去预测房价</span><br><span class="line">model = joblib.load(&quot;test.pkl&quot;)</span><br><span class="line">print(&quot;从文件加载进来的模型预测房价的结果：&quot;, std_y.inverse_transform(model.predict(x_test)))</span><br></pre></td></tr></table></figure>


<h4 id="4-6-无监督学习-K-means"><a href="#4-6-无监督学习-K-means" class="headerlink" title="4.6 无监督学习 K-means"></a>4.6 无监督学习 K-means</h4><p>没有目标值 - 无监督学习</p>
<p>聚类：K-means(K均值聚类)<br>降维：PCA</p>
<p>K-means聚类步骤：<br>1、随机设置K个特征空间内的点作为初始的聚类中心<br>2、对于其他每个点计算到K个中心的距离，未知的点选择最近的一个聚类中心点作为标记类别<br>3、接着对着标记的聚类中心之后，重新计算出每个聚类的新中心点（平均值）<br>4、如果计算得出的新中心点与原中心点一样，那么结束，否则重新进行第二步过程</p>
<p>K-超参数<br>1）看需求，要分为多少堆<br>2）调节超参数</p>
<p>api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.cluster.KMeans(n_clusters=8,init=‘k-means++’)</span><br><span class="line">k-means聚类</span><br><span class="line">n_clusters:开始的聚类中心数量，k值</span><br><span class="line">init:初始化方法，默认为&#x27;k-means ++’</span><br><span class="line">labels_:默认标记的类型，可以和真实值比较（不是值比较）</span><br><span class="line"></span><br><span class="line">cust = data[:500]</span><br><span class="line">km = KMeans(n_clusters=4)</span><br><span class="line">km.fit(cust)</span><br><span class="line">pre = km.predict(cust)</span><br></pre></td></tr></table></figure>

<p>Kmeans性能评估指标：<br>轮廓系数，类似设计模式中的高内聚低耦合。<br>内部距离最小化，外部距离最大化。<br><code>SCi = (bi - ai)/max(bi,ai)</code><br>对于每个点i 为已聚类数据中的样本 ，b_i 为i 到其它族群的所有样本的距离最小值，a_i 为i 到本身簇的距离平均值。最终计算出所有的样本点的轮廓系数平均值</p>
<p>如果b_i&gt;&gt;a_i:趋近于1效果越好， b_i&lt;&lt;a_i:趋近于-1，效果不好。轮廓系数的值是介于 [-1,1] ，越趋近于1代表内聚度和分离度都相对较优。</p>
<p>轮廓系数api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.metrics.silhouette_score(X, labels)</span><br><span class="line">计算所有样本的平均轮廓系数</span><br><span class="line">X：特征值</span><br><span class="line">labels：被聚类标记的目标值</span><br></pre></td></tr></table></figure>

<p>K-means优缺点：<br>特点分析：采用迭代式算法，直观易懂并且非常实用<br>缺点：容易收敛到局部最优解(多次聚类)<br>应用场景：没有目标值的分类，做在分类之前。</p>
<h4 id="4-7-总结"><a href="#4-7-总结" class="headerlink" title="4.7 总结"></a>4.7 总结</h4><p>1.线性回归 - 线性模型 - 线性关系：y&#x3D;w1x1+w2x2+…+wnxn+b。构建损失函数-最小二乘法&#x2F;均方误差。优化损失：正规方程（矩阵相乘直接求解），梯度下降（不断试错，不断迭代）。模型评估：均方误差。<br>2.过拟合和欠拟合，过拟合：模型过于复杂 - 正则化（用L2）。欠拟合：模型过于简单 - 增加数据、特征。<br>3.岭回归，正则化力度对模型参数的影响。<br>4.逻辑回归，用于分类，输入是线性回归的输出，放入激活函数sigmoid中。损失函数：对数似然函数。优化损失：梯度下降。二分类的模型评估：召回率，样本不均衡时使用AUC指标，接近0.5就不好。<br>5.保存和加载模型<br>6.K-Means，聚类的步骤，模型评估：用轮廓系数[-1,1]</p>
<h2 id="看图说话"><a href="#看图说话" class="headerlink" title="看图说话"></a>看图说话</h2><p>什么是特征：图像的像素、区域。单词的特性，等可以被区别于其他图像的地方，并且可以经过向量化的计算被模型所获取。</p>
<p>CNN核函数 - 得到向量一片区域的相关特性<br>编码器：例如Faster-RCNN，yolo，把文本或图像的特征做向量化的处理<br>解码器：CNN-LSTM。Transformer，把向量化处理后的特征做语义识别、分割等操作，并输出。</p>
<p>图片向量化、编码器（生成计算机可以理解的上下文信息）、解码器、文本向量化</p>
<p>看图说话：用编码器Faster-RCNN从图像中提取对象，用解码器生成一句话图像表达</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>西瓜书</title>
    <url>/2025/02/12/myblog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%A5%BF%E7%93%9C%E4%B9%A6/</url>
    <content><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><ul>
<li>什么是机器学习：在计算机上从数据中产生模型的算法，即学习算法。计算机科学是研究关于算法的学问，机器学习是研究关于学习算法的学问。</li>
<li>基本术语：样本的集合-数据集，属性张成的空间-属性空间&#x2F;样本空间，一个样本在坐标轴上表示-特征向量，一个样本的特征数-维数。聚类：将样本分簇，学习过程中使用的训练样本无标记信息。训练数据无标记信息-无监督学习：聚类为代表。监督学习：回归分类为代表。模型适用于新样本的能力，适用于整个样本空间-泛化能力。</li>
<li>归纳：从特殊到一般的泛化过程。演绎：从一般到特殊的特化过程。</li>
<li>广义的归纳学习相当于从样本中学习，狭义的归纳学习要求从训练数据中学得概念，概念学习。学得泛化性能好又语义明确的概念太困难，常用的技术是产生黑箱模型。从样例中学习就是广义的归纳学习。</li>
<li>假设空间：指模型可能学习到的所有函数或解的集合。学习过程可以看作在所有假设组成的空间中进行搜索的过程，学习得到的模型对应了假设空间中的一个假设。存在与训练集一致的假设集合，称为版本空间，其中可能多个假设空间。</li>
<li>机器学习算法在学习过程中对某种类型假设的偏好，称为归纳偏好。任何有效的机器学习算法都有归纳偏好，否则无法产生确定的学习结果。奥卡姆剃刀：选择最简单的。实际上，选择与问题相匹配的归纳偏好，才会起决定性作用。</li>
<li>人工智能发展历程：推理期（逻辑推理能力） - 知识期（专家系统，人把知识总结再教给计算机）- 机器学习（研究最多的是从样例中学习，广义的归纳学习）。机器学习：符号主义学习（决策树和基于逻辑的学习，决策树学习以信息论为基础，以信息熵最小化为目标，模拟了人类对概念进行判定的树形流程，简单易用。但是逻辑学习表示能力太强，假设空间太大，复杂度高问题规模大）- 基于神经网络的连接主义学习（与符号主义产生明确概念不同，连接主义产生的是黑箱模型，最大的局限性是试错性，参数调节对结果影响很大）- 统计学习（支持向量机SVM和核方法） - 连接主义带着深度学习卷土重来（很多层的神经网络，模型复杂度高，但是下功夫调参，性能就能好）</li>
<li>数据挖掘是从海量数据中发掘知识，数据库领域为数据挖掘提供数据管理技术，机器学习和统计学的研究为数据挖掘提供数据分许技术。</li>
<li>萨缪尔，跳棋程序。提出机器学习，是不显式编程地赋予计算机能力的研究。</li>
</ul>
<h1 id="第二章-模型评估与选择"><a href="#第二章-模型评估与选择" class="headerlink" title="第二章 模型评估与选择"></a>第二章 模型评估与选择</h1><ul>
<li>误差：训练误差或经验误差：学习器在训练集上的误差；泛化误差：学习器在新样本上的误差。</li>
<li>过拟合与欠拟合：过拟合是由于学习能力过于强大,以至于把训练样本所包含的不太一般的特性都学到了（无法完全避免）；欠拟合是由于学习能力低下而造成的（神经网络中增加训练轮次）。</li>
<li>评估方法：泛化误差无法直接获得，测试集上的测试误差作为泛化误差的近似。1、留出法： 直接将数据划分为两个互斥集合，<strong>一个集合作为训练集，另一个作为互斥集</strong>，若干次随机划分。2、交叉验证法：先将数据集划分为<strong>k</strong>个大小相似的互斥子集，每次用<strong>k-1</strong>个子集的并集作为训练集，余下那个子集作为测试集。k折交叉验证，p次随机划分，p次k折交叉验证。3、自助法：每次从数据集D中挑选一个样本，再将该样本放回初始数据集D中，重复m次，得到包含m个样本的数据集D’。初始数据集D中约有36.8%的样本未出现在D’中。小数据集中有用，但是自助法产生的数据集改变了初始数据集的分布。</li>
<li>性能度量：查准率：所预测的正例有多少是正确的概率；查全率：在真实正例条件下，有多少正例被预测出来。</li>
<li>P-R曲线：以查全率为横坐标，查准率为纵坐标。</li>
<li>出现交点时，引入平衡点(Break-Event Point, BEP)来度量学习器的优劣。是查准率&#x3D;查全率时的取值。P是查准率，R是查全率。调整阈值实现变化的。</li>
<li>F1度量：调和平均，F1 &#x3D; 2<em>P</em>R&#x2F;(P+R)。为表达对P和R的偏好，引入贝塔，F1度量的一般形式。</li>
<li>ROC曲线和AUC面积：ROC曲线的纵轴是“真正例率”(True Positive Rate, TPR)，横轴是“假正例率”(False Positive Rate, FPR)。AUC为曲线下的面积。</li>
<li>代价敏感错误率和代价曲线：分类任务中，不同错误造成的损失不同，也就是非均等代价，所以引入代价矩阵，最小化总体代价。</li>
<li>t分布：统计学中的概率分布，是一种对称的、钟形的概率分布，其形状与正态分布类似，但尾部更厚。</li>
<li>偏差与方差：偏差、方差、噪声，是影响模型性能的三个核心概念，它们共同决定了模型的泛化能力。1、偏差是模型预测值的期望（多个训练集训练的多个模型）与真实值之间的差异，反映了模型对数据的拟合能力，高偏差意味着欠拟合，需要使用更复杂的模型和增加特征数量。2、方差是模型预测值的变化程度，反映了模型对训练数据的敏感性。不同训练集训练模型的预测值与真实值的方差。高方差意味着模型过于复杂，过度拟合训练数据中的噪声。低方差意味着模型对训练数据的变化不敏感，泛化能力较强。降低方差需要使用正则化，增加训练数据量。3、噪声是数据中无法被模型捕捉的随机误差，不可避免的，与模型无关。例如图像可能包含模糊或遮挡。</li>
<li>偏差度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力;方差度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响;噪声则表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。</li>
<li>偏差-方差分解说明，泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的。给定学习任务，为了取得好的泛化性能，则需使偏差较小，即能够充分拟合数据，并且使方差较小，即使得数据扰动产生的影响小。</li>
<li>训练不足时，学习器拟合能力不足，偏差主导了泛化误差。训练程度加深，训练数据的扰动能够被学习器学习到，方差主导了泛化误差。</li>
</ul>
<h1 id="第三章-线性模型"><a href="#第三章-线性模型" class="headerlink" title="第三章 线性模型"></a>第三章 线性模型</h1><ul>
<li>线性回归：用于建模因变量与自变量之间的线性关系。非线性模型可在线性模型的基础上引入层次结构和高维映射得到。简单线性回归只有一个因变量属性，多元线性回归有多个。目标：使得模型的预测值与真实值之间的误差最小。 均方误差：差平方的平均，对应欧几里得距离。参数估计方法：最小二乘法【解析法】（基于均方误差最小化来求导进行模型求解，对异常值非常敏感）、梯度下降【迭代法】（通过迭代优化逐步调整回归系数，使损失函数最小化）线性回归优点：简单可解释性强；缺点：无法捕捉非线性关系，对异常值敏感。</li>
<li>对数线性回归：通过对因变量取对数，将其转换为线性模型的形式，从而利用线性回归的方法进行建模因变量与自变量之间的对数线性关系。通常用于处理因变量是计数数据或频率数据的情况。</li>
<li>对数几率回归：分类算法，通过将线性回归的输出映射到概率空间，并使用对数几率来建模分类问题。简单高效、可解释性强，应用于二分类问题，但只能建模线性决策边界。实际上是用线性回归模型的预测结果去逼近真实标记的对数几率，对数几率是：log(p&#x2F;1-p)</li>
<li>sigmoid函数：因其形状类似于字母“S”而得名，核心作用是将任意实数映射到 [0, 1] 区间，常用于表示概率或作为激活函数。σ(z)&#x3D;1&#x2F;1+e−z。输出范围是0-1，具有单调性、非线性、平滑性。应用：对数几率回归中用于将线性回归的输出映射到 [0, 1] 区间，表示概率。在神经网络中，Sigmoid 函数常用于隐藏层或输出层的激活函数，引入非线性能力。缺点：存在梯度消失和计算复杂度较高。</li>
<li>线性判别分析LDA：核心思想是通过将数据投影到低维空间，使得同类样本尽可能接近，不同类样本尽可能远离，从而实现分类或降维。目标是找到一个投影方向（或超平面），使得在该方向上，类内距离最小化，类间距离最大化。</li>
<li>拉格朗日乘子法：一种用于求解约束优化问题的数学方法。核心思想是通过引入拉格朗日乘子，将约束条件融入目标函数，从而将约束优化问题转化为无约束优化问题。通过求解拉格朗日函数的极值，可以得到原约束优化问题的解。对因变量和拉格朗日乘子求偏导之后解方程。</li>
<li>多分类问题：1、直接多分类方法：Softmax 回归，使用 Softmax 函数将线性模型的输出转换为概率分布。神经网络中在输出层使用 Softmax 激活函数，将输出转换为概率分布。2、间接多分类方法：将多分类任务拆为若干个二分类任务求解，一对一（需训练N(N - 1)&#x2F;2个分类器）、一对其余（需训练N 个分类器）。</li>
<li>类别不平衡问题：指在分类任务中，不同类别的样本数量分布不均衡，其中一个或少数类别的样本数量远远少于其他类别。影响：模型偏向多数类、准确率评价指标失效。解决：数据层面，过采样随机复制少数类样本增加少数类样本的数量，欠采样减少多数类样本的数量，混合采样。算法层面，为不同类别分配不同的误分类代价，使模型更关注少数类。</li>
</ul>
<h1 id="第四章-决策树"><a href="#第四章-决策树" class="headerlink" title="第四章 决策树"></a>第四章 决策树</h1><ul>
<li>决策树：通过一系列规则对数据进行划分，使得每个子集尽可能纯净（即属于同一类别或具有相似的值），构建一棵树形结构。构建过程可以看作是一个递归的“分而治之”过程。</li>
<li>决策树的构建过程：1、根据某种准则（如信息增益、基尼指数等），选择最优特征进行划分。2、根据最优特征的取值，将数据集划分为多个子集。3、对每个子集递归地重复上述过程，直到满足停止条件（如子集纯净、达到最大深度等）。4、当满足停止条件时，生成叶节点，叶节点的值为该子集中多数类别（分类任务）或平均值（回归任务）。</li>
<li>决策树用于选择最有划分特征的准则：分类任务：信息增益（表示划分前后信息熵的减少量，信息熵&#x3D;plogp，信息增益越大，就认为用属性a来进行划分所获得的纯度提升最大）、增益率（通过引入固有值对信息增益进行归一化处理，克服了信息增益对取值数目较多的特征的偏好问题）、基尼指数（表示从数据集中随机抽取两个样本，其类别标签不一致的概率。基尼指数越小，数据集的纯度越高）。回归任务：均方误差MSE（选择使均方误差最小的特征进行划分）。</li>
<li>决策树的剪枝：决策树容易过拟合，因此需要通过剪枝（Pruning）来提高泛化能力。预剪枝：节点划分前先进行估计，计算划分前和划分后的验证集精度，只有划分后精度变大了，才会划分，其他的就直接一刀切不再划分。后剪枝：先生成一颗完整的决策树，从叶节点向上剪枝，通过验证集评估剪枝前后的性能，决定是否保留。</li>
<li>决策树的连续与缺失值处理：决策树通常用于处理离散特征，如果要处理连续属性：二分法和多分法。需要注意，与连续属性不同，若当前结点划分属性为连续属性，则该属性还可作为其后代节点的划分属性。对于缺失值（样本的某些属性值缺失），通过忽略、填补或单独分支处理缺失值。</li>
<li>决策树的分类边界：决策树的分类边界有一个明显的特点：轴平行，即它的分类边界由若干个与坐标轴平行的分段组成。每一段划分都直接对应了某个属性取值。</li>
<li>多变量决策树：非叶节点不再仅对某个属性，而是对属性的线性组合进行划分，实现斜划分，与传统的单变量决策树不同，多变量决策树不是为每个非叶结点寻找一个最优划分属性，而是试图建立一个合适的线性分类器。</li>
</ul>
<h1 id="第五章-神经网络"><a href="#第五章-神经网络" class="headerlink" title="第五章 神经网络"></a>第五章 神经网络</h1><ul>
<li>神经网络：一种模仿生物神经系统结构和功能的计算模型，通过多层神经元的相互连接和权重调整，能够学习复杂的非线性关系。</li>
<li>神经元：通过加权求和和激活函数处理后输出</li>
<li>激活函数：引入非线性，使神经网络能够学习复杂模式，Sigmoid、ReLU、SoftMax。</li>
<li>神经网络的学习过程，就是根据训练数据来调整神经元之间的”连接权”以及每个功能神经元的阈值。输入层神经元仅仅是接受输入，而隐层与输出层则都包含功能神经元（有激活函数）。</li>
<li>感知器：由两层神经元组成，输入层接受外界输入信号后传递给输出层，输出层是神经元，也叫做“阈值逻辑单元”。局限性：能实现与或非逻辑运算，只能解决线性可分问题（存在一个线性超平面能将它们分开），无法处理非线性分类任务（如异或问题）。</li>
<li>多层网络：通过堆叠多个感知器层，能够学习复杂的非线性关系。包括：输入层（接收输入数据，每个节点对应一个特征）、隐藏层（通过非线性变换提取特征，可以有多层）、输出层（输出预测结果，节点数取决于任务类型，如分类任务中节点数等于类别数）。神经网络的前一层的每一个神经元都与后一层的所有神经元相连–全连接神经网络。</li>
<li>多层前馈神经网络：先将输入提供给输入层神经元，然后逐层将信号前传（前向传播），直到产生输出层的结果。然后计算输出层的误差（损失函数，如均方误差、交叉熵），再将误差逆向传播至隐层神经元（误差逆传播算法，使用链式法则逐层传播误差），最后根据隐层神经元的误差来对权值和阈值进行调整（基于梯度下降策略，以目标的负梯度方向对参数进行调整）。该迭代过程循环进行，直到达到某些停止条件为止，例如训练误差己达到一个很小的值。</li>
<li>累积误差逆向传播：基于累积误差最小化进行更新</li>
<li>只需包含足够多神经元的隐层，多层前馈网络就能以任意精度逼近任意复杂度的连续函数，通过试错法调整隐层神经元的个数。</li>
<li>解决过拟合：早停：将数据分成训练集和验证集，训练集用来计算梯度、更新连接权和阈值，验证集用来估计误差，若连续多轮训练集误差降低但验证集误差升高，则停止训练，同时返回具有最小验证集误差的连接权和阈值。正则化：在损失函数中加入额外的惩罚项，限制模型参数的大小或复杂度。</li>
<li>神经网络类型：前馈神经网络FNN：最简单的神经网络，信息单向传播。卷积神经网络CNN：用于图像处理，通过卷积核提取局部特征。循环神经网络RNN：用于序列数据（如文本、时间序列），具有记忆能力。生成对抗网络GAN：由生成器和判别器组成，用于生成数据。</li>
<li>如何避免陷入局部最小：从多个不同的初始点开始搜索、动量法通过引入历史梯度信息，加速梯度下降并帮助跳出局部最小值、使用自适应学习率方法动态调整学习率、使用模拟退火，通过引入逐渐降低的“温度”参数，控制搜索过程中的随机性，从而在早期探索更多解空间，后期逐渐收敛到全局最优解、使用SGD随机梯度，通过引入噪声帮助跳出局部最小值。（都是启发式的）</li>
<li>模拟退火：每一步以一定概率接受比当前解更差的结果，接受次优解的概率随着时间的推移逐渐降低，从而保证算法稳定。</li>
<li>RBF网络：一种单隐层前馈神经网络，使用径向基函数作为隐层神经元激活函数，输出层则是对隐层神经元输出的线性组合。常用于函数逼近、分类和回归任务，具有结构简单、训练速度快的特点。RBF 径向基函数的核心思想是通过距离度量（通常是欧氏距离）来计算输入数据点与某个中心点之间的相似性。常见的RDF函数有高斯函数，具有径向对称性、平滑性的特点。</li>
<li>竞争型学习：神经网络中一种常用的无监督学习策略，在使用该策略时，网络的输出神经元相互竞争，每一时刻仅有一个竞争获胜的神经元被激活，其他神经元的状态被抑制。这种机制亦称”胜者通吃” (winner-take-all) 原则。</li>
<li>ART（自适应共振理论网络）网络：竞争型学习的代表，该网络由比较层、识别层、识别阈值和重置模块构成。在接收到比较层的输入信号后识别层神经元之间相互竞争以产生获胜神经元。竞争的最简单方式是计算输入向量与每个识别层神经元所对应的模式类的代表向量之间的距离，距离最小者胜。获胜神经元将向其他识别层神经元发送信号，抑制其激活。若输入向量与获胜神经元所对应的代表向量之间的相似度大于识别阈值，则当前输入样本将被归为该代表向量所属类别，同时，网络连接权将会更新，使得以后在接收到相似输入样本时该模式类会计算出更大的相似度，从而使该获胜神经元有更大可能获胜。若相似度不大于识别阈值，则重置模块将在识别层增设一个新的神经元，其代表向量就设置为当前输入向量。</li>
<li>ART网络是一种基于自适应共振理论的无监督学习神经网络，能够动态地学习和分类输入数据，同时保持对之前学习模式的稳定性。可以进行增量学习。它适用于模式识别、数据聚类和异常检测等任务，尽管参数敏感和计算复杂度较高，但在动态学习任务中表现出色。</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
</search>
