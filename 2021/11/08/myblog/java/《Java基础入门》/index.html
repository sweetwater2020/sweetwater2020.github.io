<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java开发入门Java是由Sun公司于1995年开发的可编写跨平台应用软件、完全面向对象的程序设计语言。2009年被Oracle公司收购。 Java三个技术平台针对不同的开发市场，Sun公司将Java划分为三个技术平台。 （1）Java SE：（standard edition）Java平台标准版，为开发普通桌面和商务应用程序提供的解决方案，是三个平台中最核心的部分，Java EE和Java M">
<meta property="og:type" content="article">
<meta property="og:title" content="《Java基础入门》面向对象">
<meta property="og:url" content="http://example.com/2021/11/08/myblog/java/%E3%80%8AJava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B/index.html">
<meta property="og:site_name" content="Sweetwater&#39;s blog">
<meta property="og:description" content="Java开发入门Java是由Sun公司于1995年开发的可编写跨平台应用软件、完全面向对象的程序设计语言。2009年被Oracle公司收购。 Java三个技术平台针对不同的开发市场，Sun公司将Java划分为三个技术平台。 （1）Java SE：（standard edition）Java平台标准版，为开发普通桌面和商务应用程序提供的解决方案，是三个平台中最核心的部分，Java EE和Java M">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-11-08T02:33:43.803Z">
<meta property="article:modified_time" content="2025-07-22T16:44:48.695Z">
<meta property="article:author" content="Sweetwater">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/11/08/myblog/java/%E3%80%8AJava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>《Java基础入门》面向对象 | Sweetwater's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sweetwater's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/08/myblog/java/%E3%80%8AJava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《Java基础入门》面向对象
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-08 10:33:43" itemprop="dateCreated datePublished" datetime="2021-11-08T10:33:43+08:00">2021-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-23 00:44:48" itemprop="dateModified" datetime="2025-07-23T00:44:48+08:00">2025-07-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Java开发入门"><a href="#Java开发入门" class="headerlink" title="Java开发入门"></a>Java开发入门</h2><p>Java是由Sun公司于1995年开发的可编写跨平台应用软件、完全面向对象的程序设计语言。2009年被Oracle公司收购。</p>
<h3 id="Java三个技术平台"><a href="#Java三个技术平台" class="headerlink" title="Java三个技术平台"></a>Java三个技术平台</h3><p>针对不同的开发市场，Sun公司将Java划分为三个技术平台。</p>
<p>（1）Java SE：（standard edition）Java平台标准版，为开发普通桌面和商务应用程序提供的解决方案，是三个平台中最核心的部分，Java EE和Java ME都是从Java SE的基础上发展而来，Java SE包括Java最核心的类库，如集合、IO、数据库连接及网络编程。</p>
<p>（2）Java EE：（enterprise edition）平台企业版，为开发企业级应用程序提供的解决方案，包括Servlet、JSP、JavaBean、EJB、Web Service等。用来做web开发的java框架。</p>
<p>（3）Java ME：（micro edition）平台微型版，为开发电子消费产品和嵌入式设备提供的解决方案，用于微型数字电子设备上软件程序的开发，例如家用电器增加智能化控制和联网功能，未手机增加游戏和通讯录管理功能。此外，还提供HTTP等协议，为移动电话提供Client&#x2F;Server方式访问Internet，提供无线交流。</p>
<p>不管哪个版本，都是java语言实现的一个框架。之所以要分版本，是因为3个版本是针对不同问题，设计的解决方案。</p>
<p>J2SE是标准版本，J2ME是手机方向的，J2EE是网站开发方向的。</p>
<h3 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h3><ul>
<li>简单易用：丢弃了c++中的：操作符重载、多继承、自动强制类型转换、不使用指针而是引用，提供自动分配和回收内存空间。</li>
<li>安全可靠：Java通常被用在网络环境中，为此，Java 提供了一个安全机制以防恶意代码的攻击。除了Java 语言具有的许多安全特性以外，Java 对通过网络下载的类具有一个安全防范机制（类 ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类 SecurityManager）让 Java 应用设置安全哨兵。</li>
<li>跨平台：通过JVM虚拟机在不同的操作系统上允许Java程序。</li>
<li>面向对象：将一切事物都看成对象，类、接口、继承。只支持类之间的单继承，支持接口之间的多继承，支持类与接口之间的实现机制（implements）。java全面支持动态绑定，c++只对虚函数使用动态绑定。</li>
<li>支持多线程：内置了多线程控制，可使用户程序并发执行。</li>
</ul>
<h3 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK&gt;JRE&gt;JVM"></a><strong>JDK&gt;JRE&gt;JVM</strong></h3><p><strong>JVM</strong> ：（Java Virtual Machine）， Java 虚拟机。它只认识 xxx.class 类型的文件，能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。jvm 是 Java 能够跨平台的核心。</p>
<p><strong>JRE</strong> ：（Java Runtime Environment），Java 运行时环境。主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。普通用户只需要JRE进行运行已经编译好的java程序，而不需要开发。</p>
<p><strong>JDK</strong> ：（Java Development Kit），Java 开发工具包。jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。例如：javac.exe（编译 java 源码的编译器 javac），java.exe（java运行工具），jar.exe（java打包工具），java文档生成工具 等很多 java 程序调试和分析的工具。</p>
<p>1996年推出jdk1.0，随后到1.5改变命名方式，jdk1.5&#x3D;jdk5.2017年jdk9，2018年jdk10.但是并不稳定。目前最多运用jdk8.</p>
<p>安装jdk时，安装开发工具（包括javac.exe、java.exe等，以及一个专用JRE环境），源代码（Java所有核心类库的源代码），公共JRE相当于多装一个JRE在其他路径，所以不需要。</p>
<p>JDK&#x3D;JRE(JVM+JAVA基本类库)+开发工具</p>
<h3 id="JDK目录"><a href="#JDK目录" class="headerlink" title="JDK目录"></a>JDK目录</h3><ul>
<li>bin目录：存放一些可执行程序，如javac.exe（java编译器）、java.exe（java运行工具）、jar.exe（打包工具）、javadoc.exe（文档生成工具）等。</li>
<li>db目录：纯java实现的支持JDBC4.0所有规范的小型数据库。</li>
<li>include目录：由于JDK是通过C和C++实现的，因此在启动时引入一些C语言的头文件，该目录就是存放这些头文件的。</li>
<li>jre目录：Java运行时环境的根目录，，包括java虚拟机、运行时的类包、java应用启动器以及一个bin目录，不包括开发环境中的开发工具。</li>
<li>lib目录：java类库或库文件，是开发工具使用的归档包文件。</li>
</ul>
<blockquote>
<p>javac.exe：编译器工具，将java文件编译成可执行的java字节码文件.class</p>
<p>java.exe：java运行工具，会启动一个java虚拟机进程，专门负责运行字节码文件</p>
</blockquote>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>目的：在任何位置都能够编译和运行java程序。</p>
<p>配置：PATH：用于告知操作系统去指定路径寻找JDK，CLASSPATH：告知JDK去指定路径查找类文件(.class文件)</p>
<p>当在命令窗口中运行一个可执行文件时，操作系统首先会在当前目录下寻找是否存在该文件，如果不存在，会在PATH环境变量中定义的路径下寻找这个文件。</p>
<h3 id="java运行机制"><a href="#java运行机制" class="headerlink" title="java运行机制"></a>java运行机制</h3><p>.java文件，</p>
<p>使用javac.exe即java编译器进行编译，</p>
<p>.class文件，</p>
<p>使用java命令开启Java虚拟机运行程序，java虚拟机首先将编译好的字节码文件加载到内存（类加载，由类加载器完成），然后虚拟机通过java解析器对加载到内存中的java类进行解释执行，</p>
<p>机器码文件，</p>
<p>计算机运行机器码文件。</p>
<blockquote>
<p>java程序是由java虚拟机负责解释执行的，而不是操作系统，因此跨平台。</p>
</blockquote>
<h3 id="类包"><a href="#类包" class="headerlink" title="类包"></a>类包</h3><p>import导包：import 包名.类名  &#x2F;  import 包名.*</p>
<p>java的核心类主要放在java包及其子包下。java扩展的大部分类在javax包及其子包下。</p>
<p>java.util：java的大量工具类、集合类，如Arrays、List、Set等</p>
<p>java.net：java网络编程相关的类和接口</p>
<p>java.io：java输入输出相关类和接口</p>
<p>java.awt：构建图形界面GUI的类和接口</p>
<p>java.sql：数据库编程</p>
<h2 id="Java编程基础"><a href="#Java编程基础" class="headerlink" title="Java编程基础"></a>Java编程基础</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行&#x2F;&#x2F;  多行&#x2F;*  *&#x2F;</p>
<p>文档注释：对某个类或类中的方法进行系统性解释说明。开发人员可使用JDK提供的javadoc工具将文档注释提取出来生成一份API帮助文档。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  content</span><br><span class="line">*  content</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>包名：一律小写<br>类名、接口名：首字母大写<br>常量名：都大写下划线连接<br>变量名和方法名：一个单词首字母小写，后面首字母大写</p>
<h3 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h3><p>八种基本数据类型：<br>byte：是8位、有符号的，以二进制补码表示的整数；-128~127；<br>short：16位<br>int：32位<br>long：64位，所赋的值超过int的取值范围，则需要加L，long num&#x3D;10000000L;<br>float：单精度32位，小数默认为double类型，因此定义float型需要在后面加f&#x2F;F<br>double：双精度64位<br>boolean：布尔<br>char：字符，2个字节</p>
<p>引用数据类型：<br>引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型。变量一旦声明后，类型就不能被改变了。对象、数组都是引用数据类型。<br>所有引用类型的默认值都是null，表示没有指向任何对象。</p>
<p><code>char c=&#39;a&#39;</code> 和 <code>char c=97</code>一样。因为可以将char变量赋值为0-65535范围内的整数，计算机将整数自动转化为对应的字符。</p>
<h3 id="变量的类型转换"><a href="#变量的类型转换" class="headerlink" title="变量的类型转换"></a>变量的类型转换</h3><p>（1）自动类型转换（隐式类型转换）：将一个类型取值范围小的数值直接赋值给另一个取值范围大的数据类型变量。大壶装小壶。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte b=3;</span><br><span class="line">int x=b;</span><br><span class="line">double y=x;</span><br></pre></td></tr></table></figure>

<p>（2）强制类型转换（显式类型转换）：目标类型取值范围小于源类型。小壶装大壶。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte a;</span><br><span class="line">int b=298;</span><br><span class="line">a=(byte)b;   //结果a会变成42</span><br></pre></td></tr></table></figure>

<p>强制类型转换中可能丢失精度，例如int占用4个字节，而byte占用1个字节，298变二进制后只留下最低的八位。</p>
<p>（3）表达式类型自动提升：byte、short、char类型的变量在运算期间类型会自动提示为int类型，然后进行运算，因此在最后获得结果时需要强制类型转换。</p>
<p>（4）在使用+&#x3D;、-&#x3D;、*&#x3D;等运算符时，强制类型转换会自动完成。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>整形常量：二进制0b&#x2F;0B开头，八进制0开头，十六进制0x&#x2F;0X开头。</p>
<p>null：表示对象的引用为空。</p>
<p>需要用final关键字定义常量：<br><code>final int a=0</code></p>
<p>转义符<br>\r  回车符<br>\n  换行符<br>\t  制表符<br>\b  退格符，backspace<br>\后加&#39;或&quot;或\表示本身</p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选，可以不break而继续执行。</span></span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="comment">//你可以有任意数量的case语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">//可选，最后才看</span></span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>定义的三种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span>[] nums=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">剖析：<span class="type">int</span>[] nums;  nums变量的类型是<span class="type">int</span>[]。</span><br><span class="line">nums会占用一块内存单元，nums=<span class="keyword">new</span> <span class="title class_">int</span>[]; 表示创建数组，并将数组的内存地址赋值给变量nums。在程序运行期间可以用变量nums来引用数组.</span><br></pre></td></tr></table></figure>

<p>多维数组：<code>String[][] str = new String[3][4];</code></p>
<p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>对数组进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">Arrays.sort(arr,<span class="number">1</span>,<span class="number">4</span>);  左闭右开</span><br></pre></td></tr></table></figure>

<h2 id="面向对象（上）"><a href="#面向对象（上）" class="headerlink" title="面向对象（上）"></a>面向对象（上）</h2><p>面向对象是把构成问题的事物按照一定规则划分为多个独立的对象，然后通过调用对象的方法来解决问题。</p>
<p>封装：将对象的属性和行为封装起来。</p>
<p>继承：描述类与类之间的关系，使得无须重新编写原有类的情况下对原有类的功能进行扩展。</p>
<p>多态：一个类中定义的属性和功能被其他类继承后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一方法所呈现出的多种不同行为特征。</p>
<p>类是对象的抽象，共同特征作为属性（成员变量），共同行为作为类的方法（成员方法）。对象是类的实例。</p>
<p>创建对象：<code>Person p=new Person();</code></p>
<p>第一步：<code>Person p;</code> 声明一个Person类型的变量p</p>
<p>第二步：<code>=new Person();</code>创建Person对象，并将Person对象在内存中的地址赋值给变量p，这样变量p便持有了对象的引用。</p>
<p>内存中，p变量存对象的地址，在栈内存，p是一个引用，指向真正的对象。对象创建在堆内存。</p>
<blockquote>
<p>栈内存：存放基本类型的变量和对象的引用变量。</p>
<p>堆内存：存放new创建的对象和数组。</p>
</blockquote>
<p>创建好对象后，可以通过对象的引用来访问对象的所有成员。对象引用.对象成员</p>
<p>也可以使用创建的对象本身来引用对象成员：<code>new Person().成员</code>。由于没有对象引用的存在，在完成一个对象成员的访问后，该对象变成垃圾对象。<strong>当对象没有被任何变量所引用就会变成垃圾。</strong></p>
<h3 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h3><p>访问控制级别由小到大：private→default→protected→public</p>
<ul>
<li>private（当前类访问级别）：该成员只能被该类的其他成员访问，其他类无法直接访问。</li>
<li>default（包访问级别）：不使用任何访问控制修饰符的话，就是default，表示这个类或者类的成员只能被本包中的其他类访问。</li>
<li>protected（子类访问级别）：成员能被同一包内的其他类访问，也能被不同包下该类的子类访问。</li>
<li>public（公共访问级别）：该类或类的成员能被所有的类访问，不管是否在同一包中。</li>
</ul>
<blockquote>
<p>如果一个java源文件中定义的所有类都没有public修饰符，那么这个源文件的文件名可以是一切合法的文件名。</p>
<p>如果java源文件中定义了一个public修饰的类，则源文件名必须与public修饰的类的类名一致。</p>
</blockquote>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>类的封装，是指将对象的属性隐藏在对象内部，设为private级别，不允许外部程序直接访问对象的内部信息，而通过类内public的方法（setxxx，getxxx）实现对内部信息的操作及访问。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>在实例化对象的同时为这个对象的属性进行赋值，可以通过构造方法来实现。</p>
<p>构造方法需要满足的三个条件：方法名与类名相同、在方法名的前面没有返回值类型的声明、方法中不能使用return返回一个值但是可以单独return来结束方法。</p>
<p>构造方法的重载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line">    TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java中每个类都至少有一个构造方法，如果一个类中没有显示地定义构造方法，系统会自动为这个类创建一个无参构造方法。但是一旦自己定义了有参的构造方法，系统将不再提供无参的构造方法。</p>
<blockquote>
<p>疑问：构造方法用来在实例化对象的时候为对象的成员变量赋值，而在定义类的时候，可以声明变量（不赋值）也可以定义变量（赋值），那么定义了变量之后，实例化对象，是给对象的成员赋初值了吗？应该是吧</p>
</blockquote>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>关键字this用来指代当前对象，用来在方法中访问对象的其他成员。</p>
<ul>
<li>通过this关键字调用成员变量，解决与局部变量名称冲突的问题。</li>
<li>通过this关键字调用成员方法。</li>
<li>通过this关键字调用构造函方法，构造方法是在实例化对象时被java虚拟机自动调用的，但是可以<strong>在一个构造方法中</strong>用<code>this(参数);</code>的形式来调用其他的构造方法。注意：只能在构造方法中用，且必须是构造方法中的第一条语句，且只能出现一次，而且不能在两个构造方法中相互调用。</li>
</ul>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>（1）静态变量</p>
<p>类内的数据成员被一个类的所有实例对象所共享时使用，例如学校学生的学校名。不必要在每个对象占用的空间中都声明这个对象，而是在对象之外的空间中声明一个变量供所有对象来共享。</p>
<p>注意：static关键字只能用于修饰成员变量，不能用于修饰局部变量。</p>
<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String schoolName;</span><br><span class="line">&#125;</span><br><span class="line">main函数中：</span><br><span class="line">Student.schoolName=<span class="string">&quot;daxue&quot;</span>;</span><br><span class="line">Student stu1=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">使用： stu1.schoolName</span><br></pre></td></tr></table></figure>

<p>（2）静态方法</p>
<p>希望在不创建对象的情况下就可以调用某个方法时使用。</p>
<p>访问方式：<code>类名.方法</code>    或    <code>实例对象名.方法</code></p>
<p>注意：在一个静态方法中只能访问用static修饰的成员，原因在于没有没sttaic修饰的成员需要先创建对象才能访问，而静态方法在被调用时可以不创建任何对象。</p>
<blockquote>
<p>思考：一个文件中可以有多个类，文件名叫public的类的名字，类内可以有public static main函数，有main函数的类得是public的?</p>
<p>static 的成员函数，只能访问static的成员（函数或变量），public static main函数中可以创建其他类的对象，然后访问其他非static类的成员。</p>
</blockquote>
<p>（3）静态代码块</p>
<p>static{…}  在类被加载时，静态代码块会执行，由于类只加载一次，因此静态代码块也只执行一次。通常使用静态代码块对类的成员变量进行初始化。第一次实例化对象时会加载类。</p>
<h2 id="面向对象（下）"><a href="#面向对象（下）" class="headerlink" title="面向对象（下）"></a>面向对象（下）</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>is a的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类在继承父类的时候，会自动拥有父类所有公共的成员。</p>
<p>java中只支持单继承，不允许多继承，一个类只能有一个直接父类。</p>
<h3 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h3><p>不能使用比父类中重写的方法更严格的访问权限，如父类的访问权限是public，子类方法不能是private。</p>
<p>也可以重新定义父类的属性。</p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>子类重写父类方法或重新定义父类属性后，子类对象无法直接访问他们，因此，用super访问。<code>super.成员变量/成员方法</code></p>
<p>还可以用super关键字来调用父类的构造方法。<code>super([参数1,参数2]);</code>但是，只能出现在子类构造方法的第一行，且只能出现一次。</p>
<p>注意：子类的构造方法中一定会调用父类的某个构造方法，可以通过super指定。如果没有super，则会默认调用父类无参的构造方法。因此，如果父类只定义了有参的构造方法，系统不给默认无参构造方法，就会出错。因此需要在父类添加无参构造方法，或者子类指定调用父类有参构造方法。</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>java中的Object类是所有类的父类，每个类都直接或间接地继承自该类，称为超类、基类、或根类。Object类中有一些自定义的方法。</p>
<p><code>对象名.toString()  </code>返回对象的字符串表示。</p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>不可更改，最终的意思。</p>
<p>（1）修饰类：不能被继承。</p>
<p>（2）修饰方法：不能被子类重写</p>
<p>（3）修饰变量：常量，只能被赋值一次。</p>
<p>final修饰的成员变量，必须在声明的同时进行赋值。</p>
<p>final修饰的局部变量，可以先声明，再进行一次赋值。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>例如在定义Animal类时，shout()方法无法明确表示，java提供抽象方法来使得其无需提供方法的具体实现。</p>
<p>抽象方法：<code>public abstract void shout();</code>没有大括号</p>
<p>包含抽象方法的类一定是抽象类，class前加abstract，但是抽象类中可以不包含抽象方法。</p>
<p>抽象类不能被实例化，只能创建子类，并在子类中实现抽象类中的抽象方法。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是一种特殊的抽象类，它不包含普通方法，内部所有方法都是抽象方法。</p>
<p>JDK8中对接口进行了重新定义，接口中除了抽象方法外，可以有default修饰的默认方法，static修饰的静态方法，这两种方法都允许有方法体。</p>
<p>用interface修饰，可以extends多个接口。接口内部可以有final常量，定义常量时必须进行初始化赋值。</p>
<p>小提示：定义常量时<code>public static final</code>可省略，定义方法时<code>public abstract</code>可省略</p>
<p>调用静态方法：<code>接口名.方法名</code></p>
<p>调用抽象方法和默认方法需要通过接口实现类的实例对象来调用。默认方法不需要子类中实现。</p>
<p><code>public interface Hockey extends Sports, Event</code>   接口的多继承</p>
<p>一个类可以在继承一个类的同时实现多个接口：<code>public class 类名 extends 类名 implements 接口1，接口2</code>  ，extend需要在前面</p>
<blockquote>
<p>注意：如果一个类通过implement实现接口，如果该类是抽象类，则可以实现接口中的部分抽象方法，如果不是抽象类，则需要实现接口中的所有抽象方法。</p>
</blockquote>
<p>总结：类继承类（只能继承一个类，但同时可以实现多个接口），接口继承接口（可一次继承多个接口），类实现接口（可一次实现多个接口）</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指一个类中定义的属性和方法被其他类继承或重写后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一方法所呈现的多种不同形态。</p>
<p>把子类对象直接赋值给父类引用变量时，程序只有在运行时才知道该引用变量具体代表哪个子类对象。</p>
<h3 id="对象的类型转换"><a href="#对象的类型转换" class="headerlink" title="对象的类型转换"></a>对象的类型转换</h3><p>子类对象当作父类类型使用：向上转型</p>
<p><code>Animal an1=new Cat();</code>   不需要任何显示声明，但是不能通过父类变量去调用子类特有的方法。</p>
<p>要想使用子类特有的方法，需要将本质为Cat类型的an1对象由Animal类型向下转型为Cat类型。</p>
<p><code>Cat cat=(Cat)an1;</code> 就可以用cat变量来调用子类特有方法了。</p>
<p><code>instanceof</code>关键字，用来判断一个对象是否为某个类或接口的实例或子类实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal an1=new Cat();</span><br><span class="line">if(an1 instanceof Cat)&#123;</span><br><span class="line">    Cat cat=(Cat)an1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>java中允许一个类的内部定义类，这样的类叫内部类。内部类所在类叫外部类。根据内部类的位置、修饰符、定义方式的不同分为四种。</p>
<p>（1）成员内部类</p>
<p>像成员变量、成员方法一样的存在，在成员内部类中，可以访问外部类的所有成员。在外部类中，可以访问成员内部类的成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">外部类访问内部类的成员：</span><br><span class="line">Inner inner = new Inner();</span><br><span class="line">inner.成员</span><br><span class="line">在与外部类平行的类中：</span><br><span class="line">Outer out = new Outer();  创建外部类对象</span><br><span class="line">Outer.Inner in = new Inner();   创建内部类对象</span><br></pre></td></tr></table></figure>

<p>（2）局部内部类</p>
<p>也叫方法内部类，是定义在某个方法内的，有效范围仅限于方法内部。</p>
<p>局部内部类可以访问外部类所有成员，而只有在包含局部内部类的方法中才可以访问内部类的成员。</p>
<p>（3）静态内部类</p>
<p>使用static关键字修饰的成员内部类，静态内部类只能访问外部类的静态成员.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在与外部类平行的类中：</span><br><span class="line">Outer.Inner inner = new Outer.Inner();</span><br><span class="line">inner.成员</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般在刷题时，定义Solution类，类内定义成员方法实现算法。测试时，定义另一个类，类内main函数中输入输出，然后定义对象<code>Solution s = new Solution();</code>通过对象访问算法方法。</p>
</blockquote>
<p>（4）匿名内部类</p>
<p>在java中调用某个方法时，如果该方法的参数是一个接口类型，除了可以传入一个参数接口实现类，还可以使用匿名内部类实现接口来作为该方法的参数。</p>
<p>匿名内部类就是没有名称的内部类，在调用包含有接口类型参数的方法时，通常为了简化代码，不会创建一个接口的实现类作为方法参数传入，而是直接通过匿名内部类的形式传入一个接口类型参数，在匿名内部类中直接完成方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义动物类接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		String name=<span class="string">&quot;maomao&quot;</span>;</span><br><span class="line">		<span class="comment">//定义匿名内部类作为参数传递给animalShout方法</span></span><br><span class="line">		animalShout(<span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">		    <span class="comment">//匿名内部类中实现shout方法</span></span><br><span class="line">		    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>&#123;</span><br><span class="line">		    	<span class="comment">//JDK8开始，局部内部类、匿名内部类可以访问非final的局部变量</span></span><br><span class="line">		    	System.out.println(name+“喵喵”)；</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;)；</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义静态方法animalShout(),接收接口类型参数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">animalShout</span><span class="params">(Animal an)</span>&#123;</span><br><span class="line">		an.shout(); <span class="comment">//调用传入对象的shout()方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分两步：</p>
<p>第一步 <code>animalShout(new Animal()&#123;&#125;)</code> 参数位置创建一个实例对象，表示创建的对象为Animal的子类实例，该子类是匿名的。</p>
<p>第二步<code>&#123;&#125;</code>中编写匿名子类的实现代码。</p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda 表达式，也可称为<strong>闭包</strong>，它是推动 Java 8 发布的最重要新特性。它使用一个清晰简洁的表达式来表达一个接口。</p>
<p>匿名内部类存在一个问题：如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然冗余。</p>
<p>Lambda表达式针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br><span class="line">可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</span><br><span class="line">可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</span><br><span class="line">可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</span><br><span class="line">可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，return可省略</span><br></pre></td></tr></table></figure>

<p>上面的例子，用lambda表达式来做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animalShout(()-&gt;System.out.println(name+“喵喵”);)</span><br></pre></td></tr></table></figure>

<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>Lambda表达式可以实现匿名内部类的功能，但是局限在于接口中只有一个抽象方法时才能使用Lambda表达式代替匿名内部类。</p>
<p>因为Lambda表达式是基于函数式接口实现的，函数式接口就是只有一个抽象方法的接口。</p>
<p>JDK8中专门为函数式接口引入@FunctionalInterface注解，显示地标识接口是一个函数式接口，如果不是编译器就会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Calculate</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		showSum(<span class="number">10</span>, <span class="number">20</span>, (x,y)-&gt;x+y);  <span class="comment">//实现方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建参数为接口的方法</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showSum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, Calculate cu)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;和为：&quot;</span>+cu.sum(x, y));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda表达式的引用形式"><a href="#Lambda表达式的引用形式" class="headerlink" title="Lambda表达式的引用形式"></a>Lambda表达式的引用形式</h3><p>Lambda表达式的主体只有一条语句时，程序可通过<code>：：</code>的语法格式来引用方法和构造器。本质是对Lambda表达式的主体部分已存在的方法进行直接引用。</p>
<p>相当于calc方法需要实现，而又现成的abs方法可以用。</p>
<p>（1）类名引用普通方法&#x2F;静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Calculate</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含静态方法的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Math</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(num&lt;<span class="number">0</span>)  <span class="keyword">return</span> -num;</span><br><span class="line">		<span class="keyword">else</span>  <span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printAbs</span><span class="params">(<span class="type">int</span> num, Calculate cu)</span>&#123;</span><br><span class="line">		System.out.println(cu.calc(num));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//使用lambda表达式</span></span><br><span class="line">		printAbs(-<span class="number">10</span>, n-&gt;Math.abs(n));</span><br><span class="line">		<span class="comment">//使用方法引用</span></span><br><span class="line">		printAbs(-<span class="number">10</span>, Math::abs);  类名::类静态方法/普通方法名</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）对象名引用方法</p>
<p>也可以通过实例化对象的名称来对其方法进行引用。是普通方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math ma = new Math();</span><br><span class="line">printAbs(-10, n-&gt;ma.abs(n));</span><br><span class="line">printAbs(-10,ma::abs);</span><br></pre></td></tr></table></figure>

<p>（3）构造器引用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonBuilder</span>&#123;</span><br><span class="line">	Person <span class="title function_">buildPerson</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个Person类，并添加有参构造方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">(String name, PersonBuilder bu)</span>&#123;</span><br><span class="line">		System.out.println(bu.buildPerson(name).getName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//使用lambda表达式   ()-&gt;new 类名()</span></span><br><span class="line">		printAbs(<span class="string">&quot;张三&quot;</span>, name-&gt;<span class="keyword">new</span> <span class="title class_">Person</span>(name));</span><br><span class="line">		<span class="comment">//使用方法引用    类名::new</span></span><br><span class="line">		printAbs(<span class="string">&quot;张三&quot;</span>, Person::<span class="keyword">new</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>java语言引入了异常，以异常类的形式对正常情况进行封装。</p>
<p>异常类都继承自java.lang.Throwable类。</p>
<p>Throwable有两个直接子类Error和Exception。</p>
<p>其中Error称为错误类，代表Java运行时产生的系统内部错误或资源耗尽的错误，如系统崩溃、虚拟机错误。</p>
<p>Exception类称为异常类，标识程序本身可以处理的错误，异常处理都是针对该类及其子类。RuntimeException表示运行时异常，其他表示编译时异常。</p>
<p>Throwable类中常用的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String getMessage()</span><br><span class="line">返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</span><br><span class="line">public void printStackTrace()</span><br><span class="line">打印toString()结果和栈层次到System.err，即错误输出流。</span><br><span class="line">public Throwable getCause()</span><br><span class="line">返回一个Throwable 对象代表异常原因。</span><br></pre></td></tr></table></figure>

<p>运行时异常是在程序运行时由Java虚拟机自动进行捕获处理的。例如数组越界。</p>
<h3 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在除法方法中：</span><br><span class="line">try&#123;</span><br><span class="line">   可能发生异常的语句</span><br><span class="line">&#125;catch(Exception类或其子类 e1)&#123;</span><br><span class="line">   对捕获的异常进行相应的处理</span><br><span class="line">   System.out.println(&quot;异常：&quot;+e1.getMessage());</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	无论程序是否异常都会执行的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try{}中的代码块发生异常，系统会将这个异常的信息封装成一个异常对象，传递给catch(){}代码块，catch代码块需要一个参数指明它所能接收的异常类型，必须是Exception类或其子类。</p>
<p>finally{}中的代码不受return语句和程序异常的影响，可以用来完成必须要做的事，例如释放系统资源、关闭线程池等。但是在try…catch…代码块中执行了<code>System.exit(0)</code>语句的话，finally不会执行，因为<code>System.exit(0)</code>表示退出当前的java虚拟机。</p>
<h3 id="throws关键字"><a href="#throws关键字" class="headerlink" title="throws关键字"></a>throws关键字</h3><p>用于将异常从当前方法中抛出，throws写在方法声明的后面，后跟声明方法中发生异常的类型，这种做法叫做方法申明抛出一个异常。一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static int divide(int x, int y) throws Exception&#123;</span><br><span class="line">	int res=x/y;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了throws后，还需要再出现异常的代码（main中）处使用try…catch…代码块进行捕获处理。</p>
<h3 id="throw关键字"><a href="#throw关键字" class="headerlink" title="throw关键字"></a>throw关键字</h3><p>throw用于方法体内，并且抛出的是一个异常类对象。</p>
<p>通过throw关键字抛出异常后，还需要try…catch…或throws关键字对异常进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void deposit(double amount) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">  if(判断)&#123;</span><br><span class="line">      throw new Exception(&quot;异常&quot;); //可以用来指示异常信息</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throw抛出异常对象，然后通过throws关键字抛出异常，最后通过try…catch…语句捕获异常。</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>java允许用户自定义异常，但自定义的异常类必须继承自Exception或其子类。在构造方法中使用super()语句调用Exception的构造方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 	<span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>();  <span class="comment">//调用无参构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(message);  <span class="comment">//调用有参构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>java提供垃圾回收机制（Java GC），虚拟机会自动回收垃圾对象所占用的内存空间。</p>
<p>当一个对象在堆内存中运行时，根据它被引用变量所引用的状态，可以把它所处的状态分为三种：</p>
<p>（1）可用状态：对象被创建后，有一个以上的引用变量引用它，那么这个对象在程序中将处于可用状态，程序可以通过引用变量来调用该对象的实例变量和方法。</p>
<p>（2）可恢复状态：程序中某个对象不再有任何引用变量引用它，它就进入了可恢复状态。系统准备回收，回收之前会调用可恢复状态对象的<code>finalize()</code>方法进行资源清理。如果在调用<code>finalize()</code>方法之前重新使一个引用变量引用该对象，则这个对象会再次变为可用对象。</p>
<p>（3）不可用状态：调用<code>finalize()</code>方法后，对象进入不可用状态，内存被清理。</p>
<blockquote>
<p>一个对象在失去引用成为垃圾后，会暂时保存在内存中，垃圾堆积到一定程度时，java虚拟机会启动垃圾回收器将这些垃圾对象从内存中释放，也就说回收的时机无法把握。</p>
</blockquote>
<p>强制系统进行垃圾回收的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.gc();</span><br><span class="line">或：</span><br><span class="line">Runtime.getRuntime().gc();</span><br></pre></td></tr></table></figure>

<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><p>当一个对象在内存中被释放时，它的<code>finalize()</code>方法会自动调用，<code>finalize()</code>方法是定义在Object类中的实例方法，方法原型：</p>
<p><code>protected void finalize() throws Throwable&#123;&#125;</code></p>
<p>任何java类都可以重写Object类的<code>finalize()</code>方法，在该方法中清理对象占用的资源。重写实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">	public void finalize()&#123;</span><br><span class="line">		System.out.println(&quot;d&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/25/myblog/spring/Spring%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/" rel="prev" title="spring入门案例">
      <i class="fa fa-chevron-left"></i> spring入门案例
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/17/myblog/java/%E3%80%8AJava%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E3%80%8B%E7%B1%BB%E4%B8%8E%E9%9B%86%E5%90%88/" rel="next" title="《Java基础入门》类与集合">
      《Java基础入门》类与集合 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8"><span class="nav-number">1.</span> <span class="nav-text">Java开发入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E4%B8%89%E4%B8%AA%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0"><span class="nav-number">1.1.</span> <span class="nav-text">Java三个技术平台</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9"><span class="nav-number">1.2.</span> <span class="nav-text">语言特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK-JRE-JVM"><span class="nav-number">1.3.</span> <span class="nav-text">JDK&gt;JRE&gt;JVM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK%E7%9B%AE%E5%BD%95"><span class="nav-number">1.4.</span> <span class="nav-text">JDK目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">1.5.</span> <span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">1.6.</span> <span class="nav-text">java运行机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8C%85"><span class="nav-number">1.7.</span> <span class="nav-text">类包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">Java编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">2.1.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="nav-number">2.2.</span> <span class="nav-text">命名规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.3.</span> <span class="nav-text">变量的数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.4.</span> <span class="nav-text">变量的类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">2.5.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.6.</span> <span class="nav-text">switch语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">2.7.</span> <span class="nav-text">数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">面向对象（上）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6"><span class="nav-number">3.1.</span> <span class="nav-text">访问控制符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">3.2.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.4.</span> <span class="nav-text">this关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.5.</span> <span class="nav-text">static关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">面向对象（下）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">4.1.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">重写父类方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">4.3.</span> <span class="nav-text">super关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object%E7%B1%BB"><span class="nav-number">4.4.</span> <span class="nav-text">Object类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">4.5.</span> <span class="nav-text">final关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">4.6.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.7.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">4.8.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.9.</span> <span class="nav-text">对象的类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">4.10.</span> <span class="nav-text">内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.11.</span> <span class="nav-text">Lambda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.12.</span> <span class="nav-text">函数式接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%BC%95%E7%94%A8%E5%BD%A2%E5%BC%8F"><span class="nav-number">4.13.</span> <span class="nav-text">Lambda表达式的引用形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">4.14.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try%E2%80%A6catch%E2%80%A6finally"><span class="nav-number">4.15.</span> <span class="nav-text">try…catch…finally</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#throws%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">4.16.</span> <span class="nav-text">throws关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#throw%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">4.17.</span> <span class="nav-text">throw关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="nav-number">4.18.</span> <span class="nav-text">自定义异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">4.19.</span> <span class="nav-text">垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finalize-%E6%96%B9%E6%B3%95"><span class="nav-number">4.20.</span> <span class="nav-text">finalize()方法</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sweetwater"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">Sweetwater</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sweetwater</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
