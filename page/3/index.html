<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Sweetwater&#39;s blog">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Sweetwater&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Sweetwater">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Sweetwater's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sweetwater's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/30/myblog/java/java%E4%B9%8Bfastjson%E5%8F%8AXStream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/30/myblog/java/java%E4%B9%8Bfastjson%E5%8F%8AXStream/" class="post-title-link" itemprop="url">java之fastjson及XStream</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-30 09:44:44" itemprop="dateCreated datePublished" datetime="2022-04-30T09:44:44+08:00">2022-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-23 00:13:23" itemprop="dateModified" datetime="2025-07-23T00:13:23+08:00">2025-07-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>fastjson是阿里出品的处理JSON字符串的Java类库，可以对JSON字符串、JSON对象、Java对象进行互相转换。需要导入fastjson包。</p>
<h3 id="String、JSONObject、Object转换"><a href="#String、JSONObject、Object转换" class="headerlink" title="String、JSONObject、Object转换"></a>String、JSONObject、Object转换</h3><p>一、字符串转成JSON对象&#x2F;数组<br>字符串转成JSON对象<br>JSON.parseObject(String text)<br>JSON.parse(String text)</p>
<p>字符串转成JSON数组<br>JSON.parseArray(String text)<br>JSON.parse(String text)</p>
<p>二、字符串转成Java对象&#x2F;列表<br>字符串转成Java对象<br>JSON.parseObject(String text, Class<T> clazz)</p>
<p>字符串转成Java对象列表<br>JSON.parseArray(String text, Class<T> clazz)</p>
<p>三、Java对象&#x2F;列表转成JSON对象&#x2F;数组<br>Java对象转成JSON对象<br>JSONObject.toJSON(Object javaObject)<br>JSON.toJSON(Object javaObject)</p>
<p>Java对象列表转成JSON数组<br>JSONArray.toJSON(Object javaObject)<br>JSON.toJSON(Object javaObject)</p>
<p>四、JSON对象&#x2F;数组转成Java对象&#x2F;列表<br>JSON对象转成Java对象<br>JSON.toJavaObject(JSON json, Class<T> clazz)<br>jsonObject.toJavaObject(JSON json) (非静态方法)</p>
<p>JSON数组转成Java对象列表<br>jsonArray.toJavaList(Class<T> clazz) (非静态方法)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONArray;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class FastJSONLearning &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    String jsonObjectStr = &quot;&#123;\&quot;prop\&quot;:\&quot;code\&quot;,\&quot;label\&quot;:\&quot;代码\&quot;,\&quot;required\&quot;:true,\&quot;key\&quot;:true&#125;&quot;;</span><br><span class="line">    String jsonArrayStr = &quot;[&#123;\&quot;prop\&quot;:\&quot;code\&quot;,\&quot;label\&quot;:\&quot;代码\&quot;,\&quot;required\&quot;:true,\&quot;key\&quot;:true&#125;,&#123;\&quot;prop\&quot;:\&quot;explain\&quot;,\&quot;label\&quot;:\&quot;中文释义\&quot;,\&quot;required\&quot;:true&#125;]&quot;;</span><br><span class="line"> </span><br><span class="line">    // 字符串转成JSON对象/数组</span><br><span class="line">    // 字符串转成JSON对象</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONObject jsonObject1 = JSON.parseObject(jsonObjectStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON对象: &quot; + jsonObject1);</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONObject jsonObject2 = (JSONObject) JSON.parse(jsonObjectStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON对象: &quot; + jsonObject2);</span><br><span class="line"> </span><br><span class="line">    // 字符串转成JSON数组</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONArray jsonArray1 = JSON.parseArray(jsonArrayStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON数组: &quot; + jsonArray1);</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONArray jsonArray2 = (JSONArray) JSON.parse(jsonArrayStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON数组: &quot; + jsonArray2);</span><br><span class="line"> </span><br><span class="line">    // 字符串转成Java对象/列表</span><br><span class="line">    // 字符串转成Java对象</span><br><span class="line">    Dict dict = JSON.parseObject(jsonObjectStr, Dict.class);</span><br><span class="line">    System.out.println(&quot;字符串转成Java对象: &quot; + dict.toString());</span><br><span class="line"> </span><br><span class="line">    // 字符串转成Java对象列表</span><br><span class="line">    List&lt;Dict&gt; dictList = JSON.parseArray(jsonArrayStr, Dict.class);</span><br><span class="line">    System.out.println(&quot;字符串转成Java对象列表: &quot; + dictList.toString());</span><br><span class="line"> </span><br><span class="line">    // Java对象/列表转成JSON对象/数组</span><br><span class="line">    // Java对象转成JSON对象</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONObject jsonObject3 = (JSONObject) JSONObject.toJSON(dict);</span><br><span class="line">    System.out.println(&quot;Java对象转成JSON对象: &quot; + jsonObject3.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONObject jsonObject4 = (JSONObject) JSON.toJSON(dict);</span><br><span class="line">    System.out.println(&quot;Java对象转成JSON对象: &quot; + jsonObject4.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // Java对象列表转成JSON数组</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONArray jsonArray3 = (JSONArray) JSONArray.toJSON(dictList);</span><br><span class="line">    System.out.println(&quot;Java对象列表转成JSON数组: &quot; + jsonArray3.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONArray jsonArray4 = (JSONArray) JSON.toJSON(dictList);</span><br><span class="line">    System.out.println(&quot;Java对象列表转成JSON数组: &quot; + jsonArray4.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // JSON对象/数组转成Java对象/列表</span><br><span class="line">    // JSON对象转成Java对象</span><br><span class="line">    // 方法1</span><br><span class="line">    Dict dict1 = JSON.toJavaObject(jsonObject1, Dict.class);</span><br><span class="line">    System.out.println(&quot;JSON对象转成Java对象: &quot; + dict1);</span><br><span class="line"> </span><br><span class="line">    // JSON对象转成Java对象</span><br><span class="line">    // 方法2</span><br><span class="line">    Dict dict2 = jsonObject1.toJavaObject(Dict.class);</span><br><span class="line">    System.out.println(&quot;JSON对象转成Java对象: &quot; + dict2);</span><br><span class="line"> </span><br><span class="line">    // JSON数组转成Java对象列表</span><br><span class="line">    List&lt;Dict&gt; dictList1 = jsonArray1.toJavaList(Dict.class);</span><br><span class="line">    System.out.println(&quot;JSON数组转成Java对象列表: &quot; + dictList1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lasdaybg/p/15144350.html">https://www.cnblogs.com/lasdaybg/p/15144350.html</a></p>
<h3 id="json文件中获取"><a href="#json文件中获取" class="headerlink" title="json文件中获取"></a>json文件中获取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class JsonTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void TestJ()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            File jsonFile = ResourceUtils.getFile(&quot;classpath:hello.json&quot;);</span><br><span class="line">            String s = FileUtils.readFileToString(jsonFile);</span><br><span class="line">            System.out.println(&quot;s:&quot;+s);</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;error:&quot;+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileUtils 需要导包：commons-io。<br>classpath表示项目中的resource文件夹。</p>
<h3 id="JSONObject、JSONArray"><a href="#JSONObject、JSONArray" class="headerlink" title="JSONObject、JSONArray"></a>JSONObject、JSONArray</h3><p>也是fastjson下的</p>
<p>JSON是互联网开发过程中应用最广泛的一种数据类型，不管是后端API接口中，还是在前端都能得到广泛应用。JSON 就是一种轻量级的数据交换格式，被广泛应用于 WEB 应用程序开发</p>
<p>在线解析：<a target="_blank" rel="noopener" href="https://c.runoob.com/front-end/53/">https://c.runoob.com/front-end/53/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;area&quot;: &quot;山东菏泽&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;马马马马马百万&quot;,</span><br><span class="line">  &quot;age&quot;: [1,2,3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON、JSON对象、JSON数组区别<br>JSON 呢只是一种宏观上的叫法，可以理解为是一种数据结构，就像 xml 结构一样，是一种规约性内容；而 JSON 对象则是对 JSON 的具体体现；JSON 数组则是将多个 JSON 对象进行存储的一个集合，可以想象成 Java 中的 List 和 Object 的关系</p>
<h4 id="JSONObject"><a href="#JSONObject" class="headerlink" title="JSONObject"></a>JSONObject</h4><p>JSONObject 是根据 JSON 形式在 Java 中存在的对象映射<br>各大 JSON 类库的 JSONObject 内部实现也是不太一样的。<br>例如fastjson：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class JSONObject extends JSON implements Map&lt;String, Object&gt;, Cloneable, Serializable, InvocationHandler &#123;</span><br><span class="line">&#125;</span><br><span class="line">对 HashMap 的一层封装，并提供了一些个性化方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JSONObject json = new JSONObject();</span><br><span class="line">json.put(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">json.put(&quot;key1&quot;,&quot;11&quot;);</span><br><span class="line">System.out.println(json.getInteger(&quot;key1&quot;));</span><br><span class="line">System.out.println(json.getString(&quot;key&quot;));</span><br></pre></td></tr></table></figure>

<h4 id="JSONArray"><a href="#JSONArray" class="headerlink" title="JSONArray"></a>JSONArray</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class JSONArray extends JSON implements List&lt;Object&gt;, Cloneable, RandomAccess, Serializable &#123;</span><br><span class="line">&#125;</span><br><span class="line">一个 List 中 套了个 Map 类结构</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JSONObject person = new JSONObject();</span><br><span class="line">person.put(&quot;name&quot;, &quot;马马马马马百万&quot;);</span><br><span class="line">JSONObject drug = new JSONObject();</span><br><span class="line">drug.put(&quot;drugName&quot;, &quot;盐酸丁卡因注射液&quot;);</span><br><span class="line">JSONArray array = new JSONArray();</span><br><span class="line">array.add(person);</span><br><span class="line">array.add(drug);</span><br></pre></td></tr></table></figure>

<h4 id="各种转换"><a href="#各种转换" class="headerlink" title="各种转换"></a>各种转换</h4><p>普通对象、json字符串、jsonObject</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">将对象转换为json字符串</span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">String jsonStr = JSON.toJSONString(person);</span><br><span class="line">将json字符串转换为JSONObject对象</span><br><span class="line">JSONObject jsonObject = JSON.parseObject(jsonStr);</span><br><span class="line">将JSONObject 转换为对象</span><br><span class="line">JSONObject person = new JSONObject();</span><br><span class="line">person.put(&quot;name&quot;, &quot;马马马马马百万&quot;);</span><br><span class="line">person.put(&quot;age&quot;, 25);</span><br><span class="line">Student stuObj = JSON.toJavaObject(person, Student.class);</span><br></pre></td></tr></table></figure>

<h3 id="一个对象转换为另一个对象"><a href="#一个对象转换为另一个对象" class="headerlink" title="一个对象转换为另一个对象"></a>一个对象转换为另一个对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B = JSON.parseObject(JSON.toString(a), b.class)</span><br></pre></td></tr></table></figure>


<h3 id="getJSONObject、getJSONArray"><a href="#getJSONObject、getJSONArray" class="headerlink" title="getJSONObject、getJSONArray"></a>getJSONObject、getJSONArray</h3><p>Fastjson中getJSONObject()与getJSONArray()，用于获取JSONObject里的JSONObject、JSONArray()。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;    &quot;package&quot;: &#123;</span><br><span class="line">        &quot;List1&quot;: &#123;</span><br><span class="line">            &quot;errorCode&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;errorMsg&quot;: &quot;Success&quot;,</span><br><span class="line">            &quot;receiverTradeNum&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;List2&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;medicalNum&quot;: &quot;15XXXXXX&quot;,</span><br><span class="line">                &quot;queryDate&quot;: &quot;YYYYMMDD&quot;,</span><br><span class="line">                &quot;name&quot;: &quot;XXX&quot;,</span><br><span class="line">                &quot;authorizationNum&quot;: &quot;xxxxx&quot;,</span><br><span class="line">                &quot;pageNum&quot;: &quot;1&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JSONObject jsonObj = JSON.parseObject(jsonStr);</span><br><span class="line">JSONObject package = jsonObj.getJSONObject(&quot;package&quot;);     // 定位到package json对象</span><br><span class="line">JSONArray list = package.getJSONArray(&quot;List2&quot;);   //采用getJSONArray方法， 定位到json集合</span><br></pre></td></tr></table></figure>


<h3 id="XStream"><a href="#XStream" class="headerlink" title="XStream"></a>XStream</h3><p>XStream是Java类库，用来将对象序列化成XML（JSON）或反序列化为对象。<br>也就是说，使用XStream，我们可以把Java对象转换成XML，也可以将XML转换为Java对象。</p>
<p>依赖：<br>XStream的必导JAR包：<br>核心JAR包：xstream-1.4.7.jar；<br>必须依赖包：xpp3_min-1.1.4c.jar（XML Pull Parser，一款速度很快的XML解析器）。</p>
<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">XStream xStream = new XStream();</span><br><span class="line">xStream.alias(&quot;china&quot;, List.class);   //标签类换成指定字符</span><br><span class="line">xStream.alias(&quot;province&quot;, Province.class);</span><br><span class="line">xStream.alias(&quot;city&quot;, City.class);</span><br><span class="line"></span><br><span class="line">xStream.useAttributeFor(Province.class, &quot;name&quot;); //子元素编程熟悉</span><br><span class="line">xStream.addImplicitCollection(Province.class, &quot;cities&quot;);  //去掉cities标签</span><br><span class="line"></span><br><span class="line">String string = xStream.toXML(proList);</span><br><span class="line">System.out.println(string);</span><br></pre></td></tr></table></figure>

<p>更多：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u014565127/article/details/104419528">https://blog.csdn.net/u014565127/article/details/104419528</a></p>
<p><strong>高并发情况下的性能问题</strong></p>
<p>项目中使用了XStream进行XML序列化、反序列化的方案，完成服务之间的接口报文Object与Xmlg格式之间的转化。</p>
<p>当线上业务量并不大的情况下，一切正常；但是发现当业务量突然加大的情况下，突然发现，线上服务器出现CPU居高不下，服务接口调用速度越来越慢，研究JVM日志分析，发现出现很多的RUNNABLE问题。</p>
<p>问题原因：XStream在new的时候会创建CompositeClassLoader（初始类加载器），并且不断new会不断创建，导致ygc需要扫描的内容越来越多，最终导致接口调用性能下降。</p>
<p>XStream是线程安全的，不需要重复初始化xstream对象，每一种类型实例化一个对象即可，而正是由于开发人员错误地在每次处理时都实例化一个新的xstream对象，才导致了该问题。</p>
<p>解决：单列模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">原来：</span><br><span class="line">XStream xstream = XStreamInitializer.getInstance();</span><br><span class="line">xstream.processAnnotations(this.getClass());</span><br><span class="line">xstream.aliasSystemAttribute(null, &quot;class&quot;);</span><br><span class="line">return xstream.toXML(this);</span><br><span class="line"></span><br><span class="line">现在：</span><br><span class="line">实现单列：</span><br><span class="line">public class XmlHandler&#123;</span><br><span class="line"></span><br><span class="line">    private static final ConcurrentHashMap xStream = new ConcurrentHashMap&lt;String, XStream&gt;();</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 初始化</span><br><span class="line">     * @param objName</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static XStream getXStream(Class&lt;?&gt; objName) &#123;</span><br><span class="line">        String key = objName.getName();</span><br><span class="line">        if (xStream.get(key) == null)</span><br><span class="line">            xStream.put(key, new XStream());</span><br><span class="line">        return (XStream) xStream.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">序列化：</span><br><span class="line">XStream xstream = XmlHandler.getXStream(Dog.class);</span><br><span class="line">xstream.processAnnotations(Dog.class);</span><br><span class="line">String xml = xstream.toXML(dog);</span><br><span class="line"></span><br><span class="line">反序列化：</span><br><span class="line">XStream xStream = XmlHandler.getXStream(Dog.class);</span><br><span class="line">xStream.processAnnotations(Dog.class);</span><br><span class="line">Dog dog = (Dog) xStream.fromXML(xml);</span><br></pre></td></tr></table></figure>

<p>原文：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43767602/article/details/114824028">https://blog.csdn.net/weixin_43767602/article/details/114824028</a></p>
<h3 id="JSON与XML转化"><a href="#JSON与XML转化" class="headerlink" title="JSON与XML转化"></a>JSON与XML转化</h3><p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CDWLX/article/details/119038509">https://blog.csdn.net/CDWLX/article/details/119038509</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_37366055/article/details/110468129">https://blog.csdn.net/baidu_37366055/article/details/110468129</a></p>
<p>xml转json：用 org.jdom，用 dom 提取节点 转成map<br>json转xml： com.alibaba.fastjson.JSONObject</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.jdom&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jdom&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;dom4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.6.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.16.graal&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.StringReader;</span><br><span class="line">import java.io.StringWriter;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">import org.dom4j.io.OutputFormat;</span><br><span class="line">import org.dom4j.io.SAXReader;</span><br><span class="line">import org.dom4j.io.XMLWriter;</span><br><span class="line">import org.jdom.Document;</span><br><span class="line">import org.jdom.Element;</span><br><span class="line">import org.jdom.JDOMException;</span><br><span class="line">import org.jdom.input.SAXBuilder;</span><br><span class="line">import org.xml.sax.InputSource;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONArray;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line">public class JsonXML &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //请注意使用正常的xml</span><br><span class="line">        //xml-&gt;json</span><br><span class="line">//      String jsonStr = xmlToJson(&quot;D:\\NewFile.xml&quot;, null);</span><br><span class="line">//      System.out.println(jsonStr);</span><br><span class="line"></span><br><span class="line">        //json-&gt;xml</span><br><span class="line">        String xmlstr = jsonToXml(&quot;&#123;\&quot;b_content\&quot;:&#123;\&quot;sdata\&quot;:\&quot;Ps/DPJnZZPN6QQJQodY3+hK6PWCF3/2oi3DJPnFEXgKDrXX5rHT7q/I0nQPAruuBbQRfErnenQNvPpbf/lXl690qtye0/ZEuDs0ByFdFAGffQalB+Ij3lLUMDPz=\&quot;,\&quot;userobj\&quot;:&#123;\&quot;uid\&quot;:\&quot;ma000\&quot;,\&quot;realtype\&quot;:\&quot;DC\&quot;,\&quot;cn\&quot;:\&quot;法人用户2\&quot;,\&quot;tokenid\&quot;:\&quot;\&quot;,\&quot;usertype\&quot;:\&quot;2\&quot;,\&quot;link_person_name\&quot;:\&quot;联系人2\&quot;,\&quot;isreal\&quot;:\&quot;true\&quot;,\&quot;telephonenumber\&quot;:\&quot;13*******21\&quot;,\&quot;mail\&quot;:\&quot;ceshi@123.com\&quot;,\&quot;idcardtype\&quot;:\&quot;10\&quot;,\&quot;createtime\&quot;:\&quot;20150618191221\&quot;,\&quot;extproperties\&quot;:[\&quot;address=广东省广州市天河区天河北路XXX号\&quot;,\&quot;legal_code=440***********033\&quot;,\&quot;ent_type=-1\&quot;,\&quot;link_person_code=350************14\&quot;,\&quot;origin=gdbs\&quot;,\&quot;card_type_two_num=-1\&quot;,\&quot;cert_ca=-1\&quot;,\&quot;accout_type=2\&quot;,\&quot;account_uid=2\&quot;,\&quot;comm_code=-1\&quot;,\&quot;unit_type=-1\&quot;,\&quot;legal_id_type=10\&quot;,\&quot;landline=-1\&quot;,\&quot;tax_code=-1\&quot;,\&quot;cert_notafter=-1\&quot;,\&quot;card_type_one_num=-1\&quot;,\&quot;local_user=-1\&quot;,\&quot;legal_person=郑**\&quot;,\&quot;link_person_type=10\&quot;,\&quot;card_type_three=-1\&quot;,\&quot;card_type_two=-1\&quot;,\&quot;card_type_three_num=-1\&quot;,\&quot;cert_data=-1\&quot;,\&quot;area=guangzhou\&quot;,\&quot;uversion=3.0\&quot;,\&quot;cert_notbefore=-1\&quot;,\&quot;card_type_one=-1\&quot;,\&quot;user_typeext=2\&quot;],\&quot;idcardnumber\&quot;:\&quot;11***************23\&quot;,\&quot;useridcode\&quot;:\&quot;38c97fa1ee2e43d4a664cffc4554cde4\&quot;,\&quot;creditable_level_of_account_way\&quot;:\&quot;L2@YSS@2088******653||L0@IDV@44088******75||L3@GW@44088******75\&quot;,\&quot;creditable_level_of_account\&quot;:\&quot;L3\&quot;&#125;,\&quot;pareobj\&quot;:&#123;\&quot;uid\&quot;:\&quot;mayintao\&quot;,\&quot;realtype\&quot;:\&quot;DC\&quot;,\&quot;cn\&quot;:\&quot;单位用户2\&quot;,\&quot;tokenid\&quot;:\&quot;\&quot;,\&quot;usertype\&quot;:\&quot;2\&quot;,\&quot;link_person_name\&quot;:\&quot;联系人2\&quot;,\&quot;isreal\&quot;:\&quot;true\&quot;,\&quot;telephonenumber\&quot;:\&quot;13*******21\&quot;,\&quot;mail\&quot;:\&quot;ceshi@123.com\&quot;,\&quot;idcardtype\&quot;:\&quot;50\&quot;,\&quot;createtime\&quot;:\&quot;20150618191221\&quot;,\&quot;extproperties\&quot;:[\&quot;address=广东省广州市东山区\&quot;,\&quot;legal_id_type=-1\&quot;,\&quot;link_person_type=-1\&quot;,\&quot;legal_code=-1\&quot;,\&quot;origin=gdbs\&quot;,\&quot;tax_code=-1\&quot;,\&quot;legal_person=-1\&quot;,\&quot;area=shenzhen\&quot;,\&quot;link_person_code=-1\&quot;,\&quot;user_typeext=2\&quot;,\&quot;uversion=1.0\&quot;],\&quot;idcardnumber\&quot;:\&quot;456787654\&quot;,\&quot;useridcode\&quot;:\&quot;75c91fagrr2e67d4a169cfmc8735ctrf\&quot;,\&quot;creditable_level_of_account_way\&quot;:\&quot;L2@YSS@2088******653||L0@IDV@44088******75||L3@GW@44088******75\&quot;,\&quot;creditable_level_of_account\&quot;:\&quot;L3\&quot;&#125;,\&quot;user_creditable_level\&quot;:&#123;\&quot;creditable_level_of_account_way\&quot;:\&quot;L2@YSS@2088******653||L0@IDV@44088******75||L3@GW@44088******75\&quot;,\&quot;creditable_level_of_account_way_list\&quot;:[&#123;\&quot;auth_time\&quot;:\&quot;2018-02-28 16:45:26\&quot;,\&quot;uniqueid\&quot;:\&quot;***86f93fb61***\&quot;,\&quot;user_name\&quot;:\&quot;郭**\&quot;,\&quot;auth_identification\&quot;:\&quot;2088******653\&quot;,\&quot;identity_level\&quot;:\&quot;L2\&quot;,\&quot;credential_no\&quot;:\&quot;44088******75\&quot;,\&quot;way_code\&quot;:\&quot;YSS\&quot;&#125;,&#123;\&quot;auth_time\&quot;:null,\&quot;uniqueid\&quot;:\&quot;***764486f93fb61212***\&quot;,\&quot;user_name\&quot;:\&quot;郭**\&quot;,\&quot;auth_identification\&quot;:\&quot;44088******75\&quot;,\&quot;identity_level\&quot;:\&quot;L0\&quot;,\&quot;credential_no\&quot;:\&quot;44088******75\&quot;,\&quot;way_code\&quot;:\&quot;IDV\&quot;&#125;,&#123;\&quot;auth_time\&quot;:\&quot;2018-02-13 17:12:31\&quot;,\&quot;uniqueid\&quot;:\&quot;*****764486f93fb612122*****\&quot;,\&quot;user_name\&quot;:\&quot;郭**\&quot;,\&quot;auth_identification\&quot;:\&quot;44088******75\&quot;,\&quot;identity_level\&quot;:\&quot;L3\&quot;,\&quot;credential_no\&quot;:\&quot;44088******75\&quot;,\&quot;way_code\&quot;:\&quot;GW\&quot;&#125;],\&quot;creditable_level_of_account\&quot;:\&quot;L3\&quot;&#125;&#125;,\&quot;time_stamp\&quot;:\&quot;20200821\&quot;,\&quot;version \&quot;:\&quot;v1\&quot;,\&quot;sign\&quot;:\&quot;rxf0MFT7eQqYgYKWtgzNBi6mhS2tbqkPgI \&quot;&#125;&quot;);</span><br><span class="line">        System.out.println(xmlstr);</span><br><span class="line">        createXMLFile(formatXML(xmlstr), &quot;测试&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * xml转json字符串 注意:路径和字符串二传一另外一个传null&lt;br&gt;</span><br><span class="line">     * 方 法 名：xmlToJson &lt;br&gt;</span><br><span class="line">     * @param xmlPath xml路径(和字符串二传一,两样都传优先使用路径)</span><br><span class="line">     * @param xmlStr xml字符串(和路径二传一,两样都传优先使用路径)</span><br><span class="line">     * @return String</span><br><span class="line">     * @throws IOException</span><br><span class="line">     * @throws JDOMException</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static String xmlToJson(String xmlPath,String xmlStr)&#123;</span><br><span class="line">        SAXBuilder sbder = new SAXBuilder();</span><br><span class="line">        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">        Document document;</span><br><span class="line">        try &#123;</span><br><span class="line">            if(xmlPath!=null)&#123;</span><br><span class="line">                //路径</span><br><span class="line">                document = sbder.build(new File(xmlPath));</span><br><span class="line">            &#125;else if(xmlStr!=null)&#123;</span><br><span class="line">                //xml字符</span><br><span class="line">                StringReader reader = new StringReader(xmlStr);</span><br><span class="line">                InputSource ins = new InputSource(reader);</span><br><span class="line">                document = sbder.build(ins);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return &quot;&#123;&#125;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            //获取根节点</span><br><span class="line">            Element el =  document.getRootElement();</span><br><span class="line">            List&lt;Element&gt; eList =  el.getChildren();</span><br><span class="line">            Map&lt;String, Object&gt; rootMap = new HashMap&lt;String, Object&gt;();</span><br><span class="line">            //得到递归组装的map</span><br><span class="line">            rootMap = xmlToMap(eList,rootMap);</span><br><span class="line">            map.put(el.getName(), rootMap);</span><br><span class="line">            //将map转换为json 返回</span><br><span class="line">            return JSON.toJSONString(map);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return &quot;&#123;&#125;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * json转xml&lt;br&gt;</span><br><span class="line">     * 方 法 名：jsonToXml &lt;br&gt;</span><br><span class="line">     * @param json</span><br><span class="line">     * @return String</span><br><span class="line">     */</span><br><span class="line">    public static String jsonToXml(String json)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            StringBuffer buffer = new StringBuffer();</span><br><span class="line">            buffer.append(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&quot;);</span><br><span class="line">            buffer.append(&quot;&lt;base&gt;&quot;);</span><br><span class="line">            JSONObject jObj = JSON.parseObject(json);</span><br><span class="line">            jsonToXmlstr(jObj,buffer);</span><br><span class="line">            buffer.append(&quot;&lt;/base&gt;&quot;);</span><br><span class="line">            return buffer.toString();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * json转str&lt;br&gt;</span><br><span class="line">     * 方 法 名：jsonToXmlstr &lt;br&gt;</span><br><span class="line">     * @param jObj</span><br><span class="line">     * @param buffer</span><br><span class="line">     * @return String</span><br><span class="line">     */</span><br><span class="line">    public static String jsonToXmlstr(JSONObject jObj,StringBuffer buffer )&#123;</span><br><span class="line">        Set&lt;Entry&lt;String, Object&gt;&gt;  se = jObj.entrySet();</span><br><span class="line">        for( Iterator&lt;Entry&lt;String, Object&gt;&gt;   it = se.iterator();  it.hasNext(); )</span><br><span class="line">        &#123;</span><br><span class="line">            Entry&lt;String, Object&gt; en = it.next();</span><br><span class="line">            if(en.getValue() != null &amp;&amp; en.getValue().getClass().getName().equals(&quot;com.alibaba.fastjson.JSONObject&quot;))&#123;</span><br><span class="line">                buffer.append(&quot;&lt;&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">                JSONObject jo = jObj.getJSONObject(en.getKey());</span><br><span class="line">                jsonToXmlstr(jo,buffer);</span><br><span class="line">                buffer.append(&quot;&lt;/&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">            &#125;else if(en.getValue() != null &amp;&amp; en.getValue().getClass().getName().equals(&quot;com.alibaba.fastjson.JSONArray&quot;))&#123;</span><br><span class="line">                if (en.getKey().equals(&quot;extproperties&quot;)) &#123;</span><br><span class="line">                    JSONArray ja = jObj.getJSONArray(en.getKey());</span><br><span class="line">                    Iterator&lt;Object&gt; it1 = ja.iterator();</span><br><span class="line">                    List&lt;String&gt; list=new ArrayList&lt;String&gt;();</span><br><span class="line">                    while (it1.hasNext()) &#123;</span><br><span class="line">                        String ob = (String) it1.next();</span><br><span class="line">                        System.out.println(ob);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    JSONArray jarray = jObj.getJSONArray(en.getKey());</span><br><span class="line">                    for (int i = 0; i &lt; jarray.size(); i++) &#123;</span><br><span class="line">                        buffer.append(&quot;&lt;&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">                        JSONObject jsonobject =  jarray.getJSONObject(i);</span><br><span class="line">                        jsonToXmlstr(jsonobject,buffer);</span><br><span class="line">                        buffer.append(&quot;&lt;/&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;else if(en.getValue() != null &amp;&amp; en.getValue().getClass().getName().equals(&quot;java.lang.String&quot;))&#123;</span><br><span class="line">                buffer.append(&quot;&lt;&quot;+en.getKey()+&quot;&gt;&quot;+en.getValue());</span><br><span class="line">                buffer.append(&quot;&lt;/&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                buffer.append(&quot;&lt;&quot;+en.getKey()+&quot;&gt;&quot;+&quot;&quot;);</span><br><span class="line">                buffer.append(&quot;&lt;/&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 节点转map&lt;br&gt;</span><br><span class="line">     * 方 法 名：xmlToMap &lt;br&gt;</span><br><span class="line">     * @param eList</span><br><span class="line">     * @param map</span><br><span class="line">     * @return Map&lt;String,Object&gt;</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static Map&lt;String, Object&gt; xmlToMap(List&lt;Element&gt; eList,Map&lt;String, Object&gt; map)&#123;</span><br><span class="line">        for (Element e : eList) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; eMap = new HashMap&lt;String, Object&gt;();</span><br><span class="line">            List&lt;Element&gt; elementList = e.getChildren();</span><br><span class="line">            if(elementList!=null&amp;&amp;elementList.size()&gt;0)&#123;</span><br><span class="line">                eMap = xmlToMap(elementList,eMap);</span><br><span class="line">                Object obj = map.get(e.getName());</span><br><span class="line">                if(obj!=null)&#123;</span><br><span class="line">                    List&lt;Object&gt; olist = new ArrayList&lt;Object&gt;();</span><br><span class="line">                    if(obj.getClass().getName().equals(&quot;java.util.HashMap&quot;))&#123;</span><br><span class="line">                        olist.add(obj);</span><br><span class="line">                        olist.add(eMap);</span><br><span class="line"></span><br><span class="line">                    &#125;else if(obj.getClass().getName().equals(&quot;java.util.ArrayList&quot;))&#123;</span><br><span class="line">                        olist = (List&lt;Object&gt;)obj;</span><br><span class="line">                        olist.add(eMap);</span><br><span class="line">                    &#125;</span><br><span class="line">                    map.put(e.getName(), olist);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    map.put(e.getName(), eMap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                map.put(e.getName(), e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将已经格式化的xml字符串写入xml文件</span><br><span class="line">     * @param xmlStr</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean createXMLFile(String xmlStr,String xmlName)&#123;</span><br><span class="line">        boolean flag = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            XMLWriter output = null;</span><br><span class="line">            //OutputFormat   format   =   OutputFormat.createPrettyPrint();</span><br><span class="line">            //format.setSuppressDeclaration(true);</span><br><span class="line">            // format.setEncoding(&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">            //如果上面设置的xml编码类型为GBK，则应当用FileWriter来构建xml文件，否则会出现中文连码问题</span><br><span class="line">                /*outpt = new XMLWriter(</span><br><span class="line">                        new FileWriter(</span><br><span class="line">                                new File(&quot;D:/myeclipse/Workspaces/fusionChartsDemoTest/WebRoot/xml/&quot;+xmlName+&quot;.xml&quot;)) ,</span><br><span class="line">                                    format);</span><br><span class="line">                  */</span><br><span class="line"></span><br><span class="line">            //如果上面设置的xml编码类型为utf-8，则应当用FileOutputStream来构建xml文件，否则还是会出现问题</span><br><span class="line">            output = new XMLWriter(</span><br><span class="line">                    new FileOutputStream(</span><br><span class="line">                            new File(&quot;D:/&quot;+xmlName+&quot;.xml&quot;)));</span><br><span class="line">            output.setEscapeText(false);</span><br><span class="line">            output.write( xmlStr );</span><br><span class="line">            output.close();</span><br><span class="line">            return flag = true;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  String formatXML(String str) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        SAXReader reader=new SAXReader();</span><br><span class="line"></span><br><span class="line">        //创建一个串的字符输入流</span><br><span class="line">        StringReader in=new StringReader(str);</span><br><span class="line">        org.dom4j.Document doc=reader.read(in);</span><br><span class="line">        // 创建输出格式</span><br><span class="line">        OutputFormat formater=OutputFormat.createPrettyPrint();</span><br><span class="line">        //去掉xml文件的版本信息</span><br><span class="line">        //formater.setSuppressDeclaration(true);</span><br><span class="line">        //设置xml的输出编码</span><br><span class="line">        formater.setEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        //创建输出(目标)</span><br><span class="line">        StringWriter out=new StringWriter();</span><br><span class="line">        //创建输出流</span><br><span class="line">        XMLWriter writer=new XMLWriter(out,formater);</span><br><span class="line">        //输出格式化的串到目标中，执行后。格式化后的串保存在out中。</span><br><span class="line">        writer.write(doc);</span><br><span class="line"></span><br><span class="line">        writer.close();</span><br><span class="line"></span><br><span class="line">        // System.out.println(out.toString());</span><br><span class="line"></span><br><span class="line">        //返回我们格式化后的结果</span><br><span class="line">        return out.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/29/myblog/java/java%E5%B8%B8%E8%A7%84%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/29/myblog/java/java%E5%B8%B8%E8%A7%84%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">java常规注解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-29 22:56:27" itemprop="dateCreated datePublished" datetime="2022-04-29T22:56:27+08:00">2022-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-23 00:13:51" itemprop="dateModified" datetime="2025-07-23T00:13:51+08:00">2025-07-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从JDK5开始,Java增加对元数据的支持，也就是注解，注解与注释是有一定区别的，可以把注解理解为代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过注解开发人员可以在不改变原有代码和逻辑的情况下在源代码中嵌入补充信息。</p>
<p>所有的注解本质上都是继承自 Annotation 接口。但是，手动定义一个接口继承 Annotation 接口无效的，需要通过 @interface 声明注解，Annotation 接口本身也不定义注解类型，只是一个普通的接口。</p>
<h3 id="Pattern"><a href="#Pattern" class="headerlink" title="@Pattern"></a>@Pattern</h3><p>用来限定string格式，用正则表达式来限定。<br>需要导入validation-api包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">    @Setter</span><br><span class="line">    public static class StudentVO&#123;</span><br><span class="line">        @Pattern(regexp = &quot;^[A-Za-z]+$&quot;, message = &quot;只能字母&quot;)</span><br><span class="line">        private String name;</span><br><span class="line">        private Long age;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>常用的正则表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1 匹配首尾空格的正则表达式：(^\s*)|(\s*$)</span><br><span class="line">  2 整数或者小数：^[0-9]+\.&#123;0,1&#125;[0-9]&#123;0,2&#125;$</span><br><span class="line">  3 只能输入数字：&quot;^[0-9]*$&quot;。</span><br><span class="line">  4 只能输入n位的数字：&quot;^\d&#123;n&#125;$&quot;。</span><br><span class="line">  5 只能输入至少n位的数字：&quot;^\d&#123;n,&#125;$&quot;。</span><br><span class="line">  6 只能输入m~n位的数字：。&quot;^\d&#123;m,n&#125;$&quot;</span><br><span class="line">  7 只能输入零和非零开头的数字：&quot;^(0|[1-9][0-9]*)$&quot;。</span><br><span class="line">  8 只能输入有两位小数的正实数：&quot;^[0-9]+(.[0-9]&#123;2&#125;)?$&quot;。</span><br><span class="line">  9 只能输入有1~3位小数的正实数：&quot;^[0-9]+(.[0-9]&#123;1,3&#125;)?$&quot;。</span><br><span class="line"> 10 只能输入非零的正整数：&quot;^\+?[1-9][0-9]*$&quot;。</span><br><span class="line"> 11 只能输入非零的负整数：&quot;^\-[1-9][]0-9&quot;*$。</span><br><span class="line"> 12 只能输入长度为3的字符：&quot;^.&#123;3&#125;$&quot;。</span><br><span class="line"> 13 只能输入由26个英文字母组成的字符串：&quot;^[A-Za-z]+$&quot;。</span><br><span class="line"> 14 只能输入由26个大写英文字母组成的字符串：&quot;^[A-Z]+$&quot;。</span><br><span class="line"> 15 只能输入由26个小写英文字母组成的字符串：&quot;^[a-z]+$&quot;。</span><br><span class="line"> 16 只能输入由数字和26个英文字母组成的字符串：&quot;^[A-Za-z0-9]+$&quot;。</span><br><span class="line"> 17 只能输入由数字、26个英文字母或者下划线组成的字符串：&quot;^\w+$&quot;。</span><br><span class="line"> 18 验证用户密码：&quot;^[a-zA-Z]\w&#123;5,17&#125;$&quot;正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。</span><br><span class="line"> 19 验证是否含有^%&amp;&#x27;,;=?$\&quot;等字符：&quot;[^%&amp;&#x27;,;=?$\x22]+&quot;。</span><br><span class="line"> 20 只能输入汉字：&quot;^[\u4e00-\u9fa5]&#123;0,&#125;$&quot;</span><br><span class="line"> 21 验证Email地址：&quot;^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$&quot;。</span><br><span class="line"> 22 验证InternetURL：&quot;^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$&quot;。</span><br><span class="line"> 23 验证电话号码：&quot;^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$&quot;正确格式为：&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX&quot;。</span><br><span class="line"> 24 验证身份证号（15位或18位数字）：&quot;^\d&#123;15&#125;|\d&#123;18&#125;$&quot;。</span><br><span class="line"> 25 验证一年的12个月：&quot;^(0?[1-9]|1[0-2])$&quot;正确格式为：&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;12&quot;。</span><br><span class="line"> 26 验证一个月的31天：&quot;^((0?[1-9])|((1|2)[0-9])|30|31)$&quot;正确格式为；&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;31&quot;。</span><br><span class="line"> 27 匹配中文字符的正则表达式： [\u4e00-\u9fa5]</span><br><span class="line"> 28 匹配双字节字符(包括汉字在内)：[^\x00-\xff]</span><br><span class="line"> 29 应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）</span><br><span class="line"> 30 String.prototype.len=function()&#123;return this.replace(/[^\x00-\xff]/g,&quot;aa&quot;).length;&#125;</span><br><span class="line"> 31 匹配空行的正则表达式：\n[\s| ]*\r</span><br><span class="line"> 32 匹配html标签的正则表达式：&lt;(.*)&gt;(.*)&lt;\/(.*)&gt;|&lt;(.*)\/&gt;</span><br><span class="line">————————————————</span><br><span class="line">原文链接：https://blog.csdn.net/qq_36927265/article/details/87864026</span><br></pre></td></tr></table></figure>

<p>在control层，前端调用来进行数据校验。</p>
<p>一、VO对象内用@Pattern限定，control方法中用@Valid检查。<br><a target="_blank" rel="noopener" href="http://www.wpf123.com/post/97.html">http://www.wpf123.com/post/97.html</a></p>
<p>二、control类用@Validated注解，方法内String参数用@Pattern</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Validated</span><br><span class="line">class Controller &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping</span><br><span class="line">public ResponseEntity&lt;List&lt;Permission&gt;&gt; query(</span><br><span class="line">    @RequestHeader(&quot;iv-user&quot;) String userId,</span><br><span class="line">        @Pattern(regexp = &quot;^accessor$&quot;, message = &quot;请求参数不合法&quot;)</span><br><span class="line">        @RequestParam(&quot;findBy&quot;) String accessor,</span><br><span class="line">        @RequestParam(&quot;accessorId&quot;) long accessorId)&#123;</span><br><span class="line">        //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="JSONField"><a href="#JSONField" class="headerlink" title="@JSONField"></a>@JSONField</h3><p>来自fastjson，fastjson是阿里巴巴出品的快速解析json的一个工具,</p>
<p>一、name属性：用来指定JSON串中key的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@JSONField(name = &quot;AGE&quot;)</span><br><span class="line">private String age;</span><br></pre></td></tr></table></figure>
<p>也可以作用在setter、getter方法上。</p>
<p>二、format规定日期格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@JSONField(format=&quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br><span class="line">private Date date;</span><br></pre></td></tr></table></figure>

<p>三、ordinal：规定字段的顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@JSONField(ordinal = 3)</span><br><span class="line">private int f0;</span><br><span class="line"></span><br><span class="line">@JSONField(ordinal = 2)</span><br><span class="line">private int f1;</span><br><span class="line"></span><br><span class="line">@JSONField(ordinal = 1)</span><br><span class="line">private int f2;</span><br></pre></td></tr></table></figure>

<p>四、serialize&#x2F;deserialize指定字段不序列化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@JSONField(serialize=false)</span><br><span class="line">public Date date;</span><br></pre></td></tr></table></figure>

<p>五、<code>@JSONField(serializeUsing=xxx.class, deserializeUsing=xxx.class)</code><br>指定序列化和反序列化字段使用的序列化器和反序列化器。<br>需要实现<code>ObjectSerializer</code>接口。</p>
<h3 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h3><p>LomBok中的注解，用来简化代码。</p>
<p>1.默认情况下，将打印所有非静态字段。<br>2.如果要跳过某些字段，可以用注释这些字段@ToString.Exclude。<br>3.可以使用精确指定要被toString方法包含的字段，先设置@ToString(onlyExplicitlyIncluded &#x3D; true)，然后使用@ToString.Include标记每个要包含的字段。<br>4.可以更改用于标识成员的名称@ToString.Include(name &#x3D; “some other name”)，name相当于给字段起别名。<br>5.可以通过更改成员的打印顺序@ToString.Include(rank &#x3D; 1)。rank 表示该字段的优先级，值越大排在越前面，默认为 0，等级相同的成员以它们在源文件中出现的顺序打印。</p>
<h3 id="CrossOrigin"><a href="#CrossOrigin" class="headerlink" title="@CrossOrigin"></a>@CrossOrigin</h3><p>出于安全原因，浏览器禁止Ajax调用驻留在当前原点之外的资源。</p>
<p>跨源资源共享（CORS）是由大多数浏览器实现的W3C规范，允许您灵活地指定什么样的跨域请求被授权，而不是使用一些不太安全和不太强大的策略，如IFRAME或JSONP。</p>
<p>参数：<br>origins： 允许可访问的域列表<br>maxAge:准备响应前的缓存持续的最大时间（以秒为单位）。</p>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin(origins = &#123;&quot;http://domain2.com&quot;,&quot;。。。&quot;&#125;, maxAge = 3600)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Account retrieve(@PathVariable Long id) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/188106">https://cloud.tencent.com/developer/article/188106</a></p>
<h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><p>开发restful API时，会用到，@RestController 是@controller和@ResponseBody 的结合。</p>
<p>@Controller 将当前修饰的类注入Spring IOC容器，使得从该类所在的项目跑起来的过程中，这个类就被实例化。</p>
<p>@ResponseBody 它的作用是指该类中所有的API接口返回的数据，甭管你对应的方法返回Map或是其他Object，它会以Json字符串的形式返回给客户端。</p>
<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>@RequestMapping 是 Spring Web 应用程序中最常被用到的注解之一。在Spring MVC 中使用 @RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RestController  </span><br><span class="line">@RequestMapping(&quot;/home&quot;)  </span><br><span class="line">public class IndexController &#123;  </span><br><span class="line">    @RequestMapping(&quot;/&quot;)  </span><br><span class="line">    String get() &#123;  </span><br><span class="line">        //mapped to hostname:port/home/  </span><br><span class="line">        return &quot;go to home&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    @RequestMapping(&quot;/index&quot;)  </span><br><span class="line">    String index() &#123;  </span><br><span class="line">        //mapped to hostname:port/home/index/  </span><br><span class="line">        return &quot;go to index&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>参考：<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6f5aec232c97">https://www.jianshu.com/p/6f5aec232c97</a></p>
<p>✅RequestMapping参数</p>
<p>1，value，method<br>value：指定请求的实际地址，指定的地址可以是URI Template模式。<br>method：指定请求的method类型，GET、POST、PUT、DELETE等。</p>
<p>2，consumes，produces<br>consumes：指定处理请求的提交内容类型（content-type），例如application&#x2F;json，text&#x2F;html。<br>produces：指定返回的内容类型，仅当request请求头中的（Accept）类型中包含该指定类型才返回。不但可以设置返回值类型还可以设定返回值的字符编码。</p>
<p>3，params，headers<br>params：指定request中必须包含某些参数值时，才让该方法处理。<br>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>
<p>前后端数据json数据类型</p>
<p>1，json对象类型，即前端定义的Content type为application&#x2F;x-www-form-urlencoded等，后端应使用@RequestParam注解接收此类型的json参数。</p>
<p>2，json字符串类型，即前端定义的Content type为application&#x2F;json，后端应使用@RequestBody注解接收json参数。</p>
<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/FlyGoldfish/articles/15649305.html">https://www.cnblogs.com/FlyGoldfish/articles/15649305.html</a></p>
<p>在Spring MVC 中使用 @RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求，相当于Servlet中在web.xml中配置</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/web&quot;)</span><br><span class="line">piblic class TestController &#123;</span><br><span class="line">    // 方法仅处理请求方式是GET和request Content-Type为“application/json”类型的请求</span><br><span class="line">    //普通参数用@RequestParam</span><br><span class="line">    @RequestMapping(value = &quot;/test1&quot;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;, consumes = &quot;application/json&quot;)</span><br><span class="line">    public String test2(@RequestParam(&quot;id&quot;) String id)&#123;</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //对象类型用@RequestBody</span><br><span class="line">    @RequestMapping(value = &quot;/test2&quot;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;, consumes = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">    public String test2(@RequestBody VO vo)&#123;</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //指定返回值类型为json</span><br><span class="line">    @RequestMapping(value = &quot;/list&quot; , method = RequestMethod.POST,produces=&quot;application/json&quot;)</span><br><span class="line">public JSONObject list(@PathVariable String communityId) &#123;</span><br><span class="line">   JSONObject object = new JSONObject();</span><br><span class="line">   object.put(&quot;communityId&quot;,communityId);</span><br><span class="line">   return object;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    //@responseBody就是返回值是json数据，使用@responseBody，就可以省略produces属性</span><br><span class="line">    @RequestMapping(value = &quot;/list&quot; , method = RequestMethod.POST)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public JSONObject list(@PathVariable String communityId) &#123;</span><br><span class="line">    JSONObject object = new JSONObject();</span><br><span class="line">    object.put(&quot;communityId&quot;,communityId);</span><br><span class="line">    return object;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //返回值是json数据，字符编码为utf-8</span><br><span class="line">    @RequestMapping(value = &quot;/list&quot; , method = RequestMethod.POST,produces=&quot;application/json;charset=utf-8&quot;)</span><br><span class="line">    public JSONObject list(@PathVariable String communityId) &#123;</span><br><span class="line">    JSONObject object = new JSONObject();</span><br><span class="line">    object.put(&quot;communityId&quot;,communityId);</span><br><span class="line">    return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46058921/article/details/122141863">https://blog.csdn.net/weixin_46058921/article/details/122141863</a></p>
<p>✅MediaType<br>consumes参数中可以用的。</p>
<p>MediaType媒体类型：决定浏览器将以什么形式、什么编码对资源进行解析Content-Type：也属于MediaType媒体类型，主要用于在请求头中指定资源的MediaType</p>
<p><a target="_blank" rel="noopener" href="https://javajgs.com/archives/75280">https://javajgs.com/archives/75280</a></p>
<p>✅RequestMapping、GetMapping、PostMapping的区别</p>
<p>@RequestMapping是一个无方法的注解。@GetMapping和@PostMapping是组合注解，分别是@RequestMapping(method &#x3D; RequestMethod.GET)和@RequestMapping(method &#x3D; RequestMethod.POST)的缩写。<br>GET、POST是方法的映射，表示为<br>@RequestMapping(method &#x3D; RequestMethod.${方法})</p>
<p>在一开始的映射是使用@RequestMapping(method &#x3D; RequestMethod.${方法})来表示。后来Spring4.3中引进了@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping注解来帮助简化常用的HTTP方法的映射。</p>
<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>@RequestParam：将请求参数绑定到你控制器的方法参数上（是springmvc中接收普通参数的注解）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：f(@RequestParam(value=”参数名”,required=”true/false”,defaultValue=””) String s</span><br><span class="line">       , 其他入参）</span><br><span class="line"> </span><br><span class="line">value：参数名</span><br><span class="line"> </span><br><span class="line">required：是否包含该参数，默认为true，表示该请求路径中必须包含该参数，如果不包含就报错。</span><br><span class="line"> </span><br><span class="line">defaultValue：默认参数值，如果设置了该值，required=true将失效，自动为false,如果没有传该参数，就使用默认值</span><br></pre></td></tr></table></figure>

<p>✅@RequestParam如何接收List参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;hello&quot;, method = &#123;RequestMethod.POST&#125;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public boolean hello(@RequestParam(value = &quot;userIds&quot;) List&lt;Long&gt; userIds) &#123;</span><br><span class="line">   </span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postman传参：直接在Params中加：1,2,3</p>
<p>⚠️：@RequestBody传的vo，并且指明传入json格式（contentType），放在body-row中。<br>用的是@RequestParam传参，放在Params中，放在body-row中用json格式不行。放在Params中，相当于是加在url后面。</p>
<p>✅@RequestParam如何接收Date参数</p>
<p>首先引入joda-time包。maven的dependency：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;joda-time&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;joda-time&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在Controller代码里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String testMethod(@RequestParam @DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;) Date testdate)&#123;</span><br><span class="line">    System.out.println(testDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postman传参：直接2022-09-24 00:00:00</p>
<h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)，因此@RequestBody只能用于接收POST请求的参数<br>@RequestParam接收的是key-value里面的参数(URL中的参数)，通常用于接收GET请求的参数（POST也能接收只接收URL里的，请求体的接收不到）</p>
<p>即：<br>如果参数是放在请求体VO中，传入后台的话，那么后台要用@RequestBody才能接收到；<br>如果不是放在请求体中的话，那么后台接收前台传过来的参数时，要用@RequestParam来接收。</p>
<p>总结：<br>@RequestParam和@RequestBody都能接收Post方式请求传来的数据，但是@RequestParam不能接收json字符串，而@RequestBody能，@RequestBody不能接收form-data类型的内容，@RequestParam能。<br>一个请求，只有一个RequestBody；一个请求，可以有多个RequestParam。<br>@ReuestBody接受单个参数的时候只能先使用Map&lt;String,Object&gt; params接收,然后再使用params.get(“name”)获取参数的值。</p>
<p>更多：<a target="_blank" rel="noopener" href="https://blog.csdn.net/justry_deng/article/details/80972817">https://blog.csdn.net/justry_deng/article/details/80972817</a></p>
<h3 id="postman上如何请求"><a href="#postman上如何请求" class="headerlink" title="postman上如何请求"></a>postman上如何请求</h3><p>✅post请求，传参是list的话，用@RequestParam的话只能放在url后面，长度是有限制的。用@RequestBody是放在body里。</p>
<p>✅关于@RequestParam传参和@RequestBody传参，在postman中如何加：<br>1、@RequestParam的参数可以放在postman的param中（跟在url后面），也可以放在body里的form-data里（放在body里的），但是不能放在body的raw里。能放在哪里需要看consume参数的MedisType，想放在form-data里需要设置MedisType为multipart&#x2F;form-data，或者不要限定为json。<br>2、@RequestBody的参数放在body里的raw里格式为json。一般传对象vo。</p>
<p>✅RequestBody传map型参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@PostMapping(&quot;/test&quot;)</span><br><span class="line">public String testMethod(@RequestBody Map&lt;String,String&gt; map)&#123;</span><br><span class="line">    System.out.println(testDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postman如何请求：<br>1.设置请求方式为Post<br>2.在Headers中添加Content-Type，值为application&#x2F;json<br>3.在body中选择row，选择json数据格式，最后在下面以json的数据格式填写参数</p>
<p>✅@RequestParam传参什么时候放在form-data里，什么时候放在params里</p>
<p>长的话放在form-data里，不是跟在url后的。如果放在params里就是跟在url后面的。</p>
<h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>@ResponseBody 注解的作用是将Controller的方法返回的对象，通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。</p>
<p>@ResponseBody的作用其实是将java对象转为json格式的数据，然后直接写入HTTP response 的body中；一般在异步获取数据时使用</p>
<p>@ResponseBody 是作用在方法上的</p>
<p>更多：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47609799/article/details/124843709">https://blog.csdn.net/weixin_47609799/article/details/124843709</a></p>
<h3 id="Builder"><a href="#Builder" class="headerlink" title="@Builder"></a>@Builder</h3><p>lombok中的注解。<br>Builder 使用创建者模式又叫建造者模式。简单来说，就是一步步创建一个对象，它对用户屏蔽了里面构建的细节，但却可以精细地控制对象的构造过程。</p>
<p>@Builder注解的作用主要是用来生成对象，并且可以为对象链式赋值。放在实体类上。<br>​@Builder​​注释为你的类生成相对略微复杂的构建器API。</p>
<p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student student = Student.builder()</span><br><span class="line">        .name( &quot;admin&quot; )</span><br><span class="line">        .age( 18 )</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>与@Singular结合使用<br>使用@Singular注释注释一个集合字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Singular</span><br><span class="line">private List&lt;String&gt; hobbies;</span><br><span class="line"></span><br><span class="line">.hobbies( &quot;110&quot; ).hobbies( &quot;112&quot; )</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/g56467467464/article/details/105407741">https://blog.csdn.net/g56467467464/article/details/105407741</a></p>
<h3 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h3><p>baomidou.mybatisplus的注解<br>@TableName是mybatis-plus中的注解，主要是实现实体类型和数据库中的表实现映射。<br>放在实体类DO上。</p>
<p>虽然功能相同，但是，@TableName是mybatis-plus中的注解，@Table是Hibernate中的注解。</p>
<h3 id="Param"><a href="#Param" class="headerlink" title="@Param"></a>@Param</h3><p>1 、@Param注解的作用是给参数命名,参数命名后就能根据名字得到参数值,正确的将参数传入sql语句中（一般通过#{}的方式，${}会有sql注入的问题）。<br>2、一般写在mappe接口（DAO接口）的入参，对应xml中#{}中的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">使用方法：</span><br><span class="line">Mapper接口方法：</span><br><span class="line">public int findById(@Param(&quot;userId&quot;) int userId);</span><br><span class="line">对应的xml文件：</span><br><span class="line"> &lt;select id=&quot;findById&quot; resultMap=&quot;baseMap&quot;&gt;</span><br><span class="line">    select &lt;include redif=&quot;all_column_list&quot;&gt; from table_name</span><br><span class="line">    where user_id = #&#123;userId&#125;</span><br><span class="line"> &lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>不使用@Param注解时，参数只能有一个，并且是Javabean。</p>
<p>使用了@Param后，可以不用parameterType？ 存疑</p>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="@Mapper"></a>@Mapper</h3><p>在使用Mybatis持久层框架来操作数据库时，我们可以使用@Mapper注解和@MapperScan注解来将Mapper接口类交给Sprinig进行管理。</p>
<p>目的就是为了不再写mapper映射文件（xml文件）。</p>
<p>Spring Boot的核心理念是：不建议使用xml文件配置。但是，这对MyBatis来说进退两难，因为MyBatis离不开xml，需要xml来配置sql语句。为了迎合Spring Boot的发展理念，MyBatis官方开发了mybatis-spring-boot-starter，我们要想更少的依赖xml，需要深入的研究mybatis-spring-boot-starter中的用法，尤其是@MapperScan和@Mapper的用法。</p>
<p>一、注解@Mapper，这种方式要求每一个Mapper类都需要添加此注解<br>在接口类上添加了@Mapper，在编译之后会生成相应的接口实现类</p>
<p>二、@MapperScan注解，可以让我们不用为每个Mapper类都添加@Mapper注解。指定要变成实现类的接口所在的包<br>添加位置：是在Springboot启动类上面添加，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication  </span><br><span class="line">@MapperScan(&#123;&quot;cn.mybatis.mappers.class&quot;,&quot;cn.mybatis.mappers.student&quot;&#125;)  </span><br><span class="line">public class SpringbootMybatisDemoApplication&#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">       SpringApplication.run(SpringbootMybatisDemoApplication.class, args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>最终实现：直接在Mapper类中采用注解的形式操作数据库，通过@MapperScan扫描制定的映射器存放路径，最终不需要加任何注解，也不需要对应的xml文件来配置sql语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//不需要加任何注解，也不需要对应的xml文件</span><br><span class="line">public interface UserMapper&#123;</span><br><span class="line">     @Select(&quot;select * from user&quot;)</span><br><span class="line">     List&lt;User&gt; getUserList(String userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="http://www.mybatis.cn/archives/862.html">http://www.mybatis.cn/archives/862.html</a></p>
<h3 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h3><p>@PostContruct是Java自带的注解，在方法上加该注解会在项目启动的时候执行该方法，也可以理解为在spring容器初始化的时候执行该方法。可作为一些数据的常规化加载，比如数据字典之类的。</p>
<p>从Java EE5规范开始，Servlet中增加了两个影响Servlet生命周期的注解，@PostConstruct和@PreDestroy，这两个注解被用来修饰一个非静态的void（）方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostConstruct</span><br><span class="line">public void someMethod()&#123;&#125;</span><br><span class="line"></span><br><span class="line">public @PostConstruct void someMethod()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>执行时机：在依赖注入完成后被自动调用。在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。<br>Constructor &gt;&gt; @Autowired &gt;&gt; @PostConstruct &gt;&gt; init &gt;&gt; service &gt;&gt; destroy &gt;&gt; PreDestroy</p>
<p>该注解与BeanPostProcessor接口有关，它有个实现类CommonAnnotationBeanPostProcessor，就是专门处理@PostConstruct  @PreDestroy注解。</p>
<hr>
<p>InitialzingBean接口的afterPropertiesSet和配置bean时的init-method，也有类似功能。</p>
<p>initMethod和InitializingBean是spring提供的两种对类的属性进行装配的方式。initMethod和InitializingBean指定方法的执行顺序在普通属性装配之后，initMethod指定的方法又在InitializingBean指定的方法之后执行。</p>
<p>三者执行顺序：Construction &gt; 对象属性set() 方法-&gt; @PostConstruct -&gt; InitializingBean -&gt; initMethod</p>
<p>总结：可不可以理解为@PostConstruct在初始化自己bean时，依赖注入其他属性bean后执行，而InitialzingBean接口又是在它后面。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chinawangfei/article/details/122825129">https://blog.csdn.net/chinawangfei/article/details/122825129</a></p>
<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><p>@Deprecated是java内置注解，此注解可以用在方法，属性，类上，表示已废弃，不维护，可能会删除。<br>表示不推荐程序员使用，但是还可以使用。</p>
<h3 id="Valid"><a href="#Valid" class="headerlink" title="@Valid"></a>@Valid</h3><p>用于对象属性字段的规则检测，为了避免使用冗余的代码进行if判断，使用@Valid注解实现。</p>
<p>是Spring中的注解，需要引入依赖，如果是 springboot 项目，那么可以不用引入了，已经引入了，就存在于最核心的 web 开发包 spring-boot-starter-web 里面。</p>
<p>如果不是，需要引入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.validation&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;validation-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.0.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.4.1.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>使用方法：在被检验的实体类中，使用注解加一些限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@NotBlank(message = &quot;请输入名称&quot;)</span><br><span class="line">@Length(message = &quot;名称不能超过个 &#123;max&#125; 字符&quot;, max = 10)</span><br><span class="line">public String name;</span><br><span class="line"> </span><br><span class="line">@NotNull(message = &quot;请输入年龄&quot;)</span><br><span class="line">@Range(message = &quot;年龄范围为 &#123;min&#125; 到 &#123;max&#125; 之间&quot;, min = 1, max = 100)</span><br><span class="line">public Integer age;</span><br><span class="line"></span><br><span class="line">@Email(message = &quot;邮箱不正确&quot;)</span><br><span class="line">@Min(value = 1000000)</span><br><span class="line"></span><br><span class="line">@NotEmpty(message=&quot;不能为空&quot;)</span><br><span class="line">@Size(message=&quot;最多5个&quot;, max=5)</span><br><span class="line">private List&lt;Intefer&gt; list;</span><br></pre></td></tr></table></figure>

<p>在Controller的对应方法中，对传入参数加@Valid注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/action/register&quot;)</span><br><span class="line">public Result registerByForm(@Valid @RequestBody RegisterUser registerUser)&#123;</span><br><span class="line">    return userService.register(registerUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43587472/article/details/110388778">https://blog.csdn.net/weixin_43587472/article/details/110388778</a></p>
<h3 id="Transactional注解"><a href="#Transactional注解" class="headerlink" title="@Transactional注解"></a>@Transactional注解</h3><p>springframework中的注解。<br>声明式事务管理，是建立在AOP之上，本质上是对方法前后进行拦截，然后再目标方法开始之前创建或加入一个一个事务，在执行完目标方法之后，根据执行情况提交或者回滚事务。</p>
<p>简而言之：@Transactional注解在代码执行出错时进行事务的回滚。</p>
<p>java异常模型：<br>Throwable是最顶层的父类，有Error和Exception两个子类。<br>Error表示严重的错误（如OOM等）；<br>Exception可以分为运行时异常（RuntimeException及其子类）和非运行时异常（Exception的子类中，除了RuntimeException及其子类之外的类）。</p>
<p>非运行时异常是检查异常（checked exceptions），一定要try catch，因为这类异常是可预料的，编译阶段就检查的出来；<br>Error和运行时异常是非检查异常（unchecked exceptions），不需要try catch，因为这类异常是不可预料的，编辑阶段不会检查，没必要检查，也检查不出来。</p>
<p>spring的@Transactional注解可以很方便的开启事务，但是默认只在遇到运行时异常和Error时才会回滚，非运行时异常不回滚，即Exception的子类中，除了RuntimeException及其子类，其他的类默认不回滚。</p>
<p>而rollbackFor属性可以解决这个问题，rollbackFor &#x3D; Exception.class表示Exception及其子类的异常都会触发回滚，同时不影响Error的回滚。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 运行时异常，正常回滚</span><br><span class="line">@Transactional</span><br><span class="line">public void save()&#123;</span><br><span class="line">    StudentDO studentDO = new StudentDO();</span><br><span class="line">    studentDO.setName(&quot;ltm&quot;);</span><br><span class="line">    studentDO.setAge(22);</span><br><span class="line">    studentMapper.insert(studentDO);</span><br><span class="line">    throw new RuntimeException(&quot;我是异常&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 非运行时异常，加rollbackFor属性，抛出异常，并回滚</span><br><span class="line">@Transactional(rollbackFor = Exception.class)</span><br><span class="line">public void save() throws IOException&#123;</span><br><span class="line">    StudentDO studentDO = new StudentDO();</span><br><span class="line">    studentDO.setName(&quot;ltm&quot;);</span><br><span class="line">    studentDO.setAge(22);</span><br><span class="line">    studentMapper.insert(studentDO);</span><br><span class="line">    throw new IOException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c5988db897fc">https://www.jianshu.com/p/c5988db897fc</a></p>
<p>使用方法：<br>1.需要在启动类上添加@EnableTransactionManagement注解。<br>2.当作用在类上，该类所以public方法都具有该类型的事务属性。也可以加在public方法上。</p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_9177933/2978291">https://blog.51cto.com/u_9177933/2978291</a></p>
<h3 id="SneakyThrows"><a href="#SneakyThrows" class="headerlink" title="@SneakyThrows"></a>@SneakyThrows</h3><p>✅java的异常体系</p>
<p><img src="/images/java%E5%BC%82%E5%B8%B8.png"></p>
<p>Error是编译时错误和系统错误，系统错误在除特殊情况下，都不需要你来关心，基本不会出现。而编译时错误，如果你使用了编译器，那么编译器会提示。</p>
<p>Exception则是可以被抛出的基本类型，我们需要主要关心的也是这个类。<br>Exception又分为RunTimeException和其他Exception。</p>
<p>RunTimeException：运行时异常，又称不受检查异常，不受检查，因为不受检查，所以在代码中可能会有RunTimeException时Java编译检查时不会告诉你有这个异常，但是在实际运行代码时则会暴露出来，比如经典的1&#x2F;0，空指针等。如果不处理也会被Java自己处理。</p>
<p>其他Exception，受检查异常。可以理解为错误，必须要开发者解决以后才能编译通过，解决的方法有两种，<br>1：throw到上层，<br>2，try-catch处理。</p>
<p>✅@SneakyThrows的作用：<br>普通Exception类,也就是我们常说的受检异常或者Checked Exception会强制要求抛出它的方法声明throws，调用者必须显示的去处理这个异常。设计的目的是为了提醒开发者处理一些场景中必然可能存在的异常情况。比如网络异常造成IOException。</p>
<p>但是现实大部分情况下的异常，我们都是一路往外抛了事。所以渐渐的java程序员处理Exception的常见手段就是外面包一层RuntimeException，接着往上丢.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而Lombok的@SneakyThrows就是为了消除这样的模板代码。<br>使用注解后不需要担心Exception的处理.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> import lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line">public class SneakyThrowsExample implements Runnable &#123;</span><br><span class="line">  @SneakyThrows(UnsupportedEncodingException.class)</span><br><span class="line">  public String utf8ToString(byte[] bytes) &#123;</span><br><span class="line">    return new String(bytes, &quot;UTF-8&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @SneakyThrows</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    throw new Throwable();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：最重要的是throw (T)t, 使用泛型,将传入的Throwable强转为RuntimeException异常.<br>虽然, 我们抛出的异常不是RuntimeException,但是可以骗过javac编译器,泛型最后存储为字节码文件时并没有泛型信息.</p>
<p>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22162093/article/details/115486647">https://blog.csdn.net/qq_22162093/article/details/115486647</a></p>
<h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h3><p>@Data注解是lombok.jar包下的注解，该注解通常用在实体bean上，不需要写出set和get方法，但是具备实体bean所具备的方法，简化编程提高变成速度。</p>
<p>@Data相当于@Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode这5个注解的合集。</p>
<p>@Data ：注在类上，提供类的get、set、equals、hashCode、toString等方法<br>@AllArgsConstructor ：注在类上，提供类的全参构造<br>@NoArgsConstructor ：注在类上，提供类的无参构造<br>@Setter ：注在属性上，提供 set 方法<br>@Getter ：注在属性上，提供 get 方法<br>@EqualsAndHashCode ：注在类上，提供对应的 equals 和 hashCode 方法<br>@Log4j&#x2F;@Slf4j ：注在类上，提供对应的 Logger 对象，变量名为 log</p>
<h3 id="RequiredArgsConstructor"><a href="#RequiredArgsConstructor" class="headerlink" title="@RequiredArgsConstructor"></a>@RequiredArgsConstructor</h3><p>lombok中的注解。可用于生成有参构造函数，也可以方便在写controller或者Service层的时候，需要注入很多的mapper接口或者另外的service接口的时候就避免会写很多的@Autowired注解。</p>
<p>实体类有参构造函数：<br>必须声明的变量为final</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ToString</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">static class Person &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@RequiredArgsConstructor(onConstructor &#x3D;@_(@Autowired))<br>写在类上可以代替@Autowired注解，需要注意的是在注入时需要用final定义，或者使用@notnull注解.<br>当我们需要注入Bean的时候可以直接在类名称上使用。代替了Autowrited注解.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/v1/demo&quot;)</span><br><span class="line">@RequiredArgsConstructor(onConstructor = @__(@Autowired))</span><br><span class="line">public class DemoController &#123;</span><br><span class="line">    private final DemoService demoService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><p>作用：抑制编译器警告，有时候可以看到idea中有警告的颜色标注，当我们不希望看到这些警告的时候，可以使用 SuppressWarnings注解来抑制警告信息。<br>在<code>&#123;&quot; &quot;&#125; </code>中，可以写入你希望抑制(不显示)警告信息。</p>
<p>例如：<br><code>@SuppressWarnings&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;, &quot;unused&quot;&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">all，抑制所有警告</span><br><span class="line">boxing，抑制与封装/拆装作业相关的警告</span><br><span class="line">cast，抑制与强制转型作业相关的警告</span><br><span class="line">dep-ann，抑制与淘汰注释相关的警告</span><br><span class="line">deprecation，抑制与淘汰的相关警告</span><br><span class="line">fallthrough，抑制与switch陈述式中遗漏break相关的警告</span><br><span class="line">finally，抑制与未传回finally区块相关的警告</span><br><span class="line">hiding，抑制与隐藏变数的区域变数相关的警告</span><br><span class="line">incomplete-switch，抑制与switch陈述式(enum case)中遗漏项目相关的警告</span><br><span class="line">javadoc，抑制与javadoc相关的警告</span><br><span class="line">nls，抑制与非nls字串文字相关的警告</span><br><span class="line">null，抑制与空值分析相关的警告</span><br><span class="line">rawtypes，抑制与使用raw类型相关的警告</span><br><span class="line">resource，抑制与使用Closeable类型的资源相关的警告</span><br><span class="line">restriction，抑制与使用不建议或禁止参照相关的警告</span><br><span class="line">serial，抑制与可序列化的类别遗漏serialVersionUID栏位相关的警告</span><br><span class="line">static-access，抑制与静态存取不正确相关的警告</span><br><span class="line">static-method，抑制与可能宣告为static的方法相关的警告</span><br><span class="line">super，抑制与置换方法相关但不含super呼叫的警告</span><br><span class="line">synthetic-access，抑制与内部类别的存取未最佳化相关的警告</span><br><span class="line">sync-override，抑制因为置换同步方法而遗漏同步化的警告</span><br><span class="line">unchecked，抑制与未检查的作业相关的警告</span><br><span class="line">unqualified-field-access，抑制与栏位存取不合格相关的警告</span><br><span class="line">unused，抑制与未用的程式码及停用的程式码相关的警告</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41684621/article/details/123807986">https://blog.csdn.net/qq_41684621/article/details/123807986</a></p>
<p>✅<code>Raw use of parameterized class</code> 参数化类型的原始使用</p>
<p>指出省略了类型的参数化类的使用。这种对参数化类型的原始使用在Java中是有效的，但是会破坏使用类型参数的目的，并可能掩盖错误。此检查反映了编译阶段对原始类型的警告。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList(); //不指定范型，默认为Object类型</span><br><span class="line">list.add(&quot;123&quot;);</span><br><span class="line">list.add(1L);</span><br><span class="line">list.add(0.11d);</span><br><span class="line">// 可以这样构造list，但是下面转类型会出错，不能吧String类型转为double。</span><br><span class="line">//java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Double</span><br><span class="line">for (Object o : list) &#123;</span><br><span class="line">    double a = (double) o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码就是直接使用原生态类型的实现，在编译时期不会有任何问题，但是一旦运行就会报错：Exception in thread “main” java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Double，代码设计应该使错误尽早被发现，而这就是不安全的表现了，而且可读性而言，缺少了形式类型参数，我们很难明白List存储的类型是什么，表述性变差。</p>
<p>如果确定使用是安全的，不会在运行时候导致错误，则可通过 <code>@SuppressWarnings(&quot;rawtypes&quot;)</code>消除使用原生态类型警告。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1677759">https://cloud.tencent.com/developer/article/1677759</a></p>
<p>✅<code>Unchecked call to ... </code> 调用未经检查</p>
<p>比如上面add的时候就会提示，表示未检查add的参数的类型，因为定义list的时候没指定类型，如果指定类型就不报了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/26/myblog/spring/BeanFactory%E5%92%8CApplicationContext/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/26/myblog/spring/BeanFactory%E5%92%8CApplicationContext/" class="post-title-link" itemprop="url">BeanFactory、ApplicationContext</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-26 22:12:06" itemprop="dateCreated datePublished" datetime="2022-04-26T22:12:06+08:00">2022-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-18 18:31:45" itemprop="dateModified" datetime="2023-02-18T18:31:45+08:00">2023-02-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring%E7%90%86%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">spring理解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="BeanFactory与ApplicationContext"><a href="#BeanFactory与ApplicationContext" class="headerlink" title="BeanFactory与ApplicationContext"></a>BeanFactory与ApplicationContext</h3><p>BeanFactory使管理不同类型的java对象成为可能，应用上下文ApplacationContext建立在BeanFactor基础之上，提供了更多面向应用的功能，它提供了国际化支持和框架事件体系，更易于创建实际应用。我们一般称BeanFactory为IOC容器，而称ApplicationContext为应用上下文。但有时为了行文方便，我们也称ApplicationContext为Spring容器。</p>
<p>对于二者的用途，可以进行简单的划分：BeanFactor是Spring框架的基础设施，面向Spring本身；ApplicationContext面向使用Spring框架的开发者，几乎所有的应用场合都可以直接使用ApplicationContext而非底层的BeanFactory。</p>
<p>（1）BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：<br>①继承MessageSource，因此支持国际化。<br>②统一的资源文件访问方式。<br>③提供在监听器中注册bean的事件。<br>④同时加载多个配置文件。<br>⑤载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p>
<p>（2）BeanFactory通常是使用编程方式被创建的，而ApplicationContext可以用声明（就是用配置的方式）的方式创建，当然也可以使用ApplicationContext的实现类之一用编码方式来创建ApplicationContext的实例.</p>
<p>（3）BeanFactory采用的是延迟加载形式来注入bean的，只有在使用到getBean() 时，才对该bean进行加载实例化，这样我们就不能发现一些bean的配置问题。而ApplicationContext则相反，它是在容器启动的时候，一次性创建所有的bean，这样在容器启动时就能发现spring 中存在的配置错误。这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<p>（4）BeanFactory和ApplicationContext都支持BeanPostProcesser、BeanFactoryPostProcessor的使用，但两者的区别是：BeanFactory是手动注册的，ApplicationContext是自动注册的.</p>
<h3 id="ApplicationContext的创建方式"><a href="#ApplicationContext的创建方式" class="headerlink" title="ApplicationContext的创建方式"></a>ApplicationContext的创建方式</h3><h4 id="使用代码方式"><a href="#使用代码方式" class="headerlink" title="使用代码方式"></a>使用代码方式</h4><p>ApplicationContext接口常用实现类：</p>
<p>1.ClassPathXmlApplicationContext</p>
<p>a.加载单个配置文件方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext cxt = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure>

<p>b.加载多个配置文件方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] configs = &#123;&quot;bean1.xml&quot;,&quot;bean2.xml&quot;,&quot;bean3.xml&quot;&#125;;</span><br><span class="line">ApplicationContext cxt = new ClassPathXmlApplicationContext(configs);</span><br></pre></td></tr></table></figure>

<p>2.ConfigurableApplicationContext接口</p>
<p>StartApplication中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 启动springboot应用，获取spring的ioc容器</span><br><span class="line">ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br></pre></td></tr></table></figure>

<h4 id="使用配置-声明"><a href="#使用配置-声明" class="headerlink" title="使用配置(声明)"></a>使用配置(声明)</h4><p>在javaee应用中向Servlet容器中注入Spring容器的方法</p>
<p>ContextLoader 接口，它有两个实现 :ContextLoaderListener 和 ContextLoaderServlet. 其中常用的是 ContextLoaderListener. 从 spring 文档上可以查到，他们二者实现的功能基本一样，只是 ContextLoaderListener 不能在与 Servlet2.2 兼容的 web 容器中使用。另外，因为 ContextLoaderLitener 是一个 servlet Listener ，因此，它是在 servlet context 建立后立即执行，也就以为这 servlet 已建立， spring 的 ApplicationContext 就得到了初始化，并且能够相应第一个请求，所以首选 ContextLoaderListener.</p>
<p>在web.xml中添加如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;? xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; </span><br><span class="line"> &lt;! DOCTYPE web-app</span><br><span class="line">      PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span><br><span class="line">      &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt; </span><br><span class="line"> </span><br><span class="line"> &lt; web-app &gt; </span><br><span class="line">     &lt; display-name &gt; Baselib Application &lt;/ display-name &gt; </span><br><span class="line">    </span><br><span class="line">     &lt; context-param &gt; </span><br><span class="line">        &lt; param-name &gt; contextConfigLocation &lt;/ param-name &gt; </span><br><span class="line">        &lt; param-value &gt; </span><br><span class="line">        /WEB-INF/classes/spring-sup-middelbeans.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-action.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-beans.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-cm.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-hibernate.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-resource.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-sso.xml</span><br><span class="line">        /WEB-INF/classes/com/javaeye/jert/application_context.xml</span><br><span class="line">        &lt;/ param-value &gt; </span><br><span class="line">    &lt;/ context-param &gt; </span><br><span class="line"></span><br><span class="line">    &lt; listener &gt; </span><br><span class="line">        &lt; listener-class &gt; org.springframework.web.context.ContextLoaderListener &lt;/ listener-class &gt; </span><br><span class="line">    &lt;/ listener &gt; </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; param-value &gt; /WEB-INF/classes/spring-*.xml &lt;/ context-param &gt; </span><br></pre></td></tr></table></figure>

<p>这里主要是配置了 spring 的监听器 ContextLoaderListener ，它检查 contextConfigLocation 这个参数。如果它不存在的话，它将用 &#x2F;WEB-INF&#x2F;applicationContext.xml 作为默认的配置文件。如果 contextConfigLocation 存在的话，它将根据该参数的值查找配置文件的位置，来一一读取 spring 参数。</p>
<p>contextConfigLocation 是被 spring 固定的，专门用来查  找配置文件位置的.</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/sole_ghost/article/details/1389664">https://blog.csdn.net/sole_ghost/article/details/1389664</a></p>
<h3 id="ApplicationContext-getBean"><a href="#ApplicationContext-getBean" class="headerlink" title="ApplicationContext.getBean"></a>ApplicationContext.getBean</h3><p>目的：获取Spring容器中已初始化的bean</p>
<p>第一种：getBean(String name)<br>参数name表示IOC容器中已经实例化的bean的id或者name,<br>在IOC容器中是唯一的不能重名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">Person p = (Person) ctx.getBean(&quot;p&quot;);</span><br></pre></td></tr></table></figure>

<p>第二种：getBean(Class<T> type)<br>type表示要加载的Bean的类型。<br>如果该类型没有继承任何父类(Object类除外)和实现接口的话，那么要求该类型的bean在IOC容器中也必须是唯一的.(比如定义同一类的两个bean，但是property注入的属性不一样)<br>不需要类型转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">Person p = ctx.getBean(Person.class);</span><br></pre></td></tr></table></figure>

<p>第三种：getBean(String name,Class<T> type)<br>这种方式比较适合接口&#x2F;抽象类，有不同实现类或子类时，type写接口或父类，name写bean name。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = ctx.getBean(&quot;person&quot;,BasePerson.class);</span><br></pre></td></tr></table></figure>

<p>第四种： getBean(String name,Object[] args)<br>第二个参数Object[] args可以给bean的属性赋值，赋值的方式有两种：构造方法和工厂方法。但是通过这种方式获取的bean必须把scope属性设置为prototype，也就是非单例模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.构造方法方式：</span><br><span class="line">&lt;bean name=&quot;p3&quot; class=&quot;com.bean.Person&quot; scope=&quot;prototype&quot;/&gt;</span><br><span class="line"></span><br><span class="line">Person p = (Person) ctx.getBean(&quot;p3&quot;,new Object[]&#123;&quot;王五&quot;,35&#125;);</span><br><span class="line"></span><br><span class="line">2.工厂注入方式：</span><br><span class="line">工厂类：</span><br><span class="line">public class PersonFactory &#123;</span><br><span class="line">//静态工厂注入</span><br><span class="line">public static Person getPersonInstance(String name,int age)throws Exception</span><br><span class="line">&#123;</span><br><span class="line">  Person p = (Person)Class.forName(&quot;com.bean.Person&quot;).newInstance();</span><br><span class="line">   Method m = p.getClass().getMethod(&quot;setName&quot;, java.lang.String.class);</span><br><span class="line">   m.invoke(p, name);</span><br><span class="line">   m = p.getClass().getMethod(&quot;setAge&quot;, int.class);</span><br><span class="line">   m.invoke(p, age);</span><br><span class="line">   return p;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">配置bean：</span><br><span class="line">&lt;bean name=&quot;p3&quot; class=&quot;com.factory.PersonFactory&quot; factory-method=&quot;getPersonInstance&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;name&quot;&gt;</span><br><span class="line">&lt;null/&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;age&quot; value=&quot;0&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">Person p = (Person) ctx.getBean(&quot;p3&quot;,new Object[]&#123;&quot;王五&quot;,35&#125;);</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_23927391/article/details/80625578">https://blog.csdn.net/qq_23927391/article/details/80625578</a></p>
<h3 id="ApplicationContext-getBeanWithAnnotation"><a href="#ApplicationContext-getBeanWithAnnotation" class="headerlink" title="ApplicationContext.getBeanWithAnnotation"></a>ApplicationContext.getBeanWithAnnotation</h3><p>spring中可以通过getBeansWithAnnotation来获取ioc容器中使用了某个注解的所有bean,这个方法底层原理：我们知道可以通过反射来获取一个类中所有的注解，然后通过遍历spring容器中所有bean就能获取需要的结果。返回Map&lt;String, Object&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//自定义@Auditable注解</span><br><span class="line">package com.yk.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line">public @interface Auditable &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//在person类中我们引入@Auditable，并通过@Component将其注入spring容器</span><br><span class="line">package com.yk.annotation;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Auditable(&quot;person.sleep&quot;)</span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    void sleep()&#123;</span><br><span class="line">        System.out.println(&quot;睡觉了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class TestApplicationContext implements ApplicationContextAware &#123;</span><br><span class="line"> </span><br><span class="line">    protected ApplicationContext applicationContext;</span><br><span class="line">	</span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() throws Exception &#123;</span><br><span class="line">        Class aClass = Class.forName(&quot;com.yk.annotation.Auditable&quot;);</span><br><span class="line">        //boolean b = aClass.isAnnotation();</span><br><span class="line">        //System.out.println(b);</span><br><span class="line">        //Person person = applicationContext.getBean(Person.class);</span><br><span class="line">        Map beansWithAnnotation = applicationContext.getBeansWithAnnotation(aClass);</span><br><span class="line"></span><br><span class="line">        Iterator entries = beansWithAnnotation.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        while (entries.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">            Map.Entry entry = (Map.Entry) entries.next();</span><br><span class="line">            System.out.println(&quot;Key = &quot; + entry.getKey() + &quot;, Value = &quot; + entry.getValue());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42374693/article/details/115374179">https://blog.csdn.net/weixin_42374693/article/details/115374179</a></p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>一个使用工厂模式管理多个类实现同一个接口的例子：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33898233/article/details/91414228">https://blog.csdn.net/weixin_33898233/article/details/91414228</a></p>
<p><code>applicationContext.getBeansOfType(Sort.class);</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/22/myblog/spring/spring%E6%A1%86%E6%9E%B6%E4%B9%8Bbean%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/22/myblog/spring/spring%E6%A1%86%E6%9E%B6%E4%B9%8Bbean%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">spring框架@Bean注解、拦截器、监听器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-22 22:14:57" itemprop="dateCreated datePublished" datetime="2022-04-22T22:14:57+08:00">2022-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-04 15:32:59" itemprop="dateModified" datetime="2023-06-04T15:32:59+08:00">2023-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring%E7%90%86%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">spring理解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Bean注解"><a href="#Bean注解" class="headerlink" title="@Bean注解"></a>@Bean注解</h3><p>作用在方法上的注解，Spring的@Bean注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。(和xml配置中的bean标签的作用是一样的)</p>
<p>@Bean主要用在@Configuration注解的类中，也可以用在@Component注解的类中。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"> </span><br><span class="line">    // 使用@Bean 注解表明myBean需要交给Spring进行管理</span><br><span class="line">    // 未指定bean 的名称，默认采用的是方法名的配置方式</span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean buildMyBean()&#123;</span><br><span class="line">        return new MyBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class MyBean &#123;</span><br><span class="line"> </span><br><span class="line">    public MyBean()&#123;</span><br><span class="line">        System.out.println(&quot;MyBean Initializing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个测试类SpringBeanApplicationTests，测试上述代码的正确性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SpringBeanApplicationTests &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        context.getBean(&quot;buildMyBean&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Bean的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">value：bean别名和name是相互依赖关联的，value,name如果都使用的话值必须要一致；</span><br><span class="line"></span><br><span class="line">name：bean名称，如果不写会默认为注解的方法名称；</span><br><span class="line"></span><br><span class="line">autowire：自定装配默认是不开启的，建议尽量不要开启，因为自动装配不能装配基本数据类型、字符串、数组等，这是自动装配设计的局限性，并且自动装配不如依赖注入精确；</span><br><span class="line"></span><br><span class="line">initMethod：bean的初始化之前的执行方法，该参数一般不怎么用，因为完全可以在代码中实现；</span><br><span class="line"></span><br><span class="line">destroyMethod：默认使用javaConfig配置的bean，如果存在close或者shutdown方法，则在bean销毁时会自动执行该方法，如果你不想执行该方法，则添加@Bean(destroyMethod=&quot;&quot;)来防止出发销毁方法；</span><br></pre></td></tr></table></figure>

<p>Spring中的@Bean注解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_36380516/article/details/119194065">https://blog.csdn.net/weixin_36380516/article/details/119194065</a></p>
<h3 id="Bean和-Component"><a href="#Bean和-Component" class="headerlink" title="@Bean和@Component"></a>@Bean和@Component</h3><ul>
<li>@Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。</li>
<li>@Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑。</li>
</ul>
<p>相同点：两者的结果都是为spring容器注册Bean.<br>不同点：@Component 通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中。<br>　　　　@Bean 注解通常是我们在标有该注解的方法中定义产生这个bean的逻辑。</p>
<blockquote>
<p>@Component （@Controller @Service @Respository）作用于类上，只有在我们的SpringBoot应用程序启用了组件扫描并且包含了被注解的类时才有效。通过组件扫描，Spring将扫描整个类路径，并将所有@Component注释类添加到Spring Context，这里有的不足就是会把整个类当成bean注册到spring 容器上，如果这个类中并不是所有方法都需要注册为bean的话，会出现不需要的方法都注册成为bean，这时候必须确保这些不需要的方法也能注册为bean或者在扫描中加filter 过滤这些不需要的bean,否者spring将无法成功启动。</p>
</blockquote>
<blockquote>
<p>@Bean相对来说就更加灵活了，它可以独立加在方法上，按需注册到spring容器，而且如果你要用到第三方类库里面某个方法的时候（或者类？），你就只能用@Bean把这个方法注册到spring容器，因为用@Component你需要配置组件扫描到这个第三方类路径而且还要在别人源代码加上这个注解，很明显是不现实的。</p>
</blockquote>
<p>❤️当我们引用第三方库中的类需要装配到Spring容器时，则只能通过@Bean来实现<br>总结：@Component和@Bean都是用来注册Bean并装配到Spring容器中，但是Bean比Component的自定义性更强。可以实现一些Component实现不了的自定义加载类。特别是二方库或三方库的类装配为bean，只能用@Bean。</p>
<h3 id="实现FactoryBean接口"><a href="#实现FactoryBean接口" class="headerlink" title="实现FactoryBean接口"></a>实现FactoryBean接口</h3><p>org.springframework.beans.factory中</p>
<p>FactoryBean是一个工厂Bean，可以生成某一个类型Bean实例，它最大的一个作用是：可以让我们自定义Bean的创建过程。BeanFactory是Spring容器中的一个基本类也是很重要的一个类，在BeanFactory中可以创建和管理Spring容器中的Bean，它对于Bean的创建有一个统一的流程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface FactoryBean&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //返回的对象实例</span><br><span class="line">    T getObject() throws Exception;</span><br><span class="line">    //Bean的类型</span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line">    //true是单例，false是非单例  在Spring5.0中此方法利用了JDK1.8的新特性变成了default方法，返回true</span><br><span class="line">    boolean isSingleton();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FactoryBean中定义了一个Spring Bean的很重要的三个特性：是否单例、Bean类型、Bean实例。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//FactoryBean接口的实现类</span><br><span class="line">@Component</span><br><span class="line">public class FactoryBeanLearn implements FactoryBean &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object getObject() throws Exception &#123;</span><br><span class="line">        //这个Bean是我们自己new的，这里我们就可以控制Bean的创建过程了</span><br><span class="line">        return new FactoryBeanServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        return FactoryBeanService.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isSingleton() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//接口</span><br><span class="line">public interface FactoryBeanService &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 测试FactoryBean</span><br><span class="line">     */</span><br><span class="line">    void testFactoryBean();</span><br><span class="line">&#125;</span><br><span class="line">//实现类</span><br><span class="line">public class FactoryBeanServiceImpl implements FactoryBeanService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 测试FactoryBean</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void testFactoryBean() &#123;</span><br><span class="line">        System.out.println(&quot;我是FactoryBean的一个测试类。。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//单测</span><br><span class="line">@Test</span><br><span class="line">public void test() &#123;</span><br><span class="line">        ClassPathXmlApplicationContext cac = new ClassPathXmlApplicationContext(&quot;classpath:com/zkn/spring/learn/base/applicationContext.xml&quot;);</span><br><span class="line">        FactoryBeanService beanService = cac.getBean(FactoryBeanService.class);</span><br><span class="line">        beanService.testFactoryBean();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>❤️FactoryBean是自定义了一种注入Bean的方法，在类中没有加注解，也没有xml中配置，但是实现FactoryBean接口，重写getObject方法来返回对象，表示注入了bean，重写getObjectType表示获取bean时bean的类型。然后就可以通过getBean(类型.class)获取bean实例了。<br>至于，如何通过ApplicationContext.getBean()，见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zknxx/article/details/79572387">https://blog.csdn.net/zknxx/article/details/79572387</a></p>
<h3 id="ApplicationContextAware接口"><a href="#ApplicationContextAware接口" class="headerlink" title="ApplicationContextAware接口"></a>ApplicationContextAware接口</h3><p>org.springframework.context中</p>
<p>当一个类实现了这个接口之后，这个类就可以方便的获得ApplicationContext对象（spring上下文），Spring发现某个Bean实现了ApplicationContextAware接口，Spring容器会在创建该Bean之后，自动调用该Bean的setApplicationContext（参数）方法，调用该方法时，会将容器本身ApplicationContext对象作为参数传递给该方法。</p>
<p>❤️之前获取ApplicationContext需要加载配置文件从而创建应用上下文，但是实现了ApplicationContextAware接口，spring自动将容器本身ApplicationContext对象传递给其中的方法setApplicationContext。实现它的类，可以在类中创建私有的ApplicationContext变量，在setApplicationContext中this. &#x3D; 进行传递。</p>
<p>实现ApplicationContextAware接口可以方便获取ApplicationContext，即spring容器，获取容器之后就可以方便获取bean。</p>
<p>例子：<br>获取一个排序工厂：</p>
<p>排序接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Sort &#123;</span><br><span class="line">    SortType getSortType();</span><br><span class="line">    int[] sorting(int[] sourceArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排序算法实现接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SelectionSort implements Sort &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public SortType getSortType() &#123;</span><br><span class="line">        return SortType.SELECTION;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public int[] sorting(int[] sourceArray) &#123;</span><br><span class="line">        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"> </span><br><span class="line">        // 总共要经过 N-1 轮比较</span><br><span class="line">        for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            int min = i;</span><br><span class="line"> </span><br><span class="line">            // 每轮需要比较的次数 N-i</span><br><span class="line">            for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                if (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                    // 记录目前能找到的最小值元素的下标</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // 将找到的最小值和i位置所在的值进行交换</span><br><span class="line">            if (i != min) &#123;</span><br><span class="line">                int temp = arr[i];</span><br><span class="line">                arr[i] = arr[min];</span><br><span class="line">                arr[min] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举排序类型:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum SortType &#123;</span><br><span class="line">    SELECTION,</span><br><span class="line">    BUBBLE,</span><br><span class="line">    INSERT,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排序工厂，实现 ApplicationContextAware 接口:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SortFactory implements ApplicationContextAware &#123;</span><br><span class="line">    private static Map&lt;SortType, Sort&gt; sortBeanMap = new ConcurrentHashMap&lt;&gt;(16);</span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        Map&lt;String, Sort&gt; map = applicationContext.getBeansOfType(Sort.class);</span><br><span class="line">        map.forEach((key, value) -&gt; sortBeanMap.put(value.getSortType(), value));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int[] sorting(SortType sortType, int[] sourceArray) &#123;</span><br><span class="line">        Sort sort = sortBeanMap.get(sortType);</span><br><span class="line">        return sort.sorting(sourceArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class SortController &#123;</span><br><span class="line"> </span><br><span class="line">    private final SortFactory sortFactory;</span><br><span class="line"> </span><br><span class="line">    public SortController(SortFactory sortFactory) &#123;</span><br><span class="line">        this.sortFactory = sortFactory;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @PostMapping(value = &quot;factory/sort&quot;)</span><br><span class="line">    public Object sortFactory(SortType sortType, int[] sourceArr) &#123;</span><br><span class="line">        return sortFactory.sorting(sortType, sourceArr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33898233/article/details/91414228">https://blog.csdn.net/weixin_33898233/article/details/91414228</a></p>
<h3 id="InitialzingBean接口"><a href="#InitialzingBean接口" class="headerlink" title="InitialzingBean接口"></a>InitialzingBean接口</h3><p>当一个类实现这个接口之后，Spring启动后，初始化Bean时，若该Bean实现InitialzingBean接口，会自动调用afterPropertiesSet()方法，完成一些用户自定义的初始化操作。</p>
<p>同样配置Bean的时候使用init-method也可以实现类似的操作。（不需要实现InitialzingBean接口）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void afterPropertiesSet() throws Exception &#123;&#125;</span><br><span class="line"></span><br><span class="line">&lt;bean id = &quot;springBeanInit02&quot; class = &quot;com.lyj.studySpringBoot.init.SpringBeanInit&quot; init-method=&quot;testInit&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;id&quot; value=&quot;#&#123;1111111&#125;&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;$&#123;test.springEL&#125;&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;age&quot; value=&quot;#&#123;10+8&#125;&quot; /&gt; // SpringEL表达式</span><br><span class="line">	&lt;property name=&quot;sex&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">系统是先调用afterPropertiesSet方法，然后在调用init-method中指定的方法。</span><br></pre></td></tr></table></figure>

<p>Spring是通过反射来调用init-method指定方法，而实现InitializingBean接口是直接调用afterPropertiesSet方法，所以后者效率高，但使用init-method方式减少了对Spring的依赖。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40093255/article/details/117318760">https://blog.csdn.net/qq_40093255/article/details/117318760</a></p>
<h3 id="MethodInterceptor接口-拦截器"><a href="#MethodInterceptor接口-拦截器" class="headerlink" title="MethodInterceptor接口-拦截器"></a>MethodInterceptor接口-拦截器</h3><p>org.aopalliance.intercept中<br>MethodInterceptor接口继承了Interceptor接口，Intercepto接口又继承了Advice接口，因此我个将这拦截器称为一个通知。</p>
<p>实现MethodInterceptor 接口，在调用目标对象的方法时，就可以实现在调用方法之前、调用方法过程中、调用方法之后对其进行控制。</p>
<p>拦截器就像是建立了一个通知。用切面做增强一样。</p>
<p>简单的例子：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012834750/article/details/71773887">https://blog.csdn.net/u012834750/article/details/71773887</a><br>1.实现接口重写invoke方法，做增强<br>2.写一个简单方法<br>3.测试中，用代理工厂设置代理对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class TestMethodInterceptor  &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 初始化一个代理工厂</span><br><span class="line">        ProxyFactory proxyFactory=new ProxyFactory();</span><br><span class="line"></span><br><span class="line">        // 设置目标类，以便于Cglib工具包动态生成目标类的子类，即我们所需的代理类</span><br><span class="line">        // 最好把实现类单独写，这里设置的是实现类（业务）</span><br><span class="line">        proxyFactory.setTarget(new TestMethodInterceptor());</span><br><span class="line"></span><br><span class="line">        // 设置拦截器，而拦截器的&quot;public Object invoke(MethodInvocation mi)&quot;定义了代理类（实际是UserDaoImpl的子类）的方法生成策略。</span><br><span class="line">        proxyFactory.addAdvice(new adviseMethodInterceptor());</span><br><span class="line"></span><br><span class="line">        // 获取代理类</span><br><span class="line">        Object proxy = proxyFactory.getProxy();</span><br><span class="line">         // 向上转型，转型为父类类型</span><br><span class="line">        TestMethodInterceptor methodInterceptor = (TestMethodInterceptor) proxy;</span><br><span class="line"></span><br><span class="line">        methodInterceptor.doSomeThing(&quot;通过代理工厂设置代理对象，拦截代理方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class adviseMethodInterceptor implements MethodInterceptor&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">            Object result=null;</span><br><span class="line">            try&#123;</span><br><span class="line">                System.out.println(&quot;方法执行之前：&quot;+methodInvocation.getMethod().toString());</span><br><span class="line"></span><br><span class="line">                result= methodInvocation.proceed();</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;方法执行之后：&quot;+methodInvocation.getMethod().toString());</span><br><span class="line">                System.out.println(&quot;方法正常运行结果：&quot;+result);</span><br><span class="line"></span><br><span class="line">                return result;</span><br><span class="line"></span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                System.out.println(&quot;方法出现异常:&quot;+e.toString());</span><br><span class="line">                System.out.println(&quot;方法运行Exception结果：&quot;+result);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String doSomeThing(String someThing)&#123;</span><br><span class="line"></span><br><span class="line">        //int i=5/0;</span><br><span class="line">        return &quot;执行被拦截的方法：&quot;+someThing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AOP都是基于（Cglib）代理模式实现的，其中的关键点在于实现MethodInterceptor接口，在其“public Object invoke(MethodInvocation mi)”方法中制定代理方法的生成策略，而从此方法的MethodInvocation类型参数mi中可以获得目标对象、目标方法、方法的参数等信息，根据这些信息可以精确地控制增强效果。</p>
<p>invoke方法的传参是MethodInvocation，表示方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 获取方法名</span><br><span class="line">String methodName = mi.getMethod().getName();</span><br><span class="line">if (methodName.startsWith(&quot;add&quot;))</span><br><span class="line"></span><br><span class="line">// 执行目标方法</span><br><span class="line">result= methodInvocation.proceed();</span><br><span class="line"></span><br><span class="line">// 获取方法参数</span><br><span class="line">Object[] args = methodInvocation.getArguments();</span><br></pre></td></tr></table></figure>

<p>另一个比较复杂的例子：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gocode/p/aop-in-spring.html">https://www.cnblogs.com/gocode/p/aop-in-spring.html</a></p>
<p>❤️总结：拦截器，可以以动态代理的方式执行方法，另一个作用是创建一个切面，具体的通知在invoke中加，传入参数可以获取目标对象、方法、方法参数，从而选择对不同切入点进行不同的通知&#x2F;增强。也可以不加通知，只是proceed执行本方法。</p>
<p>✅拦截器为什么一定要加@Component？</p>
<p>在Spring 框架中，使用 @Component注解将一个类标记为组件，表示这个类可以被 Spring 容器扫描并创建实例。<br>在AOP中，切面类需要被 Spring 容器管理，所以需要将这个类加上@Component注解，以便被Spring 容器扫描并创建实例。如果不加@Component注解，这个切面类就不会被Spring 容器管理，也就无法执行拦截的逻辑。<br>另外，如果这个切面类需要注入其他依赖，比如数据源、缓存等，也需要加上 @Component注解，以便被 Spring容器管理。如果不加 @Component 注解，这些依赖也无法被注入，会导致代码出现错误。<br>总之，加上@Component注解可以让这个切面类被 Spring 容器管理，以便执行拦截的逻辑，并注入其他依赖，确保代码的正确性和可维护性。</p>
<h3 id="ApplicationListener接口-监听器"><a href="#ApplicationListener接口-监听器" class="headerlink" title="ApplicationListener接口-监听器"></a>ApplicationListener接口-监听器</h3><p>ApplicationContext事件机制是观察者设计模式的实现，通过ApplicationEvent类和ApplicationListener接口，可以实现ApplicationContext事件处理。</p>
<p>如果容器中有一个ApplicationListener Bean，每当ApplicationContext发布ApplicationEvent时，ApplicationListener Bean将自动被触发。这种事件机制都必须需要程序显示publish的触发。</p>
<p>事件可以自定义、监听也可以自定义，完全根据自己的业务逻辑来处理。</p>
<p>1.定义事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class EmailEvent extends ApplicationEvent&#123;</span><br><span class="line">　　 private String address;</span><br><span class="line">　　 private String text;</span><br><span class="line">　　 public EmailEvent(Object source, String address, String text)&#123;</span><br><span class="line">　　 super(source);</span><br><span class="line">　　　　　 this.address = address;</span><br><span class="line">　　　　　 this.text = text;</span><br><span class="line">　　 &#125;</span><br><span class="line">　　 public EmailEvent(Object source) &#123;</span><br><span class="line">　　　　　super(source);</span><br><span class="line">　　 &#125;</span><br><span class="line">　　 //......address和text的setter、getter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.监听事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class EmailNotifier implements ApplicationListener&#123;</span><br><span class="line">    // 监听后事件处理的方法，可以对事件做一些判断</span><br><span class="line">　　 public void onApplicationEvent(ApplicationEvent event) &#123;</span><br><span class="line">　　　　　if (event instanceof EmailEvent) &#123;</span><br><span class="line">　　　　　　　 EmailEvent emailEvent = (EmailEvent)event;</span><br><span class="line">　　　　　　　 System.out.println(&quot;邮件地址：&quot; + emailEvent.getAddress());</span><br><span class="line">　　　　　　　 System.our.println(&quot;邮件内容：&quot; + emailEvent.getText());</span><br><span class="line">　　　　　&#125; else &#123;</span><br><span class="line">　　　　　　　 System.our.println(&quot;容器本身事件：&quot; + event);</span><br><span class="line">　　　　　&#125;</span><br><span class="line">　　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.触发事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SpringTest &#123;</span><br><span class="line">　　 public static void main(String args[])&#123;</span><br><span class="line">　　　　　ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</span><br><span class="line">　　　　　//创建一个ApplicationEvent对象</span><br><span class="line">　　　　　EmailEvent event = new EmailEvent(&quot;hello&quot;,&quot;abc@163.com&quot;,&quot;This is a test&quot;);</span><br><span class="line">　　　　　//主动触发该事件</span><br><span class="line">　　　　　context.publishEvent(event);</span><br><span class="line">　　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在拦截器中做增强触发。</p>
<p>不管是内置监听还是外部自定义监听一定要把实现ApplicationListener的类定义成一个bean才行，可以是通过注解@Component等也可以通过xml的方式去执行。</p>
<p>监听器实现类实现的ApplicationListener接口中，可以加范型，事件类型。</p>
<h3 id="接口防刷"><a href="#接口防刷" class="headerlink" title="接口防刷"></a>接口防刷</h3><p>写一个通用类用redis锁来实现，需要前段传一个东西来表示redis的key：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32871365/article/details/122113652">https://blog.csdn.net/qq_32871365/article/details/122113652</a></p>
<p>在前段访问前，先从后端申请一个token，然后拿这tocken访问，后端校验tocken：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42071874/article/details/90402099">https://blog.csdn.net/weixin_42071874/article/details/90402099</a></p>
<p>自定义注解+redis+拦截器的方法：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40918145/article/details/108734614">https://blog.csdn.net/weixin_40918145/article/details/108734614</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45637260/article/details/127692497">https://blog.csdn.net/qq_45637260/article/details/127692497</a><br>1.写一个自定义注解传可访问次数<br>2.写一个拦截器，获取自定义注解，并且获取HttpServletRequest，从中获取ip，然后redis记录访问次数<br>3.配置拦截器WebMvcConfigurerAdapter<br>4.controller接口方法上加自定义注解</p>
<p>同样是以ip为维度，拦截器&#x2F;aop：<br><a target="_blank" rel="noopener" href="https://www.jb51.net/article/205093.htm">https://www.jb51.net/article/205093.htm</a></p>
<p>自定义注解：切面aop：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34033209/article/details/118601590">https://blog.csdn.net/qq_34033209/article/details/118601590</a></p>
<p>tocken：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/LilLazy/p/14708539.html">https://www.cnblogs.com/LilLazy/p/14708539.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/14/myblog/java/java%20junit%E4%B8%8Emock%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/14/myblog/java/java%20junit%E4%B8%8Emock%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">java的junit与mock测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-14 22:22:37" itemprop="dateCreated datePublished" datetime="2022-04-14T22:22:37+08:00">2022-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-18 14:13:33" itemprop="dateModified" datetime="2023-02-18T14:13:33+08:00">2023-02-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>单元测试(Unit test)：<br>单元测试关注单一的类. 它们存在的目的是检查这个类中的代码是否按照期望正确运行.<br>特征：快速、独立、可重复、自检查（不加main不打日志）<br>核心价值：缩短反馈周期，降低缺陷修复成本，理解代码意图</p>
<p>集成测试(Integration test)<br>顾名思义, 集成测试是检查开发的模块和其他模块整合时是否正常工作.<br>虽然集成测试的代码影响范围比单元测试要广, 但是集成测试和单元测试一样, 也是针对于开发者而言的.<br>集成测试是对外部系统（数据库、消息队列等）有依赖的测试。</p>
<p>端到端测试(End-to-End test)<br>端到端测试是将整个系统作为一个整体, 然后从用户的角度进行测试的.<br>端到端测试的目的是测试系统在实际使用的是否正常的, 因此通常来说是不需要测试替身的(Test Double)</p>
<h2 id="1-Junit单元测试"><a href="#1-Junit单元测试" class="headerlink" title="1.Junit单元测试"></a>1.Junit单元测试</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>单元测试的目的: 测试当前所写的代码是否是正确的, 例如输入一组数据, 会输出期望的数据; 输入错误数据, 会产生错误异常等.</p>
<p>在单元测试中, 我们需要保证被测系统是独立的(SUT 没有任何的 DOC), 即当被测系统通过测试时, 那么它在任何环境下都是能够正常工作的. 编写单元测试时, 仅仅需要关注单个类就可以了. 而不需要关注例如数据库服务, Web 服务等组件.</p>
<p>【SUT】被测系统(System under test, SUT) 被测系统。根据测试类型的不同, SUT 指代的内容也不同, 例如 SUT 可以是一个类甚至是一整个系统.</p>
<p>【DOC】被测系统所依赖的组件, 例如进程 UserService 的单元测试时, UserService 会依赖 UserDao, 因此 UserDao 就是 DOC</p>
<p>【Test Double】测试替身<br>一个实际的系统会依赖多个外部对象, 但是在进行单元测试时, 我们会用一些功能较为简单的并且其行为和实际对象类似的假对象来作为 SUT 的依赖对象, 以此来降低单元测试的复杂性和可实现性. 在这里, 这些假对象就被称为 测试替身(Test Double).</p>
<p>测试替身有以下五种：</p>
<p>1.Test stub, 为 SUT 提供数据的假对象。stub 类有时候还会记录调用的一些信息。</p>
<p>2.Fake object，实现了简单功能的一个假对象. Fake object 和 Test stub 的主要区别就是 Test stub 侧重于用于提供数据的假对象, 而 Fake object 没有这层含义，使用 Fake object 的最主要的原因就是在测试时某些组件不可用或运行速度太慢, 因而使用 Fake object 来代替它们.<br>譬如说，它存在内存中而不是真正的数据库中。</p>
<p>3.Mock object<br>是指类或者接口的模拟实现，你可以自定义这个对象中某个方法的输出结果。<br>实际上, Mock object 是 Test stub 或 Fake object 一种, 但是 Mock object 有 Test stub&#x2F;Fake object 没有的特性, Mock object 可以很灵活地配置所调用的方法所产生的行为, 并且它可以追踪方法调用, 例如一个 Mock Object 方法调用时传递了哪些参数, 方法调用了几次等.</p>
<p>4.Dummy object: 在测试中并不使用的, 但是为了测试代码能够正常编译&#x2F;运行而添加的对象. 例如我们调用一个 Test Double 对象的一个方法, 这个方法需要传递几个参数, 但是其中某个参数无论是什么值都不会影响测试的结果, 那么这个参数就是一个 Dummy object.<br>Dummy object 可以是一个空引用, 一个空对象或者是一个常量等.<br>简单的说, Dummy object 就是那些没有使用到的, 仅仅是为了填充参数列表的对象.</p>
<p>5.Test Spy<br>可以包装一个真实的 Java 对象, 并返回一个包装后的新对象. 若没有特别配置的话, 对这个新对象的所有方法调用, 都会委派给实际的 Java 对象.</p>
<p>mock 和 spy 的区别是: mock 是无中生有地生出一个<strong>完全虚拟的对象</strong>, 它的所有方法都是虚拟的; 而 spy 是在现有类的基础上包装了一个对象, 即如果我们没有重写 spy 的方法, 那么这些方法的实现其实都是调用的被包装的对象的方法.</p>
<p>【test fixture】测试的先决条件，<br>@Before 在每个测试方法运行前都会被调用, @After 在每个测试方法运行后都会被调用.<br>因为 @Before 和 @After 会在每个测试方法前后都会被调用, 而有时我们仅仅需要在测试前进行一次初始化, 这样的情况下, 可以使用@BeforeClass 和@AfterClass 注解.</p>
<p>【test case】测试用例<br>在 JUnit 3中, 测试方法都必须以 test 为前缀, 且必须是 public void 的, JUnit 4之后, 就没有这个限制了, 只要在每个测试方法标注 @Test 注解, 方法签名可以是任意的.</p>
<p>【测试套件】通过 TestSuit 对象将多个测试用例组装成一个测试套件, 测试套件批量运行.<br>通过@RunWith 和@SuteClass 两个注解, 我们可以创建一个测试套件. 通过@RunWith 指定一个特殊的运行器, 并通过@SuiteClasses 注解, 将需要进行测试的类列表作为参数传入.</p>
<h3 id="Junit4注解"><a href="#Junit4注解" class="headerlink" title="Junit4注解"></a>Junit4注解</h3><p>@Test (expected &#x3D; Exception.class) 表示预期会抛出Exception.class 的异常</p>
<p>@Ignore 含义是“某些方法尚未完成，暂不参与此次测试”。这样的话测试结果就会提示你有几个测试被忽略，而不是失败。一旦你完成了相应函数，只需要把@Ignore注解删去，就可以进行正常的测试。</p>
<p>@Test(timeout&#x3D;100) 表示预期方法执行不会超过 100 毫秒，控制死循环</p>
<p>@Before 表示该方法在每一个测试方法之前运行，可以使用该方法进行初始化之类的操作</p>
<p>@After 表示该方法在每一个测试方法之后运行，可以使用该方法进行释放资源，回收内存之类的操</p>
<p>@BeforeClass 表示该方法只执行一次，并且在所有方法之前执行。一般可以使用该方法进行数据库连接操作，注意该注解运用在静态方法。</p>
<p>@AfterClass 表示该方法只执行一次，并且在所有方法之后执行。一般可以使用该方法进行数据库连接关闭操作，注意该注解运用在静态方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import org.junit.runner.RunWith;  </span><br><span class="line">import org.junit.runners.Suite;  </span><br><span class="line">import org.junit.runners.Suite.SuiteClasses;  </span><br><span class="line">  </span><br><span class="line">@RunWith( Suite.class )  </span><br><span class="line">@SuiteClasses( &#123; JUnitTest1.class, JUnitTest2.class &#125; )  </span><br><span class="line">public class AllTests &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有多个测试类, 可以合并成一个测试套件进行测试, 运行一个 Test Suite, 那么就会运行在这个 Test Suite 中的所用的测试.<br>在这个例子中, 我们定义了一个 Test Suite, 这个 Test Suite 包含了两个测试类: JUnitTest1 和 JUnitTest2, 因此运行 这个 Test Suite 时, 就会自动运行这两个测试类了.</p>
<p>*在类名上按下command+shift+t，就可以生成对应测试类。</p>
<p>来源：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006731125">https://segmentfault.com/a/1190000006731125</a></p>
<h2 id="2-Mockito中-Mock与-InjectMock"><a href="#2-Mockito中-Mock与-InjectMock" class="headerlink" title="2.Mockito中@Mock与@InjectMock"></a>2.Mockito中@Mock与@InjectMock</h2><p>Mockito 是一个流行 mock 框架，可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象。<br>Mockito是java单元测试中，最常用的mck工具之一，提供了诸多打桩方法和注解。其中有两个比较常用的注解，@Mock和@InjectMock，名字和在代码中使用 的位置都很像。但是是在功能上无任何可类比性的完全不同的东西。<br>程序员通常创造模拟对象来测试其他对象的行为，很类似汽车设计者使用碰撞测试假人来模拟车辆碰撞中人的动态行为。</p>
<p>为什么使用mock？<br>在单元测试中，模拟对象可以模拟复杂的、真实的（非模拟）对象的行为， 如果真实的对象无法放入单元测试中，使用模拟对象就很有帮助。</p>
<p>单元测试的思路是在不涉及依赖关系的情况下测试代码（隔离性），所以测试代码与其他类或者系统的关系应该尽量被消除。一个可行的消除方法是替换掉依赖类（测试替换），也就是说我们可以使用替身来替换掉真正的依赖对象。</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>@Mock：<br>在Mockito中用于创建mock对象，使用方法如下：<br><code>@Mock</code><br><code>private ClassName mockedObject；</code></p>
<p>上面代码创建了一个名为mockedObject，类型为ClassName的mock对象，该对象所有的方法被置空，根据测试代码逻辑的需要使用.</p>
<hr>
<p>@InjectMock：<br>创建一个实例，简单的说是这个Mock可以调用真实代码的方法，其余用@Mock（或@Spy）注解创建的mock将被注入到用该实例中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(MockitoJUnitRunner.class)  </span><br><span class="line">public class Test &#123;  </span><br><span class="line">  </span><br><span class="line">    @InjectMocks  </span><br><span class="line">    private SomeHandler someHandler;  </span><br><span class="line">  </span><br><span class="line">    @Mock  </span><br><span class="line">    private OneDependency oneDependency; // 此mock将被注入到someHandler  </span><br><span class="line"></span><br><span class="line">    // ...   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这段代码中，@InjectMock下面声明了一个待测试的对象，@Mock定义的mock对象将会被注入到这个待测试的对象中。</p>
<hr>
<p>🤔 @Mock创建创建mock对象之后，在对具体的方法打桩之前，mock对象的所有属性和方法全被置空（0或者null），所以，对应的方法是不运行的。<br>*mock对象创建之后，被测试类中的该对象的方法就都不执行了。</p>
<p>🤔 @Spy可以创建的对象的所有成员方法都会按照原方法的逻辑执行，直到被打桩返回某个具体的值。</p>
<p>来源：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/langren1992/p/9681600.html">https://www.cnblogs.com/langren1992/p/9681600.html</a></p>
<h3 id="mock使用"><a href="#mock使用" class="headerlink" title="mock使用"></a>mock使用</h3><p>maven注入依赖。</p>
<p>如果你使用注解，那么必须要实例化 mock 对象。Mockito 在遇到使用注解的字段的时候必须使用@RunWith(MockitoJUnitRunner.class) 或 MockitoAnnotations.initMocks(this)进行mocks的初始化和注入。<br>(可以写一个init函数，加@Before注解)</p>
<h4 id="配置mock"><a href="#配置mock" class="headerlink" title="配置mock"></a>配置mock</h4><p>when(…​.).thenReturn(…​.)可以被用来定义当条件满足时函数的返回值，当多次调用函数的时候，Mockito 会根据你定义的先后顺序来返回返回值（多次调用）。Mocks 还可以根据传入参数的不同来定义不同的返回值。譬如说你的函数可以将anyString 或者 anyInt作为输入参数，然后定义其特定的放回值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import static org.mockito.Mockito.*;</span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test1()  &#123;</span><br><span class="line">        //  创建 mock</span><br><span class="line">        MyClass test = Mockito.mock(MyClass.class);</span><br><span class="line"></span><br><span class="line">        // 自定义 getUniqueId() 的返回值</span><br><span class="line">        when(test.getUniqueId(Mockito.anyLong())).thenReturn(43);</span><br><span class="line"></span><br><span class="line">        // 在测试中使用mock对象</span><br><span class="line">        assertEquals(test.getUniqueId(), 43);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回多个值</span><br><span class="line">@Test</span><br><span class="line">public void testMoreThanOneReturnValue()  &#123;</span><br><span class="line">        Iterator i= mock(Iterator.class);</span><br><span class="line">        when(i.next()).thenReturn(&quot;Mockito&quot;).thenReturn(&quot;rocks&quot;);</span><br><span class="line">        String result=i.next()+&quot; &quot;+i.next();</span><br><span class="line">        // 断言</span><br><span class="line">        assertEquals(&quot;Mockito rocks&quot;, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如何根据输入来返回值</span><br><span class="line">@Test</span><br><span class="line">public void testReturnValueDependentOnMethodParameter()  &#123;</span><br><span class="line">        Comparable c= mock(Comparable.class);</span><br><span class="line">        when(c.compareTo(&quot;Mockito&quot;)).thenReturn(1);</span><br><span class="line">        when(c.compareTo(&quot;Eclipse&quot;)).thenReturn(2);</span><br><span class="line">        // 断言</span><br><span class="line">        assertEquals(1,c.compareTo(&quot;Mockito&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如何让返回值不依赖于输入</span><br><span class="line">@Test</span><br><span class="line">public void testReturnValueInDependentOnMethodParameter()  &#123;</span><br><span class="line">        Comparable c= mock(Comparable.class);</span><br><span class="line">        when(c.compareTo(anyInt())).thenReturn(-1);</span><br><span class="line">        // 断言</span><br><span class="line">        assertEquals(-1 ,c.compareTo(9));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据参数类型来返回值</span><br><span class="line">@Test</span><br><span class="line">public void testReturnValueInDependentOnMethodParameter()  &#123;</span><br><span class="line">        Comparable c= mock(Comparable.class);</span><br><span class="line">        when(c.compareTo(isA(Todo.class))).thenReturn(0);</span><br><span class="line">        // 断言</span><br><span class="line">        Todo todo = new Todo(5);</span><br><span class="line">        assertEquals(todo ,c.compareTo(new Todo(1)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="无返回值的方法"><a href="#无返回值的方法" class="headerlink" title="无返回值的方法"></a>无返回值的方法</h4><p>mokito中，对无返回的函数什么都不做<br>Mokito.doNothing().when(对象).函数();</p>
<p>对于无返回值的函数，我们可以使用doReturn(…​).when(…​).methodCall来获得类似的效果。例如我们想在调用某些无返回值函数的时候抛出异常，那么可以使用doThrow 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import static org.mockito.Mockito.*;</span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line">// 下面测试用例描述了如何使用doThrow()方法</span><br><span class="line"></span><br><span class="line">@Test(expected=IOException.class)</span><br><span class="line">public void testForIOException() &#123;</span><br><span class="line">        // 创建并配置 mock 对象</span><br><span class="line">        OutputStream mockStream = mock(OutputStream.class);</span><br><span class="line">        doThrow(new IOException()).when(mockStream).close();</span><br><span class="line"></span><br><span class="line">        // 使用 mock</span><br><span class="line">        OutputStreamWriter streamWriter= new OutputStreamWriter(mockStream);</span><br><span class="line">        streamWriter.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="验证是否调用"><a href="#验证是否调用" class="headerlink" title="验证是否调用"></a>验证是否调用</h4><p>验证 query 方法是否被 MyDatabase 的 mock 对象调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import static org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line">public class MockitoTest  &#123;</span><br><span class="line"></span><br><span class="line">        @Mock</span><br><span class="line">        MyDatabase databaseMock; (1)</span><br><span class="line"></span><br><span class="line">        @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); (2)</span><br><span class="line"></span><br><span class="line">        @Test</span><br><span class="line">        public void testQuery()  &#123;</span><br><span class="line">                ClassToTest t  = new ClassToTest(databaseMock); (3)</span><br><span class="line">                boolean check = t.query(&quot;* from t&quot;); (4)</span><br><span class="line">                assertTrue(check); (5)</span><br><span class="line">                verify(databaseMock).query(&quot;* from t&quot;); (6)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mockito 会跟踪 mock 对象里面所有的方法和变量。所以我们可以用来验证函数在传入特定参数的时候是否被调用。这种方式的测试称行为测试，行为测试并不会检查函数的返回值，而是检查在传入正确参数时候函数是否被调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import static org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testVerify()  &#123;</span><br><span class="line">        // 创建并配置 mock 对象</span><br><span class="line">        MyClass test = Mockito.mock(MyClass.class);</span><br><span class="line">        when(test.getUniqueId()).thenReturn(43);</span><br><span class="line"></span><br><span class="line">        // 调用mock对象里面的方法并传入参数为12</span><br><span class="line">        test.testing(12);</span><br><span class="line">        test.getUniqueId();</span><br><span class="line">        test.getUniqueId();</span><br><span class="line"></span><br><span class="line">        // 查看在传入参数为12的时候方法是否被调用</span><br><span class="line">        verify(test).testing(Matchers.eq(12));</span><br><span class="line"></span><br><span class="line">        // 方法是否被调用两次</span><br><span class="line">        verify(test, times(2)).getUniqueId();</span><br><span class="line"></span><br><span class="line">        // 其他用来验证函数是否被调用的方法</span><br><span class="line">        verify(mock, never()).someMethod(&quot;never called&quot;);</span><br><span class="line">        verify(mock, atLeastOnce()).someMethod(&quot;called at least once&quot;);</span><br><span class="line">        verify(mock, atLeast(2)).someMethod(&quot;called at least twice&quot;);</span><br><span class="line">        verify(mock, times(5)).someMethod(&quot;called five times&quot;);</span><br><span class="line">        verify(mock, atMost(3)).someMethod(&quot;called at most 3 times&quot;);</span><br><span class="line">&#125;</span><br><span class="line">前面都加个Mockito.</span><br></pre></td></tr></table></figure>

<h3 id="spy使用"><a href="#spy使用" class="headerlink" title="spy使用"></a>spy使用</h3><p>@Spy或者spy()方法可以被用来封装 java 对象。被封装后，除非特殊声明（打桩 stub），否则都会真正的调用对象里面的每一个方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import static org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line">// Lets mock a LinkedList</span><br><span class="line">List list = new LinkedList();</span><br><span class="line">List spy = spy(list);</span><br><span class="line"></span><br><span class="line">// 可用 doReturn() 来打桩</span><br><span class="line">doReturn(&quot;foo&quot;).when(spy).get(0);</span><br><span class="line"></span><br><span class="line">// 下面代码不生效</span><br><span class="line">// 真正的方法会被调用</span><br><span class="line">// 将会抛出 IndexOutOfBoundsException 的异常，因为 List 为空</span><br><span class="line">when(spy.get(0)).thenReturn(&quot;foo&quot;);</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f6e3ab9719b9">https://www.jianshu.com/p/f6e3ab9719b9</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7b67806b74f6">https://www.jianshu.com/p/7b67806b74f6</a></p>
<h2 id="PowerMockRunner-和-MockitoJUnitRunner"><a href="#PowerMockRunner-和-MockitoJUnitRunner" class="headerlink" title="PowerMockRunner 和 MockitoJUnitRunner"></a>PowerMockRunner 和 MockitoJUnitRunner</h2><p>关于打桩：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/moshowgame/article/details/100983711">https://blog.csdn.net/moshowgame/article/details/100983711</a></p>
<h2 id="when-thenReturn-和-doReturn-when-区别"><a href="#when-thenReturn-和-doReturn-when-区别" class="headerlink" title="when().thenReturn() 和 doReturn().when() 区别"></a>when().thenReturn() 和 doReturn().when() 区别</h2><p>使用@Mock时可以相互替换，但是@Spy时，它们的调用结果不同。<br>1.when().thenReturn() 会调用真实的方法，容易抛出异常<br>2.doReturn().when() 不会调用真实方法</p>
<h2 id="PowerMockito"><a href="#PowerMockito" class="headerlink" title="PowerMockito"></a>PowerMockito</h2><p>PowerMock扩展了EasyMock和Mockito框架，增加了对static和final方法mock支持等功能.<br>PowerMock有两个重要的注解：<br> @RunWith(PowerMockRunner.class)<br> @prepareForTest({MyObject.class})<br> @PrepareForTest注解和@RunWith注解是结合使用的，不要单独使用@PrepareForTest，否则不起作用。当使用PowerMock去mock静态，final或者私有方法时，需要加上这两个注解。<br>————————————————<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/KeeYang108/article/details/79891588">https://blog.csdn.net/KeeYang108/article/details/79891588</a></p>
<h2 id="Mock测试踩坑"><a href="#Mock测试踩坑" class="headerlink" title="Mock测试踩坑"></a>Mock测试踩坑</h2><p>今天写了一个control层的mock单元测试，因为要调service层（实现类）的方法，就把service接口做了一个mock，测试时候一直包空指针异常。<br>mock service实现类之后，正常。</p>
<p>更新：今天@Mock的接口也是可以的，奇怪了：<br>mock接口出现空指针异常的case：是service（.之前的）是实现类，@Autowired的也是实现类，所以mock接口没用？<br>而今天mock接口，被测试类中.之前的是接口，@Autowired的也是接口，所以没毛病。</p>
<p>加@RunWith(PowerMockRunner.class)<br>要测试的类加@InjectMocks</p>
<p>1.service实现类不加mock，到指定方法会报空指针异常，service对象为空<br>2.如果service方法无返回，可以不打桩，如果有返回，最好打个桩。<br>3.有返回的打了桩，可以根据不同的输入，返回不同的结果。有返回如果不打桩，相当于返回的是null，返回如果被后面用到，容易报空指针异常。</p>
<h2 id="Mock测试踩坑空指针异常"><a href="#Mock测试踩坑空指针异常" class="headerlink" title="Mock测试踩坑空指针异常"></a>Mock测试踩坑空指针异常</h2><p>mock测试的被测试类（@InjectMock）中的属性一般为null，所以什么都不加就在被测试类中调用属性对象的方法时，报空指针异常，因为属性对象是null。<br>将属性对象在Test中添加@Mock为mock对象，直接忽略属性对象方法，不进入执行。<br>将属性对象在Test中添加@Spy为spy对象，会进入该方法中，但是只限于一层，再进入就不行了，还是会报空指针异常。</p>
<hr>
<h2 id="单元测试框架和步骤"><a href="#单元测试框架和步骤" class="headerlink" title="单元测试框架和步骤"></a>单元测试框架和步骤</h2><p>Jnit：一个java语言的单元测试框架，编写和运行可重复的自动化测试。</p>
<p>Mockito：单元测试模拟框架，采用模拟技术，模拟应用中依赖的复杂对象，把测试对象和依赖对象隔离开。</p>
<p>PowerMock：在Mockito的基础上作出扩展。</p>
<p>单元测试步骤：定义对象 - 模拟方法 - 调用方法 - 验证方法 （第二步和第四步是有外部依赖时需要mock使用的）</p>
<p>1、定义测试对象（new&#x2F;Mockito.spy&#x2F;@Spy&#x2F;@InjectMocks）<br>2、模拟依赖对象（直接构建对象&#x2F;Json反序列化对象&#x2F;@Mock&#x2F;@Spy）<br>3、注入依赖对象（set&#x2F;Whitebox&#x2F;@Mock）<br>4、模拟依赖方法<br>5、调用被测方法（分为构造方法、普通方法、静态方法）（都分为有权限和无权限）（有权限直接调用，无权限用：<code>Whitebox.invokeMethod(userService, &quot;isUser&quot;, uid)</code>）<br>6、验证依赖方法（Mockito.verify(…)）（用ArgumentCaptor&#x2F;@Captor捕获参数）<br>7、验证数据对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//验证对象为空</span><br><span class="line">Assert.assertNull(&quot;必须为空！&quot;, uid);</span><br><span class="line">//验证对象非空</span><br><span class="line">Assert.assertNotNull(&quot;不能为空！&quot;, uid);</span><br><span class="line">//验证为真</span><br><span class="line">Assert.assertTrue(&quot;返回必须为真&quot;, isSuper);</span><br><span class="line">//验证为假</span><br><span class="line">Assert.assertFalse(&quot;返回必须为假&quot;, isSuper);</span><br><span class="line">//验证数据对象是否一致</span><br><span class="line">Assert.assertSame(&quot;用户必须一致&quot;, exceptId, uid);</span><br><span class="line">//验证数据对象是否一致</span><br><span class="line">Assert.assertNotSame(&quot;用户不能一致&quot;, exceptId, uid);</span><br><span class="line">//验证简单数据对象</span><br><span class="line">Assert.assertNotEquals(&quot;用户名称不一致&quot;, &quot;admin&quot;, user)</span><br><span class="line">//验证简单数组或集合对象</span><br><span class="line">Assert.assertArrayEquals</span><br><span class="line">//对于复杂数据，可以先序列化为json字符串，然后Assert.assertEquals</span><br></pre></td></tr></table></figure>
<p>验证跑出异常：可以用@Test(expected&#x3D;ExampleException.class)，但是一旦内部方法抛出异常，整个方法就返回，后面的验证没法执行。@Rule注解实现。推荐使用Assert</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExampleException e = Assert.assertThrows(&quot;异常类型不一致&quot;, ExampleException.class, ()-&gt;userService.getUser(uid));</span><br><span class="line">Assert.assertEquals(&quot;异常消息不一致&quot;, exceptString, e.getMessage());</span><br></pre></td></tr></table></figure>
<p>8、验证依赖对象（一般不用）<br><code>Mockito.verifyNotInteractions</code></p>
<p>✅Mockito的any相关的参数匹配方法不支持可空参数和空参数，应该用nullable方法。<br>✅采用Mockito的参数匹配方法时，其他参数不能直接用常量或变量，应该用Mockito的eq方法。</p>
<h2 id="Mock静态方法"><a href="#Mock静态方法" class="headerlink" title="Mock静态方法"></a>Mock静态方法</h2><p>通过PowerMockito.mockStatic() 对静态方法进行mock。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.powermock&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;powermock-api-mockito2&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.powermock&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import org.junit.jupiter.api.Assertions;</span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.powermock.api.mockito.PowerMockito;</span><br><span class="line">import org.powermock.core.classloader.annotations.PowerMockIgnore;</span><br><span class="line">import org.powermock.core.classloader.annotations.PrepareForTest;</span><br><span class="line">import org.powermock.modules.junit4.PowerMockRunner;</span><br><span class="line"> </span><br><span class="line">@RunWith(PowerMockRunner.class)</span><br><span class="line">@PrepareForTest(StringUtils.class)  //多个静态方法的话&#123;1,2&#125;</span><br><span class="line">//@PowerMockIgnore(&quot;javax.crypto.*&quot;)</span><br><span class="line">public class MyTest &#123;</span><br><span class="line"> </span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        //模拟依赖方法</span><br><span class="line">        PowerMockito.mockStatic(StringUtils.class);</span><br><span class="line">        PowerMockito.when(StringUtils.isEmpty(&quot;empty&quot;)).thenReturn(true);</span><br><span class="line">        Assertions.assertTrue(StringUtils.isEmpty(&quot;empty&quot;));</span><br><span class="line">        //验证依赖方法被调用</span><br><span class="line">        PowerMockito.verifyStatic(StringUtils.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/q2878948/article/details/124862699">https://blog.csdn.net/q2878948/article/details/124862699</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34497300/article/details/119774225">https://blog.csdn.net/qq_34497300/article/details/119774225</a></p>
<h2 id="Mock私有方法"><a href="#Mock私有方法" class="headerlink" title="Mock私有方法"></a>Mock私有方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先@RunWith(PowerMockRunner.class)</span><br><span class="line">把私有方法所在类放在@PrepareForTest()中</span><br><span class="line">//模拟私有依赖方法</span><br><span class="line">PowerMockito.doReturn(true).when(MyService.class, &quot;myFunc&quot;, myParam);</span><br><span class="line">PowerMockito.when(MyService.class, &quot;myFunc&quot;, myParam).thenReturn(true);</span><br><span class="line">//验证私有方法调用</span><br><span class="line">PowerMockito.verifyPrivate(myClass, times(1)).invoke(&quot;myfunc&quot;, any(List.class))</span><br></pre></td></tr></table></figure>

<p>⚠️想mock被验证类(@InjectMock)的私有方法是不行的。只能mock注入类的私有方法。</p>
<h2 id="Mock被测试类的其他public方法"><a href="#Mock被测试类的其他public方法" class="headerlink" title="Mock被测试类的其他public方法"></a>Mock被测试类的其他public方法</h2><p>直接用Mockito.when是不行，会报空指针。</p>
<p>还没搞出来。</p>
<p>Java中使用PowerMockito mock static方法&#x2F;new对象&#x2F;mock对象的public或private方法的简单示例：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/epic358/p/16559549.html">https://www.cnblogs.com/epic358/p/16559549.html</a></p>
<h2 id="Mock测试修改方法的入参"><a href="#Mock测试修改方法的入参" class="headerlink" title="Mock测试修改方法的入参"></a>Mock测试修改方法的入参</h2><p>如果方法有返回值，直接使用Mockito.when().thenReturn()的方式Mock即可，但是对于没有返回值的方法，但是在方法内部却对方法的入参做了一些逻辑的方法，就不能再用这种方式，应该用另外一个Mock方法，即doNothing。</p>
<p>Mock的时候，首先匹配参数，然后在ArgumentMatcher中修改参数即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// mock方式修改方法入参</span><br><span class="line">doNothing().when(userService).service(any(), argThat(new ArgumentMatcher&lt;UserResponse&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(UserResponse response) &#123;</span><br><span class="line">        ImportInfo importInfo = new ImportInfo();</span><br><span class="line">        importInfo.setStatus(&quot;APPROVING&quot;);</span><br><span class="line">        // 修改入参的属性</span><br><span class="line">        response.setImportInfo(importInfo);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br><span class="line">Request request = new Request();</span><br><span class="line">Response response = new Response();</span><br><span class="line">// 这个是我们要验证的主方法</span><br><span class="line">handler.handle(request, response);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.wxxblog.com/article/5">https://www.wxxblog.com/article/5</a></p>
<h2 id="单元测试风格"><a href="#单元测试风格" class="headerlink" title="单元测试风格"></a>单元测试风格</h2><p>单元测试的意义在于验证业务代码，高覆盖率+可读性 &#x3D; 高价值。高覆盖率包括对代码的覆盖，也包括对测试用例的覆盖。</p>
<p>一个方法要测试多种测试场景的话，就写多个mock方法，一个单侧方法只针对一个行为。但是看，有些公共的mock打桩可以提取出来，写成一个公共的私有方法，或者写一个init方法，用@Before注解修饰，在运行测试方法时就提前打桩。</p>
<p>推荐的风格：<br>1.一个测试方法仅调用一次被测方法<br>2.至少一个正例的测试用例<br>3，提取公共的mock插桩<br>4.异常流的测试中，只引入一种异常的mock重写<br>5.加注释：测试什么场景，期望什么结果</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、Mockito.anyString 什么的，不能和实际的参数一起作为一个方法的输入。<br>会报错：InvalidUseOfMatchersException。</p>
<p>2、接口的单元测试类，一般是一个实现类就一个单元测试类。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/09/myblog/spring/spring-aop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/09/myblog/spring/spring-aop/" class="post-title-link" itemprop="url">spring aop总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-09 11:56:23" itemprop="dateCreated datePublished" datetime="2022-04-09T11:56:23+08:00">2022-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-31 21:49:35" itemprop="dateModified" datetime="2022-05-31T21:49:35+08:00">2022-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>工作中遇到个aop的问题，jdk代理换cglib代理还不过来，以及jdk代理存在的一个问题。总结并实战一下。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="aop相关术语"><a href="#aop相关术语" class="headerlink" title="aop相关术语"></a>aop相关术语</h4><ul>
<li>Target：代理的目标对象</li>
<li>Proxy：代理对象</li>
<li>Joinpoint：连接点，指那些被拦截到的点。在Spring中，这些点指方法，因为Spring只支持方法类型的连接点（可以被增强的方法）</li>
<li>Pointcut：切入点是指我们要对哪些Joinpoint进行拦截的定义</li>
<li>Advice：（通知&#x2F;增强）是指拦截到Joinpoint之后要做的事情就是通知</li>
<li>Aspect：切面是切入点和通知（增强）的结合</li>
<li>Weaving：织入实质把将切点和增强结合的过程是织入过程，Spring是动态代理织入，AspectJ是采用编译期织入和类装载期织入</li>
</ul>
<p>*连接点是可以被增强的方法，切点是实际上被增强过的方法，连接点范围更大</p>
<h4 id="aop开发过程"><a href="#aop开发过程" class="headerlink" title="aop开发过程"></a>aop开发过程</h4><ol>
<li><p>编写核心业务代码（Target的目标方法-切点）</p>
</li>
<li><p>编写切面类，切面类中有通知（增强功能方法）</p>
</li>
<li><p>在配置文件&#x2F;注解当中，配置织入关系，即将那些通知与哪些连接点进行结合</p>
</li>
</ol>
<p>AOP技术实现的内容：<br>Spring框架会监控切入点方法的执行–通过配置文件决定哪些方法是切点；一旦监控到切入点方法被运行，即使用代理机制，动态创建目标对象（切点）的代理对象。然后根据配置文件配置的增强类型（通知），在代理对象（切点）对应的位置，将通知对应的功能织入，完成完整的代码逻辑运行。<br>配置文件-执行切点方法-监控到并动态创建代理对象，调用代理对象同名方法-内部调用目标方法，进行增强方法的介入。</p>
<p>AOP底层使用哪种代理方式：<br>Spring会根据目标类是否实现了接口来决定采用哪种动态代理。</p>
<h3 id="实践-配置文件"><a href="#实践-配置文件" class="headerlink" title="实践-配置文件"></a>实践-配置文件</h3><p>新建个spring项目</p>
<ol>
<li><p>导入相关依赖：spring-context、spring-core、spring-beans，还有切面的包 Aspectjweaver</p>
</li>
<li><p>新建service接口，新建实现类Impl</p>
</li>
<li><p>新建切面类，定义切面方法</p>
</li>
<li><p>编写配置文件</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 开启注解扫描  --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.aop.demo&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;aop:config proxy-target-class=&quot;false&quot;&gt;</span><br><span class="line">    &lt;aop:pointcut id=&quot;userServiceImplPointcut&quot; expression=&quot;execution(* com.aop.demo.UserServiceImpl.addUser(..))&quot; /&gt;</span><br><span class="line">    &lt;aop:aspect id=&quot;aopClass&quot; ref=&quot;aopMethods&quot;&gt;</span><br><span class="line">        &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;userServiceImplPointcut&quot; /&gt;</span><br><span class="line">        &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;userServiceImplPointcut&quot; /&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>测试方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class AopTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void testUserServiceAop()&#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-aop.xml&quot;);</span><br><span class="line">        // proxy-target-class=&quot;false&quot; 时，使用jdk代理</span><br><span class="line">        // 强制转换必须用父类接口来定义</span><br><span class="line">        UserService userService = (UserService)context.getBean(&quot;userServiceImpl&quot;);</span><br><span class="line">        userService.addUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️ proxy-target-class&#x3D;”false” 或默认表示使用jdk代理，获取对象需要用父类接口，用实现类会报<code>java.lang.ClassCastException: com.sun.proxy.$Proxy* cannot be cast to***</code> 的错误。</p>
<p>⚠️ proxy-target-class&#x3D;”true”时，使用cglib代理，使用父类接口也可以，使用实现类定义对象也可以。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//UserService userService = (UserService)context.getBean(&quot;userServiceImpl&quot;);</span><br><span class="line">UserServiceImpl userService = (UserServiceImpl)context.getBean(&quot;userServiceImpl&quot;);</span><br><span class="line">userService.addUser();</span><br></pre></td></tr></table></figure>

<p>⚠️ 另外，还有个现象是在jdk代理时存在的bug：<br>原本的： <code>UserService userService = (UserService)context.getBean(&quot;userServiceImpl&quot;);</code> 可以获得bean，没问题。<br>但是： <code>UserService userService = (UserService)context.getBean(UserServiceImpl.class);</code>  通过类的全路径获得bean就会出现<code>No qualifying bean of type</code> 的问题。<br>总结：jdk代理方式不用实现类，所以也不会用实现类的bean，即使配了实现类的bean，也不行。</p>
<p>原因：spring aop默认是使用jdk动态代理的，也就是我通过getBean(ServiceImpl.class)，表达出的意思是希望程序通过jdk动态代理给我一个ServiceImpl类。而jdk的动态代理是基于接口实现的，因为它本身要继承一个Proxy类，而java是单继承（接口可以多继承），所以它通过实现接口进行代理。它通过实现我们给它的接口和继承Proxy类实现jdk动态代理。而我们给它的是一个ServiceImpl类，这个时候jdk动态代理就没有办法了。<br>jdk动态代理产生的对象属于Proxy类型，属于给定的接口（Service）类型，但不属于我们要代理的那个对象的类型，也就是本代码中ServiceImpl类型<br>因此，使用接口的类路径：<code>UserService userService = (UserService)context.getBean(UserService.class);</code> 也是可以的。这也解释了工作中遇到的问题。<br>但是，换成cglib，实现类&#x2F;父类接口，获取bean的方式：id&#x2F;类路径，都可以，没解释工作中为什么不能直接换成cglib的问题。</p>
<p>总结：<br>jdk代理：必须父类接口获得bean，括号内可以是实现类的bean id，也可以是父类接口的全路径。<br>cglib代理：怎么都行。</p>
<h3 id="实践-注解"><a href="#实践-注解" class="headerlink" title="实践-注解"></a>实践-注解</h3><ol>
<li><p>使用@Aspect注解，出了aspectweaver包之外，还需要aspectjrt包</p>
</li>
<li><p>新建service接口，新建实现类Impl</p>
</li>
<li><p>新建切面类，定义切面方法</p>
</li>
<li><p>编写配置类</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &#123;&quot;com.aop.demo.zhujie&quot;&#125;)</span><br><span class="line">@EnableAspectJAutoProxy(proxyTargetClass = false)</span><br><span class="line">public class SpringCfg &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>测试</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new AnnotationConfigApplicationContext(SpringCfg.class);  //加载配置类</span><br></pre></td></tr></table></figure>

<p>效果和配置文件一样。</p>
<h3 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h3><p><a target="_blank" rel="noopener" href="https://github.com/jadeliuliu/aop-demo">https://github.com/jadeliuliu/aop-demo</a></p>
<p>参考：<br>知识点：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Zhang-DevelopingPlatform/p/14723490.html">https://www.cnblogs.com/Zhang-DevelopingPlatform/p/14723490.html</a></p>
<p>jdk代理找不到bean：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32080243/article/details/90261768">https://blog.csdn.net/qq_32080243/article/details/90261768</a></p>
<p>cglib实现：<a target="_blank" rel="noopener" href="https://blog.csdn.net/shaoweijava/article/details/76474652">https://blog.csdn.net/shaoweijava/article/details/76474652</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/03/myblog/java/log%E6%97%A5%E5%BF%97%E4%B8%8Emaven%E6%89%93%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/03/myblog/java/log%E6%97%A5%E5%BF%97%E4%B8%8Emaven%E6%89%93%E5%8C%85/" class="post-title-link" itemprop="url">log日志与maven打包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-03 11:02:33" itemprop="dateCreated datePublished" datetime="2022-04-03T11:02:33+08:00">2022-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-20 15:34:30" itemprop="dateModified" datetime="2023-08-20T15:34:30+08:00">2023-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>工作中需要将应用部署在本地，想来之前用go的时候貌似是直接编译运行就在本地部署了，但是java需要用到maven打包，还没打包过，学习一下。顺便工作中查看日志对log4j、sjf4j、logback、lomback这几个东西有点迷糊，所以先学一下日志相关的，然后建工程打包部署在本地看下效果。</p>
<h3 id="1-lombok"><a href="#1-lombok" class="headerlink" title="1.lombok"></a>1.lombok</h3><p>自然不必多说，lombok可以通过简单的注解的形式来帮助我们简化和消除一些必须有但显得很臃肿的Java代码，比如常见的Getter&amp;Setter、toString()、构造函数等等。lombok不仅方便编写，同时也让我们的代码更简洁。</p>
<p>lombok提供了一个功能完整的jar包，可以很方便的与我们的项目进行集成。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>第一步：加入lombok依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>scop&#x3D;provided，表示它只在编译阶段生效，不需要打入包中，lombok在编译期将带lombok注解的java文件正确编译为完整的class文件。</p>
<p>第二步：idea中添加lombok插件</p>
<p>否则会报缺少方法和没有设置属性的异常。</p>
<p>第三步：设置启用注释处理</p>
<p>设置中 Annotation processors，enable annotation processing。</p>
<h4 id="lombok原理"><a href="#lombok原理" class="headerlink" title="lombok原理"></a>lombok原理</h4><ol>
<li>javac对源代码进行分析，生成了一棵抽象语法树（AST）</li>
<li>编译过程中调用实现了“JSR 269 API”的Lombok程序</li>
<li>此时Lombok就对第一步骤得到的AST进行处理，找到@Data注解所在类对应的语法树（AST），然后修改该语法树（AST），增加getter和setter方法定义的相应树节点</li>
<li>javac使用修改后的抽象语法树（AST）生成字节码文件，即给class增加新的节点（代码块）</li>
</ol>
<h3 id="2-SLF4J"><a href="#2-SLF4J" class="headerlink" title="2.SLF4J"></a>2.SLF4J</h3><h4 id="接口与包关系"><a href="#接口与包关系" class="headerlink" title="接口与包关系"></a>接口与包关系</h4><p>Simple logging Facade for Java，意思为简单日志门面，它是把不同的日志系统的实现进行了具体的抽象化，只提供了统一的日志使用接口，使用时只需要按照其提供的接口方法进行调用即可，由于<strong>它只是一个接口</strong>，并不是一个具体的可以直接单独使用的日志框架，所以最终日志的格式、记录级别、输出方式等都要<strong>通过接口绑定的具体的日志系统来实现</strong>，这些具体的日志系统就有log4j、logback、java.util.logging等，它们才实现了具体的日志系统的功能。</p>
<p>SLF4J只是一个接口，实际使用时必须要结合具体的日志系统来使用，我们首先来看SLF4J和各个具体的日志系统进行绑定时的框架原理图：</p>
<p><img src="/images/logback.png"></p>
<p>slf4j原理很简单，他只提供一个核心slf4j api(就是slf4j-api.jar包)，这个包只有日志的接口，并没有实现，所以如果要使用就得<strong>再给它提供一个实现了些接口的日志包</strong>，比 如：log4j、common logging、jdk log日志实现包等，但是<strong>这些日志实现又不能通过接口直接调用</strong>，实现上他们根本就和slf4j-api不一致，因此slf4j又增加了一层来<strong>转换各日志实现包的使用</strong>，当然slf4j-simple除外。其结构如下： </p>
<blockquote>
<p>slf4j-api(接口层)<br> | |<br>各日志实现包的连接层( slf4j-jdk14, slf4j-log4j)<br> | |<br>各日志实现包 	</p>
</blockquote>
<p><strong>所以，结合各日志实现包使用时提供的jar包情况为：</strong></p>
<p>SLF4J和logback结合使用时需要提供的jar：slf4j-api.jar、logback-classic.jar、logback-core.jar</p>
<p>SLF4J和log4j结合使用时需要提供的jar：slf4j-api.jar、slf4j-log4j12.jar、log4j.jar</p>
<p>和log4j2配合需要导入log4j2的<strong>log4j-api.jar</strong>、<strong>log4j-core.jar</strong>和桥接包<strong>log4j-slf4j-impl.jar</strong>。</p>
<p>SLF4J和JDK中java.util.logging结合使用时需要提供的jar：slf4j-api.jar、slf4j-jdk14.jar</p>
<p>SLF4J和simple(SLF4J本身提供的一个接口的简单实现)结合使用时需要提供的jar：slf4j-api.jar、slf4j-simple.jar</p>
<p>当然还有其他的日志实现包，以上是经常会使用到的一些。</p>
<p>*<strong>注意，以上slf4j和各日志实现包结合使用时最好只使用一种结合，不然的话会提示重复绑定日志，并且会导致日志无法输出。*</strong></p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>*<strong>slf4j-api.jar:对外提供统一的日志调用接口，该接口具体提供的调用方式和方法举例说明：*</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">　　<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Tester.class);  </span><br><span class="line">　　<span class="comment">//通过LoggerFactory获取Logger实例</span></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//接口里的统一的调用方法，各具体的日志系统都有实现这些方法</span></span><br><span class="line">　　		logger.info(<span class="string">&quot;testlog: &#123;&#125;&quot;</span>, <span class="string">&quot;test&quot;</span>); </span><br><span class="line">       logger.debug(<span class="string">&quot;testlog: &#123;&#125;&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">       logger.error(<span class="string">&quot;testlog: &#123;&#125;&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">       logger.trace(<span class="string">&quot;testlog: &#123;&#125;&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">       logger.warn(<span class="string">&quot;testlog: &#123;&#125;&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Lombok提供的@Slf4j注解，可以省去获取Logger对象的步骤，直接使用log.info()…</p>
<p><strong>如果系统中之前已经使用了log4j做日志输出，想使用slf4j作为统一的日志输出，该怎么办呢？</strong></p>
<p>如果之前系统中是单独使用log4j做为日志输出的，这时再想使用slf4j做为日志输出时，如果系统中日志比较多，此时更改日志输出方法肯定是不太现实的，这个时候就可以使用log4j-over-slf4j.jar将使用log4j日志框架输出的日志路由到slf4j上来统一采用slf4j来输出日志。</p>
<h4 id="为什么使用？"><a href="#为什么使用？" class="headerlink" title="为什么使用？"></a>为什么使用？</h4><p><strong>为什么要使用SLF4J?</strong></p>
<ul>
<li>slf4j是一个<strong>日志接口，自己没有具体实现日志系统</strong>，只提供了一组标准的调用api,这样<strong>将调用和具体的日志实现分离</strong>，<strong>使用slf4j后有利于根据自己实际的需求更换具体的日志系统</strong>，比如，之前使用的具体的日志系统为log4j，想更换为logback时，只需要删除log4j相关的jar，然后加入logback相关的jar和日志配置文件即可，而不需要改动具体的日志输出方法，试想如果没有采用这种方式，当你的系统中日志输出有成千上万条时，你要更换日志系统将是多么庞大的一项工程。如果你开发的是一个面向公众使用的组件或公共服务模块，那么一定要使用slf4的这种形式，这有利于别人在调用你的模块时保持和他系统中使用统一的日志输出。</li>
<li><strong>slf4j日志输出时可以使用{}占位符</strong>，如，logger.info(“testlog: {}”, “test”)，而如果只使用log4j做日志输出时，只能以logger.info(“testlog:”+”test”)这种形式，前者要比后者在性能上更好，后者采用+连接字符串时就是new 一个String 字符串，在性能上就不如前者。</li>
</ul>
<h3 id="3-log4j-log-for-java"><a href="#3-log4j-log-for-java" class="headerlink" title="3.log4j(log for java)"></a>3.<strong>log4j(log for java)</strong></h3><p>Log4j是Apache的一个开源项目，通过使用Log4j，我们可以<strong>控制日志信息输送的目的地</strong>是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以<strong>控制每一条日志的输出格式</strong>；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以<strong>通过一个配置文件来灵活地进行配置</strong>，而不需要修改应用的代码。</p>
<p><strong>如何使用？</strong></p>
<ul>
<li>引入jar,使用log4j时需要的jar为：log4j.jar。</li>
<li>定义配置文件log4j.properties或log4j.xml</li>
<li>在具体的类中进行使用：<ul>
<li>在需要日志输出的类中加入：private static final Logger logger &#x3D; Logger.getLogger(Tester.class);  &#x2F;&#x2F;通过Logger获取Logger实例</li>
<li>在需要输出日志的地方调用相应方法即可：logger.debug(“System …..”)</li>
</ul>
</li>
</ul>
<h3 id="4-logback"><a href="#4-logback" class="headerlink" title="4.logback"></a>4.logback</h3><p>logback同样是由log4j的作者设计完成的，拥有更好的特性，用来取代log4j的一个日志框架，是slf4j的原生实现(即直接实现了slf4j的接口，而log4j并没有直接实现，所以就需要一个适配器slf4j-log4j12.jar)，logback一共有以下几个模块：</p>
<ul>
<li>logback-core：其它两个模块的基础模块</li>
<li>logback-classic：它是log4j的一个改良版本，同时它完整实现了slf4j API使你可以很方便地更换成其它日志系统如log4j或JDK14 Logging</li>
<li>logback-access：访问模块与Servlet容器集成提供通过Http来访问日志的功能</li>
</ul>
<p>同样，单独使用它时，需要引入以上jar，然后进行配置文件的配置，最后就是在相关类中进行使用，使用时加入以下语句:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Test.class);</span><br><span class="line"> 　logger.info(<span class="string">&quot;打印日志&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果要改代码的日志级别：改logback-spring.xml里的<code>&lt;root level=&quot;INFO&quot;&gt;</code></p>
<h3 id="5-log发展史"><a href="#5-log发展史" class="headerlink" title="5.log发展史"></a>5.log发展史</h3><p>从JDK1.4开始提供java.until.logging日志框架来打印日志，但是大佬觉得JUL太难用了，就自己手撸了个log4j，后来log4j发现安全漏洞，加上代码结构问题难以维护，于是从1.2就停止更新log4j，并又重新手撸了个log4j2，再后来，这个大佬又双手撸了一个性能更高、功能更全的logback。</p>
<p>从此，这个大佬构建了log的世界，也创造了最常见的日志框架：log4j、log4j2、logback。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用log4j，需要log4j.jar</span></span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger_log4j</span> <span class="operator">=</span> Logger.getLogger(Test.class);</span><br><span class="line">logger_log4j.info(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用log4j2，需要log4j-api.jar、log4j-core.jar</span></span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger_log4j2</span> <span class="operator">=</span> LogManager.getLogger(Test.class);</span><br><span class="line">logger_log4j2.info(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// logback，需要logback-classic.jar、logback-core.jar</span></span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.Logger;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.LoggerContext;</span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger_logback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggerContext</span>().getLogger(Test.class);</span><br><span class="line">logger_logback.info(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.until.logging，简称jul</span></span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger_jul</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;java.Test&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>从上面不难看出，使用不同的日志框架，就要引入不同的jar包，使用不同的代码获取Logger。</p>
<p>于是Apache Commons Logging出现了。</p>
<p>Common-logging提供了一个日志入口，称作”门面日志”，即它不负责写日志，而是<strong>提供用一个统一的接口，通过jar来决定使用的日志框架</strong>，这样就不要再更换框架的时候再修改代码了。后来开发了log4j的大佬又因为嫌弃Common-logging难用，开发了门面日志框架<strong>slf4j</strong>，今天就拿slf4j讲述门面日志。</p>
<p>门面日志和设计模式中的<strong>外观模式</strong>如出一辙，本身不提供服务，为子系统提供统一的入口，封装子系统的复杂性，便于客户端调用。slf4j就像是菜鸟驿站，本身没有快递服务，但是提供顺丰、中通等快递服务，至于你想用顺丰还是用中通，完全取决于你的想法。</p>
<p>使用slf4j：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Test.class);</span><br><span class="line">logger.info(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用slf4j需要首先导入<strong>slf4j-api.jar</strong>，和log4j配合，需要导入<strong>log4j.jar</strong>，以及桥接包<strong>slf4j-log412.jar</strong>。</p>
<p>logback只需要导入<strong>logback-classic.jar</strong>和<strong>logback-core.jar</strong>即可，不需要桥接包。</p>
<h4 id="为什么使用桥接包？"><a href="#为什么使用桥接包？" class="headerlink" title="为什么使用桥接包？"></a>为什么使用桥接包？</h4><p>slf4j从LoggerFactory.getLogger()开始，原理就是就是让ClassLoader从classpath(依赖的jar)中找到<strong>StaticLoggerBinder</strong>这个类，然后利用他来返回log4j、logback中的Logger，然后打印日志。</p>
<p>所谓的桥接包，就是实现StaticLoggerBinder类，用来连接slf4j和日志框架。因为log4j和log4j2刚开始没有StaticLoggerBinder这个类，为了不改变程序结构，只能重新写一个新的jar来实现StaticLoggerBinder。而logback出现slf4j之后，于是在logback本身的jar中实现了StaticLoggerBinder，所以就不需要桥接包。</p>
<p>StaticLoggerBinder实现了使用底层日志框架创建Logger的功能，各自的StaticLoggerBinder为slf4j提供的Logger，再提供给用户打印日志。</p>
<p>log4j和log4j2桥接包及logback依赖里，都有StaticLoggerBinder类。</p>
<p>“Class path contains multiple SLF4J bindings.”在使用slf4j的时候会遇到以上的报告信息。究其根本是因为logback-classic、log4j-slf4j-impl、slf4j-log412、slf4j-jdk这些jar不能同时存在。他们都实现了StaticLoggerBinder类而导致冲突，slf4j无法确定到底用哪个日志框架。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>lombok是一个可以简化代码的jar包，需要导入依赖，添加插件，可以说是开发必备。跟日志没啥关系，只不过@Slf4j注解是lombok提供的，用来在方法中直接使用log。</p>
</li>
<li><p>slf4j是日志门面，一个日志接口，而不提供日志系统实现，方便日志系统与调用的分离，可以方便更换日志系统。相当于是提供了一种日志输出的规范，下面的日志系统都需要实现这些方法，统一了日志输出规范。它实现了日志框架一些通用的api，log4j和logback是具体的日志框架。</p>
</li>
<li><p>log4j就是一个日志实现系统，具体的配置文件log4j.properties怎么写，还得再看看。log4j在结合slf4j时需要使用一个适配类桥接包。使用Logger.getLogger。</p>
</li>
<li><p>logback时比log4j新的日志实现系统，直接实现了slf4j接口，使用LoggerFactory.getLogger。</p>
<p>他们可以单独的使用，也可以绑定slf4j一起使用。</p>
<p>单独使用，分别调用框架自己的方法来输出日志信息。绑定slf4j一起使用。调用slf4j的api来输入日志信息，具体使用与底层日志框架无关（需要底层框架的配置文件）。显然不推荐单独使用日志框架。假设项目中已经使用了log4j，而我们此时加载了一个类库，而这个类库依赖另一个日志框架。这个时候我们就需要维护两个日志框架，这是一个非常麻烦的事情。而使用了slf4j就不同了，由于应用调用的抽象层的api，与底层日志框架是无关的，因此可以任意更换日志框架。</p>
</li>
</ol>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="1-maven项目"><a href="#1-maven项目" class="headerlink" title="1.maven项目"></a>1.maven项目</h4><p>很久没在这个电脑上新建maven项目，结果问题来了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/.m2 ❯ mvn -v      </span><br><span class="line">zsh: command not found: mvn</span><br></pre></td></tr></table></figure>

<p>之前出现的问题又出现了，之前重新配置了一下就可以了，可是brew info maven 也找不到之前maven安装的路径，难道之前我不是通过brew安装的吗？</p>
<p>另外在资源库中也没找到，好吧，重新 brew install maven 😅。可是brew安装报错。</p>
<p>官网<a target="_blank" rel="noopener" href="https://maven.apache.org/download.cgi%E4%B8%8B%E8%BD%BDapache-maven-3.8.5-bin.tar.gz%E3%80%82%E8%A7%A3%E5%8E%8B%E5%88%B0%E8%B5%84%E6%BA%90%E5%BA%93%E4%B8%AD%E3%80%82%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E4%BD%BF%E5%BE%97%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E8%BE%93%E5%85%A5mvn%E8%83%BD%E5%A4%9F%E6%89%BE%E5%88%B0maven%E5%8C%85%EF%BC%9F%E5%B0%B1%E9%9C%80%E8%A6%81%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%BA%86%E3%80%82">https://maven.apache.org/download.cgi下载apache-maven-3.8.5-bin.tar.gz。解压到资源库中。那么如何使得在命令行中输入mvn能够找到maven包？就需要配置环境变量了。</a></p>
<p>下载之后，需要配置环境变量，不经想起之前的疑问：jdk环境变量在&#x2F;etc&#x2F;profile中配置，而maven中的环境变量在~&#x2F;.bash_profile，这是为什么？</p>
<p>我们常说的环境变量修改主要包含两类文件，分别是 profile 和 bashrc 文件。profile 文件又分为：”&#x2F;etc&#x2F;profile”，”<del>&#x2F;.bash_profile”；bashrc 文件则又分为 “&#x2F;etc&#x2F;bashrc”，和 “</del>&#x2F;.bashrc” 文件。</p>
<p>说到这儿，可能迷惑了，我在我电脑里没看到.bash_profile和.bashrc啊，但是看到.zshrc了，这是为啥？</p>
<blockquote>
<p>iterm2以及mac自带的terminal都是终端模拟器。最开始时候就用起了iterm2.</p>
<p>bash，zsh是shell，zsh兼容bash</p>
<p>shell：壳，用它表示“为使用者提供的操作界面”，Shell泛指所有为用户提供操作界面的程序，分为两类：命令行（CLI）与图形界面（GUI）。通常情况下，我们在聊shell的时候，其实都是聊的Linux的命令行界面。</p>
</blockquote>
<blockquote>
<p>sh和bash和zsh :</p>
<p>sh全称为Bourne Shell，来自于1977年底的Unix v7版。二进制文件位置为<code>/bin/sh</code>。 </p>
<p>bash全称为Bourne-Again Shell，是在1989年对sh的重写版，替代了sh。二进制文件位置为<code>/bin/bash</code>。 </p>
<p>现在的Linux系统以及macOS系统的shell都默认使用bash。</p>
<p>Zsh即Z shell，是一款可用作交互式登录的shell及脚本编写的命令解释器。Zsh对Bourne shell做出了大量改进，同时加入了Bash、ksh及tcsh的某些功能。 </p>
<p>所以说Zsh也是一个Shell，就是会比bash能好用很多。所以这也是2019年起，macOS的默认Shell从Bash改为Zsh的原因？</p>
<p>zsh拥有完善的插件机制以及丰富的生态，和oh my zsh一起食用更佳</p>
</blockquote>
<h5 id="查看本地Shell的命令"><a href="#查看本地Shell的命令" class="headerlink" title="查看本地Shell的命令"></a>查看本地Shell的命令</h5><ul>
<li><p>查看当前Linux的全部Shell：<code>cat /etc/shells</code></p>
</li>
<li><p>查看当前使用的Shell：<code>echo $SHELL</code>或者<code>echo $0</code></p>
</li>
<li><p>切换默认的Shell：<code>chsh -s [shell的二进制文件路径]</code>，之后要重新登陆Shell才能生效哈。例如：</p>
</li>
<li><ul>
<li>切换为Bash： <code>chsh -s /bin/bash</code></li>
<li>切换为Zsh：<code>chsh -s /bin/zsh</code></li>
</ul>
</li>
</ul>
<h5 id="Shell的各种配置文件"><a href="#Shell的各种配置文件" class="headerlink" title="Shell的各种配置文件"></a>Shell的各种配置文件</h5><p>无论是Bash还是Zsh，都是有各自的配置文件来完成自己的工作的。这些配置文件都是隐藏文件，也就是说，用户不需要知道这些配置。但是在这里也要给大家总结一下都有哪些配置文件，也许以后用的上呢。 </p>
<h5 id="Bash的配置文件"><a href="#Bash的配置文件" class="headerlink" title="Bash的配置文件"></a>Bash的配置文件</h5><ul>
<li>&#x2F;etc&#x2F;profile：为系统的<strong>每个用户</strong>设置环境信息，当用户第一次<strong>登录</strong>时会执行该文件里的命令。默认会直接调用&#x2F;etc&#x2F;bashrc。该文件的改动需要重启才能生效。用于设置系统级别的环境变量和启动程序，在这个文件下配置会对所有的用户生效。</li>
<li>&#x2F;etc&#x2F;bashrc：为每一个运行bash shell的用户执行此文件。当bash shell被打开时，会读取并执行该文件中的命令。所以修改该文件后，重新打开Shell即可生效。</li>
<li>~&#x2F;.bash_profile：和&#x2F;etc&#x2F;profile类似，但是只对当前用户生效。只对单一用户生效，该文件是一个用户级别的设置，可以理解为某一用户下的profile</li>
<li>~&#x2F;.bashrc：和&#x2F;etc&#x2F;bashrc类似，但是只对当前用户生效。</li>
<li>~&#x2F;.bash_logout：当每次退出bash shell时，执行该文件。</li>
<li>~&#x2F;.bash_history：保存了历史命令。在Shell为Bash时，每次敲击命令时，都会保存在这个文件里</li>
</ul>
<h5 id="Zsh的配置文件"><a href="#Zsh的配置文件" class="headerlink" title="Zsh的配置文件"></a>Zsh的配置文件</h5><ul>
<li>&#x2F;etc&#x2F;bashrc 对应 &#x2F;etc&#x2F;zshrc</li>
<li>~&#x2F;.bash_profile 对应 ~&#x2F;.zprofile</li>
</ul>
<p>加载顺序：zshenv、zprofile、zshrc、zlogin</p>
<hr>
<p>所以说，各种教程里说的配置都是默认bash的，bash的配置文件对标到zsh中就可以。</p>
<p><strong>&#x2F;etc&#x2F;profile 和 &#x2F;etc&#x2F;bashrc 这种在 &#x2F;etc 目录下的配置则都属于全局配置，所有用户的shell都有权使用这些环境变量，～&#x2F; 则属于用户级别的</strong></p>
<h5 id="总结一下：各种配置文件可以按两种方式分类："><a href="#总结一下：各种配置文件可以按两种方式分类：" class="headerlink" title="总结一下：各种配置文件可以按两种方式分类："></a>总结一下：各种配置文件可以按两种方式分类：</h5><table>
<thead>
<tr>
<th></th>
<th>profile</th>
<th align="center">bashrc&#x2F;zshrc</th>
</tr>
</thead>
<tbody><tr>
<td>全局</td>
<td>&#x2F;etc&#x2F;profile（无关哪个shell）</td>
<td align="center">&#x2F;etc&#x2F;bashrc</td>
</tr>
<tr>
<td>用户</td>
<td>~&#x2F;.bash_profile （专用于哪个shell）</td>
<td align="center">~&#x2F;.bashrc</td>
</tr>
</tbody></table>
<p>profile的bashrc区别?</p>
<p>要搞清bashrc与profile的区别，首先要弄明白什么是交互式shell和非交互式shell，即login shell 和non-login shell。</p>
<p>交互式模式就是shell等待你的输入，并且执行你提交的命令。这种模式被称作交互式是因为shell与用户进行交互。这种模式也是大多数用户非常熟悉的：登录、执行一些命令、签退。当你签退后，shell也终止了。 shell也可以运行在另外一种模式：非交互式模式。在这种模式下，shell不与你进行交互，而是读取存放在文件中的命令,并且执行它们。当它读到文件的结尾，shell也就终止了。</p>
<p>bashrc 与 profile 都用于保存用户的环境信息，bashrc用于交互式non-loginshell，而profile用于交互式login shell。</p>
<ol>
<li><p>&#x2F;etc&#x2F;profile: 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从&#x2F;etc&#x2F;profile.d目录的配置文件中搜集shell的设置.</p>
</li>
<li><p>&#x2F;etc&#x2F;bashrc: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.</p>
</li>
<li><p>~&#x2F;.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.</p>
</li>
<li><p>~&#x2F;.bashrc: 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.</p>
</li>
<li><p>~&#x2F;.bash_logout: 当每次退出系统(退出bash shell)时,执行该文件.</p>
</li>
</ol>
<p>另外,&#x2F;etc&#x2F;profile中设定的变量(全局)的可以作用于任何用户,而~&#x2F;.bashrc等中设定的变量(局部)只能继承&#x2F;etc&#x2F;profile中的变量,他们是”父子”关系.</p>
<hr>
<p>当登入系统时候获得一个shell进程时，其读取环境设定档有三步</p>
<p>1、首先读入的是全局环境变量设定档&#x2F;etc&#x2F;profile，然后根据其内容读取额外的设定的文档，如<br>&#x2F;etc&#x2F;profile.d和&#x2F;etc&#x2F;inputrc</p>
<p>2、然后根据不同使用者帐号，去其家目录读取<del>&#x2F;.bash_profile，如果这读取不了就读取</del>&#x2F;.bash_login，这个也读取不了才会读取<br>~&#x2F;.profile，这三个文档设定基本上是一样的，读取有优先关系</p>
<p>3、然后在根据用户帐号读取~&#x2F;.bashrc</p>
<hr>
<p>总结：配置文件全局&#x2F;用户—交互的&#x2F;非交互的，jdk的配置就是在&#x2F;etc&#x2F;profile中，maven的配置在～&#x2F;.bash_profile既然用的是zsh，就在 ~&#x2F;.zprofile里面配置。</p>
<hr>
<p>在～&#x2F;.zprofile文件中，添加配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export M=&quot;/usr/local/ApacheMaven&quot;</span><br><span class="line">export PATH=&quot;$M/bin:$PATH&quot;</span><br></pre></td></tr></table></figure>

<p>source ～&#x2F;.zprofile 即可。</p>
<p>然后配置一下阿里云仓库。在setting.xml文件中，要关注两个地方，<em><strong>localRepository</strong></em>和<em><strong>mirrors</strong></em>。第一个localRepository是你本地仓库所在的位置，你的包都会下载到这里，默认在你用户目录的.m2目录下，这里可以换成你想存放的地址。第二个mirror是你的包下载地址，因为有墙，所以建议增加阿里云仓库配置，来加速下载。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-创建maven-web项目"><a href="#2-创建maven-web项目" class="headerlink" title="2.创建maven web项目"></a>2.创建maven web项目</h4><p>新建maven项目时选中create from archetype，选择org.apache.maven.archetypes:maven-archetype-webapp。</p>
<p>选择自己maven的setting.xml。</p>
<p>配置tomcat服务器，选择tomcat-local，给服务器取名字，选版本端口号之类的。</p>
<p>deployment中artifact选择要部署的jar包，选exploded的。</p>
<p>选择热部署，在实际开发中是很管用的web开发，你后台，改了啥他就热部署，不用你重启tomcat，前台的也是，你修改jsp,css,js什么的都可以直接进行热部署，你只要自己刷新一下你的页面就行了。</p>
<h4 id="3-使用log4j集合slf4j"><a href="#3-使用log4j集合slf4j" class="headerlink" title="3.使用log4j集合slf4j"></a>3.使用log4j集合slf4j</h4><p>Apache Log4j是一个基于Java的日志记录工具，它的日志级别按下面顺序递减：</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>OFF</td>
<td>最高级别，用于关闭日志记录。</td>
</tr>
<tr>
<td>FATAL</td>
<td>将导致应用程序提前终止的严重错误的信息将立即呈现在日志上。</td>
</tr>
<tr>
<td>ERROR</td>
<td>将其他运行时错误或意外情况的信息呈现在日志上。</td>
</tr>
<tr>
<td>WARN</td>
<td>使用已过时的API，API的滥用，潜在错误，其他不良的或意外的运行时的状况（但不一定是错误的）</td>
</tr>
<tr>
<td>INFO</td>
<td>一些感兴趣的运行时事件（启动&#x2F;关闭</td>
</tr>
<tr>
<td>DEBUG</td>
<td>一些详细信息，查看程序的运行状态</td>
</tr>
<tr>
<td>TRACE</td>
<td>最详细的信息。一般这些信息只记录到日志文件中。</td>
</tr>
</tbody></table>
<h5 id="第一步：引入依赖"><a href="#第一步：引入依赖" class="headerlink" title="第一步：引入依赖"></a>第一步：引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0-alpha7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="第二步：配置log4j的配置文件"><a href="#第二步：配置log4j的配置文件" class="headerlink" title="第二步：配置log4j的配置文件"></a>第二步：配置log4j的配置文件</h5><p>其配置文件名为log4j.properties，<strong>需要手动在java&#x2F;resources下创建</strong>，如果建在其他位置，idea这个工具将无法识别。该配置文件用来设置记录器的级别、存放器和布局的，它可接key&#x3D;value格式的设置或xml格式的设置信息。通过配置，可以创建出Log4J的运行环境。</p>
<p>Log4J配置文件的基本格式如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### set log levels 配置根Logger###</span></span><br><span class="line"><span class="comment">### log4j.rootLogger  = [ level ] , appenderName1 , appenderName2 ,  … ###</span></span><br><span class="line"><span class="comment">###  level : 是日志记录的优先级 优先级从高到低分别是ERROR、WARN、INFO、DEBUG</span></span><br><span class="line"><span class="comment">###  比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来</span></span><br><span class="line"><span class="comment">### Appender 为日志输出目的地 这里 将debug层级及以上的信息输出到console和file，自己定义的名字  ###</span></span><br><span class="line"><span class="attr">log4j.rootLogger</span> = <span class="string">DEBUG,Console,File</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">###  输出到控制台  ###</span></span><br><span class="line"><span class="attr">log4j.appender.Console</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="attr">log4j.appender.Console.Target</span>=<span class="string">System.out</span></span><br><span class="line"><span class="attr">log4j.appender.Console.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.Console.layout.ConversionPattern</span>=<span class="string">[%d&#123;yy/MM/dd HH:mm:ss:SSS&#125;]-%l:%m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### 输出到日志文件 ###</span></span><br><span class="line"><span class="attr">log4j.appender.File</span>=<span class="string">org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="attr">log4j.appender.File.File</span>=<span class="string">$&#123;project&#125;src/main/resources/log/app.log</span></span><br><span class="line"><span class="attr">log4j.appender.File.MaxFileSize</span>=<span class="string">10MB</span></span><br><span class="line"><span class="attr">log4j.appender.File.Threshold</span>=<span class="string">ALL</span></span><br><span class="line"><span class="attr">log4j.appender.File.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.File.layout.ConversionPattern</span>=<span class="string">[%p][%d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125;][%c]%m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#   %m   输出代码中指定的消息</span></span><br><span class="line"><span class="comment">#　　%p   输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL</span></span><br><span class="line"><span class="comment">#　　%r   输出自应用启动到输出该log信息耗费的毫秒数</span></span><br><span class="line"><span class="comment">#　　%c   输出所属的类目，通常就是所在类的全名</span></span><br><span class="line"><span class="comment">#　　%t   输出产生该日志事件的线程名</span></span><br><span class="line"><span class="comment">#　　%n   输出一个回车换行符，Windows平台为“\r\n”，Unix平台为“\n”</span></span><br><span class="line"><span class="comment">#　　%d   输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss , SSS&#125;，输出类似：2002年10月18日  22 ： 10 ： 28 ， 921</span></span><br><span class="line"><span class="comment">#　　%l   输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: 10 )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Appender 为日志输出目的地，Log4j提供的appender有以下几种：</span></span><br><span class="line"><span class="comment">#org.apache.log4j.ConsoleAppender（控制台），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.FileAppender（文件），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Layout：日志输出格式，Log4j提供的layout有以下几种</span></span><br><span class="line"><span class="comment">#org.apache.log4j.HTMLLayout（以HTML表格形式布局），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.PatternLayout（可以灵活地指定布局模式），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</span></span><br></pre></td></tr></table></figure>

<p>当然，通过Threshold设置，可以把异常日志单独输出到一个文件中。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### set log levels ###</span></span><br><span class="line"><span class="attr">log4j.rootLogger</span> = <span class="string">debug ,  stdout ,  D ,  E</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### 输出到控制台 ###</span></span><br><span class="line"><span class="attr">log4j.appender.stdout</span> = <span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.Target</span> = <span class="string">System.out</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.layout.ConversionPattern</span> =  <span class="string">[%p][%d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125;][%c]%m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### 输出到日志文件 ###</span></span><br><span class="line"><span class="attr">log4j.appender.D</span> = <span class="string">org.apache.log4j.DailyRollingFileAppender</span></span><br><span class="line"><span class="attr">log4j.appender.D.File</span> = <span class="string">$&#123;project&#125;src/main/resources/log/app.log</span></span><br><span class="line"><span class="attr">log4j.appender.D.Append</span> = <span class="string">true</span></span><br><span class="line"><span class="attr">log4j.appender.D.Threshold</span> = <span class="string">DEBUG</span></span><br><span class="line"><span class="attr">log4j.appender.D.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.D.layout.ConversionPattern</span> = <span class="string">[%p][%d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125;][%c]%m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### 保存异常信息到单独文件 ###</span></span><br><span class="line"><span class="attr">log4j.appender.E</span> = <span class="string">org.apache.log4j.DailyRollingFileAppender</span></span><br><span class="line"><span class="attr">log4j.appender.E.File</span> = <span class="string">$&#123;project&#125;src/main/resources/log/error.log</span></span><br><span class="line"><span class="attr">log4j.appender.E.Append</span> = <span class="string">true</span></span><br><span class="line"><span class="attr">log4j.appender.E.Threshold</span> = <span class="string">ERROR</span></span><br><span class="line"><span class="attr">log4j.appender.E.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.E.layout.ConversionPattern</span> = <span class="string">[%p][%d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125;][%c]%m%n</span></span><br></pre></td></tr></table></figure>

<h5 id="第三步：编写测试类"><a href="#第三步：编写测试类" class="headerlink" title="第三步：编写测试类"></a>第三步：编写测试类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.PropertyConfigurator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Log4jDemo</span> &#123;</span><br><span class="line">    <span class="comment">//private static Logger logger = LoggerFactory.getLogger(Log4jTestDemo.class);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前项目的根目录</span></span><br><span class="line">        String relativelyPath=System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定properties文件位置</span></span><br><span class="line">        PropertyConfigurator.configure(relativelyPath+ <span class="string">&quot;/src/main/resources/conf/log4j.properties&quot;</span>);</span><br><span class="line">        <span class="comment">// 记录debug级别的信息</span></span><br><span class="line">        log.debug(<span class="string">&quot;This is debug message.&quot;</span>);</span><br><span class="line">        <span class="comment">// 记录info级别的信息</span></span><br><span class="line">        log.info(<span class="string">&quot;This is info message.&quot;</span>);</span><br><span class="line">        <span class="comment">// 记录error级别的信息</span></span><br><span class="line">        log.error(<span class="string">&quot;This is error message.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除非配置文件在resources目录下，否则不能自己找到配置文件的位置，还需要在代码中指定位置，低效！</p>
<p>这个问题貌似在spring中得到解决，在web.xml中增加配置：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/HenryMrZ/article/details/79258057">https://blog.csdn.net/HenryMrZ/article/details/79258057</a></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>log4jConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:/conf/log4j.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="4-maven项目打包"><a href="#4-maven项目打包" class="headerlink" title="4.maven项目打包"></a>4.maven项目打包</h4><p>有个问题：web项目进行部署前，必须要将项目进行打包吗？</p>
<p>直接部署在tomcat，并没有在target文件夹下找到war包。</p>
<p>maven-web项目要使用servlet，就要导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>导入之后reimport一下pom.xml。</p>
<p>发现部署之后，原本的System.getProperty输出的项目目录变成了tomcat的bin目录。</p>
<h5 id="介绍一下System-getProperty"><a href="#介绍一下System-getProperty" class="headerlink" title="介绍一下System.getProperty()"></a>介绍一下System.getProperty()</h5><p>Java中给我们提供了System.getProperty()这个函数，这个函数可以获取到Java JVM以及操作系统的一些参数，可以供程序判断等。</p>
<p>System.getProperty()方法中需要传递一个字符串的参数，表示需要获取那个环境配置，获得结果为String。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.getProperty(<span class="string">&quot;java.vm.version&quot;</span>);<span class="comment">//java虚拟机版本  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;java.vendor.url&quot;</span>); <span class="comment">//java官方网站  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;java.vm.nam&quot;</span>); <span class="comment">//java虚拟机名称  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;user.country&quot;</span>); <span class="comment">//国家或地区  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;user.dir&quot;</span>); <span class="comment">//工程的路径  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;java.runtime.version&quot;</span>);<span class="comment">//java运行环境版本  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;os.arch&quot;</span>); <span class="comment">//操作系统位数（32或64）  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;os.name&quot;</span>); <span class="comment">//操作系统名称  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;sun.jnu.encoding&quot;</span>); <span class="comment">//编码格式  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;os.version&quot;</span>); <span class="comment">//操纵系统版本  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;java.version&quot;</span>); <span class="comment">//java版本版本</span></span><br></pre></td></tr></table></figure>

<p>那么如何找到路径下的log4j.properties配置文件呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> req.getServletContext().getRealPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">System.out.println(filePath); <span class="comment">// 文件存放的路径</span></span><br><span class="line"><span class="comment">// 指定properties文件位置</span></span><br><span class="line">PropertyConfigurator.configure(filePath + <span class="string">&quot;WEB-INF/classes/conf/log4j.properties&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="项目中target目录是什么？"><a href="#项目中target目录是什么？" class="headerlink" title="项目中target目录是什么？"></a>项目中target目录是什么？</h5><p>target是用来存放项目构建后的文件和目录、jar包、war包、编译的class文件，所有都是Maven构建时生成的。</p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/zhangzhixi/5102490?b=totalstatistic">https://blog.51cto.com/zhangzhixi/5102490?b=totalstatistic</a></p>
<p>还有一个问题：tomcat运行之后，日志不保存在文件中了，难道是识别不了project目录了吗？</p>
<p>确实，log输出到了tomcat中的bin目录中。改成绝对目录。</p>
<h5 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h5><p>由于web项目没有写java文件没有main函数, 是无法直接运行的, 因此web项目需要放在一个容器里才能运行</p>
<p>这里就将web项目放在Tomcat这个web服务器里运行</p>
<p>基于maven的web项目 “ 打包、部署、使用” 操作步骤如下:</p>
<ol>
<li>打包：在IDEA主界面的右边找到maven, 在maven的生命周期Lifecycle下面找到package, 双击package命令进行运行。底下的控制台提示 BUILD SUCCESS 代表构建成功。构建成功之后, 根据控制台里提示的war包路径找到war的位置。</li>
<li>部署：”部署“ 操作      (部署就是手动把打包好的war包复制到tomcat-webapps下边)</li>
</ol>
<blockquote>
<p>不打jar包运行，tomcat文件夹下没有应用的痕迹啊。【todo】应该是把war包放在tomcat目录下和idea中启动不太一样。idea中需要idea一直在运行状态。但是idea中运行的也是tomcat？</p>
</blockquote>
<ol start="3">
<li><p>运行，首先将Tomcat加载到系统环境变量</p>
<blockquote>
<p>配置tomcat环境变量：</p>
<p>如果不配置的话，需要每次都进到tomcat的bin目录下运行startup.sh启动。</p>
<p>在 ～&#x2F;.zprofile 文件中增加  export PATH&#x3D;${PATH}:tomcat bin目录</p>
<p>​    语法：</p>
<p>​    ${}为占位符，${PATH} 和 $PATH等效</p>
<p>​    &#x3D;前后不能有空格</p>
<p>​    : 为分隔符（等同于windows环境变量中的 ; ）</p>
<p>​    PATH&#x3D;$PATH:xxx 可以理解为 “ PATH+&#x3D;xxx “（当然不能这么写）<br>​    PATH&#x3D;xxx:$PATH这种写法亦可，只是前后顺序的问题；</p>
<p>export -p 查看所有环境变量</p>
<ol>
<li>sudo su 申请权限</li>
<li>startup.sh            &#x2F;&#x2F;启动tomacat</li>
<li>shutdown.sh          &#x2F;&#x2F;关闭tomcat</li>
</ol>
</blockquote>
</li>
</ol>
<p>启动之后，好奇时一直在运行还是怎么的，应该是一直在运行。起个定时线程试一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">service.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">    log.info(<span class="string">&quot;Thread &#123;&#125;, now &#123;&#125;.&quot;</span>, Thread.currentThread(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>报不能用lambada表达式的错误，我改了level等级为8，打包时还报错。不用试了，只要tomcat开的，应用就一直是起的。每访问一次，log文件中就记录日志。</p>
<h3 id="maven打包"><a href="#maven打包" class="headerlink" title="maven打包"></a>maven打包</h3><h4 id="1-idea中使用maven插件打包"><a href="#1-idea中使用maven插件打包" class="headerlink" title="1.idea中使用maven插件打包"></a>1.idea中使用maven插件打包</h4><p>上面就是用此操作，应该先clean，再compile编译，再打包的。</p>
<p>mvn clean 清空class文件<br>mvn compile 编译<br>mvn package 打包<br>mvn test 测试<br>mvn install 打包并上传到本地仓库<br>mvn deploy 上传到远程仓库<br>mvn -Dmaven.test.skip&#x3D;true 跳过测试</p>
<p>pom中的插件应该是自动给我加的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>log-maven-package<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span><span class="comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-install-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  这种打包方式会有外部依赖包。</p>
<h4 id="2-直接使用mvn-package打包"><a href="#2-直接使用mvn-package打包" class="headerlink" title="2.直接使用mvn package打包"></a>2.直接使用mvn package打包</h4><p>不在 POM 中配置任何插件，直接使用 <code>mvn package</code> 进行项目打包，这对于没有使用外部依赖包的项目是可行的。但如果项目中使用了第三方 JAR 包，就会出现问题，因为 <code>mvn package</code> 打的 JAR 包中是不含有依赖包，会导致作业运行时出现找不到第三方依赖的异常。这种方式局限性比较大，因为实际的项目往往很复杂，通常都会依赖第三方 JAR。</p>
<p>大数据框架的开发者也考虑到这个问题，所以基本所有的框架都支持在提交作业时使用 <code>--jars</code> 指定第三方依赖包，但是这种方式的问题同样很明显，就是你必须保持生产环境与开发环境中的所有 JAR 包版本一致，这是有维护成本的。</p>
<p>基于上面这些原因，最简单的是采用 <code>All In One</code> 的打包方式，把所有依赖都打包到一个 JAR 文件中，此时对环境的依赖性最小。要实现这个目的，可以使用 Maven 提供的 <code>maven-assembly-plugin</code> 或 <code>maven-shade-plugin</code> 插件。</p>
<blockquote>
<p>我直接使用mvn package 报错误</p>
<p>[ERROR] No compiler is provided in this environment. Perhaps you are running on a JRE rather than a JDK?</p>
<p>未解决</p>
</blockquote>
<h4 id="3-maven-assembly-plugin插件"><a href="#3-maven-assembly-plugin插件" class="headerlink" title="3.maven-assembly-plugin插件"></a>3.maven-assembly-plugin插件</h4><p><code>Assembly</code> 插件支持将项目的所有依赖、文件都打包到同一个输出文件中。目前支持输出以下文件类型：</p>
<ul>
<li>zip</li>
<li>tar</li>
<li>tar.gz (or tgz)</li>
<li>tar.bz2 (or tbz2)</li>
<li>tar.snappy</li>
<li>tar.xz (or txz)</li>
<li>jar</li>
<li>dir</li>
<li>war</li>
</ul>
<p><strong>基本使用</strong></p>
<p>在 POM.xml 中引入插件，指定打包格式的配置文件 <code>assembly.xml</code>(名称可自定义)，并指定作业的主入口类：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目最终打包成的名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>community<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptors</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptor</span>&gt;</span>src/main/resources/assembly.xml<span class="tag">&lt;/<span class="name">descriptor</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptors</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 指定启动类 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.liuxuan.Log4jDemo<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>assembly.xml 文件内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">assembly</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/ASSEMBLY/2.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/ASSEMBLY/2.0.0 </span></span></span><br><span class="line"><span class="string"><span class="tag">                              http://maven.apache.org/xsd/assembly-2.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指明打包方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">formats</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">format</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">formats</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">includeBaseDirectory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">includeBaseDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencySets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencySet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>/<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">useProjectArtifact</span>&gt;</span>true<span class="tag">&lt;/<span class="name">useProjectArtifact</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">unpack</span>&gt;</span>true<span class="tag">&lt;/<span class="name">unpack</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这里以排除 storm 环境中已经提供的 storm-core 为例，演示排除 Jar 包--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.apache.storm:storm-core<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencySet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencySets</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>采用 maven-assembly-plugin 进行打包时命令如下：</p>
<p>mvn assembly:assembly </p>
<blockquote>
<p>问题：使用命令mvn compile 时，会报错 no compiler，但是idea中点击时没问题。所以得先点compile编译，再执行assembly命令。</p>
</blockquote>
<p>打包后会同时生成两个 JAR 包，其中后缀为 <code>jar-with-dependencies</code> 是含有第三方依赖的 JAR 包，后缀是由 <code>assembly.xml</code> 中 <code>&lt;id&gt;</code> 标签指定的，可以自定义修改。</p>
<h4 id="4-maven-shade-plugin插件"><a href="#4-maven-shade-plugin插件" class="headerlink" title="4.maven-shade-plugin插件"></a>4.maven-shade-plugin插件</h4><p><code>maven-shade-plugin</code> 比 <code>maven-assembly-plugin</code> 功能更为强大，比如你的工程依赖很多的 JAR 包，而被依赖的 JAR 又会依赖其他的 JAR 包，这样,当工程中依赖到不同的版本的 JAR 时，并且 JAR 中具有相同名称的资源文件时，shade 插件会尝试将所有资源文件打包在一起时，而不是和 assembly 一样执行覆盖操作。</p>
<p><strong>通常使用 <code>maven-shade-plugin</code> 就能够完成大多数的打包需求，其配置简单且适用性最广，因此建议优先使用此方式。</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目最终打包成的名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>community<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 指定启动类 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformer</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.ronz.community.CommunityApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">&lt;!-- 下面的配置仅针对存在同名资源文件的情况，如没有则不用配置--&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 有些项目包可能会包含同文件名的资源文件（例如属性文件）--&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 为避免覆盖，可以将它们的内容合并到一个文件中 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformer</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">resource</span>&gt;</span>META-INF/spring.handlers<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformer</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">resource</span>&gt;</span>META-INF/spring.schemas<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 maven-shade-plugin 进行打包的时候，打包命令和普通打包一样</p>
<p>mvn package</p>
<h4 id="5-使用-maven-jar-plugin-和-maven-dependency-plugin-插件"><a href="#5-使用-maven-jar-plugin-和-maven-dependency-plugin-插件" class="headerlink" title="5.使用 maven-jar-plugin 和 maven-dependency-plugin 插件"></a>5.使用 maven-jar-plugin 和 maven-dependency-plugin 插件</h4><p>此种打包方式有一个比较明显的缺点：打包后会在 <code>target</code> 目录下生成 <code>lib</code> 目录（存放依赖 Jar）和项目 Jar。也就是说由于依赖都存在于 <code>lib</code> 目录中，所以要想运行 Jar 包，必须将 Jar 包和 <code>lib</code>目录放在同一个路径下。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目最终打包成的名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>community<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 会在 MANIFEST.MF 中生成 Class-Path 项 --&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 系统会根据 Class-Path 项配置的路径加载依赖 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 指定依赖包所在目录，相对于项目最终 Jar 包的路径 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>lib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 指定 MainClass --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.ronz.community.CommunityApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置依赖包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 相当于执行 mvn 命令，将依赖打包到指定目录 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--将依赖打包至 target 下的 lib 目录--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个思想也比较简单。</p>
<p>首先说 maven-jar-plugin 插件，它的思想就是：指定启动类、指定依赖包相对于项目最终 Jar 包所在的路径、给 MANIFEST.MF 文件添加 Class-Path 属性（运行项目 Jar 包时会根据 Class-Path 属性来找到具体依赖 Jar 包的路径）。</p>
<p>接着是 maven-dependency-plugin 插件，它的主要思想就是：指定所有依赖被打包为 Jar 包后的存放路径。</p>
<p>pom.xml 文件配置完毕之后，就可以运行打包命令了：<br><em># 跳过测试用例执行 package 命令</em> mvn package -Dmaven.test.skip&#x3D;true</p>
<p>这种方式打包出来的 Jar 包，在代码层面只包含了项目本身的代码。而项目的依赖都以 Jar 包的形式放在了项目 Jar 包同级别目录下的 <code>lib</code> 目录中，这些依赖 Jar 包的路径在 <code>MANIFEST.MF</code> 文件中都以路径的方式指明了。</p>
<h4 id="打包总结"><a href="#打包总结" class="headerlink" title="打包总结"></a>打包总结</h4><p>工作中用到的命令只是：mvn package -Dmaven.test.skip&#x3D;true，但是看项目中貌似使用的是assembly。</p>
<p>推荐使用maven-shade-plugin插件，可以避免前面的资源文件被后面的覆盖掉。</p>
<p>只是mvn compile 这个问题还没解决，为什么idea中点击compile能够编译，终端执行命令却不行。</p>
<h3 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h3><p><a target="_blank" rel="noopener" href="https://github.com/jadeliuliu/log-maven-package/tree/master">https://github.com/jadeliuliu/log-maven-package/tree/master</a></p>
<p>摘自：</p>
<p>slf4j、log4j、logback：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/javalinux/p/15683735.html">https://www.cnblogs.com/javalinux/p/15683735.html</a></p>
<p>log发展史：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7033021644142542878">https://juejin.cn/post/7033021644142542878</a></p>
<p>idea中创建maven web项目：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/weiqingfeng/p/9494914.html">https://www.cnblogs.com/weiqingfeng/p/9494914.html</a></p>
<p>mac区分.bash_profile 和&#x2F;etc&#x2F;profile：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42214743/article/details/116133257">https://blog.csdn.net/weixin_42214743/article/details/116133257</a></p>
<p>bash和zsh：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20036548/answer/2345481001">https://www.zhihu.com/question/20036548/answer/2345481001</a></p>
<p>log4j配置文件：<a target="_blank" rel="noopener" href="http://www.blogjava.net/zJun/archive/2006/06/28/55511.html">http://www.blogjava.net/zJun/archive/2006/06/28/55511.html</a></p>
<p>maven项目打包部署到tomcat：<a target="_blank" rel="noopener" href="https://blog.csdn.net/asdx1020/article/details/104554811">https://blog.csdn.net/asdx1020/article/details/104554811</a>   &amp;&amp;   <a target="_blank" rel="noopener" href="https://blog.csdn.net/Shangxingya/article/details/107295800">https://blog.csdn.net/Shangxingya/article/details/107295800</a></p>
<p>常用maven打包方式：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904067194437639#heading-1">https://juejin.cn/post/6844904067194437639#heading-1</a>   &amp;&amp; <a target="_blank" rel="noopener" href="https://blog.csdn.net/zhuxian1277/article/details/119880760">https://blog.csdn.net/zhuxian1277/article/details/119880760</a></p>
<h3 id="log日志怎么传参"><a href="#log日志怎么传参" class="headerlink" title="log日志怎么传参"></a>log日志怎么传参</h3><p>不同于String.format和sout，log使用占位符传参，就是{}，前面用:还是&#x3D;还是其他无所谓：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;remind：orderInfo:&#123;&#125;&quot;, JSON.toJSONString(orderInfo));</span><br></pre></td></tr></table></figure>
<p>如果是log.error里面还有Exception对象，那么该怎么打印:<br>对于异常，是不需要占位符的，而且也不需要 e.getMessage()，直接打印出来即可.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">&#125; catch (Exeception e) &#123;</span><br><span class="line">    log.error(&quot;error in order:&#123;&#125;&quot;, JSON.toJSONString(orderInfo), e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="log日志级别开关"><a href="#log日志级别开关" class="headerlink" title="log日志级别开关"></a>log日志级别开关</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/19/myblog/java/servlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/19/myblog/java/servlet/" class="post-title-link" itemprop="url">servlet入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-19 15:54:44" itemprop="dateCreated datePublished" datetime="2022-03-19T15:54:44+08:00">2022-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-20 15:36:37" itemprop="dateModified" datetime="2023-08-20T15:36:37+08:00">2023-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-Http协议"><a href="#1-Http协议" class="headerlink" title="1.Http协议"></a>1.Http协议</h3><p>HTTP协议的特点<br>1.支持客户 &#x2F; 服务器模式 	<br>2.简单快速<br>3.灵活<br>4.无连接，HTTP1.1 版本后支持可持续连接<br>5.无状态</p>
<p>HTTP url:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//host[:port]/[abs_path]</span></span><br><span class="line">http:<span class="comment">//IP(主机名/域名):端口/访问的资源路径</span></span><br></pre></td></tr></table></figure>

<ul>
<li>http 表示通过HTTP协议来定位网络资源</li>
<li>host 表示合法的 Internet 主机名或者 ip 地址</li>
<li>port 指一个端口号，为空则为 80</li>
<li>abs_path 指定请求的 URL</li>
</ul>
<h4 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h4><ul>
<li>http请求由请求行、<strong>请求头</strong>、请求正文组成。<ul>
<li>请求体第一行就是请求行；请求行由请求方式，请求路径、请求协议版本三部分组成</li>
<li>请求头指一行一行的键值对</li>
<li>正文即是内容；GET请求没有正文，其内容直接跟在地址后面</li>
</ul>
</li>
</ul>
<h4 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h4><ul>
<li>在接收和解释请求消息后，服务器返回一个 HTTP 响应消息。HTTP 响应由状态行、消息报头、响应正文组成<ul>
<li>状态行由协议版本、状态码、请求结果组成</li>
<li>消息报头与请求头大致相同</li>
<li>响应正文就是浏览器呈现的内容</li>
</ul>
</li>
</ul>
<h4 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h4><p>  HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成，请求消息和响应消息都是由开始行（对于请求消息， 开始行就是请求行；响应消息则是状态行），消息报头，空行，消息正文（可选）组成</p>
<p>  每一个报头域都是由 名字+”:”+空格+值 组成，消息报头域的名字是大小写无关的</p>
<p>1.请求头：</p>
<p>  请求报头允许客户端向服务器传递请求的附加信息以及客户端自身的信息，无法通过参数来传递的用请求头。</p>
<ul>
<li><p>referer： 该请求头指明请求从哪里来</p>
<p> 此请求头后面接的值为上一个页面的URL地址，通常用来做统计、防盗链。如果是从浏览器地址栏直接输入进行访问的，都没有该请求头。例如百度的广告，搜一个东西，出现广告字样的连接，点击会记录是从百度搜索进来的。例如邀请好友，用来记录是谁邀请进来的。例如从a页面到d页面，必须要经过b页面和c页面，防盗链。</p>
</li>
</ul>
<p>2.响应头</p>
<p>  响应报头允许服务器传递不能放在状态行中的附加响应消息，以及关于服务器的信息和对Request-URL所标识的资源进行下一步访问的信息</p>
<ul>
<li>location（重定向）：location 响应报头域用于重定向接收者到一个新位置</li>
</ul>
<p>  location响应报头域，常用在服务器更换域名时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>refresh：第一种是定时自动跳转到 [url]指定的页面（单位为秒）（307重定向过来的），可以在html页面通过meta标签实现，也可以在后台实现；第二种是不带 [url] 是指每 [content] 秒刷新一次页面</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;refresh&quot;</span> content=<span class="string">&quot;3;url=http://www.baidu.com&quot;</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2-servlet概述"><a href="#2-servlet概述" class="headerlink" title="2.servlet概述"></a>2.servlet概述</h3><p>Servlet 是 Server 与 Applet 的缩写，是服务端小程序的意思。使用 Java 语言编写的服务器端程序，可以生成动态的 WEB 页，Servlet 主要运行在服务器端，并由服务器调用执行， 是一种按照 Servlet 标准来开发的类。 是 SUN 公司提供的一门用于开发动态 Web 资源的技术。（言外之意：要实现 web 开发，需要实现 Servlet 标准）</p>
<p>Servlet 本质上也是 Java 类，但要遵循 Servlet 规范进行编写，没有 main()方法，它的创建、使用、销毁都由 Servlet容器进行管理(如 Tomcat)。（言外之意：写自己的类，不用写 main 方法，别人自动调用）</p>
<p>Servlet 是和 HTTP 协议是紧密联系的，其可以处理 HTTP 协议相关的所有内容。这也是 Servlet 应用广泛的原因之一。<br>提供了 Servlet 功能的服务器，叫做 Servlet 容器，其常见容器有很多，如 Tomcat, Jetty, WebLogic Server, WebSphere, JBoss 等等。</p>
<p><strong>tomcat和servlet的关系</strong></p>
<p>Tomcat 是Web应用服务器,是一个Servlet&#x2F;JSP容器. Tomcat 作为Servlet容器,负责处理客户请求,把请求传送给Servlet,并将Servlet的响应传送回给客户.而Servlet是一种运行在支持Java语言的服务器上的组件。</p>
<h3 id="3-使用servlet"><a href="#3-使用servlet" class="headerlink" title="3.使用servlet"></a>3.使用servlet</h3><h4 id="3-1-新建web项目"><a href="#3-1-新建web项目" class="headerlink" title="3.1.新建web项目"></a>3.1.新建web项目</h4><p>创建web工程，java enterprise - web application，引入jdk、tomcat。</p>
<h4 id="3-2-实现servlet规范"><a href="#3-2-实现servlet规范" class="headerlink" title="3.2.实现servlet规范"></a>3.2.实现servlet规范</h4><p>实现 Servlet 规范，即继承 HttpServlet 类（tomcat里的jar包支持的），该类中已经完成了通信的规则，我们只需要进行业务的实现即可。</p>
<p><strong>重写 service 方法</strong><br>满足 Servlet 规范只是让我们的类能够满足接收请求的要求，接收到请求后需要对请求进行分析，以及进行业务逻辑处理，计算出结果，则需要添加代码，在规范中有一个叫做 service的方法，专门用来做请求处理的操作，业务代码则可以写在该方法中。</p>
<p><strong>通过注解设置路径</strong></p>
<p>在完成好了一切代码的编写后，还需要向服务器说明，特定请求对应特定资源。</p>
<p>开发servlet项目，使用@WebServlet将一个继承于javax.servlet.http.HttpServlet 的类定义为Servlet组件。在Servlet3.0 中 ， 可以使用@WebServlet注解将一个继承javax.servlet.http.HttpServlet的类标注为可以处理用户请求的Servlet。</p>
<blockquote>
<p>javax.servlet下面有两个servlet-api，一个是servlet-api，这个定义了servlet规范，一个是javax.servlet-api，这个是serlvet提供的api。<br>@WebServlet这个注解是在javax.servlet-api依赖包里</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name可写可不写，value过滤器会拦截，urlPatterns过滤器不会拦截</span><br><span class="line"><span class="meta">@WebServlet(name=&quot;Servlet01&quot;,value=&quot;/ser01&quot;)</span> </span><br><span class="line"><span class="meta">@WebServlet(name=&quot;Servlet01&quot;,urlPatterns = &quot;/ser01&quot;)</span></span><br><span class="line">也可以配置多个路径：</span><br><span class="line"><span class="meta">@WebServlet(name=&quot;Servlet01&quot;,value=&#123;&quot;/ser01&quot;,&#x27;/ser001&#x27;&#125;)</span> </span><br><span class="line"><span class="meta">@WebServlet(name=&quot;Servlet01&quot;,urlPatterns=&#123;&quot;/ser01&quot;,&#x27;/ser001&#x27;&#125;)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-19 17:00</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Servlet!&quot;</span>);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-发布项目并启动服务"><a href="#3-3-发布项目并启动服务" class="headerlink" title="3.3.发布项目并启动服务"></a>3.3.发布项目并启动服务</h4><p>到此，需要编写和配置的地方已经完成，项目已经完整了，但是如果需要外界能够访问， 还需要将项目发布到服务器上并运行服务器。</p>
<p>设置tomcat配置，设置项目的站点名（项目对外访问路径）</p>
<p>配置中选deployment更改站点名。</p>
<p>然后启动就可以访问页面。</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/servlet_demo/ser01">http://localhost:8080/servlet_demo/ser01</a></p>
<p>tomcat有个绿点表示正在运行。</p>
<h3 id="4-servlet工作流程"><a href="#4-servlet工作流程" class="headerlink" title="4.servlet工作流程"></a>4.servlet工作流程</h3><p>1.通过请求头获知浏览器访问的是哪个主机</p>
<p>2.再通过请求行获取访问的是哪个一个web应用</p>
<p>3.再通过请求行中的请求路径获知访问的是哪个资源</p>
<p>4.通过获取的资源路径在配置中匹配到真实的路径</p>
<p>5.服务器会创建servlet对象，（如果是第一次访问时，创建servlet实例，并调用init方法进行初始化操作）</p>
<p>6.调用service（request， response）方法来处理请求和响应的操作</p>
<p>7.调用service完毕后返回服务器，由服务器将response缓冲区的数据取出，以http响应的格式发送给浏览器</p>
<h3 id="5-servlet工作模式"><a href="#5-servlet工作模式" class="headerlink" title="5.servlet工作模式"></a>5.servlet工作模式</h3><ul>
<li>客户端发送请求至服务器</li>
<li>服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器</li>
<li>服务器将响应返回客户端</li>
</ul>
<h3 id="6-servlet生命周期"><a href="#6-servlet生命周期" class="headerlink" title="6.servlet生命周期"></a>6.servlet生命周期</h3><p>Servlet没有 main()方法，不能独立运行，它的运行完全由 Servlet 引擎来控制和调度。 所谓生命周期，指的是servlet 容器何时创建 servlet 实例、何时调用其方法进行请求的处理、 何时并销毁其实例的整个过程。</p>
<ol>
<li>实例和初始化时机（类加载和实力化）<br>当请求到达容器时，容器查找该 servlet 对象是否存在，如果不存在，则会创建实例并进行初始化。</li>
<li>就绪&#x2F;调用&#x2F;服务阶段<br>有请求到达容器，容器调用 servlet 对象的 service()方法,处理请求的方法在整个生命周期中可以被多次调用；<br>HttpServlet 的 service()方法，会依据请求方式来调用 doGet()或者 doPost()方法。但是， 这两个 do 方法默认情况下，会抛出异常，需要子类去 override。</li>
<li>销毁时机<br>当容器关闭时（应用程序停止时），会将程序中的 Servlet 实例进行销毁。</li>
</ol>
<p>上述的生命周期可以通过 Servlet 中的生命周期方法来观察。在 Servlet 中有三个生命周 期方法，不由用户手动调用，而是在特定的时机由容器自动调用，观察这三个生命周期方法 即可观察到 Servlet 的生命周期。</p>
<p>1⃣️ init 方法，在 Servlet 实例创建之后执行（证明该 Servlet 有实例创建了）</p>
<p>2⃣️service 方法，每次有请求到达某个 Servlet 方法时执行，用来处理请求（证明该Servlet 进行服务了）</p>
<p>3⃣️destroy 方法，Servlet 实例销毁时执行（证明该 Servlet 的实例被销毁了）</p>
<p>Servlet 的生命周期，简单的概括这就分为四步：servlet 类加载–&gt;实例化–&gt;服务–&gt;销毁。<br>下面描述一下 Tomcat 与 Servlet 是如何工作的,看看下面的时序图：</p>
<p><img src="/images/servlet%E6%97%B6%E5%BA%8F%E5%9B%BE.png"></p>
<ol>
<li>Web Client 向 Servlet 容器（Tomcat）发出 Http 请求</li>
<li>Servlet 容器接收 Web Client 的请求</li>
<li>Servlet 容器创建一个 HttpServletRequest 对象，将 Web Client 请求的信息封装到这个对象 中</li>
<li>Servlet 容器创建一个 HttpServletResponse 对象</li>
<li>Servlet 容器调HttpServlet 对象service 方法，把 Request 与 Response 作为参数，传给 HttpServlet</li>
<li>HttpServlet 调用 HttpServletRequest 对象的有关方法，获取 Http 请求信息</li>
<li>HttpServlet 调用 HttpServletResponse 对象的有关方法，生成响应数据</li>
<li>Servlet 容器把 HttpServlet 的响应结果传给 Web Client</li>
</ol>
<h3 id="7-形参：HttpServletRequest对象"><a href="#7-形参：HttpServletRequest对象" class="headerlink" title="7.形参：HttpServletRequest对象"></a>7.形参：HttpServletRequest对象</h3><p>HttpServletRequest 对象：主要作用是用来接收客户端发送过来的请求信息，例如：请求的参数，发送的头信息等都属于客户端发来的信息，service()方法中形参接收的HttpServletRequest 接口的实例化对象，表示该对象主要应用在 HTTP 协议上，该对象是由 Tomcat 封装好传递过来。</p>
<p>HttpServletRequest 是 ServletRequest 的子接口，ServletRequest 只有一个子接口，就是 HttpServletRequest。既然只有一个子接口为什么不将两个接口合并为一个？<br>从长远上讲：现在主要用的协议是 HTTP 协议，但以后可能出现更多新的协议。若以后想要支持这种新协议，只需要直接继承 ServletRequest 接口就行了。</p>
<p>在 HttpServletRequest 接口中，定义的方法很多，但都是围绕接收客户端参数的。但是怎么拿到该对象呢？不需要，直接在 Service 方法中由容器传入过来，而我们需要做的就是取出对象中的数据，进行分析、处理。</p>
<h4 id="接收请求"><a href="#接收请求" class="headerlink" title="接收请求"></a>接收请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-20 09:41</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser03&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet3</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 常用方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 获取请求时的完整路径（从http开始，到？前面结束）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestURL() +<span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;url:&quot;</span>+url);</span><br><span class="line">        <span class="comment">// 获取请求时的部分路径（从项目的站点名称开始，到？前面结束）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> req.getRequestURI();</span><br><span class="line">        System.out.println(<span class="string">&quot;uri:&quot;</span>+uri);</span><br><span class="line">        <span class="comment">// 获取请求时的参数字符串（从？开始）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queryString</span> <span class="operator">=</span> req.getQueryString();</span><br><span class="line">        System.out.println(<span class="string">&quot;queryString:&quot;</span>+queryString);</span><br><span class="line">        <span class="comment">// 获取请求方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;method:&quot;</span>+method);</span><br><span class="line">        <span class="comment">// 获取当前协议版本</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">protocol</span> <span class="operator">=</span> req.getProtocol();</span><br><span class="line">        System.out.println(<span class="string">&quot;protocol:&quot;</span>+protocol);</span><br><span class="line">        <span class="comment">// 获取项目的站点名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">webApp</span> <span class="operator">=</span> req.getContextPath();</span><br><span class="line">        System.out.println(<span class="string">&quot;webApp:&quot;</span>+webApp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取请求的参数</span></span><br><span class="line"><span class="comment">         * http://localhost:8080/servlet_demo/ser03?uname=lili&amp;upwd=lslsls&amp;input=111&amp;input=222&amp;input=333</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 获取指定名称的参数值,返回字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">upwd</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;upwd&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;uname:&quot;</span>+uname);</span><br><span class="line">        System.out.println(<span class="string">&quot;upwd:&quot;</span>+upwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定名称的参数的所有参数值,返回字符串数组（用于复选框传值）</span></span><br><span class="line">        String[] strings = req.getParameterValues(<span class="string">&quot;input&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(strings != <span class="literal">null</span> &amp;&amp; strings.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(String s : strings)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;strings:&quot;</span>+s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="请求乱码问题"><a href="#请求乱码问题" class="headerlink" title="请求乱码问题"></a>请求乱码问题</h4><p>由于现在的 request 属于接收客户端的参数，所以必然有其默认的语言编码，主要是由于在解析过程中默认使用的编码方式为 ISO-8859-1(此编码不支持中文)，所以解析时一定会出现乱码。要想解决这种乱码问题，需要设置request 中的编码方式，告诉服务器以何种方式来解析数据。或者在接收到乱码数据以后，再通过相应的编码格式还原。<br>方式一：</p>
<p><code>String nuname = new String(request.getParameter(name).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); </code></p>
<p>借助了String 对象的方法，该种方式对任何请求有效，是通用的。但是原本不是乱码的，使用的话会出现乱码。<br>Tomcat8起，以后的GET方式请求是不会出现乱码的。POST请求是会乱码的。</p>
<p>用JSP进行post请求表单提交：新建login.jsp</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;ser03&quot;</span>&gt;</span><br><span class="line">        姓名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;uname&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">        密码：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;upwd&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">        &lt;button&gt;登录&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>访问：<a target="_blank" rel="noopener" href="http://localhost:8080/servlet_demo/login.jsp">http://localhost:8080/servlet_demo/login.jsp</a></p>
<p>方式二：通过设置服务器解析编码的格式（只针对post请求）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置编码格式</span></span><br><span class="line">req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);	</span><br></pre></td></tr></table></figure>

<h4 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h4><p>请求转发，是一种服务器的行为，当客户端请求到达后，服务器进行转发，此时会将请求对象进行保存，地址栏中的 URL 地址不会改变，得到响应后，服务器端再将响应发送给客户端，从始至终只有一个请求发出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-20 21:34</span></span><br><span class="line"><span class="comment"> * 请求转发跳转</span></span><br><span class="line"><span class="comment"> * 可以让请求从服务端跳转到客户端即jsp（或跳转到指定Servlet）服务器行为</span></span><br><span class="line"><span class="comment"> * 特点：1。服务端行为 2。地址栏不会发生改变</span></span><br><span class="line"><span class="comment"> * 3。从始至终只有一个请求 4。request数据可以共享</span></span><br><span class="line"><span class="comment"> * 只能跳一次</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser04&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet4</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 接收客户端请求的参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ser04 uname:&quot;</span>+uname);</span><br><span class="line">        <span class="comment">// 请求转发跳转到ser03</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;ser03&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="request作用域"><a href="#request作用域" class="headerlink" title="request作用域"></a><strong>request作用域</strong></h4><p>通过该对象可以在一个请求中传递数据，作用范围：在一次请求中有效，即服务器跳转有效。（请求转发跳转时有效，直接访问跳转的url无效）。作用域在一次请求中，在请求转发过程中通过request来传输&#x2F;共享数据。</p>
<p>Ser05，准备用来请求转发。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-20 21:34</span></span><br><span class="line"><span class="comment"> * request作用域</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser05&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet5</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 设置域对象</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        req.setAttribute(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        req.setAttribute(<span class="string">&quot;list&quot;</span>, list);</span><br><span class="line">        <span class="comment">// 请求转发并跳转到Servlet6，共享同一个req对象</span></span><br><span class="line">        <span class="comment">//req.getRequestDispatcher(&quot;ser06&quot;).forward(req, resp);</span></span><br><span class="line">        <span class="comment">// 一般是从客户端获取数据，所以跳转到jsp客户端</span></span><br><span class="line">        <span class="comment">// 请求转发跳转到jsp，并通过域对象传递数据</span></span><br><span class="line">        <span class="comment">// html就不行，因为是静态页面，而jsp是动态页面</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;attribute.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跳转到ser06</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-20 21:34</span></span><br><span class="line"><span class="comment"> * request作用域</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser06&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet6</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取域对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) req.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name：&quot;</span> + name);</span><br><span class="line">        List&lt;String&gt; list = (List&lt;String&gt;) req.getAttribute(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跳转到jsp：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;attribute页面&lt;/h2&gt;</span><br><span class="line">&lt;%-- 如果要在jsp中写java代码，需要写在脚本段中 --%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 获取域对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) request.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name：&quot;</span> + name);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<h3 id="8-形参：HttpServletResponse对象"><a href="#8-形参：HttpServletResponse对象" class="headerlink" title="8.形参：HttpServletResponse对象"></a>8.形参：<strong>HttpServletResponse对象</strong></h3><p>Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的 request 对象和代表响应的 response 对象。<br>request 和 response 对象代表请求和响应：获取客户端数据，需要通过 request 对象；向客户端输出数据，需要通过 response 对象。</p>
<p>HttpServletResponse 的主要功能用于服务器对客户端的请求进行响应，将 Web 服务器处理后的结果返回给客户端。service()方法中形参接收的是 HttpServletResponse 接口的实例化对象，这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法。</p>
<h4 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h4><p>接收到客户端请求后，可以通过 HttpServletResponse 对象直接进行响应，响应时需要获取输出流。有两种形式：</p>
<p>getWriter() 获取字符流(只能响应字符) </p>
<p>getOutputStream() 获取字节流(能响应一切数据)</p>
<p>响应回的数据到客户端被浏览器解析。<br>注意：两者不能同时使用。一个文件里只能用一个，因为response只有一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-22 08:50</span></span><br><span class="line"><span class="comment"> * getWriter() 字符输出流(输出字符串)</span></span><br><span class="line"><span class="comment"> * getOutputStream() 字节输出流(输出一切数据)</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser07&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet7</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">//        // getWrite获取字符输出流</span></span><br><span class="line"><span class="comment">//        PrintWriter writer = resp.getWriter();</span></span><br><span class="line"><span class="comment">//        // 输出数据</span></span><br><span class="line"><span class="comment">//        writer.write(&quot;hello&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// getOutputStream字节输出流</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line">        <span class="comment">// 输出数据</span></span><br><span class="line">        out.write(<span class="string">&quot;hi&quot;</span>.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="响应乱码问题"><a href="#响应乱码问题" class="headerlink" title="响应乱码问题"></a>响应乱码问题</h4><p>在响应中，如果我们响应的内容中含有中文，则有可能出现乱码。这是因为服务器响应的数据也会经过网络传输，服务器端有一种编码方式，在客户端也存在一种编码方式，当两端使用的编码方式不同时则出现乱码。</p>
<p>getWriter()的字符乱码<br>对于 getWriter()获取到的字符流，响应中文必定出乱码，由于服务器端在进行编码时默认会使用 ISO-8859-1 格式的编码，该编码方式并不支持中文。</p>
<p>要解决该种乱码只能在服务器端告知服务器使用一种能够支持中文的编码格式，比如我们通常用的”UTF-8”。</p>
<p>客户端也要设置，字节输出流可以设置响应类型，默认是字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置服务端的编码格式</span></span><br><span class="line">resp.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// 设置客户端的编码格式和响应类型</span></span><br><span class="line">resp.setHeader(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;text/html;charset=UTF-8&quot;</span>);       </span><br></pre></td></tr></table></figure>

<p>字符输出流也一样。</p>
<p>也可以同时设置客户端和服务端的编码格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同时设置服务端和客户端的编码格式</span></span><br><span class="line">resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>总结：要想解决响应的乱码，只需要保证使用支持中文的编码格式。并且保证服务器端 和客户端使用相同的编码方式即可。</p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>重定向是一种服务器指导，客户端的行为。客户端发出第一个请求，被服务器接收处理后，服务器会进行响应，在响应的同时，服务器会给客户端一个新的地址（下次请求的地址 response.sendRedirect(url);），当客户端接收到响应后，会立刻、马上、自动根据服务器给的新地址发起第二个请求，服务器接收请求并作出响应，重定向完成。<br>从描述中可以看出重定向当中有两个请求存在，并且属于客户端行为。</p>
<p>特点：<br>服务端指导，客户端行为<br>存在两次请求<br> request对象不共享</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-22 08:50</span></span><br><span class="line"><span class="comment"> * 重定向 302</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser08&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet8</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ser08&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ser08:&quot;</span>+uname);</span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;ser07&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过观察浏览器我们发现第一次请求获得的响应码为 302，并且含有一个 location 头信息。并且地址栏最终看到的地址是和第一次请求地址不同的，地址栏已经发生了变化。</p>
<h4 id="请求转发与重定向的区别"><a href="#请求转发与重定向的区别" class="headerlink" title="请求转发与重定向的区别"></a><strong>请求转发与重定向的区别</strong></h4><p><img src="/images/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91.png"></p>
<p>对于请求转发，举个例子，前端页面输入用户名和密码，req.getAttribute获取参数，或是req.setAttribute设置参数，使用请求转发可以将参数传递到jsp页面，jsp页面使用req.getAttribute进行获取。</p>
<p>而重定向是返回一个新的页面，两个页面之间没有参数传递。</p>
<p>请求转发的地址只能是当前站点下（字符串参数就是加载项目根目录后面的字符串），重定向地址可以是任意地址。跨域跳转只能用重定向。</p>
<h3 id="9-cookie"><a href="#9-cookie" class="headerlink" title="9.cookie"></a>9.cookie</h3><p>web程序使用http协议传输，http无状态，导致每一次连接传输的数据量增大。服务器从网络连接中无法获得客户端身份，cookie相当于是服务端颁发给客户端的通行证。不同的服务器应用给客户端的cookie也不一样，是隔离的。</p>
<p>cookie是浏览器提供的一种技术，通过服务器的程序能将一些只须保存在客户端，或者在客户端进行处理的数据，放在本地的计算机上，不需要通过网络传输，因而提高网页处理的效率，并且能够减少服务器的负载，但是由于cookie是服务器保存在客户端的信息，所以其安全性也是很差的。例如常见的记住密码则可以通过cookie来实现，还有通常的推荐显示。</p>
<p>有一个专门操作Cookie的类javax.servlet.http.Cookie。随着服务器端的响应发送给客户端，保存在浏览器。当下次再访问服务器时把Cookie再带回服务器。</p>
<p>Cookie的格式：键值对用&#x3D;连接，多个键值对间用;隔开。</p>
<h4 id="cookie的创建和发送"><a href="#cookie的创建和发送" class="headerlink" title="cookie的创建和发送"></a>cookie的创建和发送</h4><p>通过 new Cookie(“key”,“value”);来创建一个 Cookie 对象，要想将 Cookie 随响应发送到客户端，需要先添加到 response 对象中，response.addCookie(cookie);此时该 cookie 对象则随着响应发送至了客户端。在浏览器上可以看见。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.cookie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-26 11:04</span></span><br><span class="line"><span class="comment"> * cookie的创建和发送</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/coo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cookie01</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 创建cookie name唯一</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">        <span class="comment">// 发送（响应）cookie</span></span><br><span class="line">        resp.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mac浏览器检查cookie：右键检查元素–储存空间–点击cookie</p>
<h4 id="cookie的获取"><a href="#cookie的获取" class="headerlink" title="cookie的获取"></a>cookie的获取</h4><p>在服务器端只提供了一个 getCookies()的方法用来获取客户端回传的所有 cookie 组成的一个数组，如果需要获取单 个 cookie 则需要通过遍历，getName()获取 Cookie 的名称，getValue()获取 Cookie 的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.cookie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-26 11:04</span></span><br><span class="line"><span class="comment"> * cookie的返回，是数组</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/coo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cookie02</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取cookie数组</span></span><br><span class="line">        Cookie[] cookies = req.getCookies();</span><br><span class="line">        <span class="comment">// 非空判断</span></span><br><span class="line">        <span class="keyword">if</span>(cookies != <span class="literal">null</span> &amp;&amp; cookies.length &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 遍历cookie数组</span></span><br><span class="line">            <span class="keyword">for</span>(Cookie cookie : cookies)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cookie.getName();</span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cookie.getValue();</span><br><span class="line">                System.out.println(<span class="string">&quot;名称：&quot;</span>+name+<span class="string">&quot;--值：&quot;</span>+value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接运行就有上次传入浏览器的cookie。</p>
<h4 id="cookie设置到期时间"><a href="#cookie设置到期时间" class="headerlink" title="cookie设置到期时间"></a>cookie设置到期时间</h4><p>除了 Cookie 的名称和内容外，我们还需要关心一个信息，到期时间，到期时间用来指定该 cookie 何时失效。默认 为当前浏览器关闭即失效。我们可以手动设定 cookie 的有效时间（通过到期时间计算），通过 setMaxAge(int time);方法设定 cookie 的最大有效时间，以秒为单位。</p>
<p>到期时间的取值：</p>
<ul>
<li><p>负整数</p>
<p>若为负数，表示不在硬盘存储该 cookie。</p>
<p>cookie 的 maxAge 属性的默认值就是-1，表示只在浏览器内存中存活，一旦关闭浏览器窗口，那么 cookie 就会消失。</p>
</li>
<li><p>正整数</p>
<p>大于 0 的整数，表示存储的秒数。</p>
<p>表示 cookie 对象可存活指定的秒数。当生命大于 0 时，浏览器会把 Cookie 保存到硬盘上，就算关闭浏览器， 就算重启客户端电脑，cookie 也会存活相应的时间。</p>
</li>
<li><p>零(用于删除Cookie)</p>
<p>若为 0，表示删除该 cookie。</p>
<p>cookie 生命等于 0 是一个特殊的值，它表示 cookie 被作废！也就是说，如果原来浏览器已经保存了这个 Cookie，那么可以通过 Cookie 的 setMaxAge(0)来删除这个 Cookie。 无论是在浏览器内存中，还是在客户端 硬盘上都会删除这个 Cookie。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.cookie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-26 11:04</span></span><br><span class="line"><span class="comment"> * cookie的到期时间</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/coo3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cookie03</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 默认值-1，表示只在浏览器内存中</span></span><br><span class="line">        <span class="comment">// 创建Cookie对象</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置Cookie 3天后失效</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">3</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">        <span class="comment">// 发送Cookie对象 设置之后必需进行响应</span></span><br><span class="line">        resp.addCookie(cookie);</span><br><span class="line">        <span class="comment">// 删除之前的cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">oldCookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;kkk&quot;</span>);</span><br><span class="line">        oldCookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">        resp.addCookie(oldCookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="cookie的注意点"><a href="#cookie的注意点" class="headerlink" title="cookie的注意点"></a>cookie的注意点</h4><ul>
<li>Cookie保存在当前浏览器中。</li>
</ul>
<p>在一般的站点中常常有记住用户名这样一个操作，该操作只是将信息保存在本机上，换电脑以后这些信息就无 效了。而且 cookie 还不能跨浏览器。</p>
<ul>
<li>Cookie存中文问题 （一般不存中文）</li>
</ul>
<p>Cookie 中不能出现中文，如果有中文则通过 URLEncoder.encode()来进行编码，获取时通过 URLDecoder.decode()来进行解码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;姓名&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="comment">// 通过 URLEncoder.encode()来进行编码</span></span><br><span class="line">name = URLEncoder.encode(name);</span><br><span class="line">value = URLEncoder.encode(value);</span><br><span class="line"><span class="comment">// 创建Cookie对象</span></span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(name,value);</span><br><span class="line"><span class="comment">// 发送Cookie对象</span></span><br><span class="line">response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取时通过 URLDecoder.decode()来进行解码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> URLDecoder.decode(cookie.getName());</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> URLDecoder.decode(cookie.getValue());</span><br></pre></td></tr></table></figure>

<ul>
<li>同名Cookie问题</li>
</ul>
<p>如果服务器端发送重复的Cookie那么会覆盖原有的Cookie。</p>
<ul>
<li>浏览器存放Cookie的数量</li>
</ul>
<p>不同的浏览器对Cookie也有限定，Cookie的存储有是上限的。Cookie是存储在客户端（浏览器）的，而且一般 是由服务器端创建和设定。后期结合Session来实现回话跟踪。Cookie的大小也是有限制的，一般是4kb以下。</p>
<h4 id="cookie的路径"><a href="#cookie的路径" class="headerlink" title="cookie的路径"></a>cookie的路径</h4><p>Cookie的setPath设置cookie的路径，这个路径直接决定服务器的请求是否会从浏览器中加载某些cookie。</p>
<p><strong>情景一：当前服务器下任何项目的任意资源都可获取Cookie对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line"><span class="comment">// 设置路径为&quot;/&quot;，表示在当前服务器下任何项目都可访问到Cookie对象</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<p><strong>情景二：当前项目下的资源可获取Cookie对象 （默认不设置Cookie的path）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line"><span class="comment">// 设置路径为&quot;/s01&quot;，表示在当前项目下任何项目都可访问到Cookie对象</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/servlet_demo&quot;</span>); <span class="comment">// 默认情况，可不设置path的值</span></span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<p><strong>情景三：指定项目下的资源可获取Cookie对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当前项目路径为：servlet_demo */</span></span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line"><span class="comment">// 设置路径为&quot;/servlet_1&quot;，表示在s02项目下才可访问到Cookie对象</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/servlet_1&quot;</span>); <span class="comment">// 只能在servlet_1项目下获取Cookie，就算cookie是servlet_demo产生的，servlet_demo也不能获取它</span></span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<p><strong>情景四：指定项目的指定目录下的资源可获取Cookie对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line"><span class="comment">// 设置路径为&quot;/servlet_demo/coo1&quot;，表示在servlet_demo/coo1目录下才可访问到Cookie对象</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/servlet_demo/cook&quot;</span>); </span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<p>如果我们设置path，如果当前访问的路径包含了cookie的路径（当前访问路径在cookie路径基础上要比cookie的范围小）cookie就会加载到request对象之中。</p>
<p>cookie的路径指的是可以访问该cookie的顶层目录，该路径的子路径也可以访问该cookie。</p>
<p>总结：当访问的路径包含了cookie的路径时，则该请求将带上该cookie；如果访问路径不包含cookie路径，则该请求不会携带该cookie。</p>
<h3 id="10-HttpSession对象"><a href="#10-HttpSession对象" class="headerlink" title="10.HttpSession对象"></a>10.HttpSession对象</h3><p>上面讲解了请求的概念，无状态，无法做到多个请求之间的数据共享。</p>
<p>HttpSession对象是javax.servlet.http.HttpSession的实例，该接口并不像HttpServletRequest或HttpServletResponse还存在一个父接口，该接口只是一个纯粹的接口。这因为Session本身就属于HTTP协议的范畴。</p>
<p>Session：在计算机中，尤其是在网络应用中，称为“会话控制”。Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。</p>
<p>对于服务器而言，每一个连接到它的客户端都是一个 session，servlet 容器使用此接口创建 HTTP 客户端和 HTTP 服务器之间的会话。会话将保留指定的时间段，跨多个连接或来自用户的页面请求。<strong>一 个会话通常对应于一个用户，该用户可能多次访问一个站点</strong>。可以通过此接口查看和操作有关某个会话 的信息，比如会话标识符、创建时间和最后一次访问时间。在整个 session 中，最重要的就是属性的操作。</p>
<p>session无论客户端还是服务器端都可以感知到，若重新打开一个新的浏览器，则无法取得之前设置的session，因为每一个session只保存在当前的浏览器当中，并在相关的页面取得。</p>
<p>session的作用是为了标识一次会话，或者说确认一个用户；并且在**一次会话（一个用户的多次请求）**期间共享数据。可以通过request.getSession()方法，来获取当前会话的session对象。当获取session对象时，会先判断session对象是否存在，如果存在，则获取session对象，如果不存在，则创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-26 22:54</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/sess01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Session1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// session对象的获取,</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        <span class="comment">// 获取session的唯一标识--会话标识符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> session.getId();</span><br><span class="line">        System.out.println(<span class="string">&quot;唯一标识符号：&quot;</span>+id);</span><br><span class="line">        System.out.println(<span class="string">&quot;创建时间：&quot;</span>+session.getCreationTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;最后一次访问时间(时间戳)：&quot;</span>+session.getLastAccessedTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否是新的session对象：&quot;</span>+session.isNew());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="标识会话-JSESSIONID"><a href="#标识会话-JSESSIONID" class="headerlink" title="标识会话 JSESSIONID"></a><strong>标识会话 JSESSIONID</strong></h4><p>Session 既然是为了标识一次会话，那么此次会话就应该有一个唯一的标志，这个标志就是 sessionId。</p>
<p>每当一次请求到达服务器，如果服务器开启了会话（访问了 session），服务器第一步会查看是否从客户端回传一个名为 JSESSION 的 cookie，如果没有则认为这是一次新的会话，会创建一个新的 session 对象，并用唯一的 sessionId 为此次会话做一个标志，<strong>并且还会传对应的cookie在浏览器</strong>。如果有 JESSIONID 这个 cookie 回传，服务器则会 根据 JSESSIONID 这个值去查看是否含有 id 为 JSESSION 值的 session 对象，如果没有则认为是一个新的会话，重新创建一个新的 session 对象，并标志此次会话，<strong>并会向浏览器响应一个新的cookie，浏览器更新这个cookie</strong>；如果找到了相应的 session 对象，则认为是之前标志过的一次会话，返回该 session 对象，数据达到共享。</p>
<blockquote>
<p>浏览器每一次访问服务器，都会将cookie传给后台，后台可以操作cookie再响应。</p>
<p>浏览器里可以将sessionid的cookie删掉。</p>
</blockquote>
<p>这里提到一个叫做 JSESSION 的 cookie，这是一个比较特殊的 cookie，当用户请求服务器时，如果访问了 session，则服务器会创建一个名为 JSESSION，值为获取到的 session（无论是获取到的还是 新创建的）的 sessionId 的 cookie 对象，并添加到 response 对象中，响应给客户端，有效时间为关闭浏览器。</p>
<p>sessionid以cookie的形式存储； Session 的底层依赖 Cookie 来实现。一个服务器应用可以对应多个cookie，但是只能有一个session。</p>
<p>cookie是为了方便减少数据传输的，让服务端记住客户端身份的；session是为了多次访问记住状态的，也就是形成会话的。</p>
<p>cookie是有路径的，session就看是不是一次会话了。</p>
<h4 id="session域对象"><a href="#session域对象" class="headerlink" title="session域对象"></a>session域对象</h4><p>Session 用来表示一次会话，在一次会话中数据是可以共享的，这时 session 作为域对象存在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setAttribute(String name, Object o); <span class="comment">// 设置域对象内容 </span></span><br><span class="line">getAttribute(String name); <span class="comment">// 获取域对象内容 </span></span><br><span class="line">removeAttribute(String name); <span class="comment">//删除域对象内容</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-27 09:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/sess02&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Session2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        session.setAttribute(<span class="string">&quot;uname&quot;</span>, <span class="string">&quot;lili&quot;</span>);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        session.removeAttribute(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">        req.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lili&quot;</span>);</span><br><span class="line">        <span class="comment">// 请求转发跳转到jsp页面，请求转发，一次请求，request可以拿到，session也可以拿到</span></span><br><span class="line">        <span class="comment">//req.getRequestDispatcher(&quot;sess01.jsp&quot;).forward(req, resp);</span></span><br><span class="line">        <span class="comment">// 重定向跳转到jsp页面,两次请求，request失效，但是session可以拿到</span></span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;sess01.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: mac</span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">3</span>/<span class="number">27</span></span><br><span class="line">  Time: 上午<span class="number">10</span>:<span class="number">00</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;获取域对象&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 获取session域对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> (String) request.getSession().getAttribute(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> (String) request.getSession().getAttribute(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取request域对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) request.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;session uname:&quot;</span>+uname);</span><br><span class="line">    System.out.println(<span class="string">&quot;session pwd:&quot;</span>+ pwd);</span><br><span class="line">    System.out.println(<span class="string">&quot;request name:&quot;</span>+ name);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>数据存储在 session 域对象中，当 session 对象不存在了，数据也就不能共享了。不同的服务器应用之间，session对象也是隔离的，两个不同的session对象间数据不能共享。</p>
<h4 id="session的销毁"><a href="#session的销毁" class="headerlink" title="session的销毁"></a><strong>session的销毁</strong></h4><p>1.默认到期时间</p>
<p>当客户端第一次请求servlet并且操作session时，session对象生成，Tomcat中session默认的存活时间为30min，即你不操作界面的时间，一旦有操作，session会重新计时。</p>
<p>session的默认时间可以在tomcat安装目录下的conf目录下的web.xml文件中进行修改。单位为分。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.设置到期时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过session.setMaxInactionInterval()可以自行设定存活时间，单位为秒</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">session.setMaxInactiveInterval(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//10秒后销毁session</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看session最大不活动时间，即存活时间</span></span><br><span class="line">System.out.println(session.getMaxInactiveInterval());</span><br></pre></td></tr></table></figure>

<p>3.立即销毁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session.invalidate();</span><br><span class="line"><span class="comment">//session立即作废</span></span><br></pre></td></tr></table></figure>

<p>浏览器每次访问都是一个新的。</p>
<p>4.关闭浏览器</p>
<p>session底层以来cookie，cookie对象默认只在浏览器内存中存活，关闭浏览器即失效。</p>
<p>这个默认的优先级高，如果不关浏览器30分钟失效，关了浏览器立马失效。</p>
<p>5.关闭服务器</p>
<p>非正常关闭服务器时才会失效。  	</p>
<p>如果是正常关闭服务器，session会被钝化到本地磁盘，下次访问时会从本地磁盘中活化出来。在 工作空间 work 目录下的 SESSION.ser 文件中。 </p>
<p>Session 失效则意味着此次会话结束，数据共享结束。</p>
<h3 id="11-ServletContext对象"><a href="#11-ServletContext对象" class="headerlink" title="11.ServletContext对象"></a>11.ServletContext对象</h3><h4 id="ServletContext对象的获取"><a href="#ServletContext对象的获取" class="headerlink" title="ServletContext对象的获取"></a>ServletContext对象的获取</h4><p>每一个web应用都有且仅有一个ServletContext对象，又称为Application对象，从名称中可知，该对象是与应用程序相关的。在web容器启动时，会为每一个web应用程序创建一个对应的ServletContext对象。</p>
<p>该对象有两大作用，第一、作为域对象来共享数据，此时数据在整个应用程序中共享；第二、该对象中保存了当前应用程序相关信息。例如可以通过getServerInfo()方法获取当前服务器信息，getRealPath(String path)获取资源的真实路径等。</p>
<p>ServletContext对象获取：</p>
<p>①.通过request对象获取</p>
<p>ServletContext servletContext &#x3D; req.getServletContext();<br>(不能用了？)</p>
<p>②.通过session对象获取</p>
<p>ServletContext servletContext &#x3D; request.getSession().getServletContext();</p>
<p>③.通过servletConfig对象获取，在Servlet标准中提供了ServletConfig方法</p>
<p>ServletContext servletContext &#x3D; getServletConfig().getServletContext();</p>
<p>④.直接获取 Servlet类中提供了直接获取ServletContext对象的方法</p>
<p>ServletContext servletContext &#x3D; getServletContext();</p>
<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> getServletContext();</span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="comment">//获取当前服务器的版本信息</span></span><br><span class="line"><span class="comment">//Apache Tomcat/9.0.59</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ServletInfo</span> <span class="operator">=</span> servletContext.getServerInfo();</span><br><span class="line">System.out.println(<span class="string">&quot;服务器当前的版本信息：&quot;</span> + ServletInfo);</span><br><span class="line"><span class="comment">//获取项目的真实路径</span></span><br><span class="line"><span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;/&quot;</span>);     <span class="comment">//表示获取根路径,项目的而不是应用的</span></span><br><span class="line"><span class="comment">///Users/liuxuan/MyProject/JavaProject/java/web/target/web/</span></span><br><span class="line">System.out.println(<span class="string">&quot;获取项目的真实路径：&quot;</span> + realPath);</span><br></pre></td></tr></table></figure>



<h4 id="ServletContext域对象"><a href="#ServletContext域对象" class="headerlink" title="ServletContext域对象"></a>ServletContext域对象</h4><p>ServletContext也可以当做域对象来使用，通过ServletContext中存取数据，可以使得整个应用程序共享某些数据。当然不建议存放过多数据，因为ServletContext中的数据一旦存储进去没有手动移除的话，将会一直保存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-29 09:19</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/con02&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        <span class="comment">// 设置域对象</span></span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取域对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) servletContext.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="comment">// 移除域对象</span></span><br><span class="line">        servletContext.removeAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Servlet三大作用域</strong>：</p>
<p>1.request域对象<br>在一次请求中有效。请求转发有效,重定向失败。</p>
<p>2.session域对象<br>在一次会话中有效。请求转发和重定向都有效，session销毁后失效。</p>
<p>3.servletContext域对象<br>在整个应用程序中有效。服务器关闭销毁。</p>
<h3 id="12-文件上传和下载"><a href="#12-文件上传和下载" class="headerlink" title="12.文件上传和下载"></a>12.文件上传和下载</h3><p>servlet中如何实现文件的上传和下载。</p>
<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>文件上传涉及到前台页面的编写和后台服务器端代码的编写，前台发送文件，后台接收并保存文件，这才是一个完整的文件上传。</p>
<h5 id="前台页面"><a href="#前台页面" class="headerlink" title="前台页面"></a>前台页面</h5><p>在做文件上传的时候，会有一个上传文件的界面，首先我们需要一个表单，并且表单的请求方式为 POST；其次我们的 form 表单的 enctype 必须设为”multipart&#x2F;form-data”即 enctype&#x3D;“multipart&#x2F;form-data” 意思是设置表单的 MIME 编码。默认情况下这个编码格式是 ”application&#x2F;x-www-form-urlencoded”，不能用于文件上传；只有使用了 multipart&#x2F;form-data 才能完整地传递文件数据。</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: mac</span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">3</span>/<span class="number">29</span></span><br><span class="line">  Time: 下午<span class="number">9</span>:<span class="number">41</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;文件上传&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        <span class="number">1.</span>准备表单</span><br><span class="line">        <span class="number">2.</span>设置表单的提交类型 method=<span class="string">&quot;post&quot;</span></span><br><span class="line">        <span class="number">3.</span>设置表单类型为文件上传表单 enctype=<span class="string">&quot;multipart/form-data&quot;</span></span><br><span class="line">        <span class="number">4.</span>设置文件提交的地址 action=<span class="string">&quot;uploadServlet&quot;</span></span><br><span class="line">        <span class="number">5.</span>准备表单元素 <span class="number">1.</span>普通表单项 type=<span class="string">&quot;text&quot;</span> <span class="number">2.</span>文件项 type=<span class="string">&quot;file&quot;</span></span><br><span class="line">        <span class="number">6.</span>设置表单元素的name属性值，否则后台无法接收数据</span><br><span class="line">        --&gt;</span><br><span class="line">    &lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;uploadServlet&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">        姓名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;uname&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">        文件：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;myfile&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">        &lt;!-- button 默认的 type 属性是 submit，做提交按钮可以不设置 type --&gt;</span><br><span class="line">        &lt;button type=<span class="string">&quot;submit&quot;</span>&gt; 提交 &lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h5 id="后台实现"><a href="#后台实现" class="headerlink" title="后台实现"></a>后台实现</h5><p>使用注解 <code>@MultipartConfig</code>标识为支持文件上传， Servlet 将 <code>Multipart/form-data</code> 的post请求封装成 Part 通过part对上传文件进行操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.MultipartConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Part;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-29 21:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@MultipartConfig</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/uploadServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件上传......&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为保证数据正确性，首先设置编码</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取普通表单项参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;uname&quot;</span>); <span class="comment">// 表单元素中 uname 的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;uname：&quot;</span> + uname);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Part 对象，上传的文件</span></span><br><span class="line">        <span class="type">Part</span> <span class="variable">part</span> <span class="operator">=</span> req.getPart(<span class="string">&quot;myfile&quot;</span>); <span class="comment">// 表单中 file 文件域的 name 属性值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 part 对象得到上传的文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> part.getSubmittedFileName();</span><br><span class="line">        System.out.println(<span class="string">&quot;上传的文件名：&quot;</span> + fileName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到文件要存放的路径--项目路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> req.getServletContext().getRealPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        System.out.println(filePath); <span class="comment">// 文件存放的路径</span></span><br><span class="line">        <span class="comment">// /Users/liuxuan/MyProject/JavaProject/servletdemo/servlet-demo/out/artifacts/servlet_demo_war_exploded/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存文件到指定路径</span></span><br><span class="line">        part.write(filePath + <span class="string">&quot;/&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前端页面…&#x2F;upload.jsp选择文件提交后，自动跳转至…&#x2F;uploadServlet页面。</p>
<p>⚠️一个飘红问题</p>
<p>Servlet3.0新增了request.getParts()&#x2F;getPart(String filename) api，用于获取使用multipart&#x2F;form-data格式传递的http请求的请求体，通常用于获取上传文件。用于从请求中解析上传的文件。</p>
<p>request.getParts()  获取请求中全部文件<br>getPart(String filename)   获取请求中指定name的文件</p>
<p>所以getPart方法飘红的话，看一下用的servlet方法版本是不是3.0的。</p>
<p><code>InputStream is = part.getInputStream();</code> 获取输入流</p>
<p>需要注意的是，使用request.getParts()方法必须给servlet添加注解@MultipartConfig，否则虽然不会抛出异常，但是获取不到数据。</p>
<p>更多用法撒：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012334071/article/details/50261063/">https://blog.csdn.net/u012334071/article/details/50261063/</a></p>
<p><a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/c66d20190a12a21614791711cc7931b765ce7b61.html">https://wenku.baidu.com/view/c66d20190a12a21614791711cc7931b765ce7b61.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sunyongxing/articles/2622891.html">https://www.cnblogs.com/sunyongxing/articles/2622891.html</a></p>
<h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><p>即将服务器上的资源下载（拷贝）到本地，可以通过两种方式下载：通过超链接下载、通过代码下载。</p>
<p>项目内的文本或图片资源文件夹需要通过 Tomcat -&gt; Deployment 进行上传才能通过项目发布，进行访问。</p>
<h5 id="超链接下载"><a href="#超链接下载" class="headerlink" title="超链接下载"></a>超链接下载</h5><p>当我们在HTML或JSP页面中使用a标签时，原意是希望能够进行跳转，但当超链接遇到浏览器不识别的资源时会自动下载；当遇到浏览器能够直接显示的资源，浏览器就会默认显示出来，比如txt、png、jpg等。当然我们也可以通过download属性规定浏览器进行下载。但有些浏览器并不支持。</p>
<p>在web文件夹下新建一个download文件夹，准备图片、文本放在这个文件夹下，文件存放地址需要配置一下，点右上角configuration，再点deployment，再点加号external source，选到download文件夹下，再改一下application context：&#x2F;servlet_demo&#x2F;download。这样文件夹下的资源才能被浏览器访问到。（这个download是文件夹名字）</p>
<p>访问：<a target="_blank" rel="noopener" href="http://localhost:8080/servlet_demo/download.html">http://localhost:8080/servlet_demo/download.html</a> （这个download是html名字）</p>
<p>download.html：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>文件下载<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 浏览器能够识别的资源，点击展示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;download/TacoCloud.jpeg&quot;</span>&gt;</span>图片文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;download/Taco.java&quot;</span>&gt;</span>文本文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加download点击下载,可不写属性名，表示文件名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;download/TacoCloud.jpeg&quot;</span> <span class="attr">download</span>=<span class="string">&quot;百度.jpeg&quot;</span>&gt;</span>图片文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;download/Taco.java&quot;</span> <span class="attr">download</span>=<span class="string">&quot;&quot;</span>&gt;</span>文本文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 浏览器不能够识别的资源,自动下载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>压缩文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="后台实现下载"><a href="#后台实现下载" class="headerlink" title="后台实现下载"></a>后台实现下载</h5><p>实现步骤：</p>
<p>得知道要下载的资源文件名，文件名传到后台代码之后：</p>
<ol>
<li>需要通过response.setContentType方法设置Content-type头字段的值，为浏览器无法使用某种方式或激活某个程序来处理的MIME类型，例如“application&#x2F;octet-stream”或“application&#x2F;x-msdownload‘等。</li>
<li>需要通过response.setHeader方法设置Content-Disposition头的值为“attachment;filename&#x3D;文件名“</li>
<li>读取下载文件，调用response.getOutputStream方法向客户端写入附件内容。</li>
</ol>
<p>第一步：写html页面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;文件下载&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;downloadServlet&quot;</span>&gt;</span><br><span class="line">        文件名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;fileName&quot;</span> placeholder=<span class="string">&quot;请输入要下载的文件名&quot;</span>&gt;</span><br><span class="line">        &lt;button&gt;下载&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：写一个servlet页面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-31 21:59</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/downloadServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DownloadServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写钥匙的</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件下载===&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置请求的编码格式</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 乱码问题，设置编码格式</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取参数（得到要下载的文件名）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;fileName&quot;</span>);</span><br><span class="line">        <span class="comment">// 参数的非空判断  trim()去除字符串前后空格，中间的不管</span></span><br><span class="line">        <span class="keyword">if</span>(fileName == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(fileName.trim()))&#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;请输入要下载的文件名！&quot;</span>);</span><br><span class="line">            resp.getWriter().close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到图片存放的路径,文件放在配置好的download目录下的。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> req.getServletContext().getRealPath(<span class="string">&quot;/download/&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过路径得到file对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path + fileName);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件：&quot;</span>+ file);</span><br><span class="line">        <span class="comment">// 判断文件对象是否存在，并且是个标准文件</span></span><br><span class="line">        <span class="keyword">if</span>(file.exists() &amp;&amp; file.isFile())&#123;</span><br><span class="line">            <span class="comment">// 1.设置响应类型，设置为浏览器无法使用某种方式或激活某个程序来处理的MIME类型</span></span><br><span class="line">            resp.setContentType(<span class="string">&quot;application/x-msdownload&quot;</span>);</span><br><span class="line">            <span class="comment">// 2.设置响应头</span></span><br><span class="line">            resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName);</span><br><span class="line">            <span class="comment">// 3.得到file文件的输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            <span class="comment">// 4.得到字节输出流，字符输出流文件是不行的</span></span><br><span class="line">            <span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line">            <span class="comment">// 5.定义byte数组</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">// 6.定义长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 7.循环输出</span></span><br><span class="line">            <span class="keyword">while</span> ((len = in.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 8.关闭资源</span></span><br><span class="line">            out.close();</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;文件不存在，请重试！&quot;</span>);</span><br><span class="line">            resp.getWriter().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h3><p><a target="_blank" rel="noopener" href="https://github.com/jadeliuliu/servletdemo/tree/master/servlet-demo">https://github.com/jadeliuliu/servletdemo/tree/master/servlet-demo</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>比较全的文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_19782019/article/details/80292110">https://blog.csdn.net/qq_19782019/article/details/80292110</a></p>
<p>实现：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Hello_zbs/article/details/108394660">https://blog.csdn.net/Hello_zbs/article/details/108394660</a></p>
<p>b站视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ta4y1H7Vc?p=26&spm_id_from=pageDriver">https://www.bilibili.com/video/BV1Ta4y1H7Vc?p=26&amp;spm_id_from=pageDriver</a></p>
<p>学习笔记：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yuan-liu/p/15255326.html">https://www.cnblogs.com/yuan-liu/p/15255326.html</a></p>
<h3 id="servlet的get和post请求"><a href="#servlet的get和post请求" class="headerlink" title="servlet的get和post请求"></a>servlet的get和post请求</h3><p>get：将数据通过url附加数据现行的向服务器发送数据<br>post：将数据存放在请求体中隐性的向服务器发送数据</p>
<p>区别：<br>1.get常用于不包含敏感信息的查询功能 （不用输入密码）<br>2.post用于安全性较高的功能或者服务器的“写”操作 eg：用户登录、注册、更新账目</p>
<p>service()是请求处理的核心方法，无论是get或者是post都会被service()方法处理。<br>当采用无差别请求时，可以用service()方法。<br>request.getMethod()查看请求方式<br>doGet()方法处理get请求<br>doPost()方法处理post请求<br>response.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”);解决中文乱码</p>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6869979139164602382">https://juejin.cn/post/6869979139164602382</a></p>
<h3 id="WebServlet和-RequestMapping"><a href="#WebServlet和-RequestMapping" class="headerlink" title="@WebServlet和@RequestMapping"></a>@WebServlet和@RequestMapping</h3><p>都是用在Controller类里，用于拦截特定请求的。</p>
<p>@WebServlet注解作用在类上，用于标注在一个继承了HttpServlet类之上，属于类级别的注解，一般用于需要有HttpServletRequest请求中带了参数，或者需要filter等场景，这个是Servlet实现的路径映射逻辑。</p>
<p>@RequestMapping 在controller类上加，具体的方法上再加， 可以在控制器类的级别和&#x2F;或其中的方法的级别上使用 处理普通的URI请求，或者http请求，这个是spring实现的DispatcherServlet的路径映射逻辑。</p>
<p>✅ 两种构造Controller的区别：</p>
<p>Controller是spring 的一个bean，由spring的IOC来管理的一个bean</p>
<p>Servlet是一个接口或者接口的实现（常见的是GenericServlet 和 HttpServlet）</p>
<p>Servlet实现方式：<br>有一个映射关系servlet-mapping，url的endpoint 对应的具体的servlet， 比如规定’&#x2F;demo’ 映射到ServletDemo（继承自HttpServlet，重写doGet，doPost等方法）.<br>在浏览器地址栏输入localhost:8088&#x2F;demo   , 这个请求就会执行到ServletDemo的doGet方法，经过一系列逻辑，最终将要返回给浏览器的数据写入HttpServletResponse，这样浏览器就能收到结果。</p>
<p>Controller实现方式：<br>只是一个bean，方法上可以加上注解GetMapping，PostMapping等，标注映射的url的endpoint。<br>Servlet容器（Tomcat等）接收到请求以后，将请求交给DispatcherServlet的service方法来处理，servlet会在doDispatch里面先找到mappedHandler ，然后找到HandlerAdapter。调用HandlerAdapter 的handle方法，其实应该是AbstractHandlerMethodAdapter，<br>然后调用到RequestMappingHandlerAdapter的handleInternal，最终调用到invokeAndHandle，反射调用controller的方法。找到endpoint对应的bean的方法，并调用。</p>
<p>总结：<br><em><strong>容器&#x3D;&#x3D;》DispatcherServlet (service方法) &#x3D;&#x3D;》 doDispatcher &#x3D;&#x3D;》HandlerAdapter （handle）&#x3D;》AbstractHandlerMethodAdapter&#x3D;&#x3D;》RequestMappingHandlerAdapter &#x3D;&#x3D;》invokeAndHandle&#x3D;&#x3D;》反射具体的controller方法</strong></em></p>
<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/huainanyin/p/15936212.html">https://www.cnblogs.com/huainanyin/p/15936212.html</a></p>
<p>Spring提供的DispatcherServlet是怎么调用我们的Controller里的业务接口的：<a target="_blank" rel="noopener" href="https://blog.csdn.net/caoyuanyenang/article/details/114401414">https://blog.csdn.net/caoyuanyenang/article/details/114401414</a></p>
<p>✅@RequestMaping参数<br>见java注解</p>
<h3 id="cookie-session-tocken的区别"><a href="#cookie-session-tocken的区别" class="headerlink" title="cookie session tocken的区别"></a>cookie session tocken的区别</h3><p>鉴权：鉴定权限</p>
<p>✅cookie</p>
<p>cookie是鉴权的方式之一，是客户端登录后，服务器端生成后发送给客户端的。cookie可以保存很多种数据，但是他只能保存字符串，且在安全性上有隐患。<br>在客户端发起请求后，服务器端生成一个cookie，并发送给客户端，保存在客户端本地，下次请求的时候带上cookie。</p>
<p>✅session</p>
<p>session是一种会话，比如我发起请求到关闭浏览器这个过程就是一个会话。session是鉴权的方式之二，在客户端发起请求后，服务器生成一个对应的session，并保存在服务器中，再把session id保存到cookie里面，通过cookie发送给客户端，客户端接收到cookie过后，下一次请求时就会把cookie带上，服务器收到请求中的session id后就会把它与之前保存的session做对比，如果是一样的，那就说明是已经登录过的，如果不一样，那就需要重新登录：服务器为客户端创造一个session，并且生成一个与session相关联的session id存放到cookie中，在本次响应中返回到客户端保存。</p>
<p>✅token</p>
<p>token是一个令牌，是鉴权方式之三，他是由一部分固定的header、以及body组成的，在body中可以放userid+电话号码，等用户的非隐秘信息，然后再通过某种加密方式，把这两部分加密形成一个秘钥。</p>
<p>在客户端发起请求后，服务器会生成一个token，可以通过cookie也可以直接发送给客户端，客户端接收到token后，会把它保存在本地，在下一次请求时，会带上，服务器端收到二次请求以及带上的token后，会再根据用户的信息去加密一个token，再把两次token进行比对，如果是相同的，那就不用再登录了，如果不一样就需要再重新登录。</p>
<p>第一次请求客户端发送的没有这个tocken，服务端生成tocken给客户端，客户端第二次发送带上tocken，就不用重新登陆了。服务端不保存tocken。</p>
<p>✅区别</p>
<p>cookie、session、token的区别<br>1.生成的位置相同：cookie、session、token都是在服务器端生成；<br>2.保存的位置不同：cookie、token保存在客户端本地，session保存在服务器；<br>3.鉴权过程不同：<br>cookie是将请求中携带的cookie与服务器记录的cookie做对比；<br>session是将请求中携带的session与服务器存储的session做对比；<br>token是将请求中携带的token与服务器通过请求中的信息（userid、签名）生成的token作对比。</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43844012/article/details/124271258">https://blog.csdn.net/qq_43844012/article/details/124271258</a></p>
<p>cookie：用来保存一些信息在客户端的，比如记住密码和推荐显示。<br>session：是用来标识一次会话的，在一次会话期间共享数据。<br>token：用来作为密钥快捷登录的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/19/myblog/java/java%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/19/myblog/java/java%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">java实现自定义注解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-19 10:22:13" itemprop="dateCreated datePublished" datetime="2022-03-19T10:22:13+08:00">2022-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-09 22:43:27" itemprop="dateModified" datetime="2022-04-09T22:43:27+08:00">2022-04-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="关于注解"><a href="#关于注解" class="headerlink" title="关于注解"></a>关于注解</h3><p>Annotation，注解是Java SE 5.0版本开始引入的概念，它是对java源代码的说明，是一种元数据（描述数据的数据）。</p>
<ul>
<li>注释<br>   注释是对代码的说明，给代码的读者看，便于帮读者梳理业务逻辑；</li>
<li>注解<br>  注解也是对代码的说明，需要配合工具（解析它的代码）使用，参与代码的编译，给应用程序看的。</li>
</ul>
<p>注解的渊源：</p>
<p>在频繁使用注解之前，是用xml 来作为元数据使用，在最开始使用ssm(Spring,SpringMVC,Mybatis)框架时，bean与bean之间的依赖关系是通过xml文件来配置，这个xml文件和源代码分散，当微服务、分布式注解流行，系统越来越大，需要越来越多的xml文件来配置管理，文件配置冗长，而且类型不安全（运行期才会发现错误）,此时就需要一种比较简单直观而且类型安全的配置方式，注解就应运而生了，按照Springboot“约定大于配置”的方式，通过注解来约定其含义，更是减少了xml配置文件的数量。<br>     对于一些经常变动或者配置复杂的配置，使用xml文件来说是比较合适的，所以现在经常是注解和xml方式共存。<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zt15732625878/article/details/99671586">https://blog.csdn.net/zt15732625878/article/details/99671586</a></p>
<p>————————————————</p>
<h3 id="注解分类"><a href="#注解分类" class="headerlink" title="注解分类"></a>注解分类</h3><p>按照来源划分，可以分为 JDK的注解，第三方的注解，自定义注解。</p>
<p>JDK注解</p>
<p>Java 内置三大注解<br>@Override （标记重写方法）<br>@Deprecated （标记过时）<br>@SuppressWarnings （忽略警告）</p>
<p>元注解 (注解的注解)<br>@Target （注解的作用目标）<br>@Retention （注解的生命周期）<br>@Document （注解是否被包含在JavaDoc中）<br>@Inherited （是否允许子类集成该注解）</p>
<p>第三方注解（主要来源于各种框架）<br>Spring注解<br>@RequestMapping,@RestController,@Configuration,@Value,@Controller,@Service,@Repository,@Component等<br>SpringBoot注解<br>@SpringBootApplication,@EnableAutoConfiguration等<br>JPA注解<br>@Table,@Entity,@Column,@Id等<br>……</p>
<p>自定义注解<br>使用元注解自己定义的注解</p>
<h3 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h3><p>1&gt;.每一个方法实际上是声明了一个配置参数,<br>2&gt;.方法的名称就是参数的名称,<br>3&gt;.返回值类型就是参数的类型,(返回值类型只能是基本类型、Class、String、enum)<br>4&gt;.可以通过default来声明参数的默认值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="meta">@interface</span> 注解名 &#123;</span><br><span class="line">    注解元素的声明<span class="number">1</span> </span><br><span class="line">    注解元素的声明<span class="number">2</span></span><br><span class="line">    type <span class="title function_">elementName</span><span class="params">()</span>;</span><br><span class="line">    type <span class="title function_">elementName</span><span class="params">()</span> <span class="keyword">default</span> value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Service的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ElementType.TYPE 代表在类上使用</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="comment">// RetentionPolicy.RUNTIME 代表运行时使用，可以通过反射获取到</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">//包含在JavaDoc中</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">//允许通过包扫描的方式自动检测</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">	 * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line">	String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Annotation：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所有注解</strong>，<strong>默认是一个实现了Annotation接口的接口。</strong></p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>注解是一种能被添加到java源代码中的元数据，可以看作是一种特殊的标记，可以用在方法、类、参数和包上，程序在编译或者运行时可以检测到这些标记而进行一些特殊的处理。</p>
<p>注解的基本元素：</p>
<ul>
<li>修饰符<br> 访问修饰符必须为public,不写默认为pubic；</li>
<li>关键字<br> 关键字为@interface；</li>
<li>注解名称<br> 注解名称为自定义注解的名称，使用时还会用到；</li>
<li>注解类型元素<br> 注解类型元素是注解中内容，可以理解成自定义接口的实现部分；</li>
</ul>
<p>使用元注解修饰注解：</p>
<p>@Target，@Retention,@Document,@Inherited用来修饰注解。</p>
<p><strong>@Target</strong><br> 表明该注解可以应用的java元素类型。<br>ElementType.TYPE	应用于类、接口（包括注解类型）、枚举<br>ElementType.FIELD	应用于属性（包括枚举中的常量）<br>ElementType.METHOD	应用于方法<br>ElementType.PARAMETER	应用于方法的形参<br>ElementType.CONSTRUCTOR	应用于构造函数<br>ElementType.LOCAL_VARIABLE	应用于局部变量<br>ElementType.ANNOTATION_TYPE	应用于注解类型<br>ElementType.PACKAGE	应用于包<br>ElementType.TYPE_PARAMETER	1.8版本新增，应用于类型变量<br>ElementType.TYPE_USE	1.8版本新增，应用于任何使用类型的语句中（例如声明语句、泛型和强制转换语句中的类型）</p>
<p>@Retention<br>  表明该注解的生命周期<br>RetentionPolicy.SOURCE	编译时被丢弃，不包含在类文件中<br>RetentionPolicy.CLASS	JVM加载时被丢弃，包含在类文件中，默认值<br>RetentionPolicy.RUNTIME	由JVM 加载，包含在类文件中，在运行时可以被获取到</p>
<p>@Document<br>  表明该注解标记的元素可以被Javadoc 或类似的工具文档化</p>
<p>@Inherited<br>  表明使用了@Inherited注解的注解，所标记的类的子类也会拥有这个注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Info &#123;</span><br><span class="line">      String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;tracy&quot;</span>;</span><br><span class="line">      <span class="type">boolean</span> <span class="title function_">isDelete</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用自定义注解"><a href="#使用自定义注解" class="headerlink" title="使用自定义注解"></a>使用自定义注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="comment">// 为Person类配置了刚刚定义的注解@Info</span></span><br><span class="line"><span class="meta">@Info(isDelete = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用反射解析注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取Person的Class对象(类)</span></span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> Person.builder().build();</span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> person.getClass();</span><br><span class="line">            <span class="comment">//判断类上是否有Info注解</span></span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(Info.class)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Person类上配置了Info注解！&quot;</span>);</span><br><span class="line">                <span class="comment">//获取该对象上Info类型的注解</span></span><br><span class="line">                <span class="type">Info</span> <span class="variable">infoAnno</span> <span class="operator">=</span> (Info) clazz.getAnnotation(Info.class);</span><br><span class="line">                System.out.println(<span class="string">&quot;infoAnno.value :&quot;</span> + infoAnno.value() + <span class="string">&quot;,infoAnno.isDelete:&quot;</span> + infoAnno.isDelete());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Person类上没有配置Info注解！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个类或者接口来说，Class类(java.lang包下)中提供了一些方法用于反射注解，当然对于字段、方法来说反射注解的方式很类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回指定的注解</span></span><br><span class="line">getAnnotation</span><br><span class="line"><span class="comment">//判断当前元素是否被指定注解修饰</span></span><br><span class="line">isAnnotationPresent</span><br><span class="line"><span class="comment">//返回所有的注解</span></span><br><span class="line">getAnnotations</span><br></pre></td></tr></table></figure>

<p>————————————————</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zt15732625878/article/details/100061528">https://blog.csdn.net/zt15732625878/article/details/100061528</a></p>
<p>————————————————</p>
<h3 id="使用自定义注解例子2"><a href="#使用自定义注解例子2" class="headerlink" title="使用自定义注解例子2"></a>使用自定义注解例子2</h3><p>&lt;1&gt;.作用在属性上注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FiledAnnotation &#123;</span><br><span class="line">	 String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;GetFiledAnnotation&quot;</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;2&gt;.作用在方法上注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MethodAnnotation &#123;</span><br><span class="line">	String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;MethodAnnotation&quot;</span>;   </span><br><span class="line">    String <span class="title function_">url</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;https://www.cnblogs.com&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;3&gt;.作用在类上注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TypeAnnotation &#123;</span><br><span class="line">	String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;Is-TypeAnnotation&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;4&gt;.使用自定义注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TypeAnnotation(value = &quot;doWork&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line"><span class="meta">@FiledAnnotation(value = &quot;CSDN博客&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">myfield</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@MethodAnnotation()</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getDefaultInfo</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;do the getDefaultInfo method&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@MethodAnnotation(name = &quot;百度&quot;, url = &quot;www.baidu.com&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getDefineInfo</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;do the getDefineInfo method&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt;5&gt;.测试自定义注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMain</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.zbz.annotation.pattern3.Worker&quot;</span>);</span><br><span class="line">    Method[] method = cls.getMethods();</span><br><span class="line">    <span class="comment">/**判断Worker类上是否有TypeAnnotation注解*/</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> cls.isAnnotationPresent(TypeAnnotation.class);</span><br><span class="line">    <span class="comment">/**获取Worker类上是TypeAnnotation注解值*/</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    	<span class="type">TypeAnnotation</span> <span class="variable">typeAnno</span> <span class="operator">=</span> (TypeAnnotation) cls.getAnnotation(TypeAnnotation.class);</span><br><span class="line">    	System.out.println(<span class="string">&quot;@TypeAnnotation值:&quot;</span> + typeAnno.value());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**方法上注解*/</span></span><br><span class="line">    List&lt;Method&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Method&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; method.length; i++) &#123;</span><br><span class="line">        list.add(method[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Method m : list) &#123;</span><br><span class="line">    	<span class="type">MethodAnnotation</span> <span class="variable">methodAnno</span> <span class="operator">=</span> m.getAnnotation(MethodAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span> (methodAnno == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        System.out.println( <span class="string">&quot;方法名称:&quot;</span> + m.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;方法上注解name = &quot;</span> + methodAnno.name());</span><br><span class="line">        System.out.println(<span class="string">&quot;方法上注解url = &quot;</span> + methodAnno.url());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**属性上注解*/</span></span><br><span class="line">    List&lt;Field&gt; fieldList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Field&gt;();  <span class="comment">//Field表示属性</span></span><br><span class="line">    <span class="keyword">for</span> (Field f : cls.getDeclaredFields()) &#123;<span class="comment">// 访问所有字段</span></span><br><span class="line">    	<span class="type">FiledAnnotation</span> <span class="variable">filedAno</span> <span class="operator">=</span> f.getAnnotation(FiledAnnotation.class);</span><br><span class="line">    	System.out.println( <span class="string">&quot;属性名称:&quot;</span> + f.getName());</span><br><span class="line">    	System.out.println(<span class="string">&quot;属性注解值FiledAnnotation = &quot;</span> + filedAno.value());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangbeizhen18/article/details/87885441/">https://blog.csdn.net/zhangbeizhen18/article/details/87885441/</a></p>
<p>————————————————</p>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>自定义注解像是为类或者什么的新增加了属性，可以有默认值，通过类可以获得类上的自定义注解，然后通过注解获得注解中的值。注解不是属于对象的。定义在属性上的，可以用属性注解来区别这些属性，相当于属性名的别名。</p>
<h3 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h3><p>自定义注解+AOP：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/283936459">https://zhuanlan.zhihu.com/p/283936459</a></p>
<p>使用方法上的注解，实现通过注解来唤醒一个类里方法的效果：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b5b79434d3b5">https://www.jianshu.com/p/b5b79434d3b5</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/12/myblog/java/Mybatis%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/12/myblog/java/Mybatis%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">mybatis入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-12 21:21:21 / Modified: 23:44:29" itemprop="dateCreated datePublished" datetime="2022-03-12T21:21:21+08:00">2022-03-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>mybatis</strong></p>
<h3 id="⛽️第一课"><a href="#⛽️第一课" class="headerlink" title="⛽️第一课"></a>⛽️第一课</h3><p>✅开发步骤：</p>
<p>1.添加Mybatis的坐标、mysql的驱动（pom.xml中）</p>
<p>2.创建数据表、编写对应的实体类（操作实体从而间接操作表，查询表从而间接封装实体）</p>
<p>3.编写映射文件UserMapper.xml  主要描述sql文件（第一个点：namespace命名空间，第二个点：id和resultType，通过命名空间.id进行调用，resultType结果集，封装到指定的类型中）</p>
<p>4.编写核心文件sqlMapConfig.xml，配置mybatis核心内容的，配置数据源信息、加载映射文件（可能很多）。</p>
<p>5.编写测试类（1.获取核心配置文件 2.获得session工厂对象 3.获得session会话对象 4.执行操作 5.打印数据 6.释放资源）</p>
<p>mybatis映射文件： </p>
<p><img src="https://img-blog.csdnimg.cn/6779525e71d546109fea38a2120c0479.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="Pasted Graphic.tiff"></p>
<p>DTD约束头在写标签或者属性时能给提示。</p>
<p>✅什么是mybatis？</p>
<p>是apache的一个开源项目iBatis，2010年迁移到google code，改名为mybatis，2013年迁移到github。</p>
<p>Mybatis是一个实现了数据持久化的开源框架，简单理解就是对JDBC进行封装。</p>
<p>ORMapping：Object Relationship Mapping 对象关系映射</p>
<p>对象：面向对象</p>
<p>关系：关系型数据库</p>
<p>映射：java到mysql的映射，开发者以面向对象的思想来管理数据库。</p>
<p>✅mybatis优缺点</p>
<p>优点：</p>
<p>1⃣️与JDBC相比，减少50%代码量</p>
<p>2⃣️最简单的持久化框架，小巧简单</p>
<p>3⃣️灵活，不会对程序或数据库的现有设计强行加任何影响，sql写在xml中，从程序代码中彻底分离，解耦合，可重用。</p>
<p>4⃣️提供xml标签，支持编写动态sql语句。</p>
<p>5⃣️提供映射标签，支持对象的属性与数据库的ORM字段关系映射。</p>
<p>缺点：</p>
<p>1⃣️半自动的，sql语句编写工作量大</p>
<p>2⃣️依赖于数据库，数据库迁移性差。</p>
<p>✅Mybatis核心接口和类</p>
<p>java和Mybatis的连接者：sqlsession</p>
<p>SqlSessionFactoryBuilder接口 build()方法。得到SqlSessionFactory（工厂对象）。调用openSession()方法，获得SqlSession。</p>
<p>✅Mybatis的开发方式</p>
<p>1⃣️使用原生接口</p>
<p>2⃣️Mapper代理实现自定义接口</p>
<p>两种方法都是通过sqlsession的相关方法来完成的。</p>
<p>✅创建第一个mybatis项目</p>
<p>1⃣️新建一个maven项目</p>
<p>pom.xml文件：增加mybatis坐标org.mybatis. mysql驱动</p>
<p>❓pom.xml中加入依赖显红怎么办？</p>
<p>解决：首先删除.m文件夹下的repo文件夹，然后回到项目右键pom.xml，选maven，选reimport</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>2⃣️新建表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database mybatis;</span><br><span class="line"><span class="keyword">create table</span> account(</span><br><span class="line"> id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment,</span><br><span class="line"> username <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line"> password <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line"> age <span class="type">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>3⃣️新建数据表对应的实体类</p>
<p>这里用Lombok库，用来自动生成构造方法.类级别的 @Data 注释是由 Lombok 提供的，它告诉 Lombok 生成所有缺少的方法，以及接受所有final属性作为参数的构造函数。</p>
<p>加lombok依赖时，有错误，因为版本号的原因。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>4⃣️创建mybatis配置文件 config.xml 文件名可自定义，建在resource文件夹中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">​    <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置Mybatis运行环境 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!-- 下面可以多个environment，但是上面选一个 --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">​      <span class="comment">&lt;!-- 配置jdbc事务管理 --&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">​      <span class="comment">&lt;!--POOLED配置JDBC数据源连接池 --&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xuan&quot;</span>/&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jade&quot;</span>/&gt;</span></span><br><span class="line">​      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>5⃣️使用原生接口的方式开发</p>
<p>（1）Mybatis框架需要开发者自定义sql语句，写在Mapper.xml文件中，实际开发中，会为每个实体类创建对应的Mapper.xml，定义管理该对象数据的SQL。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">​    <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- namespace是mybatis加载配置文件时要找的路径（包+文件名的形式）。</span></span><br><span class="line"><span class="comment">  id是一会儿调用sql语句时要用的名字，自定义的.</span></span><br><span class="line"><span class="comment">  parameterType是要传入的参数,下面语句是从对象中取值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.demo.mybatis.mapper.AccountMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;save&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line">​    insert into account(username, password, age) values(#&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）在全局配置文件config.xml中注册AccountMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册AccountMapper.xml，加载映射文件，这里带后缀，所以用路径/ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/demo/mybatis/mapper/AccountMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）调用mybatis的原生接口执行添加操作，写测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.demo.mybatis.entity.Account;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInsert</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//加载mybatis配置文件config.xml</span></span><br><span class="line">​    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> TestInsert.class.getClassLoader().getResourceAsStream(<span class="string">&quot;config.xml&quot;</span>); <span class="comment">//变成一个流</span></span><br><span class="line">​    <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">​    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(inputStream); <span class="comment">//传入流</span></span><br><span class="line">​    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//然后就可以进行java和mysql的关联，结合namespace和id获取位置</span></span><br><span class="line">​    <span class="comment">//因为配置文件已经加载到环境中，因此可以通过下面找到</span></span><br><span class="line">​    <span class="type">String</span> <span class="variable">statement</span> <span class="operator">=</span> <span class="string">&quot;com.demo.mybatis.mapper.AccountMapper.save&quot;</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//传参数需要对象，因此需要实例化一个对象</span></span><br><span class="line">​    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">1L</span>, <span class="string">&quot;liu&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">12</span>);</span><br><span class="line">​    sqlSession.insert(statement, account);</span><br><span class="line">​    <span class="comment">//commit方法提交事务</span></span><br><span class="line">​    sqlSession.commit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>❓出现问题，明明已经有lombok，可是在对象实例化的时候还是有问题。</p>
<p>解决：添加插件：设置里找到plugins，搜索lombok plugin，安装，重启。勾选配置：setting–&gt;build,excecution,deployment–&gt;compiler–&gt;annotation processors勾选上 enable annotation processing。即可生效。</p>
<p>⚠️maven工程中不能直接读取resource以外的xml文件，得在pom里加一个配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>❓java.lang.ClassNotFoundException: Cannot find class: com.mysql.cj.jdbc</p>
<p>解决：<property name="driver" value="com.mysql.cj.jdbc.Driver"/> 少写了Driver</p>
<p>🎉Success</p>
<h3 id="⛽️第二课"><a href="#⛽️第二课" class="headerlink" title="⛽️第二课"></a>⛽️第二课</h3><p>✅使用Mapper代理实现自定义接口</p>
<p>实际开发中推荐用这种。</p>
<p>Mapper是mybatis内部提供的组建，接口是开发者自己写，接口的实现类是由mybatis动态生成实现类，同时获取实现类的对象，可以直接用。</p>
<p>1⃣️自定义接口，定义相关的业务方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.mybatis.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.mybatis.entity.Account;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountRepository</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">  <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> Account <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2⃣️编写与接口相对应的Mapper.xml，定义接口方法对应的sql语句。</p>
<p>statement标签（如<code>&lt;insert&gt;</code>）可根据sql执行的业务选择insert、delete、update、select。</p>
<p>Mybatis会自动根据规则自动创建接口实现类的代理对象。</p>
<p>规则：</p>
<ol>
<li>Mapper.xml中namespace为接口的全类名。</li>
<li>Mapper.xml中statement的id为接口中对应的方法名。</li>
<li>Mapper.xml中statement的parameterType和接口中对应方法的参数类型一致。</li>
<li>Mapper.xml中statement的resultType和接口中对应的方法的返回值类型一致。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">​    <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.demo.mybatis.repository.AccountRepository&quot;</span>&gt;</span>  <span class="comment">&lt;!-- 映射 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;save&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!-- 添加 修改 删除 三个操作在数据库返回的结果一定是int， 所以这里没有resultType属性 --&gt;</span></span><br><span class="line">​    insert into account(username, password, age) values(#&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line">​    update account set username = #&#123;username&#125;, password = #&#123;password&#125;, age = #&#123;age&#125; where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span>&gt;</span></span><br><span class="line">​    delete from account where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!-- 不写集合类型，而写集合里的泛型类型 --&gt;</span></span><br><span class="line">​    select * from account</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line">​    select * from account where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>3⃣️在config.xml中注册AccountRepository.xml</p>
<p><code>&lt;mappers&gt;</code></p>
<p>  <code>&lt;mapper resource=&quot;com/demo/mybatis/mapper/AccountMapper.xml&quot;&gt;&lt;/mapper&gt;</code></p>
<p>  <code>&lt;!-- 注册第二课中的AccountRepository.xml --&gt;</code></p>
<p>  <code>&lt;mapper resource=&quot;com/demo/mybatis/repository/AccountRepository.xml&quot;&gt;&lt;/mapper&gt;</code></p>
<p><code>&lt;/mappers&gt;</code></p>
<p>4⃣️测试</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">​    <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置Mybatis运行环境 ,配置数据源信息--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!-- 下面可以多个environment，但是上面选一个 --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">​      <span class="comment">&lt;!-- 配置jdbc事务管理 --&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">​      <span class="comment">&lt;!--POOLED配置JDBC数据源连接池 --&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xuan&quot;</span>/&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jade&quot;</span>/&gt;</span></span><br><span class="line">​      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 注册AccountMapper.xml，加载映射文件，这里带后缀，所以用路径/ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/demo/mybatis/mapper/AccountMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!-- 注册第二课中的AccountRepository.xml --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/demo/mybatis/repository/AccountRepository.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>🤔我对动态代理的理解：</p>
<p>自己只需要写一个类，框架为我动态代理实现接口的实现类，并且还给我实现类的对象，可以直接用。</p>
<p>可以看到第一种方法，确实比较复杂，需要自己写statement，但是说的自己写接口实现类？没有吧</p>
<h3 id="⛽️第三课"><a href="#⛽️第三课" class="headerlink" title="⛽️第三课"></a>⛽️第三课</h3><p>Mapper.xml解读</p>
<ol>
<li><p>statement标签，select、update、delete、insert分别对应查询、修改、删除、添加</p>
</li>
<li><p>parameterType：参数数据类型</p>
<p>A. 基本数据类型，通过id查询Account,  “long”</p>
<p>b. String类型，通过name查询Account，”java.lang.String”</p>
<p>C. 包装类，通过id查询Account。“java.lang.long”</p>
</li>
</ol>
<p>​     {用包装类的好处：基本数据类型接受不了null，null传进来报异常，业务中可能会有null，需要判断}</p>
<p>   D.多个参数，通过username和age查询account</p>
<p>​     ⚠️：如果返回结果可能多个，就得List。好像多个操作commit一次就行吧。</p>
<p>   e.java bean</p>
<p>​    update操作传入的account对象</p>
<ol>
<li><p>resultType结果类型</p>
<p>A. 基本数据类型</p>
<p>B. 包装类 java.lang.Integer</p>
<p>C. string类型，比如通过id查询username</p>
</li>
</ol>
<p>  ⚠️看到id有中断，这是因为之前程序有错异常了，没commit提交，但是id已经涨了。</p>
<p>   D. Java bean</p>
<p>​    findAll返回的account对象</p>
<h3 id="⛽️第四课"><a href="#⛽️第四课" class="headerlink" title="⛽️第四课"></a>⛽️第四课</h3><p>✅及联查询</p>
<p>1⃣️一对多，一个班对应多个学生</p>
<p>要查询id&#x3D;1的学生的名字、班级</p>
<p>建表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> student(</span><br><span class="line"> id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment,</span><br><span class="line"> name <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line"> cid <span class="type">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> classes(</span><br><span class="line"> id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment,</span><br><span class="line"> name <span class="type">varchar</span>(<span class="number">11</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>查询语句： <code>select * from student s, classes c where s.id =1 and s.cid=c.id;</code></p>
<p>🤔首先建接口，再写xxxRepository.xml, 再把xml文件加载到config中。 测试代码中，用方法就好了。</p>
<p>🏁mybatis和java类怎么做到映射，mybatis不关注表和类的结构，关注的是结果集和类的映射。</p>
<p>从select查出来的结果集，到赋给resutl的结果的映射。从结果集里按顺序找result对的上的字段，赋给result。</p>
<p>应该给后面的取别名。这里关于班级的信息要赋给classes对象，需要建立映射，用resultMap。</p>
<p>注意映射的时候，是看这个查询结果集上面的字段。</p>
<p>这样就完成了，结果类 和 结果集的映射</p>
<p>2⃣️通过classes查students</p>
<p>通过班级id，查出整个classes类.</p>
<p>首先写接口，再写xml文件，xml文件中先写sql语句，完成映射，添加到config，测试。</p>
<p>⚠️注意结果集要用resultMap，要还是用resultType的话，相当于写的映射没有用到。</p>
<p>3⃣️多对多</p>
<p>比如说，客户和商品，这两个是多对多的关系。</p>
<p>customer表和goods表，中间需要建一个从表customer_goods，里面cid表示客户表的外键，gid表示商品表的外键。</p>
<p>customer类中，有一个goods集合</p>
<p>goods类中，有一个custimer集合</p>
<p>要做的是：根据customer的id，返回custimer类。</p>
<p><code>select c.id as cid, c.name as came, g.id as gid, g.name as gname from customer as c, goods as g， customer_goods as cg where c.id=1 and cg.cid = c.id and cg.gid = g.id;</code> </p>
<p>返回id&#x3D;1的客人买的商品。</p>
<p>⚠️知识点；笛卡尔积，需要找这两张表的关联关系：第三张表.</p>
<p>根据一对多来建立多对多的映射就好了，不同之处在去sql语句中两张表建立关系的方式是通过第三张表了。</p>
<p>但是xml文件中构建映射要看的是sql语句返回结果集和接口方法要返回的返回类对象。</p>
<h3 id="⛽️第五课"><a href="#⛽️第五课" class="headerlink" title="⛽️第五课"></a>⛽️第五课</h3><p>✅逆向工程</p>
<p>对传统开发反向的一个方式。</p>
<p>Mybatis框架需要：实体类、自定义的Mapper接口、Mapper.xml。</p>
<p>传统的开发中，上述的三个组件需要开发者手动创建，逆向工程可以帮助开发者自动创建这三个组件，减轻开发者的工作量，提高工作效率。</p>
<p>缺点：逆向工程只能执行一次，逆向工程根据数据表来建立实体类等，如果改了表结构，就需要重新执行一次逆向工程。</p>
<p>如果改了表结构，就需要删了已经存在的，重新执行。</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>如何使用：</p>
<p>Mybatis Generator，简称MBG，是一个专门为Mybatis框架开发者定制的代码生成器和自动生成Mybatis框架所需的实体类、Mapper接口、Mapper.xml，支持基本CRUD操作，但是一些相对复杂的sql需要开发者自己来完成。</p>
<p>1⃣️新建Maven工程，引入依赖</p>
<p>数据库建个表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table t_user(</span><br><span class="line"> id int primary key auto_increment,</span><br><span class="line"> name varchar(11),</span><br><span class="line"> age int</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>2⃣️创建MBG配置文件generatorConfig.xml</p>
<p> \1. jdbcConnection 配置数据库连接信息</p>
<p> \2. javaModelGenerator 配置javaBean的生成策略，要把创建的实体类放在哪个包里</p>
<p> \3. sqlMapGenerator 配置sql映射文件生成策略</p>
<p> \4. javaClientGenerator 配置Mapper接口</p>
<p> \5. table 配置目标数据表（tableName：表名，dominObjectName：JavaBean类名）</p>
<p>3⃣️创建Generator执行类</p>
<p>启动类main，里面没有业务逻辑，没理解反正是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.MyBatisGenerator;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.xml.ConfigurationParser;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.exception.InvalidConfigurationException;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.exception.XMLParserException;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.internal.DefaultShellCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">​    List&lt;String&gt;warings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">​    <span class="type">boolean</span> <span class="variable">overwrite</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">​    <span class="type">String</span> <span class="variable">genCig</span> <span class="operator">=</span> <span class="string">&quot;/generatorConfig.xml&quot;</span>; <span class="comment">// /就表示resource文件夹</span></span><br><span class="line">​    <span class="type">File</span> <span class="variable">configFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(Main.class.getResource(genCig).getFile()); <span class="comment">//获取运行时类，getResource(路径)，获取配置文件</span></span><br><span class="line"></span><br><span class="line">​    <span class="type">ConfigurationParser</span> <span class="variable">configurationParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationParser</span>(warings);</span><br><span class="line">​    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span> &#123;</span><br><span class="line">​      configuration = configurationParser.parseConfiguration(configFile);</span><br><span class="line">​    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125; <span class="keyword">catch</span> (XMLParserException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="type">DefaultShellCallback</span> <span class="variable">callback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultShellCallback</span>(overwrite);</span><br><span class="line">​    <span class="type">MyBatisGenerator</span> <span class="variable">myBatisGenerator</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">​    <span class="keyword">try</span> &#123;</span><br><span class="line">​      myBatisGenerator = <span class="keyword">new</span> <span class="title class_">MyBatisGenerator</span>(configuration, callback, warings);</span><br><span class="line">​    &#125; <span class="keyword">catch</span> (InvalidConfigurationException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span> &#123;</span><br><span class="line">​      myBatisGenerator.generate(<span class="literal">null</span>);</span><br><span class="line">​    &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">​      throwables.printStackTrace();</span><br><span class="line">​    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>IDEA抛出异常快捷键：</strong></p>
<p><strong>Mac</strong></p>
<p><strong>方式一（光标移到该代码行，option+Enter），可以异常外抛出，也可以try-catch：</strong></p>
<p><strong>方式二（光标移到该代码行，或者选中该行代码，option+command+T）：[使用关键字或控制语句，比如if…else, try…catch, for, synchronized等]</strong></p>
<p>4⃣️<strong>然后运行main方法，文件夹下什么都有了，而且根据数据库的表建立了实体类。</strong></p>
<h3 id="⛽️第六课"><a href="#⛽️第六课" class="headerlink" title="⛽️第六课"></a>⛽️<strong>第六课</strong></h3><p>✅<strong>延迟加载</strong></p>
<p><strong>什么是延迟加载？也叫懒加载、惰性加载</strong></p>
<p><strong>使用延迟加载可以提高程序的运行效率，针对于数据的持久层的操作。在某些特定的情况下去访问特定的数据库，在其他情况下可以不访问某些表，从一定程度上减少了java应用与数据库的交互次数。</strong></p>
<p><strong>比如说上面及联查询时，查询学生和班级，学生和班级在两张不同的表，如果当前的需求只需要获取学生的信息，那么查询学生单表即可，如果需要通过学生获取对应的班级信息，则必须查询两张表。</strong></p>
<p><strong>不同的业务需求，需要查询不同的表，根据具体的业务需求来动态减少数据表查询的工作就是延迟加载。</strong></p>
<p><strong>举例：student和classes的例子里，两个接口里都增加一个方法，各自重写xml里面对应新增方法的sql语句，select语句不联表查询了，各查各的，测试时，首先得到student的名字，如果够了，就不用查classes表了，如果不够，再根据student的cid获得classes相关信息。</strong></p>
<p><strong>因此要在配置文件里完成一个连接的操作来自动识别是否还需要查另一张表，在</strong>association中。</p>
<p>实践效果：根据学生id，查到学生完成信息，包括里面的Classes类。</p>
<p>实际上进行了两次sql查询，本身student接口方法调用查询一次，student配置文件中select标签又查一次。</p>
<p>通过配置config文件中setting可以打印sql执行过程。</p>
<p>但是，只拿name的话，还是执行两次sql。因此需要在config中开启延迟加载。</p>
<p>奇怪了，我开启了延迟加载，只获得student的name，还是查两次。</p>
<p>⚠️出现问题，Cannot enable lazy loading because CGLIB is not available. Add CGLIB to your classpath.</p>
<p>应该增加CGLIB依赖。</p>
<p>❓依赖闲红的时候，必须要删除.m2文件夹下的所有依赖，然后reimport吗？</p>
<h3 id="⛽️第七课"><a href="#⛽️第七课" class="headerlink" title="⛽️第七课"></a>⛽️第七课</h3><p>✅MyBatis缓存</p>
<p>什么事mybatis缓存？使用缓存可以减少Java应用与数据库的交互次数，从而提高程序的运行效率。比如查询出id&#x3D;1的对象，第一次查询出之后会自动将该对象保存到缓存中，当下一次查询时，直接从缓存中取出对象即可，无需再次访问数据库。</p>
<p>Mybatis缓存分类：</p>
<ol>
<li><strong>一级缓存：SqlSession级别，默认开启，并且不能关闭。</strong></li>
</ol>
<p>  <strong>操作数据库时需要创建SqlSession对象，在对象中有一个HashMap用于存储缓存数据，不同的SqlSession之间缓存数据区域是互不影响的。</strong></p>
<p>  <strong>一级缓存的作用域是SqlSession范围的，当在同一个SqlSession中执行两次相同的SQL语句时，第一次执行完毕将结果保存到缓存中，第二次查询时直接从缓存中获取。</strong></p>
<p>  <strong>需要注意的是：如果SqlSession执行了DML操作（insert、update、delete），Mybatis必须将缓存清空，来保证数据的准确性。</strong></p>
<ol>
<li><strong>二级缓存：Mapper级别的，默认关闭，可以开启。</strong></li>
</ol>
<p>  <strong>使用二级缓存时，多个SqlSession使用同一个Mapper的sql语句操作数据库，得到的数据会存在二级缓存中，同样是使用HashMap进行数据存储，相比较一级缓存，二级缓存的范围更大，多个sqlsession可以共用二级缓存。二级缓存是跨sqlsession的。</strong></p>
<p>  <strong>二级缓存是多个sqlsession共享的，其作用域是mapper的同一个namespqce，不同的sqlsession两次执行相同的namespace下的sql语句，参数也相同，则第一次执行成功之后会将数据保存到二级缓存中，第二次可直接从二级缓存中取出数据。</strong></p>
<p>⚠️<strong>一级缓存是一个sqlsession一个缓存。二级缓存是一个mapper一个，多个sqlsession 可能是使用的同一mapper，也就是同一个namespace。二级缓存范围更大。</strong></p>
<p><strong>如何开启二级缓存：</strong></p>
<p><strong>config.xml中</strong></p>
<p><code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code></p>
<p><strong>然后再对应的mapper.xml中，添加配置二级缓存</strong></p>
<p><code>&lt;cache&gt;&lt;/cache&gt;</code></p>
<p><strong>然后实体类实现序列化接口</strong></p>
<p><code>public class Classes implements Serializable</code></p>
<ol>
<li><strong>第三方二级缓存。需要在pom.xml里添加相关依赖</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   &lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>然后添加配置文件ehcache.xml 不用自己写，定义了一些二级缓存的设置</strong></p>
<p><strong>然后在config.xml中开启二级缓存</strong></p>
<p><strong>然后在mapper.xml中配置二级缓存</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;</span><br><span class="line">  &lt;!-- 缓存创建之后，最后一次访问缓存的时间至缓存失效的时间间隔 --&gt;</span><br><span class="line">  &lt;property name=&quot;timeToIdleSeconds&quot; value=&quot;3600&quot;/&gt;</span><br><span class="line">  &lt;!-- 缓存自创建时间起至失效的时间间隔 --&gt;</span><br><span class="line">  &lt;property name=&quot;timeToLiveSeconds&quot; value=&quot;3600&quot;/&gt;</span><br><span class="line">  &lt;!-- 缓存的回收策略 ,LRU移除近期使用最少--&gt;</span><br><span class="line">  &lt;property name=&quot;memoryStoreEvictionPolicy&quot; value=&quot;LRU&quot;/&gt;</span><br><span class="line">&lt;/cache&gt;</span><br></pre></td></tr></table></figure>

<p><strong>这个缓存里实体类内不需要实现序列化接口</strong></p>
<h3 id="⛽️第八课-Mybatis动态sql"><a href="#⛽️第八课-Mybatis动态sql" class="headerlink" title="⛽️第八课 Mybatis动态sql"></a>⛽️<strong>第八课 Mybatis动态sql</strong></h3><p><strong>sql语句是动态创建的，只需要定一个大致的样式，它会根据具体的参数、具体的业务去动态生成不同的sql。</strong></p>
<p><strong>背景：业务比较复杂时，如果需要我们手动去拼接sql语句来完成操作，效率比较低而且容易出错。</strong></p>
<p>❓<strong>发现test类里，第一行的加载类一直是第一次用的，这合理吗？</strong></p>
<p><strong>用一个account对象查account对象，根据对象的四个参数对应放到sql语句中，如果传入的account的一个参数没设置，则传到sql语句那里，这个字段&#x3D;null。一般就没结果。</strong></p>
<p><strong>动态sql：只需要写一个模版，让程序自动根据属性是否有值，来动态决定是否加这个条件。</strong></p>
<p><strong>其实就是一个if else的流程，判断如果为null，就忽略掉，使得有结果。</strong></p>
<p><strong>使用动态sql的作用：可简化代码的开发，减少开发者的工作量，程序可以自动根据业务参数来决定sal的组成。</strong></p>
<ul>
<li><strong>if标签</strong></li>
</ul>
<p><strong>～～～～～</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByAccount1&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  select * from account where</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != 0&quot;</span>&gt;</span></span><br><span class="line">​    id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">​    and username = #&#123;username&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span></span><br><span class="line">​    and password = #&#123;password&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != 0&quot;</span>&gt;</span></span><br><span class="line">​    age = #&#123;age&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>但是，如果第一个参数不给，就会出错，因为直接and后面的，语法错误。</strong></p>
<p><strong>将if标签的语句，放在where标签里就可以了。</strong></p>
<p><strong>if标签可以自动根据表达式的结果来决定是否将对应的语句添加到sql中，如果条件不成立则不添加，如果条件成立则添加。</strong></p>
<p><strong>where标签可以自动判断是否要删除语句块中的and关键字，如果监测到where直接跟and拼接，则自动删除and，通常情况下 if 和 where结合使用。</strong></p>
<ul>
<li><strong>choose、when标签</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByAccount2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  select * from account</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span> = <span class="string">&quot;id !=0 &quot;</span>&gt;</span></span><br><span class="line">​        id = #&#123;id&#125;</span><br><span class="line">​      <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​      <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span> = <span class="string">&quot;username !=null &quot;</span>&gt;</span></span><br><span class="line">​        username = #&#123;username&#125;</span><br><span class="line">​      <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​      <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span> = <span class="string">&quot;password !=null &quot;</span>&gt;</span></span><br><span class="line">​        password = #&#123;password&#125;</span><br><span class="line">​      <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​      <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span> = <span class="string">&quot;age !=0 &quot;</span>&gt;</span></span><br><span class="line">​        age = #&#123;age&#125;</span><br><span class="line">​      <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>trim标签：trim标签中的prefix和suffix属性会被用于生成实际的sql语句，会和标签内部的语句进行拼接，如果语句前后出现了prefixOverrides或者suffixOverrides属性中指定的值，Mybatis框架会自动将其删除。</strong></p>
</li>
<li><p><strong>set标签：用于update操作，会自动根据参数来选择生成sql语句。</strong></p>
</li>
</ul>
<p><strong>update传入的对象，如果set属性只有一个，相当于其他属性不传值，变为了null或者0.</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update1&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  update account</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != 0&quot;</span>&gt;</span></span><br><span class="line">​      id = #&#123;id&#125;</span><br><span class="line">​    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">​      and username = #&#123;username&#125;</span><br><span class="line">​    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span></span><br><span class="line">​      and password = #&#123;password&#125;</span><br><span class="line">​    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != 0&quot;</span>&gt;</span></span><br><span class="line">​      age = #&#123;age&#125;</span><br><span class="line">​    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">   where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>这是sql拼接吗？</strong></p>
<ul>
<li><strong>foreach标签</strong></li>
</ul>
<p><strong>foreach标签可以迭代生成一系列值，这个标签主要用于sql的in语句。</strong></p>
<p><code>private List&lt;Long&gt; ids;</code></p>
<p><code>List&lt;Long&gt; ids = new ArrayList&lt;Long&gt;();</code></p>
<p><strong>还得在实体类里建一个List吗？感觉不太便利。</strong></p>
<p><code>&lt;select id=&quot;findByIds&quot; param&gt;</code></p>
<h3 id="⛽️第九课-mybatis-通用Mapper"><a href="#⛽️第九课-mybatis-通用Mapper" class="headerlink" title="⛽️第九课 mybatis 通用Mapper"></a>⛽️<strong>第九课 mybatis 通用Mapper</strong></h3><p><strong>虽然有逆向工程MBG，能够自动生成代码，但是entity改变会牵一发而动全身。</strong></p>
<p>1⃣️<strong>建表</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> mapperdemo(</span><br><span class="line"> id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment,</span><br><span class="line"> username <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line"> password <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line"> age <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> mapperdemo (username, password, age) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;liuxuan&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="number">23</span>),</span><br><span class="line">(<span class="string">&#x27;jade&#x27;</span>, <span class="string">&#x27;kk&#x27;</span>, <span class="number">22</span>),</span><br><span class="line">(<span class="string">&#x27;aks&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure>



<p>2⃣️新建java实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.mybatis.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span> <span class="comment">//有参构造</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span>  <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mapperdemo</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>
考虑到基本数据类型在Java类型中都有默认值，会导致mybatis在执行相关操作时很难判断当前字段是否为null。因此在mybatis环境下使用基本数据类型对应的包装类型。(上面的作废)



✅mapper注解重来：

参考链接：https://blog.csdn.net/jintingbo/article/details/80517053



从mybatis3.4.0开始加入了@Mapper注解，目的就是为了不再写mapper映射文件

现在我们通过一个简易的maven项目去了解@Mapper注解的使用方式：



1⃣️建表：

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> <span class="keyword">user</span>(</span><br><span class="line"> name <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line"> pwd <span class="type">varchar</span>(<span class="number">11</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> <span class="keyword">user</span> (name, pwd) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;liuxuan&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;jade&#x27;</span>, <span class="string">&#x27;kk&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;aks&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>);</span><br></pre></td></tr></table></figure>



2⃣️实体类

操作之前，从github上clone下来的项目出现问题

1.文件左下角有个橙色的小时钟，出现橙色原因：没有添加到maven解决办法：找到项目的xml,如果最外层没有xml,找到模块里面对应的xml,右键选择Add as Maven project. 导入通过maven导入jar。就解决了了。

2.项目依赖是红的，去maven仓库[Maven Repository: Search/Browse/Explore](https://mvnrepository.com/)下下来，放在.m2文件夹下。

3.没弄sdk，弄成jdk1.8

4.奇了怪了，这个项目里实体类用Lombok，依赖显红，懵逼了。

5.p空间显红的解决办法：file--&gt;settings...--&gt;languages &amp; frameworks--&gt;schemas and DTDs --&gt; 添加url



3⃣️加载配置文件时找不到bean

不知道啥原因了，应该是mybatis结合spring，这一点还没掌握。



总之，使用方面，不需要在mapper.xml里写sql语句？

测试类里直接调用dao接口里的方法即可？

！！！项目里还是有sql语句的，接口里用@mapper @param注解，只是传递参数。和之前学的，只是在接口里多了这俩注解。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sweetwater"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">Sweetwater</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sweetwater</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
