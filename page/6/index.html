<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Sweetwater&#39;s blog">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="Sweetwater&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Sweetwater">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Sweetwater's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sweetwater's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/08/myblog/java/%E3%80%8AJava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/08/myblog/java/%E3%80%8AJava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B/" class="post-title-link" itemprop="url">《Java基础入门》面向对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-08 10:33:43" itemprop="dateCreated datePublished" datetime="2021-11-08T10:33:43+08:00">2021-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-23 00:44:48" itemprop="dateModified" datetime="2025-07-23T00:44:48+08:00">2025-07-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java开发入门"><a href="#Java开发入门" class="headerlink" title="Java开发入门"></a>Java开发入门</h2><p>Java是由Sun公司于1995年开发的可编写跨平台应用软件、完全面向对象的程序设计语言。2009年被Oracle公司收购。</p>
<h3 id="Java三个技术平台"><a href="#Java三个技术平台" class="headerlink" title="Java三个技术平台"></a>Java三个技术平台</h3><p>针对不同的开发市场，Sun公司将Java划分为三个技术平台。</p>
<p>（1）Java SE：（standard edition）Java平台标准版，为开发普通桌面和商务应用程序提供的解决方案，是三个平台中最核心的部分，Java EE和Java ME都是从Java SE的基础上发展而来，Java SE包括Java最核心的类库，如集合、IO、数据库连接及网络编程。</p>
<p>（2）Java EE：（enterprise edition）平台企业版，为开发企业级应用程序提供的解决方案，包括Servlet、JSP、JavaBean、EJB、Web Service等。用来做web开发的java框架。</p>
<p>（3）Java ME：（micro edition）平台微型版，为开发电子消费产品和嵌入式设备提供的解决方案，用于微型数字电子设备上软件程序的开发，例如家用电器增加智能化控制和联网功能，未手机增加游戏和通讯录管理功能。此外，还提供HTTP等协议，为移动电话提供Client&#x2F;Server方式访问Internet，提供无线交流。</p>
<p>不管哪个版本，都是java语言实现的一个框架。之所以要分版本，是因为3个版本是针对不同问题，设计的解决方案。</p>
<p>J2SE是标准版本，J2ME是手机方向的，J2EE是网站开发方向的。</p>
<h3 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h3><ul>
<li>简单易用：丢弃了c++中的：操作符重载、多继承、自动强制类型转换、不使用指针而是引用，提供自动分配和回收内存空间。</li>
<li>安全可靠：Java通常被用在网络环境中，为此，Java 提供了一个安全机制以防恶意代码的攻击。除了Java 语言具有的许多安全特性以外，Java 对通过网络下载的类具有一个安全防范机制（类 ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类 SecurityManager）让 Java 应用设置安全哨兵。</li>
<li>跨平台：通过JVM虚拟机在不同的操作系统上允许Java程序。</li>
<li>面向对象：将一切事物都看成对象，类、接口、继承。只支持类之间的单继承，支持接口之间的多继承，支持类与接口之间的实现机制（implements）。java全面支持动态绑定，c++只对虚函数使用动态绑定。</li>
<li>支持多线程：内置了多线程控制，可使用户程序并发执行。</li>
</ul>
<h3 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK&gt;JRE&gt;JVM"></a><strong>JDK&gt;JRE&gt;JVM</strong></h3><p><strong>JVM</strong> ：（Java Virtual Machine）， Java 虚拟机。它只认识 xxx.class 类型的文件，能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。jvm 是 Java 能够跨平台的核心。</p>
<p><strong>JRE</strong> ：（Java Runtime Environment），Java 运行时环境。主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。普通用户只需要JRE进行运行已经编译好的java程序，而不需要开发。</p>
<p><strong>JDK</strong> ：（Java Development Kit），Java 开发工具包。jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。例如：javac.exe（编译 java 源码的编译器 javac），java.exe（java运行工具），jar.exe（java打包工具），java文档生成工具 等很多 java 程序调试和分析的工具。</p>
<p>1996年推出jdk1.0，随后到1.5改变命名方式，jdk1.5&#x3D;jdk5.2017年jdk9，2018年jdk10.但是并不稳定。目前最多运用jdk8.</p>
<p>安装jdk时，安装开发工具（包括javac.exe、java.exe等，以及一个专用JRE环境），源代码（Java所有核心类库的源代码），公共JRE相当于多装一个JRE在其他路径，所以不需要。</p>
<p>JDK&#x3D;JRE(JVM+JAVA基本类库)+开发工具</p>
<h3 id="JDK目录"><a href="#JDK目录" class="headerlink" title="JDK目录"></a>JDK目录</h3><ul>
<li>bin目录：存放一些可执行程序，如javac.exe（java编译器）、java.exe（java运行工具）、jar.exe（打包工具）、javadoc.exe（文档生成工具）等。</li>
<li>db目录：纯java实现的支持JDBC4.0所有规范的小型数据库。</li>
<li>include目录：由于JDK是通过C和C++实现的，因此在启动时引入一些C语言的头文件，该目录就是存放这些头文件的。</li>
<li>jre目录：Java运行时环境的根目录，，包括java虚拟机、运行时的类包、java应用启动器以及一个bin目录，不包括开发环境中的开发工具。</li>
<li>lib目录：java类库或库文件，是开发工具使用的归档包文件。</li>
</ul>
<blockquote>
<p>javac.exe：编译器工具，将java文件编译成可执行的java字节码文件.class</p>
<p>java.exe：java运行工具，会启动一个java虚拟机进程，专门负责运行字节码文件</p>
</blockquote>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>目的：在任何位置都能够编译和运行java程序。</p>
<p>配置：PATH：用于告知操作系统去指定路径寻找JDK，CLASSPATH：告知JDK去指定路径查找类文件(.class文件)</p>
<p>当在命令窗口中运行一个可执行文件时，操作系统首先会在当前目录下寻找是否存在该文件，如果不存在，会在PATH环境变量中定义的路径下寻找这个文件。</p>
<h3 id="java运行机制"><a href="#java运行机制" class="headerlink" title="java运行机制"></a>java运行机制</h3><p>.java文件，</p>
<p>使用javac.exe即java编译器进行编译，</p>
<p>.class文件，</p>
<p>使用java命令开启Java虚拟机运行程序，java虚拟机首先将编译好的字节码文件加载到内存（类加载，由类加载器完成），然后虚拟机通过java解析器对加载到内存中的java类进行解释执行，</p>
<p>机器码文件，</p>
<p>计算机运行机器码文件。</p>
<blockquote>
<p>java程序是由java虚拟机负责解释执行的，而不是操作系统，因此跨平台。</p>
</blockquote>
<h3 id="类包"><a href="#类包" class="headerlink" title="类包"></a>类包</h3><p>import导包：import 包名.类名  &#x2F;  import 包名.*</p>
<p>java的核心类主要放在java包及其子包下。java扩展的大部分类在javax包及其子包下。</p>
<p>java.util：java的大量工具类、集合类，如Arrays、List、Set等</p>
<p>java.net：java网络编程相关的类和接口</p>
<p>java.io：java输入输出相关类和接口</p>
<p>java.awt：构建图形界面GUI的类和接口</p>
<p>java.sql：数据库编程</p>
<h2 id="Java编程基础"><a href="#Java编程基础" class="headerlink" title="Java编程基础"></a>Java编程基础</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行&#x2F;&#x2F;  多行&#x2F;*  *&#x2F;</p>
<p>文档注释：对某个类或类中的方法进行系统性解释说明。开发人员可使用JDK提供的javadoc工具将文档注释提取出来生成一份API帮助文档。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  content</span><br><span class="line">*  content</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>包名：一律小写<br>类名、接口名：首字母大写<br>常量名：都大写下划线连接<br>变量名和方法名：一个单词首字母小写，后面首字母大写</p>
<h3 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h3><p>八种基本数据类型：<br>byte：是8位、有符号的，以二进制补码表示的整数；-128~127；<br>short：16位<br>int：32位<br>long：64位，所赋的值超过int的取值范围，则需要加L，long num&#x3D;10000000L;<br>float：单精度32位，小数默认为double类型，因此定义float型需要在后面加f&#x2F;F<br>double：双精度64位<br>boolean：布尔<br>char：字符，2个字节</p>
<p>引用数据类型：<br>引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型。变量一旦声明后，类型就不能被改变了。对象、数组都是引用数据类型。<br>所有引用类型的默认值都是null，表示没有指向任何对象。</p>
<p><code>char c=&#39;a&#39;</code> 和 <code>char c=97</code>一样。因为可以将char变量赋值为0-65535范围内的整数，计算机将整数自动转化为对应的字符。</p>
<h3 id="变量的类型转换"><a href="#变量的类型转换" class="headerlink" title="变量的类型转换"></a>变量的类型转换</h3><p>（1）自动类型转换（隐式类型转换）：将一个类型取值范围小的数值直接赋值给另一个取值范围大的数据类型变量。大壶装小壶。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte b=3;</span><br><span class="line">int x=b;</span><br><span class="line">double y=x;</span><br></pre></td></tr></table></figure>

<p>（2）强制类型转换（显式类型转换）：目标类型取值范围小于源类型。小壶装大壶。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte a;</span><br><span class="line">int b=298;</span><br><span class="line">a=(byte)b;   //结果a会变成42</span><br></pre></td></tr></table></figure>

<p>强制类型转换中可能丢失精度，例如int占用4个字节，而byte占用1个字节，298变二进制后只留下最低的八位。</p>
<p>（3）表达式类型自动提升：byte、short、char类型的变量在运算期间类型会自动提示为int类型，然后进行运算，因此在最后获得结果时需要强制类型转换。</p>
<p>（4）在使用+&#x3D;、-&#x3D;、*&#x3D;等运算符时，强制类型转换会自动完成。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>整形常量：二进制0b&#x2F;0B开头，八进制0开头，十六进制0x&#x2F;0X开头。</p>
<p>null：表示对象的引用为空。</p>
<p>需要用final关键字定义常量：<br><code>final int a=0</code></p>
<p>转义符<br>\r  回车符<br>\n  换行符<br>\t  制表符<br>\b  退格符，backspace<br>\后加&#39;或&quot;或\表示本身</p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选，可以不break而继续执行。</span></span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="comment">//你可以有任意数量的case语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">//可选，最后才看</span></span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>定义的三种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span>[] nums=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">剖析：<span class="type">int</span>[] nums;  nums变量的类型是<span class="type">int</span>[]。</span><br><span class="line">nums会占用一块内存单元，nums=<span class="keyword">new</span> <span class="title class_">int</span>[]; 表示创建数组，并将数组的内存地址赋值给变量nums。在程序运行期间可以用变量nums来引用数组.</span><br></pre></td></tr></table></figure>

<p>多维数组：<code>String[][] str = new String[3][4];</code></p>
<p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>对数组进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">Arrays.sort(arr,<span class="number">1</span>,<span class="number">4</span>);  左闭右开</span><br></pre></td></tr></table></figure>

<h2 id="面向对象（上）"><a href="#面向对象（上）" class="headerlink" title="面向对象（上）"></a>面向对象（上）</h2><p>面向对象是把构成问题的事物按照一定规则划分为多个独立的对象，然后通过调用对象的方法来解决问题。</p>
<p>封装：将对象的属性和行为封装起来。</p>
<p>继承：描述类与类之间的关系，使得无须重新编写原有类的情况下对原有类的功能进行扩展。</p>
<p>多态：一个类中定义的属性和功能被其他类继承后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一方法所呈现出的多种不同行为特征。</p>
<p>类是对象的抽象，共同特征作为属性（成员变量），共同行为作为类的方法（成员方法）。对象是类的实例。</p>
<p>创建对象：<code>Person p=new Person();</code></p>
<p>第一步：<code>Person p;</code> 声明一个Person类型的变量p</p>
<p>第二步：<code>=new Person();</code>创建Person对象，并将Person对象在内存中的地址赋值给变量p，这样变量p便持有了对象的引用。</p>
<p>内存中，p变量存对象的地址，在栈内存，p是一个引用，指向真正的对象。对象创建在堆内存。</p>
<blockquote>
<p>栈内存：存放基本类型的变量和对象的引用变量。</p>
<p>堆内存：存放new创建的对象和数组。</p>
</blockquote>
<p>创建好对象后，可以通过对象的引用来访问对象的所有成员。对象引用.对象成员</p>
<p>也可以使用创建的对象本身来引用对象成员：<code>new Person().成员</code>。由于没有对象引用的存在，在完成一个对象成员的访问后，该对象变成垃圾对象。<strong>当对象没有被任何变量所引用就会变成垃圾。</strong></p>
<h3 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h3><p>访问控制级别由小到大：private→default→protected→public</p>
<ul>
<li>private（当前类访问级别）：该成员只能被该类的其他成员访问，其他类无法直接访问。</li>
<li>default（包访问级别）：不使用任何访问控制修饰符的话，就是default，表示这个类或者类的成员只能被本包中的其他类访问。</li>
<li>protected（子类访问级别）：成员能被同一包内的其他类访问，也能被不同包下该类的子类访问。</li>
<li>public（公共访问级别）：该类或类的成员能被所有的类访问，不管是否在同一包中。</li>
</ul>
<blockquote>
<p>如果一个java源文件中定义的所有类都没有public修饰符，那么这个源文件的文件名可以是一切合法的文件名。</p>
<p>如果java源文件中定义了一个public修饰的类，则源文件名必须与public修饰的类的类名一致。</p>
</blockquote>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>类的封装，是指将对象的属性隐藏在对象内部，设为private级别，不允许外部程序直接访问对象的内部信息，而通过类内public的方法（setxxx，getxxx）实现对内部信息的操作及访问。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>在实例化对象的同时为这个对象的属性进行赋值，可以通过构造方法来实现。</p>
<p>构造方法需要满足的三个条件：方法名与类名相同、在方法名的前面没有返回值类型的声明、方法中不能使用return返回一个值但是可以单独return来结束方法。</p>
<p>构造方法的重载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line">    TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java中每个类都至少有一个构造方法，如果一个类中没有显示地定义构造方法，系统会自动为这个类创建一个无参构造方法。但是一旦自己定义了有参的构造方法，系统将不再提供无参的构造方法。</p>
<blockquote>
<p>疑问：构造方法用来在实例化对象的时候为对象的成员变量赋值，而在定义类的时候，可以声明变量（不赋值）也可以定义变量（赋值），那么定义了变量之后，实例化对象，是给对象的成员赋初值了吗？应该是吧</p>
</blockquote>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>关键字this用来指代当前对象，用来在方法中访问对象的其他成员。</p>
<ul>
<li>通过this关键字调用成员变量，解决与局部变量名称冲突的问题。</li>
<li>通过this关键字调用成员方法。</li>
<li>通过this关键字调用构造函方法，构造方法是在实例化对象时被java虚拟机自动调用的，但是可以<strong>在一个构造方法中</strong>用<code>this(参数);</code>的形式来调用其他的构造方法。注意：只能在构造方法中用，且必须是构造方法中的第一条语句，且只能出现一次，而且不能在两个构造方法中相互调用。</li>
</ul>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>（1）静态变量</p>
<p>类内的数据成员被一个类的所有实例对象所共享时使用，例如学校学生的学校名。不必要在每个对象占用的空间中都声明这个对象，而是在对象之外的空间中声明一个变量供所有对象来共享。</p>
<p>注意：static关键字只能用于修饰成员变量，不能用于修饰局部变量。</p>
<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String schoolName;</span><br><span class="line">&#125;</span><br><span class="line">main函数中：</span><br><span class="line">Student.schoolName=<span class="string">&quot;daxue&quot;</span>;</span><br><span class="line">Student stu1=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">使用： stu1.schoolName</span><br></pre></td></tr></table></figure>

<p>（2）静态方法</p>
<p>希望在不创建对象的情况下就可以调用某个方法时使用。</p>
<p>访问方式：<code>类名.方法</code>    或    <code>实例对象名.方法</code></p>
<p>注意：在一个静态方法中只能访问用static修饰的成员，原因在于没有没sttaic修饰的成员需要先创建对象才能访问，而静态方法在被调用时可以不创建任何对象。</p>
<blockquote>
<p>思考：一个文件中可以有多个类，文件名叫public的类的名字，类内可以有public static main函数，有main函数的类得是public的?</p>
<p>static 的成员函数，只能访问static的成员（函数或变量），public static main函数中可以创建其他类的对象，然后访问其他非static类的成员。</p>
</blockquote>
<p>（3）静态代码块</p>
<p>static{…}  在类被加载时，静态代码块会执行，由于类只加载一次，因此静态代码块也只执行一次。通常使用静态代码块对类的成员变量进行初始化。第一次实例化对象时会加载类。</p>
<h2 id="面向对象（下）"><a href="#面向对象（下）" class="headerlink" title="面向对象（下）"></a>面向对象（下）</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>is a的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类在继承父类的时候，会自动拥有父类所有公共的成员。</p>
<p>java中只支持单继承，不允许多继承，一个类只能有一个直接父类。</p>
<h3 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h3><p>不能使用比父类中重写的方法更严格的访问权限，如父类的访问权限是public，子类方法不能是private。</p>
<p>也可以重新定义父类的属性。</p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>子类重写父类方法或重新定义父类属性后，子类对象无法直接访问他们，因此，用super访问。<code>super.成员变量/成员方法</code></p>
<p>还可以用super关键字来调用父类的构造方法。<code>super([参数1,参数2]);</code>但是，只能出现在子类构造方法的第一行，且只能出现一次。</p>
<p>注意：子类的构造方法中一定会调用父类的某个构造方法，可以通过super指定。如果没有super，则会默认调用父类无参的构造方法。因此，如果父类只定义了有参的构造方法，系统不给默认无参构造方法，就会出错。因此需要在父类添加无参构造方法，或者子类指定调用父类有参构造方法。</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>java中的Object类是所有类的父类，每个类都直接或间接地继承自该类，称为超类、基类、或根类。Object类中有一些自定义的方法。</p>
<p><code>对象名.toString()  </code>返回对象的字符串表示。</p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>不可更改，最终的意思。</p>
<p>（1）修饰类：不能被继承。</p>
<p>（2）修饰方法：不能被子类重写</p>
<p>（3）修饰变量：常量，只能被赋值一次。</p>
<p>final修饰的成员变量，必须在声明的同时进行赋值。</p>
<p>final修饰的局部变量，可以先声明，再进行一次赋值。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>例如在定义Animal类时，shout()方法无法明确表示，java提供抽象方法来使得其无需提供方法的具体实现。</p>
<p>抽象方法：<code>public abstract void shout();</code>没有大括号</p>
<p>包含抽象方法的类一定是抽象类，class前加abstract，但是抽象类中可以不包含抽象方法。</p>
<p>抽象类不能被实例化，只能创建子类，并在子类中实现抽象类中的抽象方法。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是一种特殊的抽象类，它不包含普通方法，内部所有方法都是抽象方法。</p>
<p>JDK8中对接口进行了重新定义，接口中除了抽象方法外，可以有default修饰的默认方法，static修饰的静态方法，这两种方法都允许有方法体。</p>
<p>用interface修饰，可以extends多个接口。接口内部可以有final常量，定义常量时必须进行初始化赋值。</p>
<p>小提示：定义常量时<code>public static final</code>可省略，定义方法时<code>public abstract</code>可省略</p>
<p>调用静态方法：<code>接口名.方法名</code></p>
<p>调用抽象方法和默认方法需要通过接口实现类的实例对象来调用。默认方法不需要子类中实现。</p>
<p><code>public interface Hockey extends Sports, Event</code>   接口的多继承</p>
<p>一个类可以在继承一个类的同时实现多个接口：<code>public class 类名 extends 类名 implements 接口1，接口2</code>  ，extend需要在前面</p>
<blockquote>
<p>注意：如果一个类通过implement实现接口，如果该类是抽象类，则可以实现接口中的部分抽象方法，如果不是抽象类，则需要实现接口中的所有抽象方法。</p>
</blockquote>
<p>总结：类继承类（只能继承一个类，但同时可以实现多个接口），接口继承接口（可一次继承多个接口），类实现接口（可一次实现多个接口）</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指一个类中定义的属性和方法被其他类继承或重写后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一方法所呈现的多种不同形态。</p>
<p>把子类对象直接赋值给父类引用变量时，程序只有在运行时才知道该引用变量具体代表哪个子类对象。</p>
<h3 id="对象的类型转换"><a href="#对象的类型转换" class="headerlink" title="对象的类型转换"></a>对象的类型转换</h3><p>子类对象当作父类类型使用：向上转型</p>
<p><code>Animal an1=new Cat();</code>   不需要任何显示声明，但是不能通过父类变量去调用子类特有的方法。</p>
<p>要想使用子类特有的方法，需要将本质为Cat类型的an1对象由Animal类型向下转型为Cat类型。</p>
<p><code>Cat cat=(Cat)an1;</code> 就可以用cat变量来调用子类特有方法了。</p>
<p><code>instanceof</code>关键字，用来判断一个对象是否为某个类或接口的实例或子类实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal an1=new Cat();</span><br><span class="line">if(an1 instanceof Cat)&#123;</span><br><span class="line">    Cat cat=(Cat)an1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>java中允许一个类的内部定义类，这样的类叫内部类。内部类所在类叫外部类。根据内部类的位置、修饰符、定义方式的不同分为四种。</p>
<p>（1）成员内部类</p>
<p>像成员变量、成员方法一样的存在，在成员内部类中，可以访问外部类的所有成员。在外部类中，可以访问成员内部类的成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">外部类访问内部类的成员：</span><br><span class="line">Inner inner = new Inner();</span><br><span class="line">inner.成员</span><br><span class="line">在与外部类平行的类中：</span><br><span class="line">Outer out = new Outer();  创建外部类对象</span><br><span class="line">Outer.Inner in = new Inner();   创建内部类对象</span><br></pre></td></tr></table></figure>

<p>（2）局部内部类</p>
<p>也叫方法内部类，是定义在某个方法内的，有效范围仅限于方法内部。</p>
<p>局部内部类可以访问外部类所有成员，而只有在包含局部内部类的方法中才可以访问内部类的成员。</p>
<p>（3）静态内部类</p>
<p>使用static关键字修饰的成员内部类，静态内部类只能访问外部类的静态成员.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在与外部类平行的类中：</span><br><span class="line">Outer.Inner inner = new Outer.Inner();</span><br><span class="line">inner.成员</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般在刷题时，定义Solution类，类内定义成员方法实现算法。测试时，定义另一个类，类内main函数中输入输出，然后定义对象<code>Solution s = new Solution();</code>通过对象访问算法方法。</p>
</blockquote>
<p>（4）匿名内部类</p>
<p>在java中调用某个方法时，如果该方法的参数是一个接口类型，除了可以传入一个参数接口实现类，还可以使用匿名内部类实现接口来作为该方法的参数。</p>
<p>匿名内部类就是没有名称的内部类，在调用包含有接口类型参数的方法时，通常为了简化代码，不会创建一个接口的实现类作为方法参数传入，而是直接通过匿名内部类的形式传入一个接口类型参数，在匿名内部类中直接完成方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义动物类接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		String name=<span class="string">&quot;maomao&quot;</span>;</span><br><span class="line">		<span class="comment">//定义匿名内部类作为参数传递给animalShout方法</span></span><br><span class="line">		animalShout(<span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">		    <span class="comment">//匿名内部类中实现shout方法</span></span><br><span class="line">		    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>&#123;</span><br><span class="line">		    	<span class="comment">//JDK8开始，局部内部类、匿名内部类可以访问非final的局部变量</span></span><br><span class="line">		    	System.out.println(name+“喵喵”)；</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;)；</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义静态方法animalShout(),接收接口类型参数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">animalShout</span><span class="params">(Animal an)</span>&#123;</span><br><span class="line">		an.shout(); <span class="comment">//调用传入对象的shout()方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分两步：</p>
<p>第一步 <code>animalShout(new Animal()&#123;&#125;)</code> 参数位置创建一个实例对象，表示创建的对象为Animal的子类实例，该子类是匿名的。</p>
<p>第二步<code>&#123;&#125;</code>中编写匿名子类的实现代码。</p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda 表达式，也可称为<strong>闭包</strong>，它是推动 Java 8 发布的最重要新特性。它使用一个清晰简洁的表达式来表达一个接口。</p>
<p>匿名内部类存在一个问题：如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然冗余。</p>
<p>Lambda表达式针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br><span class="line">可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</span><br><span class="line">可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</span><br><span class="line">可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</span><br><span class="line">可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，return可省略</span><br></pre></td></tr></table></figure>

<p>上面的例子，用lambda表达式来做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animalShout(()-&gt;System.out.println(name+“喵喵”);)</span><br></pre></td></tr></table></figure>

<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>Lambda表达式可以实现匿名内部类的功能，但是局限在于接口中只有一个抽象方法时才能使用Lambda表达式代替匿名内部类。</p>
<p>因为Lambda表达式是基于函数式接口实现的，函数式接口就是只有一个抽象方法的接口。</p>
<p>JDK8中专门为函数式接口引入@FunctionalInterface注解，显示地标识接口是一个函数式接口，如果不是编译器就会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Calculate</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		showSum(<span class="number">10</span>, <span class="number">20</span>, (x,y)-&gt;x+y);  <span class="comment">//实现方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建参数为接口的方法</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showSum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, Calculate cu)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;和为：&quot;</span>+cu.sum(x, y));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda表达式的引用形式"><a href="#Lambda表达式的引用形式" class="headerlink" title="Lambda表达式的引用形式"></a>Lambda表达式的引用形式</h3><p>Lambda表达式的主体只有一条语句时，程序可通过<code>：：</code>的语法格式来引用方法和构造器。本质是对Lambda表达式的主体部分已存在的方法进行直接引用。</p>
<p>相当于calc方法需要实现，而又现成的abs方法可以用。</p>
<p>（1）类名引用普通方法&#x2F;静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Calculate</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含静态方法的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Math</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(num&lt;<span class="number">0</span>)  <span class="keyword">return</span> -num;</span><br><span class="line">		<span class="keyword">else</span>  <span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printAbs</span><span class="params">(<span class="type">int</span> num, Calculate cu)</span>&#123;</span><br><span class="line">		System.out.println(cu.calc(num));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//使用lambda表达式</span></span><br><span class="line">		printAbs(-<span class="number">10</span>, n-&gt;Math.abs(n));</span><br><span class="line">		<span class="comment">//使用方法引用</span></span><br><span class="line">		printAbs(-<span class="number">10</span>, Math::abs);  类名::类静态方法/普通方法名</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）对象名引用方法</p>
<p>也可以通过实例化对象的名称来对其方法进行引用。是普通方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math ma = new Math();</span><br><span class="line">printAbs(-10, n-&gt;ma.abs(n));</span><br><span class="line">printAbs(-10,ma::abs);</span><br></pre></td></tr></table></figure>

<p>（3）构造器引用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonBuilder</span>&#123;</span><br><span class="line">	Person <span class="title function_">buildPerson</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个Person类，并添加有参构造方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">(String name, PersonBuilder bu)</span>&#123;</span><br><span class="line">		System.out.println(bu.buildPerson(name).getName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//使用lambda表达式   ()-&gt;new 类名()</span></span><br><span class="line">		printAbs(<span class="string">&quot;张三&quot;</span>, name-&gt;<span class="keyword">new</span> <span class="title class_">Person</span>(name));</span><br><span class="line">		<span class="comment">//使用方法引用    类名::new</span></span><br><span class="line">		printAbs(<span class="string">&quot;张三&quot;</span>, Person::<span class="keyword">new</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>java语言引入了异常，以异常类的形式对正常情况进行封装。</p>
<p>异常类都继承自java.lang.Throwable类。</p>
<p>Throwable有两个直接子类Error和Exception。</p>
<p>其中Error称为错误类，代表Java运行时产生的系统内部错误或资源耗尽的错误，如系统崩溃、虚拟机错误。</p>
<p>Exception类称为异常类，标识程序本身可以处理的错误，异常处理都是针对该类及其子类。RuntimeException表示运行时异常，其他表示编译时异常。</p>
<p>Throwable类中常用的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String getMessage()</span><br><span class="line">返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</span><br><span class="line">public void printStackTrace()</span><br><span class="line">打印toString()结果和栈层次到System.err，即错误输出流。</span><br><span class="line">public Throwable getCause()</span><br><span class="line">返回一个Throwable 对象代表异常原因。</span><br></pre></td></tr></table></figure>

<p>运行时异常是在程序运行时由Java虚拟机自动进行捕获处理的。例如数组越界。</p>
<h3 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在除法方法中：</span><br><span class="line">try&#123;</span><br><span class="line">   可能发生异常的语句</span><br><span class="line">&#125;catch(Exception类或其子类 e1)&#123;</span><br><span class="line">   对捕获的异常进行相应的处理</span><br><span class="line">   System.out.println(&quot;异常：&quot;+e1.getMessage());</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	无论程序是否异常都会执行的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try{}中的代码块发生异常，系统会将这个异常的信息封装成一个异常对象，传递给catch(){}代码块，catch代码块需要一个参数指明它所能接收的异常类型，必须是Exception类或其子类。</p>
<p>finally{}中的代码不受return语句和程序异常的影响，可以用来完成必须要做的事，例如释放系统资源、关闭线程池等。但是在try…catch…代码块中执行了<code>System.exit(0)</code>语句的话，finally不会执行，因为<code>System.exit(0)</code>表示退出当前的java虚拟机。</p>
<h3 id="throws关键字"><a href="#throws关键字" class="headerlink" title="throws关键字"></a>throws关键字</h3><p>用于将异常从当前方法中抛出，throws写在方法声明的后面，后跟声明方法中发生异常的类型，这种做法叫做方法申明抛出一个异常。一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static int divide(int x, int y) throws Exception&#123;</span><br><span class="line">	int res=x/y;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了throws后，还需要再出现异常的代码（main中）处使用try…catch…代码块进行捕获处理。</p>
<h3 id="throw关键字"><a href="#throw关键字" class="headerlink" title="throw关键字"></a>throw关键字</h3><p>throw用于方法体内，并且抛出的是一个异常类对象。</p>
<p>通过throw关键字抛出异常后，还需要try…catch…或throws关键字对异常进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void deposit(double amount) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">  if(判断)&#123;</span><br><span class="line">      throw new Exception(&quot;异常&quot;); //可以用来指示异常信息</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throw抛出异常对象，然后通过throws关键字抛出异常，最后通过try…catch…语句捕获异常。</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>java允许用户自定义异常，但自定义的异常类必须继承自Exception或其子类。在构造方法中使用super()语句调用Exception的构造方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 	<span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>();  <span class="comment">//调用无参构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(message);  <span class="comment">//调用有参构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>java提供垃圾回收机制（Java GC），虚拟机会自动回收垃圾对象所占用的内存空间。</p>
<p>当一个对象在堆内存中运行时，根据它被引用变量所引用的状态，可以把它所处的状态分为三种：</p>
<p>（1）可用状态：对象被创建后，有一个以上的引用变量引用它，那么这个对象在程序中将处于可用状态，程序可以通过引用变量来调用该对象的实例变量和方法。</p>
<p>（2）可恢复状态：程序中某个对象不再有任何引用变量引用它，它就进入了可恢复状态。系统准备回收，回收之前会调用可恢复状态对象的<code>finalize()</code>方法进行资源清理。如果在调用<code>finalize()</code>方法之前重新使一个引用变量引用该对象，则这个对象会再次变为可用对象。</p>
<p>（3）不可用状态：调用<code>finalize()</code>方法后，对象进入不可用状态，内存被清理。</p>
<blockquote>
<p>一个对象在失去引用成为垃圾后，会暂时保存在内存中，垃圾堆积到一定程度时，java虚拟机会启动垃圾回收器将这些垃圾对象从内存中释放，也就说回收的时机无法把握。</p>
</blockquote>
<p>强制系统进行垃圾回收的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.gc();</span><br><span class="line">或：</span><br><span class="line">Runtime.getRuntime().gc();</span><br></pre></td></tr></table></figure>

<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><p>当一个对象在内存中被释放时，它的<code>finalize()</code>方法会自动调用，<code>finalize()</code>方法是定义在Object类中的实例方法，方法原型：</p>
<p><code>protected void finalize() throws Throwable&#123;&#125;</code></p>
<p>任何java类都可以重写Object类的<code>finalize()</code>方法，在该方法中清理对象占用的资源。重写实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">	public void finalize()&#123;</span><br><span class="line">		System.out.println(&quot;d&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/myblog/spring/Spring%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/myblog/spring/Spring%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/" class="post-title-link" itemprop="url">spring入门案例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-25 18:43:01" itemprop="dateCreated datePublished" datetime="2021-08-25T18:43:01+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-10 21:40:51" itemprop="dateModified" datetime="2022-05-10T21:40:51+08:00">2022-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring入门案例"><a href="#Spring入门案例" class="headerlink" title="Spring入门案例"></a>Spring入门案例</h1><h2 id="0-java基础"><a href="#0-java基础" class="headerlink" title="0.java基础"></a>0.java基础</h2><h3 id="a-java版本"><a href="#a-java版本" class="headerlink" title="a.java版本"></a>a.java版本</h3><p>Java是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。</p>
<p>Java编程语言的风格十分接近C++语言。继承了C++语言面向对象技术的核心，舍弃了容易引起错误的指针，以引用取代；移除了C++中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。在Java SE 1.5版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装&#x2F;拆箱特性。</p>
<blockquote>
<p>Java的三个版本 : JAVASE(标准版),JAVAEE(企业版),JAVAME(微型版).</p>
<p>java是一个平台。他包括了，java语言，java开发环境(jdk)。java有三个版本<br>j2se(标准版),j2ee(企业版),j2me(微型版)<br>不管哪个版本，都是java语言实现的一个框架。之所以要分版本，是因为3个版本是针对不同问题，设计的解决方案。<br>j2EE是java的企业级开发版本，其实换句话说就是用来做web开发的java框架。javaEE通过设定统一的标准来解决web开发的问题，javaEE的接口，抽象类，规定了web开发所需要实现的流程。整个web的开发，有2层，第1层是服务器容器，比如tomcat，weblogic。他们在javaEE的规范下，实现套接字的连接，封装消息等等，第2层是业务，而这一层是你要做的，通过tomcat封装的消息，进行相应的业务处理。服务器容器的开发由大型的产商开发，而我们通常做的开发是在服务器容器上的业务开发，正是sun的javaEE统一了规范(比如用servlet)我们的业务代码，能和comcat进行很好的通讯。</p>
</blockquote>
<p>J2SE是标准版本，J2ME是手机方向的，J2EE是网站开发方向的。</p>
<blockquote>
<p>从JDK 5.0开始 J2EE 改名为 java EE，J2SE 改名为 java SE，J2ME 改名成 java ME.java EE 是java的企业版，主要面向web应用，尤其是企业级开发</p>
</blockquote>
<h3 id="b-jdk版本"><a href="#b-jdk版本" class="headerlink" title="b.jdk版本"></a>b.jdk版本</h3><p>Java Development Kit（JDK）是太阳微系统针对Java开发人员发布的免费软件开发工具包（SDK，Software development kit）。自从Java推出以来，JDK已经成为使用最广泛的Java SDK。</p>
<p>作为Java语言的SDK，普通用户并不需要安装JDK来运行Java程序，而只需要安装JRE（Java Runtime Environment）。而程序开发者必须安装JDK来编译、调试程序。</p>
<p>JDK是个Java开发的工具包，Java是门编程语言。</p>
<p>JDK8或者JDK1.8是由于自从JDK1.5&#x2F;JDK5命名方式改变后遗留的新旧命令方式问题。所以JDK8或者JDK1.8也是同一个东西。</p>
<blockquote>
<p>JDK1.4 正则表达式，异常链，NIO，日志类，XML解析器，XLST转换器<br>JDK1.5 自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环<br>JDK1.6 提供动态语言支持、提供编译API和卫星HTTP服务器API，改进JVM的锁，同步垃圾回收，类加载<br>JDK1.7 提供GI收集器、加强对非Java语言的调用支持（JSR-292,升级类加载架构<br>JDK8 Lambda 表达式、方法引用、默认方法、新工具、Stream API、Date Time API 、Optional 类、Nashorn, JavaScript 引擎<br>JDK9 1、集合加强；2、私有接口方法；3、垃圾收集机制；4、I&#x2F;O流加强；5、JShell工具<br>JDK10 1、局部变量类型推断；2、线程本地握手；3、GC改进和内存管理；<br>JDK11 1、字符串加强；2、HttClient Api；3、用于 Lambda 参数的局部变量语法；4、ZGC<br>JDK12 1、Switch Expressions；2、Shenandoah GC；<br>JDK13 1、switch优化更新；2、文本块升级；3、重新实现旧版套接字API；4、核心库&#x2F;java.util中：I18N；5、取消使用未使用的内存<br>JDK14 1、switch优化变更为最终版；2、垃圾回收相关；3、instanceof的模式匹配（预览版）；4、删除了安全库java.security.acl API；5、货币格式（优化）<br>JDK15</p>
</blockquote>
<h2 id="1-Spring简介"><a href="#1-Spring简介" class="headerlink" title="1.Spring简介"></a>1.Spring简介</h2><p>Spring是一个开源框架，Spring是2003年兴起的轻量级java开发框架，它是为了解决企业级开发的复杂性而创建的。Spring的用途不仅限于服务器端的开发，从简单性、可测试性、低耦合的角度而言任何java应用都可以在spring中受益。</p>
<p>简单的来说Spring就是轻量级的控制反转（IOC）和面向切面（AOP）的容器框架。</p>
<blockquote>
<p>javaBean：<br>符合一定规范编写的Java类，不是一种技术，而是一种规范。针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其他的程序员或者框架使用。这些约定包括：getXXX，setXXX，isXXX，addXXX。</p>
</blockquote>
<h3 id="Spring解决什么："><a href="#Spring解决什么：" class="headerlink" title="Spring解决什么："></a>Spring解决什么：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当客户端向服务器发出请求时，服务器把得到的请求发送给控制器Servlet，而在Servlet中需要创建Service对象来调用业务层相关功能(故说控制器层Servlet依赖于业务层Service),而在Service中又需要创建数据库层DAO对象来对数据库进行操作(故说业务层Service依赖于数据库层DAO)。</span><br><span class="line"></span><br><span class="line">针对上述问题，需要考虑：1.Servlet、Service以及Dao对象的创建时间、创建数量。2.Servlet、Service以及Dao之间的依赖关系。</span><br><span class="line"></span><br><span class="line">spring：</span><br><span class="line">用来处理对象的创建、以及对象之间依赖关系的一个开发框架。它打破了我们传统开发的观念，我们不再需要像以前那样在具体的类中创建具体的对象，而是将对象的创建交给它去完成。</span><br></pre></td></tr></table></figure>

<p>非侵入式设计：引入了框架，对现有的类结构没有影响。</p>
<h3 id="IOC控制反转"><a href="#IOC控制反转" class="headerlink" title="IOC控制反转"></a>IOC控制反转</h3><p>Inversion On Control，简称IOC。对象的创建交给外部容器自动完成，这个就叫做控制反转。(有控制反转就有控制正转，控制正转:对象的创建由我们自己创建)</p>
<p>依赖注入dependency injection,简称DI，用于处理对象间的依赖关系。</p>
<p><strong>二者区别:</strong><br>控制反转(IOC):解决对象创建的问题，(对象的创建交给别人)。<br>依赖注入(DI):在创建完对象后，对象关系的处理就是依赖注入，(通过set方法依赖注入。)</p>
<h3 id="AOP面向切面"><a href="#AOP面向切面" class="headerlink" title="AOP面向切面"></a>AOP面向切面</h3><p>面向切面编程。切面，简单来说可以理解为一个类，由很多重复代码形成的类。切面举例:事务、日志、权限。</p>
<h2 id="2-Mac下spring配置"><a href="#2-Mac下spring配置" class="headerlink" title="2.Mac下spring配置"></a>2.Mac下spring配置</h2><p>配置Spring不管在哪个环境下都是大同小异，下载Spring-framework，解压缩，然后导入使用的项目即可。</p>
<p>spring3.x与jdk1.7兼容，spring4.x与jdk1.8才兼容，IDEA默认下的JDK使用1.8版本。</p>
<blockquote>
<p>直接通过IDEA创建项目选择spring模版<br>发现：没有spring模板，打开设置-&gt;plugins-&gt;搜索spring assistant-&gt;安装后重启</p>
<p>依然没有，没法了</p>
</blockquote>
<p>![image-20210825183129555](&#x2F;Users&#x2F;liuxuan14&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210825183129555.png)</p>
<h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><p>Spring Boot 是 Pivotal 团队在 Spring 的基础上提供的一套全新的开源框架，其目的是为了简化 Spring 应用的搭建和开发过程。Spring Boot 去除了大量的 XML 配置文件，简化了复杂的依赖管理。</p>
<p>Spring Boot 具有 Spring 一切优秀特性，Spring 能做的事，Spring Boot 都可以做，而且使用更加简单，功能更加丰富，性能更加稳定而健壮。随着近些年来微服务技术的流行，Spring Boot 也成了时下炙手可热的技术。</p>
<h2 id="新建spring工程"><a href="#新建spring工程" class="headerlink" title="新建spring工程"></a>新建spring工程</h2><p>idea新建maven工程，选择模版maven-archetype-quikstart，依赖：spring-core、spring-beans、spring-context。</p>
<p>archetype的意思就是模板原型的意思，原型是一个Maven项目模板工具包。</p>
<p>maven-archetype-quickstart：在这个项目里，除了pom.xml外，没有其他的xml了，但是有main、test两个包，包里放了一个App、AppTest类。</p>
<p>maven-archetype-webapp：在这个项目里，有WEB-INF目录，并且有web.xml和一个index.jsp。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/myblog/java/MAC%E4%B8%8B%E5%AE%89%E8%A3%85java%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/myblog/java/MAC%E4%B8%8B%E5%AE%89%E8%A3%85java%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">mac安装和配置java环境</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-25 16:47:53" itemprop="dateCreated datePublished" datetime="2021-08-25T16:47:53+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-25 22:03:14" itemprop="dateModified" datetime="2021-09-25T22:03:14+08:00">2021-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MAC下java环境安装"><a href="#MAC下java环境安装" class="headerlink" title="MAC下java环境安装"></a>MAC下java环境安装</h1><h2 id="1-下载jdk8并且安装"><a href="#1-下载jdk8并且安装" class="headerlink" title="1.下载jdk8并且安装"></a>1.下载jdk8并且安装</h2><p><code>java -version</code>看一下有没有安装</p>
<p>若没有，<a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<h2 id="2-配置java环境"><a href="#2-配置java环境" class="headerlink" title="2.配置java环境"></a>2.配置java环境</h2><p>我们如果要在terminal终端上使JAVA命令，还有让其实应用知道JDK1.8环境的存在，那我们还需要配置系统的环境变量。</p>
<p>访达中，打开资源库，打开java，下面有jdk目录。</p>
<p><code>/Library/Java/JavaVirtualMachines/jdk1.8.0_192.jdk/Contents/Home</code>  右键打开终端</p>
<p>终端运行：<code>sudo vim/etc/profile</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_192.jdk/Contents/Home&quot;</span><br><span class="line">export JAVA_HOME</span><br><span class="line">CLASS_PATH=&quot;$JAVA_HOME/lib&quot;</span><br><span class="line">PATH=&quot;.$PATH:$JAVA_HOME/bin&quot;</span><br></pre></td></tr></table></figure>

<p><code>source /etc/profile  //使配置生效</code></p>
<p><code>echo $JAVA_HOME //得到配置的路径，说明配置成功</code></p>
<h2 id="3-vim一个java程序"><a href="#3-vim一个java程序" class="headerlink" title="3.vim一个java程序"></a>3.vim一个java程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">文件名需要跟java文件中的类名一致！</span><br><span class="line">public class helloworld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">javac helloworld.java   //生成.class字节码文件</span><br><span class="line">java helloworld    //运行</span><br></pre></td></tr></table></figure>

<h3 id="4-java-IDE"><a href="#4-java-IDE" class="headerlink" title="4.java IDE"></a>4.java IDE</h3><p>官网下载：<a target="_blank" rel="noopener" href="https://www.jetbrains.com/">https://www.jetbrains.com/</a></p>
<p>下载破解包，保存在百度云中了。</p>
<p>安装IDEA，在注册页面，选择 Evaluate for free，点击 Evaluate 试用软件</p>
<p>将下载的破解文件夹中的 jetbrains-agent.jar 文件拖动到软件内，然后点击 Restart 重启软件</p>
<p>重启完成之后，如果弹出了激活方式，选择 Activation code，没有弹出则不用管，复制破解文件中的 Activation code，然后选择激活，重启软件</p>
<p>重启软件，在 Get Help 中点击 About ，可以查看激活情况</p>
<p><strong>不得行</strong></p>
<p>更新：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bbc7cd207a85">https://www.jianshu.com/p/bbc7cd207a85</a></p>
<h3 id="5-用idea的第一个java程序"><a href="#5-用idea的第一个java程序" class="headerlink" title="5.用idea的第一个java程序"></a>5.用idea的第一个java程序</h3><p>![image-20210823173916506](&#x2F;Users&#x2F;liuxuan14&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210823173916506.png)</p>
<p>右键运行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/myblog/java/MAC%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEMaven/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/myblog/java/MAC%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEMaven/" class="post-title-link" itemprop="url">mac安装和配置maven</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-25 12:18:11" itemprop="dateCreated datePublished" datetime="2021-08-25T12:18:11+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-25 22:02:48" itemprop="dateModified" datetime="2021-09-25T22:02:48+08:00">2021-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MAC安装和配置Maven"><a href="#MAC安装和配置Maven" class="headerlink" title="MAC安装和配置Maven"></a>MAC安装和配置Maven</h1><h2 id="1-Maven简介"><a href="#1-Maven简介" class="headerlink" title="1.Maven简介"></a>1.Maven简介</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">背景：开发A项目，A项目中的一些功能依赖于B项目中的某些类，那么如何维系这种依赖关系？需要用哪个项目中的哪些类，也就是用别人写好了的功能代码，导入jar包即可。所以这里也如此，可以将B项目打成jar包，然后在A项目的Library下导入B的jar文件，这样，A项目就可以调用B项目中的某些类了。如果在开发过程中，发现B中的bug，则必须将B项目修改好，并重新将B打包并对A项目进行重编译操作</span><br></pre></td></tr></table></figure>

<p>Maven是基于项目对象模型(POM project object model)，可以通过一小段描述信息（配置）来管理项目的构建，报告和文档的软件项目管理工具。</p>
<p>Maven的核心功能便是合理叙述项目间的依赖关系，通俗点讲，就是通过pom.xml文件的配置获取jar包，而不用手动去添加jar包。</p>
<p>由于Maven仓库中所有的JAR都有其自己的坐标，该坐标告诉Maven它的组ID，构件ID，版本，打包方式等等， 因此Maven项目可以方便的进行依赖版本管理。</p>
<h2 id="2-安装和配置Maven"><a href="#2-安装和配置Maven" class="headerlink" title="2.安装和配置Maven"></a>2.安装和配置Maven</h2><p>下载地址： <a target="_blank" rel="noopener" href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p>
<p>![image-20210824144100726](&#x2F;Users&#x2F;liuxuan14&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210824144100726.png)</p>
<p>我下载在了<code>/Library/ApacheMaven</code></p>
<p><code>vim ~/.bash_profile</code>  &#x2F;&#x2F;配置环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export M=&quot;/Library/ApacheMaven&quot;  //根据自己放在哪个目录</span><br><span class="line">export PATH=&quot;$M/bin:$PATH&quot;</span><br></pre></td></tr></table></figure>

<p><code>source ~/.bash_profile</code>     &#x2F;&#x2F;使配置生效</p>
<p><code>mvn -v</code>   &#x2F;&#x2F;查看版本</p>
<p>或者，可以直接<code>brew install maven</code></p>
<h3 id="下载远程仓库到本地"><a href="#下载远程仓库到本地" class="headerlink" title="下载远程仓库到本地"></a>下载远程仓库到本地</h3><p>maven 就像是一个大仓库，里面是很多的jar包，我们需要的时候就去里面拿，所以这就涉及到一个 ‘‘本地仓库’’（不能需要什么再去网上下载吧，速度有时候很慢的）,那么咱们就得先把这些jar包下载到咱们本地方便使用，<br>默认请况下，这个本地仓库会在&#x2F;user&#x2F;name&#x2F;.m2下面（name 是你的用户名）。为了方便，把本地仓库改在Maven安装目录下。</p>
<p>打开安装目录下的conf目录下的<code>settings.xml</code><br>加入<code>&lt;localRepository&gt;/Library/ApacheMaven/repository &lt;/localRepository&gt;</code></p>
<p>输入<code>mvn help:system</code></p>
<p>![image-20210824175620786](&#x2F;Users&#x2F;liuxuan14&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210824175620786.png)</p>
<p>多了一个repository文件夹，这就是咱们从远程仓库下载到本地仓库的文件。</p>
<h2 id="3-创建Maven项目"><a href="#3-创建Maven项目" class="headerlink" title="3.创建Maven项目"></a>3.创建Maven项目</h2><h3 id="a-使用命令行创建Maven项目"><a href="#a-使用命令行创建Maven项目" class="headerlink" title="a.使用命令行创建Maven项目"></a>a.使用命令行创建Maven项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=cn.xuanliu.helloword -DartifactId=helloworld -Dpackage=cn.cxuanliu.helloword -Dversion=1.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-quickstart</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mvn</code>:表示使用的是maven命令。</li>
<li><code>archetype:generate</code>:表示使用generate这个插件为我们的maven项目自动生成一个maven骨架，即我们项目的工程结构。后边跟的是该插件为我们创建工程结构所需要的一连串的参数。</li>
<li><code>-DgroupId</code>:标识项目的坐标元素之一，项目包名，可以是：域名的反写+项目名。</li>
<li><code>-DartifactId</code>:标识项目的坐标元素之一，它的值为我们的项目名。我这里指定我要生成的项目名为helloword。</li>
<li><code>-Dpackage</code>:标识项目的坐标元素之一,这里值就跟DgroupId的值保持一致即可。此属性在命令行中可选。</li>
<li><code>-Dversion</code>:指定版本号。此属性在命令行中可选</li>
<li><code>-DarchetypeArtifactId</code>:表示我们生成的工程结构为哪一种，这里的属性值为<code>maven-archetype-quickstart</code>表示生成工程目录结构为quickstart的结构。其值还可以为<code>maven-archetype-webapp</code>表示生成的工程目录结构为webapp的结构。</li>
</ul>
<p>![image-20210824155803431](&#x2F;Users&#x2F;liuxuan14&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210824155803431.png)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目录解读：在maven项目的开发中，所有的源代码放在文件夹 /src/main/java/下, 所有的单元测试代码放入 /src/test/java/。</span><br><span class="line">pom.xml 描述了整个项目的信息</span><br></pre></td></tr></table></figure>

<h3 id="b-使用IDEA创建Maven项目"><a href="#b-使用IDEA创建Maven项目" class="headerlink" title="b.使用IDEA创建Maven项目"></a>b.使用IDEA创建Maven项目</h3><p><code>Create New Project</code>，选择<code>Maven</code>，勾选<code>Create from archetype</code></p>
<p><img src="https://img2018.cnblogs.com/blog/1068501/201809/1068501-20180914191722384-1695467171.png" alt="img"></p>
<p>写<code>Maven</code>的坐标，“groupId”，“artifactId”，以及“version”，其中groupId是公司域名的反写，而artifactId是项目名或模块名，version就是该项目或模块所对应的版本号。</p>
<p>![image-20210824174243856](&#x2F;Users&#x2F;liuxuan14&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210824174243856.png)</p>
<p>![image-20210824180029943](&#x2F;Users&#x2F;liuxuan14&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210824180029943.png)</p>
<p>maven会自动下载maven依赖，当所有的都自动完成后，创建的maven项目结构如下所示： </p>
<p>![image-20210824180441439](&#x2F;Users&#x2F;liuxuan14&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210824180441439.png)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）在大多数情况下，把项目的主代码放到 src/main/java 目录下（遵循Maven约定），如果没有其他的配置，Maven在运行时将自动搜寻该目录下的主代码。</span><br><span class="line">（2）为了使项目的结构保持清晰，所以IDEA自动创建了 test 文件，将主代码和测试代码分别放到了独立的目录中。</span><br><span class="line">（3）pom.xml为Maven的核心配置文件，它的全称为（Project Object Model，项目对象模型），我们在使用Maven的时候也通常在这个pom .xml 中配置。</span><br></pre></td></tr></table></figure>

<h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml:"></a>pom.xml:</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>    <span class="comment">&lt;!-- xml头，指定xml文档的版本信息和编码方式 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;project&gt;为所有pom.xml的根元素，声明了一些POM相关的命名空间及xsd元素，</span></span><br><span class="line"><span class="comment">  这些元素不是pom.xml中必须添加的，但是使用这些属性可以使第三方工具，</span></span><br><span class="line"><span class="comment">  如IDE中的xml编辑器帮助开发者快速编辑POM。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;modeVersion&gt; 指定了当前POM模板的版本 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.liuxuan<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="comment">&lt;!-- &lt;groupId&gt; 定义了该项目属于哪个项目组 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ideamaven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   <span class="comment">&lt;!-- &lt;&lt;artifactId&gt;定义了当前Maven项目在项目组的唯一一个ID,项目名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="comment">&lt;!--&lt;version&gt;定义了Hello Maven项目当前的版本号 1.0-SNAPSHOT 为IDEA默认的初始版本号 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>在没有实际的java代码时，我们就可以完整的创建一个Maven项目的pom.xml，这说明了Maven可以使项目对象模型最大程度的与代码相独立，这充分体现了解耦的原则和理念！为开发者节省了时间，大大缩短了项目开发周期。在项目开发到稳定期时，升级版本时，开发者可以不需要修改实际的 java 代码，而是只修改pom.xml，这一特点使Maven被广泛的使用。</p>
<h2 id="4-编写主代码"><a href="#4-编写主代码" class="headerlink" title="4.编写主代码"></a>4.编写主代码</h2><p><strong>项目主代码和测试代码不同，主代码会被打包到最终的构件中，而测试代码只在运行测试时用到，不会被打包。</strong></p>
<p><strong>在src&#x2F;main&#x2F;java中创建文件com&#x2F;feiyu&#x2F;web&#x2F;helloworld&#x2F;helloWorld.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello liuxuan&#x27;s Maven!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">hello</span>().sayHello());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>右键运行。</p>
<p>目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---pom.xml　　　　核心配置，项目根下</span><br><span class="line">---src</span><br><span class="line">　　---main　　　　　　</span><br><span class="line">　　　   ---java　　　　java源码目录</span><br><span class="line">　　     ---resources　  java配置文件目录</span><br><span class="line">　　---test</span><br><span class="line">　　　　　---java　　　　测试源码目录</span><br><span class="line">　　　　　---resources　  测试配置目录</span><br><span class="line">---target    输出目录</span><br></pre></td></tr></table></figure>

<h2 id="5-Maven仓库"><a href="#5-Maven仓库" class="headerlink" title="5.Maven仓库"></a>5.Maven仓库</h2><p>Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。</p>
<p>Maven 仓库有三种类型：</p>
<ul>
<li>本地（local）</li>
<li>中央（central）</li>
<li>远程（remote）</li>
</ul>
<h3 id="a-本地仓库"><a href="#a-本地仓库" class="headerlink" title="a.本地仓库"></a>a.本地仓库</h3><p>第一次执行 maven 命令的时候才被创建。运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。</p>
<p>默认情况下，不管Linux还是 Windows，每个用户在自己的用户目录下都有一个路径名为 .m2&#x2F;respository&#x2F; 的仓库目录。</p>
<p>可以修改默认位置，改变settings.xml中的配置。<br><code>&lt;localRepository&gt;C:/MyLocalRepository&lt;/localRepository&gt;</code></p>
<h3 id="b-中央仓库"><a href="#b-中央仓库" class="headerlink" title="b.中央仓库"></a>b.中央仓库</h3><p>Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。</p>
<p>中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。</p>
<p>中央仓库的关键概念：</p>
<ul>
<li>这个仓库由 Maven 社区管理。</li>
<li>不需要配置。</li>
<li>需要通过网络才能访问。</li>
</ul>
<p>要浏览中央仓库的内容，maven 社区提供了一个 URL：<a target="_blank" rel="noopener" href="http://search.maven.org/#browse%E3%80%82%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E4%BB%93%E5%BA%93%EF%BC%8C%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%8F%AF%E4%BB%A5%E6%90%9C%E7%B4%A2%E6%89%80%E6%9C%89%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96%E7%9A%84%E4%BB%A3%E7%A0%81%E5%BA%93%E3%80%82">http://search.maven.org/#browse。使用这个仓库，开发人员可以搜索所有可以获取的代码库。</a></p>
<h3 id="c-远程仓库"><a href="#c-远程仓库" class="headerlink" title="c.远程仓库"></a>c.远程仓库</h3><p>中央仓库是一些常用的库？远程仓库是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</p>
<h3 id="d-Maven依赖搜索顺序"><a href="#d-Maven依赖搜索顺序" class="headerlink" title="d.Maven依赖搜索顺序"></a>d.Maven依赖搜索顺序</h3><ul>
<li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li>
<li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。</li>
<li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li>
<li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li>
</ul>
<h3 id="e-更换Maven阿里云仓库"><a href="#e-更换Maven阿里云仓库" class="headerlink" title="e.更换Maven阿里云仓库"></a>e.更换Maven阿里云仓库</h3><p>Maven根目录下，conf文件夹下setting.xml文件，mirrors节点上修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirrors&gt;</span><br><span class="line">  &lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">  &lt;/mirror&gt;</span><br><span class="line">&lt;/mirrors&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：pom.xml文件里添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories&gt;  </span><br><span class="line">        &lt;repository&gt;  </span><br><span class="line">            &lt;id&gt;alimaven&lt;/id&gt;  </span><br><span class="line">            &lt;name&gt;aliyun maven&lt;/name&gt;  </span><br><span class="line">            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;  </span><br><span class="line">            &lt;releases&gt;  </span><br><span class="line">                &lt;enabled&gt;true&lt;/enabled&gt;  </span><br><span class="line">            &lt;/releases&gt;  </span><br><span class="line">            &lt;snapshots&gt;  </span><br><span class="line">                &lt;enabled&gt;false&lt;/enabled&gt;  </span><br><span class="line">            &lt;/snapshots&gt;  </span><br><span class="line">        &lt;/repository&gt;  </span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure>

<h2 id="6-Maven命令"><a href="#6-Maven命令" class="headerlink" title="6.Maven命令"></a>6.Maven命令</h2><p><code>maven -version   Maven版本及控制信息</code></p>
<p><code>mvn archetype:create  -DgroupId=   DartifactId=   构建java项目</code>   </p>
<p><code>mvn archetype:create  -DgroupId=   DartifactId=   -DarchetypeArtifactId=maven-archetype-webapp ls创建web项目</code></p>
<p><code>mvn compile     编译源代码</code>     </p>
<p><code>mvn test-compile    编译测试代码</code></p>
<p><code>mvn clean   打包前清理掉之前有过打包的文件夹target</code></p>
<p><code>mvn package  打包，package包括了编译、打包这两步</code>    </p>
<p>![image-20210825113016694](&#x2F;Users&#x2F;liuxuan14&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210825113016694.png)</p>
<p><code>mvn install   将打包好的jar包部署到本地，放到本地仓库</code> </p>
<h2 id="7-运行jar包"><a href="#7-运行jar包" class="headerlink" title="7.运行jar包"></a>7.运行jar包</h2><p><code>java -jar ideamaven-1.0-SNAPSHOT.jar</code></p>
<p>问题：<code>ideamaven-1.0-SNAPSHOT.jar中没有主清单属性</code></p>
<p>解决：找不到<code>main</code>方法，需要在<code>pom.xml</code>配置<code>main</code>方法的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  添加main方法   --&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.2.1&lt;/version&gt;</span><br><span class="line">  &lt;executions&gt;</span><br><span class="line">    &lt;execution&gt;</span><br><span class="line">      &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">      &lt;goals&gt;</span><br><span class="line">        &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">      &lt;/goals&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;transformers&gt;</span><br><span class="line">          &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;</span><br><span class="line">            &lt;!-- 在这里指定入口类 --&gt;</span><br><span class="line">            &lt;mainClass&gt;com.liuxuan.hello&lt;/mainClass&gt;</span><br><span class="line">          &lt;/transformer&gt;</span><br><span class="line">        &lt;/transformers&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/execution&gt;</span><br><span class="line">  &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

<p>mvn打包和jar包运行问题未解决。</p>
<p>问题：<code>Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.8.0:compile (default-compile) on project ideamaven: Compilation failure</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://console.cloud.baidu-int.com/devops/icode/repos/baidu/netdisk/platform-idproducter/reviews/18480257/files/base...latest/service/create_service.go">https://console.cloud.baidu-int.com/devops/icode/repos/baidu/netdisk/platform-idproducter/reviews/18480257/files/base...latest/service/create_service.go</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wfy2695766757/article/details/81189291">https://blog.csdn.net/wfy2695766757/article/details/81189291</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sweetwater"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">Sweetwater</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sweetwater</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
