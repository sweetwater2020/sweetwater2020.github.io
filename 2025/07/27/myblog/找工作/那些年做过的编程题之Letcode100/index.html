<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1题目 通用：数组初始化后填充某个数：Arrays.fill(arr, 0);    数组排序：Arrays.sort(names, Collections.reverseOrder());  数组装箱：Integer[] boxedNums &#x3D; Arrays.stream(nums).boxed().toArray(Integer[]::new);  反转数组：需要先变为List，List li">
<meta property="og:type" content="article">
<meta property="og:title" content="那些年做过的编程题之Letcode100">
<meta property="og:url" content="http://example.com/2025/07/27/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%81%9A%E8%BF%87%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B9%8BLetcode100/index.html">
<meta property="og:site_name" content="Sweetwater&#39;s blog">
<meta property="og:description" content="1题目 通用：数组初始化后填充某个数：Arrays.fill(arr, 0);    数组排序：Arrays.sort(names, Collections.reverseOrder());  数组装箱：Integer[] boxedNums &#x3D; Arrays.stream(nums).boxed().toArray(Integer[]::new);  反转数组：需要先变为List，List li">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-07-27T09:07:02.540Z">
<meta property="article:modified_time" content="2025-07-30T14:34:30.211Z">
<meta property="article:author" content="Sweetwater">
<meta property="article:tag" content="八股">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2025/07/27/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%81%9A%E8%BF%87%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B9%8BLetcode100/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>那些年做过的编程题之Letcode100 | Sweetwater's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sweetwater's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/27/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%81%9A%E8%BF%87%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B9%8BLetcode100/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          那些年做过的编程题之Letcode100
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-27 17:07:02" itemprop="dateCreated datePublished" datetime="2025-07-27T17:07:02+08:00">2025-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-30 22:34:30" itemprop="dateModified" datetime="2025-07-30T22:34:30+08:00">2025-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目 通用：数组初始化后填充某个数：Arrays.fill(arr, 0);    数组排序：Arrays.sort(names, Collections.reverseOrder());  数组装箱：Integer[] boxedNums = Arrays.stream(nums).boxed().toArray(Integer[]::new);  反转数组：需要先变为List，List list = Arrays.asList(arr);   Collections.reverse(list);    arr = list.toArray(new Integer[0]); (变为Integer[]) 或者 resList.stream().mapToInt(Integer::intValue).toArray();  (变为int[]) 小顶堆：PriorityQueue minHeap = new PriorityQueue&lt;&gt;();   PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; minHeap =          new PriorityQueue&lt;&gt;(Comparator.comparingInt(Map.Entry::getValue)); 大顶堆：PriorityQueue maxHeap = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());    heap.offer插入 poll删除元素 堆顶元素peek。 s.substring(startIndex, endIndex) 左闭右开 int sum = Arrays.stream(nums).sum(); 求和 回文链表：先把元素遍历出来到数组list，然后前后双指针进行对比。还可以使用递归，使用递归反向迭代节点，同时使用递归函数外的变量向前迭代。 环形链表：方法一：使用HashSet记录走过的节点，如果之前走过，则环形链表。方法二：快慢指针，有换一定会遇到，遇到后，一个指针从起始节点出发，一个指针从相遇节点出发，相同速度移动，撞见就是环形相交节点。 合并两个有序链表：双指针，while条件里可以是两个其中之一不为null，也可以是两个都不为null，然后next直接指向剩余的那个ListNode。注意ListNode a = new Listnode(1);  然后ListNode b = a; a/b再变，另一个是不跟着变得，因为不是ab指向的对象发生了变化，而是b指向了别的东西。 两数相加：while循环中求当前数和进位数，最后判断进位是否为0，也就是是否要加一个数。 删除链表的倒数第N个结点：双指针，得模拟一下，快指针移动几步（n步），然后慢指针停止的条件是什么（fast!=null）。考虑只有一个结点的情况，得用preHead。 两两交换链表中的节点（不能改节点的值）：跟链表翻转类似，遍历过程中模拟翻转的过程，需要定义哪些临时节点进行记录。注意要用preHead。链表翻转就不用preHead。 k个一组翻转链表：是翻转链表的复杂版本，不光要翻转，翻转之后连接分段，所以要在遍历过程中记录头节点和尾节点。首先判断分段是否够，顺便遍历到tail节点。子函数进行分段翻转，传入preHead和k，遍历用k，提前定义pre和cur，循环中1保存next，2箭头翻转，3移动pre和cur。然后连线，再移动。 排序链表：二分，归并排序（递归）先用快慢指针找到链表中点，分割进行递归，终止条件是只有一个节点。递归排序后进行merge，双指针法进行合并，得用preHead。 合并k个升序链表：优先级队列PriorityQueue，因为数组里的列表都是排好序的，所以先把数组中每个列表的头节点加进去，然后取队列里最小的，然后把取到的节点的next加入优先级队列，直到优先级队列为空了 LinkedHashMap：LinkedHashMap继承自HashMap，在 HashMap 的基础上增加了对元素顺序的维护能力，既可以按照插入顺序排序，也可以按照访问顺序排序。底层实现：HashMap（实现O(1) 时间复杂度的插入、删除和查找操作）+ 双向链表（用于记录键值对的顺序，链表的头节点表示最早插入或最久未访问的元素，尾节点表示最近插入或最近访问的元素。当哈希表需要扩容时，LinkedHashMap 会重新分配桶中的节点，但不会影响双向链表的顺序。扩容时机：当哈希表中的元素数量超过 容量 × 负载因子（默认0.75） 时，触发扩容操作。扩容为原数组容量的两倍。LinkedHashMap默认不移除元素，重写removeEldestEntry方法进行移除来实现LRU。 为什么LRU得是双向链表：涉及到找到节点，然后把节点移动到链表尾部，双向链表实现该操作只需要O1时间复杂度，单向链表无法获取上一个节点，是On复杂度。 实现LRU缓存：存放的是key-value对，自定义双向链表，节点内维护key和value，HashMap是用来快速找到节点的，所以key就是key，value是Node节点。需要自定义双向链表类，get方法中，首先判断在不在map中，如果在则移动节点到尾部。put方法中，首先判断容量是否达到上限，如果达到则移除头部节点（伴随改变size和map），然后添加节点到尾节点（伴随改变size和map）。注意前后都要哨兵节点，并且相连。 层序遍历：用队列来实现。每次访问一层，并把下一层加入到队列中。 栈： Stack 类由于继承自 Vector 导致的性能问题，不推荐使用。Deque（双端队列）接口提供了更灵活和高效的栈实现方法。ArrayDeque 和 LinkedList 是最常用的 Deque 实现类。 Deque stack = new ArrayDeque&lt;&gt;(); stack.pop()、 stack.peek()、 stack.push(num) 队列：使用Queue 队列：Queue queue = new ArrayDeque&lt;&gt;(); queue.offer(num)、queue.poll()、queue.peek() Queue 是一个接口，表示队列（FIFO，先进先出）的数据结构。 单向队列，offer()、poll() 和 peek() Deque 是一个接口，表示双端队列的数据结构。 addFirst()、addLast()、pollFirst()、pollLast()、用作栈，通过 push() 、 pop() 、peek() Deque 继承了 Queue 接口。 ArrayDeque 和 LinkedList 都实现了 Deque 接口，因此它们都可以用作双端队列或普通队列。 ArrayDeque：基于动态数组实现。不支持存储 null 元素。不是线程安全的。 LinkedList：基于双向链表实现。支持存储 null 元素。不是线程安全的。 前/中/后序遍历：方法一：递归法，递归的时候隐式地维护了一个栈。方法二：迭代法，显式地将这个栈模拟出来。前序遍历先把root节点压进去，然后遍历中pop加到res里，再右左节点压进去。后序遍历，先把root节点压进去，然后左右节点，这样是前右左顺序，再Collections.reverse(result)一下。中序遍历先一直压左边的，压到头了，再加到res，再压右节点，注意while里的条件是栈不空或root不为null，pop后，压pop节点的右节点。 广度优先搜索：一种逐层遍历的方式，从根节点开始，先访问当前层的所有节点，然后再访问下一层的所有节点。使用队列Queue来实现。 深度优先搜索：一种沿着树的深度方向尽可能深入访问节点的方式，直到到达叶子节点后再回溯。使用递归或者栈。 二叉树的最大深度：深度优先搜索，递归，终止条件是null节点返回0，不然看左右谁大。也可以用广度优先搜索，类似层序遍历，看有多少层。 翻转二叉树：深度优先搜索，递归，终止条件是null，返回null，然后左右节点递归，然后左右节点互换。 对称二叉树：递归，输入两个节点，一左一右，比较。 二叉树的直径：树中任意两个节点之间最长路径的长度。其实跟左子树深度和右子树深度(节点数)有关。但是需要注意，最大直径不一定需要经过根节点！!因此在递归中需要记录结果。递归返回节点数，边就在节点数基础上 - 1。 将有序数组转换为二叉搜索树：高度平衡的二叉树，不能选择中点之后直接做一支右一支，用递归，左边右边分别再递归。其实就是根据中序遍历恢复二叉树，只不过指定中点。 验证二叉树：使用递归，但是不能单纯地只判断左子树和右子树，递归输入中还得传最大值和最小值，不能只比父节点，父节点的父节点也得比，就传一个max一个min。 二叉搜索树中第k小的元素：中序遍历是顺序数列，先中序遍历再找数。拓展：如果一个数要频繁地找第k小，怎么优化，每个节点记录以该节点为根的节点数，然后再找。 二叉树的右视图：类似层序遍历，但是只记录每层的最后一个数。用队列。 二叉树展开为链表：先序遍历的方式，右指针是next。可以先先序遍历，然后再展开为列表。方法二是同时进行，但是要用迭代方式的前序遍历，用栈把右子树节点记录下来。 从前序与中序遍历序列构造二叉树：递归，前提条件是遍历中没有重复元素。前序遍历第一个节点是根节点，再从中序遍历中拆出左子树的中序遍历和右子树的中序遍历。 在中序遍历中找节点，用一个hash来快速找，通过数来找索引 路径总和：用递归解决，但是要注意从根节点到叶子结点，叶子结点得是left和right都为null的 路径总和2：需要找出从根节点到叶子结点的符合要求的所有路径。注意1:添加结果时需要添加结果的拷贝，因为是引用传递。注意2:需要回溯，就是在返回上一层前list去掉该节点。 路径总和3：不限制从根节点到叶子结点，但是需要从上到下，也就是从父节点到叶子结点。 解法1:暴力法，每个节点都走一遍递归。dfs函数，计算的是以root为开始，不管谁为结束的符合要求的数量，会存在整数溢出的问题，把dfs函数的targetSum参数类型变为long就行了。解法2: 用前缀和，就是用一个Map记录之前路径上从根节点到某节点的和对应的数量，这样只需要用从根节点到当前节点的和来解决问题了。dfs递归过程中记录根节点到目前的总和。dfs表示以当前节点为尾节点。依然要用Long解决溢出问题。 二叉树的最近公共祖先：用递归，递归函数的输出的是最近公共祖先，退出条件是如果当前节点是 p 或 q 或 空，则直接返回当前节点。在左右子树中分别递归查找 p 和 q：如果左子树返回非空结果且右子树返回非空结果，则当前节点就是最近公共祖先。如果只有左子树返回非空结果，则返回左子树的结果。如果只有右子树返回非空结果，则返回右子树的结果。脑子里模拟一下这个过程，一个函数就解决。 二叉树中的最大路径和：用递归，不限制父节点到子节点，所以，当前节点路径=当前节点+左路径+右路径，对比全局最大。注意，递归函数是包含root节点的单边的。 岛屿数量：递归dfs，递归使相邻的置为0。也可以使用并查集，并查集的核心思想是通过树形结构维护集合关系，并通过路径压缩优化查找效率。第一步初始化父节点和深度节点列表，然后合并，合并过程中寻找root节点是否相同，不相同则需要合并，find的过程中递归。深度小的往深度大的合并，提高查找根结点的效率。将rank较小的根节点指向rank较大的根节点，以保持树的平衡。如果两个根节点的rank相同，则可以将其中一个根节点作为另一个根节点的子节点，并将rank增加1。 腐烂的橘子：广度优先搜索，用到队列，将最开始腐烂的橘子加入到队列中，然后一层层往外遍历。注意，while判断里，除了queue不为空，还需要新鲜橘子数量大于0. 课程表：判断图中有没有环。用邻接表来表示图，维护节点状态：未访问、正在访问、已访问，用深度优先搜索，遍历所有节点，递归遍历后序节点（反个方向是不是也行？）。其实就是判断图中有没有环。首先，构建邻接表，放的是节点的后置节点。其次，创建初始状态，0未访问，1访问中，2已访问。然后进行DFS。 List转换为Integer[]：list.toArray(new Integer[list.size()]) List转换为int[]：res.stream().mapToInt(Integer :: intValue).toArray() 课程表输出顺序：注意，应该在递归回溯的时候再往结果里放入，如果遍历的是后序节点，还应该Collections.reverse(list)。 全排列：给的元素无重复，同一个元素不能重复使用。用递归DFS，但是需要记录哪些元素已经使用过了。在回溯的时候需要移除List和移除记录使用元素的Set。拷贝一个list：new ArrayList&lt;&gt;(list)。 子集：给的元素无重复，返回所有子集，不能包含重复的子集。不是看排列了，而是看子集了。使用递归DFS，但是不用记录使用set了，需要记录开始递归位置start。 电话号码的字母组合：递归DFS，带start，初始化map，new HashMap&lt;&gt;()&#123;&#123;put(1,&quot;a&quot;); put...)&#125;&#125;，注意得是两个大括号。遍历字符串中的字符：for(char c : s.toCharArray())。s.substring(start, end)。 组合总和：给的是无重复的数组，返回和为target的组合方案，一个数可以使用多次。用DFS，先给数组排个序，DFS中如果大于target就False，后面就不遍历了。为了避免重复，应该用start来限制开始遍历的数字。注意：1.写入结果传副本。2.先排序，大了就不用往后走了。3.回溯后移除节点。4.传start避免结果重复。 括号生成：给出一个n，返回可能的括号组合。DFS中两种情况：放左括号和放右括号。 单词搜索：深度优先搜索，不能光遍历四周，遍历过的还不能再遍历了，不然一直在dfs。用set维护路径。最开始的想法：从头开始DFS，用Set记录走过的路径防止重复遍历。但是比较字符串需要比较结尾。改进方法：DFS，dfs起点：每个点；dfs需要携带的：匹配上的字符长度；dfs出口：字符不一样/字符长度达到。已经用过的字母不能再用：向下一个递归之前变为其他字符，递归完之后再变回来 分割回文串：给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。 解法：DFS+回溯，要传start记录切割位置，for横向遍历，dfs纵向遍历。把一个字符串分割成若干个回文串，DFS，目标是挨个遍历，遍历到回文串存一个，然后继续向后遍历，出递归的条件是遍历到了末尾。要用start记录遍历到了哪里，注意单个字符也算回文。 N皇后：输入n，求得所有可能的排布。使用回溯，用什么表示：用一个数组，数组表示index行的皇后放在value列。什么时候记录：所有行都完备了添加。需要有检查排布是否可以的方法。用StringBuilder，s.setCharAt(track[i], &#x27;Q&#x27;); 二分查找：mid = l + (r - l) /2; 要注意while里的条件是l&lt;=r。l要更新为mid-1。r要更新为r+1。 搜索二维矩阵：先用一遍二分找在哪个行，注意所在行是最后的l-1。再用二分找在哪个列。 在排序数组中查找元素的第一个和最后一个位置：先二分查找找到目标，再前后移动找位置. 寻找旋转排序数组中的最小值：直接遍历虽然能解，但是复杂度要求达不到，要用二分。画张图举个例子好理解，中间节点和两边节点判断可过滤不可能的，注意和传统二分区别：while里条件l&lt;r。 寻找两个正序数组的中位数：限制时间负责度logm+n，所以双指针前后遍历是不行的，得二分。思路：扩展到获取第k大的数，分别获取两个数组k/2的位置，小的左边就能淘汰。第一步：出递归条件：如果一个数组已经被淘汰没了，则直接从另一个获取。第二步：递归：获取每个数组的第k/2位置数做比较，可能越界，所以得判断。注意得是index=s1+k/2-1，然后淘汰index及之前的。先要看k是不是等于1，等于1则可以直接判断。 有效的括号：构件一个map和左括号list，用栈，为空或者为左括号则加入，为右括号则pop出来看是否匹配，最后返回栈是否为空。Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;()&#123;&#123;put(&#x27;)&#x27;, &#x27;(&#x27;);   List left = Arrays.asList(&#x27;(&#x27;, &#x27;&#123;&#x27;, &#x27;[&#x27;);  Deque stack = new ArrayDeque&lt;&gt;();   遍历string：char c : s.toCharArray() 字符串解码：重复次数可能是多位的，开始使用一个栈记录重复次数和字符串，有点乱。使用两个栈分别记录。使用两个栈：一个存重复次数，一个存之前的解码结果。注意3[a2[c]这种，左括号的时候进行压栈，右括号的时候pop栈，这时候需要重复的是currentStr，栈里pop出的是需要在前面的，重复完之后要更新currentStr。判断一个char为数字的两种办法：Character.isDigit()、c - &#x27;0&#x27;&lt;=9。 每日温度：一个数组表示温度，返回数组表示对于i天，下一个更高温度出现在几天后，如果不会升高则0。使用栈，纠结于如何记录结果，其实栈中存放的元素不是温度，而是索引。栈里的元素应该是从大到小的，遍历过程中，元素大于栈顶就pop。注意，栈里放的是索引，不是实际温度。 柱状图中最大的矩形：一个数组表示柱状图的高度，返回能勾勒出矩形的最大面积。思考暴力情况下如何解决：对每一个柱子，向左向右扩展，直到遇到比它矮的，那么以当前柱子高度为高的矩形的宽度就确认出来，这样再全局比较。所以，关键点在于找左边第一个比它小的位置和右边第一个比它小的位置。用单调栈，栈中依然保存索引。每当遇到一个比栈顶元素小的高度时，说明找到了栈顶元素的右边界；弹出栈顶元素，此时它的左边是前一个栈顶元素（即左边界）。注意，获取左边界时stack为空，则left=-1可以。还需要管最后一个元素的结果，所以for循环边界是heights.length，搞个最后的0作为哨兵节点。 数组中的第k个最大元素：使用最小堆，优先级队列。如果堆大小为k，则需要对比堆顶元素和当前元素哪个更大。其实不用，先插入，大于k则弹出堆顶元素即可。 前k个高频元素：先用Map记录频率，然后用小顶堆记录k个Map.Entry，表示键值对项，其他和k个最大元素一样。 买卖股票的最佳时机：贪心，遍历过程中记录历史最低点，同时记录最大收益。 跳跃游戏：判断是否能到达最后一个下标。遍历过程中记录最远能跳到哪里，如果当前索引小于maxReach则直接返回false。 跳跃游戏2：返回最少跳跃数。最少跳跃数，两种方法：一种用动态规划记录最少跳跃数，然后双层遍历外层遍历数组，内层遍历该位置跳跃范围。另一种是贪心，双层循环，外层while从后往前遍历能跳到的位置，内层从前往后找最少跳跃位置。前提是一定能跳到，不然会死循环，所以pos &gt; 0。 划分字母区间：同一个字母最多出现在一个片段中，返回表示每个字符串片段长度的列表。用一个map记录每个字符最后出现的位置，然后遍历字符串进行切分，记录start和end，遍历过程中更新end，如果i==end则表示可以切分。 爬楼梯：每次爬1或2阶，总共有多少种爬台阶的方法。动态规划，dp[n+1]，初始化0和1，然后遍历。 杨辉三角：动态规划，List创建时初始化：List list = Arrays.asList(&quot;apple&quot;)。List获取get(index). 打家劫舍：不能偷窃相邻的房屋，动态规划，dp[i]表示偷到i的最大收益，初始化前两个。 完全平方数：返回和为n的完全平方数的最少数量，可重复使用的。动态规划，一个一维数组初始化比较大的值。双层遍历，外层遍历1-n/2的平方数，内层遍历dp数组。如果大于平方数，则更新。 零钱兑换：给定一个可用零钱面值数组和总金额，返回需要的最少硬币数量，都是可重复使用的，思路和完全平方数一样。注意初始化用Integer.MAX_VALUE-1。 单词拆分：给一个字符串，一个字符串列表，判断能否用列表中的字符串拼接出该字符串，可重复使用。是背包问题。完全平方数是先遍历平方数，再遍历数。这里需要先遍历字符串再遍历物品列表。因为这里对物品顺序是有要求的。dp[i]表示以字符串i-1索引结尾的结果。// 检查以i-1结尾的字符往前倒的字符串，和wordDict[j]是不是一样。 最长递增子序列：子序列是顺序不能变，可以删掉部分元素组成。动态规划dp[i]表示以i结尾的最长递增子序列，双层遍历。 乘积最大子数组：得是连续的最大子数组。用动态规划，两维数组记录i-j的连续乘积，要双层遍历，感觉不是最优。正解：关键点：因为负数的存在，最大和最小可能一下反转。记录阶段最大值和阶段最小值（也就是以上一个数为尾部的最大值最小值）。因为负数存在，当遍历到负数时，最大数和最小数要做交换。遍历过程中记录最大的阶段最大值。 分割等和子集：给一个数组，能否分成两个和相等的子集，不要求连续。是一个背包问题，维护dp[i][j]，i表示考虑0-i的物品，j表示容量为j，dp值表示背包最大能放的重量。初始化i=0的时候，j为多少能放下改物品。不需要提前排序的。遍历时候双层循环，外层物品，内层重量。内层也得从1开始遍历。两种选择：一种不放这个，一种放这个。 最长有效括号：只包含()的字符串，找出最长有效的连续字串长度。用栈保存左括号的索引，初始化时，栈先压入 -1，表示“有效括号子串起点前的位置”。遇到右括号则弹出栈顶，如果弹出后栈空了，说明遇到不能配对的右括号，把当前位置下标入栈（新起点）。否则，当前有效括号长度为i - 栈顶下标，更新最大长度。这里记录不是遇到不有效再记录，而是每次遇到有效时记录。 不同路径：多维动态规划，简单。 最小路径和：依然多维路径规划，初始化左边和上边，直接在原数组上操作。 最长回文子串：多维数组表示i-j的子串是否是回文子串，推演关系决定遍历顺序，ij依赖i+1,j-1，所以从左下角开始遍历。如果ij字符相等，相差&lt;=1，或者dp[i+1][j-1]为true，则为回文，记录结果 最长公共子序列：两位数组表示text1的i-1结尾和text2的j-1结尾的最长公共子序列长度。注意字符不等于的时候，Math.max(dp[i - 1][j], dp[i][j - 1]). 编辑距离：插入、删除、替换。思路：二维动态数组，长度len1+1*len2+1，表示i-1结尾和j-1结尾的。为什么数组长度要+1，因为0的位置需要遍历，初始化不好初始化，只能用-1的初始化，初始化为对应的ij。状态转移：字符相等则等于dp[i-1][j-1]，不想等则删除：dp[i-1][j], dp[i][j-1]，修改：dp[i-1][j-1]，其中取最小然后+1。 只出现一次的数字：遍历，用map可以，但是最好的是用异或运算，^，相同异或为0，与0异或为自己。 多数元素：使用投票机制，记录一个结果数和一个数量，如果数量等于0则换数，否则看当前数是否等于结果数，决定投票+1/-1。 颜色分类：三色国旗问题，双指针，都从0开始遍历，一个指针用来换1，一个指针用来换0，但是换0需要注意，可能把1换出去了，所以换完0之后如果p0&lt;p1就得交换i和p1。 下一个排列：举个例子123654，124653，先要从后往前找到第一个升序的，然后从后往前找到第一个比升序对第一个数大的，然后交换，变成了124653，然后反转i+1到末尾这段。 </span><br></pre></td></tr></table></figure>

<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</span><br><span class="line">你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</span><br><span class="line">你可以按任意顺序返回答案。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, map.get(target - nums[i])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="## 字母异位词分组"></a>## 字母异位词分组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</span><br><span class="line">示例 1:</span><br><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用stream聚合strs</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = Arrays.stream(strs)</span><br><span class="line">                .collect(Collectors.groupingBy(str -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 对数组排序</span></span><br><span class="line">                    <span class="type">char</span>[] array = str.toCharArray();</span><br><span class="line">                    Arrays.sort(array);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">                &#125;));</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</span><br><span class="line">请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] != nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                maxLen = Math.max(maxLen, preLen);</span><br><span class="line">                preLen = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                preLen ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = Math.max(maxLen, preLen);</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</span><br><span class="line"></span><br><span class="line">例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</span><br><span class="line">整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</span><br><span class="line"></span><br><span class="line">例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。</span><br><span class="line">类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。</span><br><span class="line">而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</span><br><span class="line">给你一个整数数组 nums ，找出 nums 的下一个排列。</span><br><span class="line"></span><br><span class="line">必须 原地 修改，只允许使用额外常数空间。</span><br></pre></td></tr></table></figure>

<p><strong>纯找规律，举例：123654，从后往前找到第一个正向升序的，就是36，然后从后往前找第一个比3大的数，就是4，然后交换，交换之后反转i+1到末尾这段。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 举例：123654，纯找规律，从后往前找到第一个正向升序的，就是36，然后从后往前找第一个比3大的数，就是4，然后交换，交换之后反转i+1到末尾这段。</span></span><br><span class="line">        <span class="comment">// 1.找第一个正向升序的</span></span><br><span class="line">        <span class="comment">// 没有找到就不做第二步交换，比如321，得反转</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">record</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                record = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.从后向前找比record大的数</span></span><br><span class="line">        <span class="keyword">if</span> (record &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bigger</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[bigger] &lt;= nums[record] &amp;&amp; bigger &gt; record) &#123;</span><br><span class="line">                bigger --;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(record, bigger, nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.翻转record+1到末尾的</span></span><br><span class="line">        reverse(record + <span class="number">1</span>, nums.length - <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            swap(i, j, nums);</span><br><span class="line">            i ++;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a>寻找重复数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</span><br><span class="line">假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</span><br><span class="line">你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,3,4,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>不能用map、set，数组中如果没有重复的数，那就是一对一的关系，有重复的就是多个下标对应一个数的关系。和环形链表类似，使用快慢指针。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 衍生为环形链表问题，用快慢指针找到环的入口。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到相遇处</span></span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[nums[fast]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 慢指针从0出发，快指针从原地出发，都+1行走</span></span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%85%AB%E8%82%A1/" rel="tag"># 八股</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="prev" title="那些年背过的面试题之大数据">
      <i class="fa fa-chevron-left"></i> 那些年背过的面试题之大数据
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/07/27/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bjava2025/" rel="next" title="那些年背过的面试题之java2025">
      那些年背过的面试题之java2025 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.</span> <span class="nav-text">两数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="nav-number">1.1.</span> <span class="nav-text">## 字母异位词分组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="nav-number">2.</span> <span class="nav-text">最长连续序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.1.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text">下一个排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">寻找重复数</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sweetwater"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">Sweetwater</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sweetwater</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
