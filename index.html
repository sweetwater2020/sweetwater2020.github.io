<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Sweetwater&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Sweetwater&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Sweetwater">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Sweetwater's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sweetwater's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E5%A4%A7%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E5%A4%A7%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">那些年背过的面试题之大数据</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-24 22:27:03 / Modified: 22:29:54" itemprop="dateCreated datePublished" datetime="2025-07-24T22:27:03+08:00">2025-07-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>谷歌的“三架马车”：谷歌文件系统GFS（2003），MapReduce（2004）和Big Table（2006），奠定了大数据时代的基础。</li>
<li>离线计算：Hadoop（Mapreduce）、Hive、Spark</li>
<li>2006年实现了由HDFS分布式文件系统和MapReduce计算框架组成的Hadoop，成为了离线数据处理的核心。</li>
<li>HDFS：Hadoop的存储部分，一个分布式文件系统，将数据文件分块存储在集群的节点上。HDFS可以实现在整个集群上高效地存储和访问数据。</li>
<li>MapReduce：大数据处理技术，属于离线计算的一种。将数据处理任务分成两个阶段：Map阶段，数据被切分成小块，并在计算机集群的各个节点上进行并行处理。Reduce阶段，将Map阶段的结果进行合并和汇总，生成最终的输出结果。</li>
<li>2007年Hive：起源于FaceBook，是基于Hadoop的一个数据仓库工具，用来进行数据提取、转化、加载ETL，一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制。能将结构化的数据文件映射为一张数据库表，并提供SQL查询功能，能将SQL语句转变成MapReduce任务来执行。</li>
<li>2010年Spark：Hadoop缺点：MapReduce框架在每个计算阶段都需进行磁盘读写导致较高的磁盘IO开销、对于迭代计算效率低下。Spark是加州大学伯克利分校开源的类Hadoop MapReduce的通用并行框架，与MapReduce不同：中间输出结果可以保存在内存中，从而不再需要读写HDFS，避免大部分磁盘IO开销，提高计算性能。同时Spark能更好的适用于数据挖掘与机器学习等需要迭代的MapReduce的算法。Spark通过使用RDD（弹性分布式数据集）、DAG切分的多阶段计算过程来实现高效的数据并行处理，支持大规模数据集的分布式计算和分析任务，是离线计算（批处理）领域的主流技术栈。</li>
<li>Spark拥有一个丰富的生态系统：Spark SQL（用于SQL查询）、Spark Streaming（用于实时流处理）、MLlib（用于机器学习）、GraphX（用于图计算）等。是一个强大且灵活的分布式计算框架，它通过内存计算和统一的编程模型，为大规模数据处理提供了高效的解决方案，适用于各种数据处理任务和应用场景。</li>
<li>实时计算：Storm、Spark Streaming、Flink</li>
<li>实时计算：在早期，基于Hadoop的数据处理主要采用批处理方式，也就是离线计算的方式：数据会先存储在分布式文件系统中，然后通过批处理作业进行处理和分析，数据处理的延迟较高，需要等待一段时间才能获取结果。</li>
<li>离线&#x3D;批处理，实时&#x3D;流式处理。流式处理技术将数据分成小的批次进行处理，在数据到达时立即进行处理和分析，流式处理技术又分为两种：原生流、微批拟流（Spark Streaming）</li>
<li>Storm是一个免费开源、分布式、高容错的实时计算系统。Storm最早于2011年诞生于Twitter。早期Storm用于实时计算，Hadoop用于离线计算。已不推荐使用。在Storm中，先要设计一个用于实时计算的图状拓扑（Topology），一个Topology是由多个Spout（数据输入处理模块）和Bolt（输出处理模块）通过Stream连接起来的有向无环图。</li>
<li>Spark Streaming：2013年Spark 2.0推出了Spark Streaming。但由于不是原生流处理技术栈，认为流是批的特例，将输入数据切分成一个个小的切片，存在时延，且高级功能不如Flink，已不是主流技术栈，不推荐使用。</li>
<li>Flink最初是由德国柏林工业大学开发。Apache Flink是分布式流式处理引擎，用于无界和有界数据流的有状态计算。Flink创造性地统一了流处理和批处理，作为流处理看待时输入数据流是无界的，而批处理被作为一种特殊的流处理，只是它的输入数据流被定义为有界的。</li>
<li>分布式存储HBase：一个分布式的、面向列的开源数据库，建立在 HDFS 之上。HBase 的计算和存储能力取决于 Hadoop 集群。它介于NoSql和RDBMS之间，仅能通过主键(row key)和主键的range来检索数据，仅支持单行事务。</li>
<li>OLAP 和 OLTP：OLTP（联机事务处理）对数据库的增删改。OLAP（联机分析处理）对数据的查询。</li>
<li>OLAP的分类：ROLAP（关系型联机分析处理）、MOLAP（多维联机分析处理）、HOLAP（混合型OLAP）。ROLAP：传统关系型数据库、MPP分布式数据库以及Hadoop的Spark。实时根据用户提出的需求对数据进行计算后返回给用户。使用灵活，可以随意选择维度组合进行实时计算。有性能问题。MOLAP：将客户的需求计算好以结果的形式存下来，提出需求后，找到对应的结果返回即可。需要的磁盘存储空间大。</li>
<li>MPP（Massive Parallel Processing,海量并行处理）：是一种基于共享磁盘的并行数据库处理架构，通过将数据分布到多个节点上进行并行处理，从而实现对大规模数据的快速分析和查询。只负责计算，不负责存储。</li>
<li>MapReduce和MPP架构：都是分布式并行处理，将任务并行的分散到多个服务器节点上，在每个节点上计算完成后，将各自部分的结果汇总到一起。不同的是，MapReduce任务的tasks会动态的分配在空闲的Executor上，执行慢的Executor会分配到更少的task。缺点是MapReduce将一个任务分解成有依赖关系的tasks（DAG），task是异步执行的，因此必须通过写入中间数据共享内存来解决数据的依赖，性能有所损耗。MPP每个处理数据的task被绑定在持有该数据切片的指定Executor上，单一的Executor只处理单一的task，不需要将中间数据写入磁盘，直接将数据Stream到下一个执行阶段，性能好。缺点是如果某个Executor执行过慢或者故障，整个集群的性能就会受限于这个异常节点，所以MPP架构的集群节点不宜过多。</li>
<li>Lambda架构：一种用于数据处理的架构设计模式，结合了实时计算和批处理两种方法，以满足不同的数据分析需求。L由三个层级组成：批处理层、速度层和服务层。批处理层负责离线处理大量数据，通常通过批处理系统（如Hadoop、Spark等）处理数据，并将结果存储在数据仓库中。速度层用于处理实时数据流，通常采用流式处理技术（如Storm、Spark Streaming等），以快速处理数据并产生实时结果。服务层负责将批处理层和速度层的结果整合，并为用户提供统一的数据查询和分析接口。优点：可扩展性强、能够处理大规模数据、满足实时和离线数据处理需求。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BSpring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BSpring/" class="post-title-link" itemprop="url">那些年背过的面试题之Spring</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-24 22:25:25 / Modified: 22:26:41" itemprop="dateCreated datePublished" datetime="2025-07-24T22:25:25+08:00">2025-07-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><ul>
<li><p>Spring的架构：1⃣️控制反转IOC容器，负责管理对象的生命周期。2⃣️AOP面向切面编程，实现跨应用程序的共有关注点，代码前后做增强。3⃣️简化数据访问，如JDBC，提供一致的数据访问。4⃣️Web层，Spring MVC提供一个分离的模型-视图-控制器实现，用于构建Web应用。</p>
</li>
<li><p>spring bean的加载过程&#x2F;生命周期：1⃣️启动spring应用上下文。2⃣️加载bean定义：读取xml文件、java注解、java配置类，为每个声明的Bean创建一个BeanDefinition对象，包含bean的所有定义信息。 3⃣️实例化bean：调用构造函数、依赖注入、BeanPostProcessor 的前处理。4⃣️初始化bean：调用bean的初始化方法：@PostConstruct注解的方法、指定的init-method、InitializingBean的afterPropertiesSet方法。5⃣️使用bean。6⃣️销毁：容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy方法。</p>
</li>
<li><p>spring IOC：控制反转，通过spring来管理对象的创建、配置、生命周期，把控制权交给spring。提供BeanFactory和ApplicationContext两种IOC容器，实现对bean的管理。实现原理：依赖注入DI、Bean生命周期管理。</p>
</li>
<li><p>spring AOP：面向切面编程，一种编程范式，代码前后做增强操作，提高代码模块性。实现：基于动态代理，实现接口用JDK动态代理，否则CGLIB动态代理。@Aspect注解和@Around切入点实现切面。</p>
</li>
<li><p>JDK和CGLIB动态代理：JDK动态代理针对类实现某个接口，基于反射生成实现同样接口的代理类。CGLIB底层基于asm第三方框架，通过修改字节码生成一个子类。</p>
</li>
<li><p>Spring AOP和AspectJ AOP：Spring AOP 基于动态代理实现，只能在运行时织入，性能比AspectJ编译织入慢。AspectJ只支持编译前后和类加载时织入，性能更好，功能更加强大。</p>
</li>
<li><p>java反射：对于任何一个类，都能知道这个类所有的属性和方法；对于任何一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。getField(属性名字)和getDeclaredField（忽略访问控制）获取属性Field。getMethod获取方法Method。invoke执行。</p>
</li>
<li><p>BeanFactory和ApplicationContext：都是Spring中管理Bean的容器。BeanFactory是Spring IoC容器的基础接口，ApplicationContext实现BeanFactory，提供更丰富功能：国际化、事件发布、注解支持。BeanFactory 采用懒加载（延迟初始化）策略，只有在请求获取 Bean 时才会创建和初始化该 Bean。ApplicationContext采用即时加载策略，容器启动时会预先创建和初始化所有 Singleton Bean。</p>
</li>
<li><p>FactoryBean和BeanFactory：BeanFactory是IOC容器，负责生产和管理Bean对象：读取bean配置、加载bean、依赖注入、bean生命周期管理。FactoryBean是工厂Bean，可以实现该接口来自定义Bean的创建过程。重写getObject方法控制Bean的创建，getBean获取Bean实例。</p>
</li>
<li><p>Spring事务的传播机制：用来定义业务方法之间事务处理方式的机制，根据给定的事务规则来创建和控制事务的边界和范围，保证数据一致性。@Transactional注解的propagation属性指定。例如银行转账操作中有个审计方法，这个方法异常不想影响转账事务的回滚，就用REQUIRES_NEW创建新事务。一共有七种：1.REQUIRED：默认的，存在就加入该事务，没有事务就创建新的。2.REQUIRES_NEW：无论存不存在都创建新的。3.NOT_SUPPORTED：非事务方式执行，存在事务则挂起。4.SUPPORTS：存在则加入事务，不存在则非事务。5.NESTED：如果存在事务，则在嵌套事务（可独立提交，外部事务回滚它也得回滚）内执行。如果没有事务，则按REQUIRED属性执行。6.NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。7.MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p>
</li>
<li><p>@Autowired和@Resource：都是用来实现依赖注入的注解。@Autowired是spring的注解，默认根据类型注入，多个类型相同则进一步根据名称。如果按照类型匹配接口不同实现类需要结合@Qualifier。提供required属性允许找不到bean时是否抛出异常。@Resource是j2ee的注解，默认按byName自动注入，不能用于构造函数。</p>
</li>
<li><p>Spring核心注解：@SpringBootApplication：组合注解，用于启动Spring Boot应用，包含@Configuration、@EnableAutoConfiguration和@ComponentScan。@Component：标注一个类为需要Spring管理的bean。@Configuration：表明该类是用于定义Bean的配置类，配合@Bean来在容器中注册自定义的Bean，方法返回对象被容器管理。@Transactional：用于声明一个方法或类需要事务管理。</p>
</li>
<li><p>Spring依赖注入注解：@Autowired、@Qualifier、@Resource、@Value：注入普通类型的属性。</p>
</li>
<li><p>Spring组件扫描注解：@Service：用于Service层的组件。@Repository：用于DAO层的组件。@Controller：用于标记控制层组件。</p>
</li>
<li><p>spring bean生命周期：1.创建bean的实例，在堆中开辟一块内存空间给这个对象，生成实例对象。2.填充bean的成员属性。3.调用initializeBean方法初始化bean（调用@PostConstruct、实现Aware接口的方法、before…方法、init-method方法、afterPropertiesSet方法）。</p>
</li>
<li><p>spring的三级缓存：用来解决单例bean循环依赖问题，提前拿到未初始化完全的对象。第一级缓存：用来保存实例化、初始化都完成的对象。第二级缓存：用来保存实例化完成但是未初始化完成的对象。第三级缓存：保存创建早期bean的工厂ObjectFactory，getObject()创建一个对该bean的早期引用，这个引用可以被二级缓存使用，确保bean可以按需要的代理和增强创建出来。原理：实例化和初始化流程分开，在Bean完全初始化之前，可以暴露一个早期的bean引用，从而打破循环依赖。</p>
</li>
<li><p>二级缓存行不行：当涉及AOP或其他代理增强时，仅凭二级缓存不够，因为要在返回代理对象前确保执行所有增强的逻辑。所以，如果一个bean需要被代理，它首先应该通过三级缓存的ObjectFactory被创建，该工厂负责处理所有的代理相关逻辑。一旦经过这个步骤得到的bean被放入二级缓存中，它就可以被其他bean使用了。</p>
</li>
<li><p>spring解决循环依赖的具体流程：1.单例bean首先检查一级缓存，存在则直接返回。2.不存在则实例化对象，还未属性注入和初始化。3.创建好bean实例后，将ObjectFactory放入三级缓存。4.属性注入，请求创建依赖的bean，如果有循环依赖，通过三级缓存创建一个早期的bean引用，并放到二级缓存，同时删除三级缓存。5.完成注入及初始化，bean创建成功。6.bean放入一级缓存，并从二级和三级缓存中移除。</p>
</li>
<li><p>spring bean：根据作用域，Singleton：默认的作用域，整个容器中只有一个实例，适用于配置类、工具类、服务类。Prototype：原型bean，每次请求都会创建一个新的实例。spring容器仅负责实例化，不管生命周期。Request：每个HTTP请求都会创建一个Bean，仅适用于web应用。Session：每个HTTP Session都会创建一个Bean，仅适用于web应用。</p>
</li>
<li><p>@PostConstruct：Java EE 5引入的注解，在Bean的实例化和依赖注入完成后被自动调用。用来执行必要的初始化代码，例如资源分配，加载数据。通过容器来控制初始化。修饰无参数无返回值方法，每个类只能有一个该方法。InitializingBean接口的afterPropertiesSet和配置bean时的init-method也有类似功能。@PostConstruct先于他俩。</p>
</li>
<li><p>InitializingBean：接口，定义了afterPropertiesSet方法，这个方法会在bean的所有属性都设置好之后执行，用于在依赖注入后执行某些初始化操作。</p>
</li>
<li><p>ApplicationContextAware：用于方便获取ApplicationContext，spring会自动调用setApplicationContext(ApplicationContext applicationContext)方法，可将ApplicationContext实例注入到bean中，用于获取其他bean、访问资源文件、发布事件。</p>
</li>
<li><p>spring事务的实现原理：两种事务的实现方式：编程式（通过代码控制事务处理逻辑）、声明式（@Transactional注解实现）。事务的操作本由数据库自动控制，为方便业务逻辑操作，由spring框架控制。spring事务的实现原理是通过AOP实现，生成代理对象，代理会在方法执行前后织入事务管理的相关操作：事务开始，先把事务的自动提交给关闭、提交事务、异常回滚。可以设置事务的传播行为、隔离级别、超时设置。总之，Spring AOP 提供了声明式事务管理的基础，使得事务管理逻辑能够以切面的形式，织入到业务逻辑中。</p>
</li>
<li><p>a方法加了@Transactional，b方法没加，b内部调用a，会有事务产生吗：@Transactional声明式事务，事务的传播行为决定事务如何传播和边界所在。由于spring的事务管理是基于AOP，通过代理实现的，分两种情况：第一种，如果方法在同一个类中，自调用，a方法的调用不会通过spring生成的代理对象调用，不会开始新的事务。第二种，在不同的类中，a方法通过spring的代理对象调用，开始一个新事务。</p>
</li>
</ul>
<h2 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h2><ul>
<li>什么是springboot：基于spring的开源框架，用于快速创建独立的生产级别的可运行的Spring应用程序。不是Spring功能上的增强，而是提供一种快速开发Spring项目的方式。spring问题：写配置文件繁琐，依赖繁琐，maven坐标版本问题。springboot提供的优点：自动配置、起步依赖、安全。约定优于配置的理念，开发者不需要手动配置大量spring配置文件，而是自动配置。提供一系列的起步依赖starter，快速构建出一些常用的应用程序，整合Junit、redis、mybatis等很方便。帮助管理jar包版本，避免依赖版本不一致的问题。</li>
<li>Spring、Spring MVC和SpringBoot区别：Spring是Java开发框架，用于创建企业级的java应用程序，提供IOC和AOP等功能。Spring MVC是Spring框架的一个模块，用于创建Web应用程序，使用控制器、视图和模型来实现MVC设计模式。Spring Boot是一个基于Spring框架的快速开发工具，使用自动配置快速创建Spring应用程序。总结：Spring是基础框架，Spring MVC是基于Spring的Web框架，而Spring Boot则是基于Spring的快速开发框架。Spring Boot内嵌了Tomcat、Jetty等Web容器，可以直接运行Web应用程序，而Spring MVC需要部署到Web容器中才能运行。</li>
<li>springboot自动配置的原理：基于Spring的条件化配置功能实现，Condition接口和@Conditional注解。以及springboot的一系列自动配置类，Spring Boot应用的入口类会使用@SpringBootApplication注解，它包含@SpringBootConfiguration，@EnableAutoConfiguration和@ComponentScan注解，@EnableAutoConfiguration是自动配置的核心。@EnableAutoConfiguration利用Spring的@Import注解来加载配置类，META-INF&#x2F;spring.factories配置文件中定义了大量的配置类，springboot应用启动时会自动加载这些配置类。并且在配置类中使用Condition来加载满足条件的bean，如DataSource、JdbcTemplate等。（总结：1.条件注解 2.@EnableAutoConfiguration）</li>
<li>springboot核心注解：@SpringBootApplication：复合注解，标识springboot应用的主类。@Configuration表明该类是java配置类。@ EnableAutoConfiguration开启自动配置功能。@ComponentScan用于自动扫描和注册bean。</li>
<li>spring boot starter：是预配置的依赖管理器，将一组库&#x2F;依赖捆绑在一起，便于开发特定类型的应用程序。简化依赖管理，提供开箱即用的配置，是约定优于配置的应用，集成常用技术和库。spring-boot-starter-web：开发Web应用，包含Spring MVC、Tomcat容器等。spring-boot-starter-data-jpa：使用JPA的Starter，包含Hibernate、Spring Data JPA、Spring ORM等依赖。spring-boot-starter-data-redis：使用Redis的Starter，包含Jedis客户端和Spring Data Redis等依赖。spring-boot-starter-test：适用于测试的Starter，包含JUnit、Mockito、Spring Test等依赖。spring-boot-starter-actuator：监视器，适用于监控和管理Spring Boot应用程序的Starter，包含Spring Boot Actuator等依赖。</li>
<li>spring-boot-starter-parent：springboot官方提供的一个Maven父工程，是springboot项目的父工程，parent元素设置为它，继承一些常用依赖和插件，减少手动配置。统一管理springboot中的常用依赖版本号，确保版本兼容性。</li>
<li>如何自定义spring boot starter：在项目的src&#x2F;main&#x2F;resources目录下创建META-INF&#x2F;spring.factories文件，内容如下：org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;com.example.my_starter.MyAutoConfiguration，告诉springboot启动时自动加载配置类。创建MyAutoConfiguration配置类，并在类上加上@Configuration注解，在其中定义需要自动配置的Bean。然后打包上传Maven仓库。</li>
<li>spring-boot-maven-plugin：用于将SpringBoot应用，以及依赖项和配置文件打包成可执行的Jar包或War包，包含嵌入式的Tomcat容器或Jetty容器。方便部署和运行。</li>
<li>springboot打成的jar包和普通jar包区别：1⃣️springboot的jar包是可执行的jar包，包含了内嵌的Tomcat、Jetty等Web服务器，可直接运行。普通jar包纸包含类、资源等，需要在外部环境中手动配置Web服务器运行。2⃣️springboot打的jar包中包含了启动类的main方法，可直接运行。普通jar包需要指定启动类。3⃣️springboot的jar包中包含一些默认的配置文件，如application.properties，用于配置属性、数据源等。普通jar包不包含。</li>
<li>springboot实现热部署：使用Spring DevTools工具，支持应用程序代码修改后自动重新加载应用程序上下文和服务器。spring loaded也行，避免反复构建和部署。</li>
<li>springboot可以兼容老spring项目吗：可以使用@ImportResource注解来加载老的xml配置文件，用于@Configuration或@SpringBootApplication类上。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="post-title-link" itemprop="url">那些年背过的面试题之中间件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-24 22:23:55 / Modified: 22:28:31" itemprop="dateCreated datePublished" datetime="2025-07-24T22:23:55+08:00">2025-07-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><ul>
<li><p>微服务是什么：架构风格，大型服务-多个小服务，轻量级通信机制协作。模块儿化，独立部署扩展维护、可靠、技术异构。</p>
</li>
<li><p>微服务组件：服务、通信机制、服务发现与注册、负载均衡、API网关</p>
</li>
<li><p>微服务间如何通信：http、消息队列、rpc</p>
</li>
</ul>
<h2 id="rpc、HSF"><a href="#rpc、HSF" class="headerlink" title="rpc、HSF"></a>rpc、HSF</h2><ul>
<li><p>rpc：远程过程调用，就像调用本地函数一样调用远程服务，通信协议、序列化协议，http、自定义报文tcp，文本xml json 二进制protobuf hessian。</p>
</li>
<li><p>自定义报文？http消息头复杂，短链接</p>
</li>
<li><p>HSF：高速服务框架，分布式rpc服务框架。统一服务的发布&#x2F;订阅&#x2F;调用方式，解决服务间的高效调用。</p>
</li>
<li><p>HSF架构：服务提供者、服务消费者、地址注册中心configServer（注册服务、订阅服务、向消费者推送服务提供者地址）、持久化配置中心diamond（configServer的类型和地址、订阅路由规则等）、元数据存储中心redis（服务上报元数据：方法列表参数结构）、控制台（服务查询治理测试运维）</p>
</li>
<li><p>HSF服务发布源码：核心是HSFSpringProviderBean，通过@Import注解引入配置类，配置类实现ImportBeanDefinationRegistrar来创建复杂的bean并注册到spring容器中。HSFSpringProviderBean的afterPropertiesSet()方法中进行服务初始化（初始化调用链，两条链，一是protocolFilterChain: Protocol，它专注于流程编排，在publish()流程顺序执行；一是invocationHandler链，用于后续处理hsf请求调用）、服务发布（使用线程池，Future阻塞等待服务发布成功。使用调用链进行，上报元数据到Redis，启动并监听tcp&#x2F;http端口、分配服务线程池、服务注册。使用Protocol进行流程编排，初始化时编排流程顺序。注册信息：ip&#x2F;port&#x2F;序列化方式&#x2F;路由规则&#x2F;应用名称&#x2F;超时时间。HSFProtocol中开启netty服务，设置tcp相关协议）。</p>
</li>
<li><p>HSF消费源码：1.服务初始化，初始化调用链，初始化HSF代理对象jdk。2.服务调用，同样使用调用链，在IO传输层使用netty长连接，使用hessian序列化，在服务提供方使用反射调用（运行时动态获取类的信息）。</p>
</li>
<li><p>HSF相比SpringCloud优势：1.HSF使用高性能的异步事件驱动的NIO框架Netty。2.序列化协议hession相比json。3.HSF只需将二方包暴露给用户 4.HSF使用代理机制，将协议封装、选址、远程调用封装，用户只需Spring配置。</p>
</li>
<li><p>HSF源码心得：从服务端初始化、服务注册、客户端初始化、调用服务，使用Netty、Hession、ProtocolFilter、InvocationHandler链式调用过程进行流程编排、灵活配置的注册中心、事件监听机制、通过随机数的方式实现随机负载均衡。高内聚低耦合的设计方法。</p>
</li>
<li><p>一次完整的HSF调用：服务寻址、网络连接、序列化传输、反射调用</p>
</li>
<li><p>一个rpc框架最重要的是什么部分：通信机制（传输协议自定义tcp报文还是http、负载均衡、容错机制）、序列化反序列化协议（网络只能传输字节流，需要将对象转换为字节流），还需要服务发现与注册机制、服务治理机制。</p>
</li>
<li><p>shell脚本查询对应错误出现次数：grep “2024-01-01*error” error.log ｜ wc -l</p>
</li>
</ul>
<h2 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h2><ul>
<li><p>dubbo：高性能RPC框架，阿里开源，netty网络框架，异步IO，线程池</p>
</li>
<li><p>dubbo框架：服务提供者启动时向注册中心注册服务，服务消费者启动时订阅服务，注册中心Registry向消费者推送服务提供者地址列表，如果发生变化通过长链接推送变更，消费者用负载均衡选择地址，监控中心Monitor，消费者和提供者定时发送统计数据（调用次数调用时间）</p>
</li>
<li><p>dubbo负载均衡：随机、轮询、最少活跃调用、一致性哈希、权重</p>
</li>
<li><p>dubbo中的Filter：责任链模式的实现，根据配置生成Filter链，实现对Dobbo代码的拦截和扩展，类似于AOP，优雅的代码增强手段，逻辑分层，代码解耦。应用：日志、鉴权、限流、负载均衡。</p>
</li>
<li><p>dubbo中的spi扩展：服务扩展机制，可以在运行时动态加载实现类。提供丰富的SPI扩展点，类似java SPI，可以自定义扩展实现，配置方式替换框架中的组件。使用了url总线设计，url参数识别用哪个接口实现。使用@SPI注解指定扩展点名。面向接口编程。</p>
</li>
<li><p>dubbo的SPI实现：1.ExtensionLoader单例工厂类，负责加载和管理扩展点实现类。2.不仅通过接口名获取，还有一个key。3.Adaptive自适应扩展，可以在运行时通过传入参数动态选择合适的扩展实现。</p>
</li>
<li><p>dubbo的SPI应用：Protocol协议、Cluster集群容错策略、LoadBalance负载均衡策略。都是根据配置动态切换。</p>
</li>
<li><p>dubbo中的url总线设计：为了各层解耦，交换参数不用Model，用url参数，方便扩展。底层netty。</p>
</li>
<li><p>dubbo启动过程：注册中心（加载配置、启动定时、NettyServer启动netty）提供者（DubboProtocol提供远程服务，RemoteRegistry建立与注册中心连接）消费者（RemoteRegistry，RegistryDirectory订阅服务，创建代理，实际调用InvokerInvocationHandler）</p>
</li>
<li><p>dubbo服务治理：负载均衡（请求均匀分配）、集群容错（调用失败时切换机器重试）、服务降级（负载过高时屏蔽部分服务保障核心）、路由策略（选择最优服务提供者）、监控管理（监控报警）</p>
</li>
<li><p>dubbo中的设计模式：ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();是工厂模式，Adaptive运行时动态决定调用哪个实现，代理模式。使用调用链Filter责任链模式。ClassLoaderFilter在主功能上添加功能装饰器模式。注册中心向消费者发送notify消息表示服务更新，观察者模式。</p>
</li>
<li><p>dubbo总结：Dubbo考虑了框架可扩展性，url总线设计，层次划分。一个调用链路中存在很多Filter拦截，相对HSF性能差，但是可以将自己逻辑整合到调用链中。</p>
</li>
<li><p>dubbo限流：服务治理的一种，确保服务提供者不会因为过高请求负载而崩溃。基于令牌桶算法，以恒定速率向桶中添加令牌，每个请求需要从桶中消耗令牌，Guava中RateLimiter实现令牌桶。基于信号量Semaphore，控制同时执行服务的线程数。</p>
</li>
<li><p>dubbo序列化有哪些：Hessian2序列化，紧凑且效率高，二进制序列化协议，跨语言，dubbo中默认的。java内置序列化。Fastjson序列化，将对象序列化为json字符串，适合web通信场景。Protobuf序列化，使用.proto文件定义数据结构，生成二进制格式存储数据，跨语言。</p>
</li>
<li><p>dubbo比spring cloud优势：1.轻量级和高性能：基于RPC和Netty框架。强调性能。2.灵活的服务治理：路由规则、负载均衡、故障转移、集群支持。3.独立的注册中心：zookeeper等可选，提供分离的服务发现设计。4.支持跨语言的服务调用，gRpc、Hessian集成。5.简单易用，二方包的形式</p>
</li>
<li><p>Spring Cloud：基于Spring Boot，一整套微服务解决方案，提供一系列用于构建微服务应用的工具和框架。相对更重。基于REST原则，基于HTTP&#x2F;REST的服务通信。</p>
</li>
</ul>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ul>
<li>分布式：多台计算机位于不同地理位置，分布式存储处理数据和应用程序。组件之间通过网络连接。</li>
<li>分布式优点：可扩展性、容错性、地理分散降低延时。</li>
<li>分布式难点：数据一致性、系统管理（部署、管理、容灾、处理节点故障）、跨节点事务</li>
<li>分布式事务：事务的操作分布在不同节点，跨库事务，需要确保事务ACID（原子性、一致性、隔离性、持久性）</li>
<li>分布式事务方法：两阶段提交2PC（准备阶段询问所有参与者是否可提交，根据答复指示所有参与者提交&#x2F;回滚，所有ok才提交）、三阶段提交3PC（增加预提交，参与者将事务操作记录写入日志，即使协调者失去响应，参与者也有足够的信息来完成或回滚事务。减少因协调者故障导致的阻塞，提高容错）、分布式事务框架（XA事务协议）、事务补偿、BASE理论（宽松，基本可用，软状态，最终一致性）</li>
<li>分布式锁：分布式系统中同步访问共享资源的机制，避免多节点同时修改同一数据的冲突。1⃣️基于数据库锁，select for update对特定行上行级锁。2⃣️基于redis，SETNX命令，expire过期时间。3⃣️基于zookeeper，分布式协调服务，创建一个独特的节点表示获锁。保障原子性和唯一性。</li>
</ul>
<h2 id="metaq"><a href="#metaq" class="headerlink" title="metaq"></a>metaq</h2><ul>
<li>metaq：分布式的，基于队列模型的消息队列中间件，基于发布订阅模式，有push&#x2F;pull两种消费模式。支持严格的消息顺序，亿级别堆积能力，支持消息回溯。延时消息。</li>
<li>消息队列三大场景：异步、解耦、削峰。</li>
<li>metaq架构：NameServer（路由注册中心，实例彼此独立，用于服务发现和Topic的注册中心，每个节点维护topic和broker的映射关系）、Broker（实际消息存储的服务器，分master和slave，每个Broker与所有的NameServer建立长连接，定时注册Topic信息到NameServer。主节点读写，从节点提供冗余和故障转移。）、Producer（消息生产者，与NameServer其中一个建立长连接，读取Topic路由信息。与提供Topic服务的Master Broker建立长连接，并定时向其发送心跳）、Consumer（消息消费者，与NameServer其中一个建立长连接，读取Topic路由信息。从Master Broker&#x2F;Slave Broker订阅消息，与Broker建立心跳。可pull可push，可集群可广播）。</li>
<li>metaq的存储模型：1⃣️CommitLog是物理存储文件，存储所有Topic的消息元数据，是全局的顺序写入的日志文件。2⃣️ConsumerQueue逻辑队列是每个Message Queue的索引文件及存储上的体现，记录CommitLog中的消息地址（偏移量、大小、消息tag的hashcode），每个条目20字节，提供快速访问。类似B+树，CommitLog是叶子结点存储实际数据，ConsumerQueue是中间节点负责索引数据。3⃣️Message Queue是逻辑上的消息队列，是Topic的分区，分散在不同Broker。用于并行发送和接收消息。4⃣️IndexFile用于快速检索消息，维护消息键（消息ID、Key）到物理位置的映射。</li>
<li>metaq如何保证消息高可用：1⃣️Producer：支持同步异步发送方式，同步消息发送确认、消息重试。使用负载均衡选择Broker进行消息投递。快速失败：调度线程定时检查第一个节点排队时间，超过就立即返回失败，以尽快重试。故障规避机制避开上次失败的Broker。2⃣️Consumer：消息拉取确认、消费失败重试队列、消费进度存储（定期存储消费进度offset，重启或故障后从进度继续消费）、业务层实现幂等消费（重复消费也不影响）。3⃣️Broker：持久化存储机制（存储到CommitLog，顺序写入磁盘）、主从部署（主从同步、主从切换，Master和Slave故障转移）、死信队列（无法成功消费的消息进入死信队列）、使用内存映射文件MappedFile（将磁盘文件映射到内存中，以操作内存方式操作磁盘，减少CPU拷贝）</li>
<li>同步刷盘和异步刷盘：将内存中数据持久化到磁盘中，同步刷盘是将消息成功写入commitLog中之后再返回给生产者成功，更可靠。异步刷盘是写到内存后直接返回，然后通过另一个后台线程来刷盘，吞吐量更高。</li>
<li>Broker主从同步：从节点定时向主节点发送同步请求，主节点根据从节点CommitLog最大偏移量返回消息。</li>
<li>NameServer作用：Broker的动态注册与发现（心跳检测是否存活）、路由信息管理（保存整个Broker集群的路由信息，topic和Broker的映射关系）。每个NameServer有一份完整数据。</li>
<li>Raft协议和Paxos：分布式系统中用于解决一致性问题的共识算法。例如Zookeeper中的Leader选举。</li>
<li>RocketMq集群模式：1⃣️单master模式：不能故障转移和高可用。2⃣️多master模式：不能故障转移。3⃣️多maste多slave异步模式：异步复制，实时性高，Master宕机磁盘损坏情况下会丢失少量消息。4⃣️多master多slave同步模式：同步双写，写成功才返回给应用，无单点故障。</li>
<li>RocketMq顺序消息如何保证：CommitLog的写入是顺序的，消息队列FIFO，对于单个Message Queue而言，是按存储顺序顺序消费的。多个Message Queue是不保证全局顺序的。需要确保消息只分配给一个Message Queue。</li>
<li>RocketMq负载均衡：Producer负载均衡，轮询方式发送到Message Queue。Consumer负载均衡，集群模式下queue均匀分配给实例，每个queue只分给一个Consumer实例。广播模式下所有consumer分到所有queue。</li>
<li>死信队列：消息重复消费失败，达到最大重试次数，进入死信队列。一个死信队列对应一个GroupId，不分Topic。</li>
<li>消息幂等：消费者接收到消息后，根据业务唯一Key（如Message key）做幂等，即使重复消费也没事。</li>
<li>推拉消息模式：Pull：拉取型，消费者主动定期轮询Broker，请求新消息。Push：消费者注册消息监听器来接收Broker的消息推送，被动消费。但实现上，都是消费端主动拉取的方式，RocketMq的服务端不会主动推送，push模式下还是消费端拉取消息，拉取后调用回调接口，模拟推送。</li>
<li>任何一台Broker宕机怎么办：Broker采用主从架构，多副本策略。Broker宕机后主从切换，高可用。4.5开始支持Dlegder模式，基于raft分布式一致算法。</li>
<li>消息被消费后会立即删除吗：不会，消费后只是消息队列的消费进度（offset）更新，消息的删除是通过定期清理过期文件来实现的。</li>
<li>延时消息实现：是在投递到Topic这一阶段延时的。1⃣️消息投递：提供若干个延时等级。有一个专门的延时Topic，存入对应延时等级的队列中。2⃣️消息调度：Broker启动时，创建ScheduledThreadPoolExecutor线程池，每个延迟队列一个线程扫描，定期检查延时队列中的消息是否到期。3⃣️转移消息：取出消息重新进行CommitLog写入，写入对应Consumer Queue。然后正常消费。</li>
<li>metaq总结：高性能（吞吐量高并发量高，队列模型、并行消费、基于Netty）、高可靠性（消息丢失可能小，重试机制、故障规避机制、重试、死信队列）、高实时性（低延迟，快速失败、异步刷盘、零拷贝）</li>
</ul>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul>
<li>消息队列：消息队列是一个用于接收消息、存储消息并且转发消息的中间件，异步、削峰、解耦。</li>
<li>metaq中的nameserver：类似kafka中zookeeper的角色，不直接采用ZooKeeper是因为ZooKeeper有自动选举Master的功能，MetaQ的架构设计上决定了它不需要进行Master选举，而只需要使用一个轻量级的元数据服务器就可以了。</li>
<li>kafka：一个多分区、多副本且基于 ZooKeeper协调的分布式消息系统。定位为一个分布式流式处理平台，高吞吐、可持久化、可水平扩展、支持流数据处理。</li>
<li>kafka的架构：zookeeper保存broker集群元数据，对控制器进行选举操作。Producer生产消息并发送到Broker。Consumer从Broker订阅并消费消息。Broker接收生产者的消息，存储消息，为消息设置偏移量。Topic消息的主题。一个Topic细分为多个分区，在存储上看作一个可追加的Log文件。offset是消息在分区中的唯一标识，保证消息在分区的顺序性，不跨分区，也就是kafka只保证分区有序性。Replication副本，保证高可用，同一Partion在多个Broker上存多个副本，主提供读写，主失效的话，zookeeper选举controller，controller选择主。</li>
<li>kafka高可用：多分区，一个Topic主题分区数据跨越多个broker分布式存储，每个分区有多个副本，主出现故障，可以故障转移。</li>
<li>kafka一定不会丢失消息吗：只有一个副本情况下会丢失，生产者确认策略是异步的还是同步的，异步的可能在消息到达服务器之前丢失。短暂网络故障、磁盘损坏。</li>
<li>netty的优点：1⃣️Reactor模型处理并发网络事件：主Reactor线程负责接收新的客户端连接，将连接分配给从Reactor，负责监控和处理IO事件。2⃣️内存管理：池化的内存分配方式，减少内存分配和回收成本。字节缓冲区ByteBuf提供内存读写，较JDK自带的ByteBuffer具有更高的性能，引用计数。3⃣️连接管理：基于事件循环(EventLoop)的模型来管理网络连接。每个EventLoop都维护了它自己的选择器(Selector)和任务队列，能够处理成百上千的连接而不会创建与之对等的线程，降低资源消耗。链式的处理器ChannelHandler来处理网络事件。</li>
<li>tcp和udp：tcp面向连接，udp无连接。tcp提供可靠传输，流量控制，拥塞控制，udp尽力而为，不保证数据包顺序、完整性、正确性，不会自动重传。tcp点到点的，面向字节流，传输慢，首部开销大20-60字节，适合文件传输、网页。udp一对一多对一多对多一对多，面向报文，传输效率快，不可靠，首部开销小8字节，适合视频通话。</li>
</ul>
<h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><ul>
<li>Netty是什么：提供异步的基于事件驱动的网络应用程序框架。用来快速开发高性能、高可靠性的网络IO程序，最流行的NIO框架。Elasticsearch、Dubbo、gRpc、Zookeeper、Rocketmq都用Netty。NIO、Seletor选择器、事件驱动、回调异步。</li>
<li>Netty的事件驱动：事件如连接打开、数据到达、连接关闭均以异步方式处理。提供EventLoop处理IO事件，其中ChannelHandlers响应事件。发起IO后，立即返回ChannelFuture对象，开发者在上面增加监听器ChannelFutureListener，在IO完成时收到通知。回调机制和Future的异步编程模型。</li>
<li>Reactor模型：事件驱动架构的一种实现方式。一个单线程监听就绪IO事件，并将IO事件分发给回调函数。Acceptor处理新连接，Reactor分派事件分派给Handler，Handler事件处理。NIO就是。</li>
<li>Netty优点：高并发基于NIO、传输快零拷贝、封装好、内存池设计使用直接内存、高性能序列化协议Protobuf</li>
<li>Netty应用场景：RPC框架的网络通信工具、实现HTTP服务器、实现即时通讯系统、消息推送系统</li>
<li>Netty相比原生NIO优势：易用性（封装API）、稳定性（修复了select空转导致CPU100%问题）、高性能（对象池复用和零拷贝技术）、Netty异步基于事件驱动</li>
<li>Netty和Tomcat区别：Tomcat是用作Servlet容器的Web服务器，Netty是异步事件驱动的网络应用框架。通信协议上，Tomcat基于http，Netty不仅支持http，可以通过编程自定义各种协议。Tomcat需要遵循Servlet规范请求与响应模型，Netty不需要。</li>
<li>Netty体系结构：1⃣️Channel：Socket的连接依据，创建、注册到EventLoop、连接到远程节点。2⃣️EventLoop：Executor在Netty的线程模型抽象，由EventLoopGroup分配管理。一个EventLoop可以被分配给多个Channel，一个Channel的IO操作由一个线程执行。作用是负载监听网络事件并调用事件处理器进行IO操作。3⃣️EventLoopGroup：线程池，通常两个，一个用于接受新连接，另一个用于处理已接受连接的数据传输IO操作。4⃣️ChannelHandler：处理具体的业务逻辑，用户自定义事件处理逻辑，如连接打开关闭、数据读取写入。5⃣️ChannelPipeline：ChannelHandler实例链，编排Handler事件处理器链式执行。6⃣️Bootstrap：启动类，用于配置整个Netty程序，进程绑定到端口、设置线程模型、事件处理流。分为服务端ServerBootstrap和客户端Bootstrap</li>
<li>Netty运行总结：Netty的服务端通过Channel处理每次的连接请求，Channel都会注册到EventLoop线程模型中等待排队或立即执行。EventLoop由EventLoopGroup管理和分配。Channel有四种生命状态，ChannaelHandler处理具体的业务逻辑，ChannelPipeline编排所有的Handler顺序执行。Bootstrap用于将这些逻辑成为一个可运行的程序，提供一个运行入口。</li>
<li>网关：客户端和服务之间的中介，简化网络结构，对外提供统一的访问接口。功能：路由转发、负载均衡、鉴权、限流、监控。Netty可实现网关，实现WebSocketHandler，两个EventLoopGroup，通过ServerBootstrap引导，异步调用的Channel方式，执行ChannelPipeline中的ChannelHandler。</li>
<li>Netty线程模型：使用事件循环EventLoop处理IO操作，每个EventLoop绑定到一个线程，服务多个Channel，负责调度和执行ChannelPipeline中的ChannelHandler。EventLoopGroup一个接收新连接的boss和负责已连接的worker。实现Reactor模式，每个EventLoop包含一个Selector选择器来监听注册在其上的channel事件。</li>
<li>Netty服务端启动过程：1.创建主从EventLoopGroup实例 2.初始化服务端启动引导ServerBootstrap实例，配置启动参数  3.设置ChannelPipeline，添加自定义ChannelHandler来处理事件和数据交互 4.ServerBootstrap的bind方法绑定服务器监听的端口，启动服务器来接收客户端连接 5.sync方法阻塞等待直到服务器绑定操作完成，随后进入服务模式</li>
<li>Netty的无锁化体现在哪：串行无锁化设计，在IO线程内部进行多个Handler串行操作，期间不进行线程切换，避免多线程导致的锁竞争。</li>
<li>Netty如何解决epoll空轮询的：使用NIO的epoll选择器时遇到无效的文件描述符而无限循环。Netty维护一个计数器监控epoll_wait返回次数，如果没有任何IO事件情况下连续多次返回，认为空轮询，Netty会重建Selector，将原来的Channel重新注册到新的Selector上。</li>
<li>拆包和粘包：TCP面向流，没有界限的一串数据，会根据TCP缓冲区的实际情况进行包的划分。通过上层应用协议设计来解决：1.消息长度固定 2.特殊分隔符作为结束标志 3.消息头定义消息长度</li>
<li>Netty解决拆包和粘包：依靠提供的一系列解码器（Decoder），能够根据应用层协议将接收到的字节流重新组合成有意义的数据单元（消息或帧）。</li>
<li>Netty零拷贝：使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。Netty的Zero-copy完全是在用户态（Java应用层）的，偏向于优化数据操作。OS层面的Zero-copy通常是避免在用户态和内核态之间的拷贝数据。</li>
<li>TCP长连接和短连接：TCP的长连接和短连接由应用层面决定。短连接是建立连接读写完成后关闭连接，每次建立连接消耗资源。长连接是读写后不关闭连接，后续继续使用。</li>
<li>Netty长连接和心跳机制：TCP长连接中可能出现断网异常，因此引入心跳机制，在client和server之间没有数据交互时给对方发送特殊数据包，对方收到后回应一个（PING-PONG交互），表示仍然在线。</li>
<li>Netty对象池技术：对象池缓存创建好的对象，避免需要时才创建。Netty中buffer是对数据的抽象，数据拷贝时用到，代表可读写的内存区域，通过ByteBuf类实现，Netty会对其进行池化，减少内存分配和垃圾回收开销。</li>
<li>Netty序列化协议：不强制使用特定的序列化协议。它提供了灵活的编解码器机制，允许开发者根据需要使用不同的序列化协议：json&#x2F;pb。</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li>设计模式：23种，为复杂解耦，将一大坨代码拆分成职责单一的模块，满足高内聚低耦合、开闭原则（不改变现有代码的基础上扩展功能）。创建型：创建和使用解耦。结构型：不同的功能代码解耦。行为型：不同的行为代码解耦。</li>
<li>面向对象的四大特征：封装（封装成对象，隐藏实现细节，private public控制访问权限）、抽象（忽略不同，抽象相同点，继承抽象类is a和实现接口has a）、继承（继承父类的属性和方法，允许重用和扩展）、多态（重载是静态，重写Override是动态）</li>
<li>创建型模式：封装复杂的创建过程，解耦对象创建和使用。单例模式：创建全局唯一对象。工厂模式：创建不同但相关类型的对象（同一父类&#x2F;接口），给定参数决定对象类型。建造者模式：创建复杂对象，设置不同可选参数定制化对象Builder。原型模式：创建成本大，复制已有对象进行创建。</li>
<li>单例模式：一个类创建全局唯一实例，提供全局访问点。spring容器一级缓存即单例池，ApplicationContext.getBean获取bean。唯一访问性能高，不适合有状态的。</li>
<li>单例模式实现：1⃣️饿汉式：类加载时就创建，线程安全，但无法延迟加载。2⃣️懒汉式：第一次使用时才创建，延迟加载，但多线程下需要加锁保证线程安全避免创建多实例。3⃣️静态内部类：在外部类加载时不会被加载，只有第一次使用才加载并创建实例，JVM保证线程安全。4⃣️枚举类：天生单例。5⃣️双重检查锁定：既延迟加载又线程安全，同步外检查一次，同步块内检查一次，volatile+synchronized。</li>
<li>线程唯一单例怎么实现：ConcurrentHashMap、或ThreadLocal线程局部变量。</li>
<li>工厂模式：提供工厂类来代替new操作。Executors方法时静态工厂模式。1⃣️简单工厂模式：工厂类方法根据传入参数不同决定生成不同对象。2⃣️工厂方法模式：工厂接口，不同产品创建实现类，开闭原则。3⃣️抽象工厂模式：接口代表一个产品族。不同方法创建不同产品。</li>
<li>建造者模式：创建复杂对象，@Builder传入参数定制化。</li>
<li>原型模式：创建对象成本大，直接复制已有对象方式创建。浅拷贝：只对基本数据类型复制，引用数据类型进行引用传递。深拷贝：引用数据类型创建新对象并复制内容。实现：实现Cloneable接口，重写Object的clone方法。或序列化实现。</li>
<li>代理模式：结构型模式，给某对象提供代理，由代理对象控制对真实对象的访问，直接调用变间接调用，不改变原代码前提下增加功能：鉴权、统计、监控、限流。1⃣️静态代理：在运行前就创建代理类，实现相同接口&#x2F;继承实现类。2⃣️动态代理：运行期间通过反射动态创建代理类，运行前不存在代理类字节码文件。不需要为每个代理类创建代理对象。</li>
<li>适配器模式：允许不兼容的接口之间交互，创建一个中间层，将一个接口转换为适配的接口。类适配器：继承实现。对象适配器：组合实现。例如Spring MVC中提供不同的HandlerAdapter适配不同的处理器，供DispatchServlet处理HTTP请求。Spring AOP中提供不同的适配器AdvisorAdapter来封装不同类型的通知。</li>
<li>观察者模式：行为型模式，基于发布订阅，对象发生变化时进行通知。同步阻塞：阻塞消息发布者。异步非阻塞：使用消息队列，非阻塞地通知观察者。</li>
<li>模版模式：通过定义一个算法的骨架，并将一些步骤的实现延迟到子类。算法结构不变，子类重新定义算法。例如JdbcTemplate。</li>
<li>策略模式：行为型模式，定义一个算法接口，不同算法实现该接口，上下文类表示使用策略的类，维护一个指向策略接口的引用。可以轻松增加、替换算法。</li>
<li>责任链模式：多个不同的处理类对象Handler组成一条链，请求在链上传递，链上每个对象处理，返回&#x2F;传递给下一个对象。</li>
<li>Spring中的设计模式：1⃣️单例模式：Spring容器单例池，bean都是单例的。2⃣️工厂模式：BeanFactory和ApplicationContext创建Bean。3⃣️代理模式：Aop功能使用JDK动态代理和Cglib动态代理。4⃣️模版模式：JdbcTemplate提供一套模板方法来处理数据库的连接、执行 SQL 语句、处理结果集。5⃣️观察者模式：Spring事件驱动模型，ApplicationEvent事件、发布者、监听器。6⃣️适配器模式：Spring MVC中适配不同的处理器Controller。AOP中适配不同的通知Advice。</li>
<li>工作中用到的设计模式：1⃣️单例模式：数据库连接池、XStream用来进行xml序列化反序列化，反复创建回造成ygc，使用单例模式。2⃣️工厂模式：根据不同业务类型返回对应的业务处理类。实现InitializingBean接口，重写afterPropertiesSet方法，用Map维护不同业务类的引用。3⃣️观察者模式：报警系统，定义事件类继承ApplicationEvent，业务类中使用applicationContext.publishEvent(ApplicationEvent)来发送事件，定义监听器EventListener，监听消息发送报警。4⃣️责任链模式：轨迹处理流程：解析、切分、抽稀、匹配、入库，定义责任链HandlerChain，按照流程处理。</li>
</ul>
<h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><ul>
<li>zookeeper：分布式协调服务，用来管理hadoop生态圈的。为分布式应用提供一致性服务的软件，功能：配置管理、服务发现、领导者选举、集群管理。</li>
<li>zookeeper为什么使用集群：1.高可用性，单节点失败仍可运行。2.数据一致性，ZAB协议实现所有节点数据一致性。3.负载均衡，分散负载。4.可伸缩性。</li>
<li>zooleeper架构：1.Client连接到一台Server，向server获取信息，周期性发送心跳给server，server回复ack，没回复则重定向一台server。2.Server包括一台Leader和多台Follower。3.ensemble表示一组服务器，至少3台。4.Leader，服务启动时进行Leader选举，负责处理写操作，在集群中同步数据。5.Follower跟随者，处理读操作，数据冗余，转发写请求，参与投票。</li>
<li>zookeeper中数据结构：和Unix文件系统类似，看作一棵树，节点称为Znode，存储1MB数据，通过其路径唯一标识。不能存大数据。create命令创建数据，get命令获取目录的值，用多版本并发控制来解决并发，set修改。</li>
<li>zookeeper三种目录节点znode类型：1.持久目录：创建之后一直存在，直到显式删除，存储长期有效的配置信息和系统状态信息。2.临时目录：在client活动期间有效，断开自动删除，不能有子目录。常用于锁和服务发现机制，例如标记某个资源正在被使用，或一个实例的注册信息。3.顺序目录：在指定路径后增加一个单调递增的计数器作为后缀，生成唯一的标识符，用于分布式锁中的实现队列顺序。</li>
<li>zookeeper分布式锁：顺序临时节点+watch监听器。创建一个锁节点&#x2F;locks，请求获锁，需要在该目录下创建一个顺序临时节点，然后判断自己是不是最小节点，是则获取到锁，不是则创建一个监听器监听比自己小一的上一个节点，上一个节点删除（手动删或断开连接自动删除）则该节点获取到锁。</li>
<li>zookeeper的观察者模式：zookeeper&#x3D;文件系统+通知机制。zookeeper允许客户端设置对znode的监视（watch），典型的发布-订阅模式，节点发生变化时，客户端会被通知。特点：一次性（监视被触发后会被移除），可以对分布式环境中的状态变化快速做出反应。</li>
<li>zookeeper的leader选举：最小号选举法：每个节点投票给自己，节点之间互相发送自己的投票，节点收到投票后评估选择最小id的节点成为领导者。当一个节点收到超过半数节点支持同一id的投票时，节点认为领导者已选好。考虑节点id和最大的事务id（zxid），确保领导者是数据最新的节点。</li>
<li>zookeeper的ZAB协议：原子广播协议，保证数据一致性。负责服务之间的数据复制（顺序一致性的）和领导者选举过程中的状态同步。1⃣️消息广播：类似两阶段提交，Leader接收写请求，请求封装成事务，事务zxid保证顺序，发送给所有Follower，超过半数成功响应则执行commit。未响应的随后同步。2⃣️崩溃恢复：选举数据最新的节点作为Leader，与集群中其他节点同步状态。</li>
<li>zookeeper集群搭建：准备至少三台服务器，安装zookeeper，zoo.cfg配置文件中设置数据目录，设置连接端口，配置服务器列表。启动zookeeper服务。</li>
<li>zookeeper如何保证hadoop高可用的：1⃣️故障切换和Leader选举：Zookeeper故障转移控制器ZKFC监控和处理NameNode的故障切换，协助备用NameNode成为主节点保障HDFS高可用。ResourceManager也是。2⃣️集群元信息同步：zookeeper提供一致性的分布式数据管理，Hadoop的组件可以利用zookeeper维护和同步系统信息如配置信息、集群状态。3⃣️服务发现：zooKeeper 可以作为一个服务注册表，帮助客户端发现当前可用的服务地址。</li>
<li>zookeeper的应用：Kafka中zookeeper用于集群管理和协调，包括 Broker 的注册、领导者选举、集群配置管理等。还是Kafka 集群元数据的存储中心。HBase中zookeeper用于领导者选举、存储集群元数据。</li>
</ul>
<h2 id="hadoop"><a href="#hadoop" class="headerlink" title="hadoop"></a>hadoop</h2><ul>
<li>hadoop：分布式计算框架，用于在分布式服务器集群上存储和处理大数据集的框架，包括底层存储框架HDFS、分布式计算框架MapReduce、资源调度系统YARN。可以分布式运行PB级别数据。Zookeeper提供协调服务，例如HBase中集群协调领导者选举。</li>
<li>HDFS：分布式文件系统，将文件数据存储在多台机器组成的集群上，每份数据具有多个备份，更可靠。</li>
<li>HDFS架构：主从结构，一个主节点namenode，多个从节点datanode。1⃣️namenode负责接收用户请求，维护文件目录结构、管理文件和block(文件被分为块)的关系以及block和datanode的关系。2⃣️datanode负责存储文件，文件被分成block存储（128M&#x2F;256M），在不同datanode上有多个副本。文件索引与实际数据分离。对硬件要求不高，可存储超大文件，目标是高数据吞吐量。</li>
<li>mapreduce：分布式运算程序的编程框架，用于大数据集的并行运算，海量计算任务分而治之。计算任务分摊到各个计算节点并行计算，汇总得到最终结果。分布式的，抽象了并行处理的复杂度，开发者只需要实现Mapper和Reducer。</li>
<li>mapreduce核心步骤：map拆解（处理输入的键值对，执行定义的Map函数，生成中间键值对）、reduce组合（汇总每个键的值，生成最终结果）。具体可分为：Split、Map、Combiner、Shuffle、Reduce。</li>
<li>split：将输入文件切割为若干块，每一块由不同节点处理。将文章分为不同句。</li>
<li>map：将每个节点的原始数据处理为中间数据，输入输出都是kv。</li>
<li>shuffle：洗牌，因为split是随机的，导致相同key数据处理在不同节点。shuffle将map后的结果重新分组，相同key给到同一reduce节点。</li>
<li>combiner：减少shuffle需要的网络IO操作，对Map后的结果提前做一次归约，相同key组成一条。</li>
<li>mapreduce的架构：计算向数据靠拢，使用主从架构，一个JobTracker接收客户端提交的计算任务，把计算任务分给TaskTracker执行，进行调度、监控。多个TaskTracker执行分配的计算任务。</li>
<li>JobTracker：跟踪任务的执行进度、资源使用量等信息，将这些信息告诉任务调度器TaskScheduler。</li>
<li>TaskTracker：使用slot划分节点资源（CPU、内存），将slot分配给MapTask和ReduceTask。2.0用YARN来进行资源调度。</li>
<li>YARN：负责资源管理、任务调度的框架。基于主从模式的分布式架构。一个ResourceManager，多个NodeManager其中包含ApplicationMaster和Container。1⃣️ResourceManager是中控模块，负责整个集群资源的管理和分配。2⃣️NodeManager是每个节点上的资源和任务管理器，启动管理container。3⃣️ApplicationMaster每个应用的调度和协调，向RM申请资源，告诉container做什么。4⃣️Container资源容器，程序执行环境，封装任务所需的资源：cpu、内存。</li>
<li>自己使用mapreduce：在odps处理大规模数据时，map任务组织数据键值对，定义key和value，key位分组依据adcode，value为数据。reduce中数据已经按照adcode进行了分组，在分组中做数据处理计算。</li>
<li>MaxCompute：odps，大规模数据计算服务，负责存储和处理大量数据。</li>
<li>DataWorks：数据开发与管理平台，负责流程设计、调度、管理，提交到 MaxCompute中执行计算任务。</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul>
<li>10G文件1G内存怎么排序：外部排序，分隔为小的文件块，对每个小文件放入内存进行排序，排序结果写回磁盘。对多个排序结果进行归并排序，使用优先队列（最小堆），归并过程中，每次从堆中取出的最小元素被挨个写入最终的输出文件中。</li>
<li>直接选择排序：第一次从arr[0到]arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]到arr[n-1]中选取最小值，与arr[1]交换。总共n-1次。</li>
<li>插入排序：逐渐构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</li>
<li>堆排序：通过构建二叉堆，不断移除堆顶元素并重建堆，最终得到一个有序序列。</li>
<li>归并排序：归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表</li>
<li>希尔排序：希尔排序又叫缩小增量排序，把所有的数据按照下标间隔进行分组，在每个组内进行插入排序。排完之后缩小分组数，再插入排序。不断缩小组的间距。直到只分一为组。</li>
<li>排序复杂度：快排时间Onlogn空间Ologn不稳定。冒泡时间On空间O1稳定。</li>
</ul>
<h2 id="计算机原理"><a href="#计算机原理" class="headerlink" title="计算机原理"></a>计算机原理</h2><ul>
<li><p>网络分层：物理层（比特流的透明传输，中继器、集线器）、数据链路层（传送帧MAC、网卡、网桥、交换机）、网络层（选择合适的路由，IP、ICMP、路由器、防火墙）、传输层（TCP、UDP）、应用层（DNS、HTTP、SMTP、FTP）</p>
</li>
<li><p>TCP的安全性：三次握手（客户端SYN，服务端ACKSYN，客户端ACK）、四次挥手（客户端FIN、服务端ACK、服务端传输完FIN、客户端ACK）</p>
</li>
<li><p>tcp流量控制：避免发送方发送得太快接收方来不及处理，滑动窗口的方式，接收端告诉客户端确认序列号和还能接受多少数据。发送端调整滑动窗口（已发送未确认、为发送可接受）。更新窗口信息可能丢失，设置0窗口探测报文。</p>
</li>
<li><p>tcp拥塞控制：防止过多数据注入网络。慢开始（加倍达到慢开始门限）。拥塞避免（拥塞窗口+1），如果拥塞，门限减半，窗口变1，执行慢开始。快重传：接收方收到失序报文发出重复ACK，发送方收到三个重复确认，就重传。快恢复：失序报文后，慢开始门限减半，拥塞窗口设为减半后的门限，执行拥塞避免。</p>
</li>
<li><p>tcp不提供加密功能，需要应用层的TSL&#x2F;SSL。两台服务器间可以建立多个tcp连接（socket&#x3D;ip+端口号不同即可）</p>
</li>
<li><p>输入url发生什么：1.DNS解析获取ip，浏览器缓存-路由器缓存-DNS缓存。2.根据ip建立TCP连接。3.浏览器向服务器发送http请求。4.服务器响应http请求。5.浏览器进行渲染。</p>
</li>
<li><p>tcp&#x2F;ip理解：IP协议是网络层的协议，使用分组交换技术来传输数据，通过路由器进行转发，最终到达目的地。无连接性、无状态性、不保证可靠传输。TCP是传输层协议，主要负责在IP协议提供的基础上实现可靠的、有序的、有连接的和无差错的数据传输。</p>
</li>
<li><p>cookie、session、token：1⃣️cookie用来保存一些信息在客户端比如记住密码和推荐显示。2⃣️session用来标识一次会话，记录用户状态，在一次会话期间共享数据。用户首次访问服务器时创建一个session，session id设置为cookie保存在浏览器。3⃣️token用来做密钥快捷登录的。</p>
</li>
<li><p>cookie、session、token：生成位置都在服务器，cookie和token保存在客户端，session保存在服务器。鉴权过程：请求携带cookie与服务器记录cookie对比确认用户状态。session用请求中session id提取，恢复用户状态。请求携带token与服务器通过请求信息生成token对比。</p>
</li>
<li><p>http状态码：301永久重定向。302临时重定向。400服务端无法理解客户端请求。401未授权，需要用户身份认证。403禁止访问，服务端拒绝。404未找到请求的资源。500服务端内部错误。</p>
</li>
<li><p>DNS基于什么协议：DNS域名解析系统，应用层，用于将人类可读的主机名转换为机器可读的IP地址。主要基于UDP进行工作，但当响应数据大小超过报文限制，或者需要更可靠传输时，用TCP。</p>
</li>
<li><p>DNS过程：解析域名时，首先检查本地DNS缓存，如果未找到，请求将发送至配置的递归DNS服务器，递归DNS服务器会进行一系列迭代查询，从根服务器开始，逐级向下询问直到找到该域名的权威DNS服务器，获取对应IP地址。沿着查询链路返回给用户的设备。</p>
</li>
</ul>
<h2 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h2><ul>
<li>边缘计算：一种分布式计算框架，在靠近数据生成的位置（边缘）处理数据的方法。将计算能力下放到网络的边缘，边缘网络基本上由终端设备、边缘设备、边缘服务器等构成。特点：低延迟、节省带宽、提高隐私和安全性、实时数据处理。应用场景：物联网（IoT）、智慧城市、无人超市。</li>
<li>边缘计算和云计算：边缘计算采用分布式计算架构，将运算分散在靠近数据源的近端设备处理，分担云平台的工作量，不需要把数据回传云端处理，实时性更好、效率更高、延迟最短，没有网络也不妨碍。</li>
<li>k8s：Kubernetes是一个开源的容器编排系统，用于自动化部署、扩展和管理容器化应用程序。由google设计。</li>
<li>docker：容器化技术允许将应用程序及其依赖项打包到一个轻量级、可移植的容器中，使得应用程序能够在任何环境中一致地运行。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bredismysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bredismysql/" class="post-title-link" itemprop="url">那些年背过的面试题之redis&musql</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-24 22:22:24 / Modified: 22:24:11" itemprop="dateCreated datePublished" datetime="2025-07-24T22:22:24+08:00">2025-07-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><ul>
<li><p>redis分布式锁原理：1⃣️setnx键不存在时设置，expire过期时间避免死锁。2⃣️看门狗机制，如果客户端仍在运行，自动续租锁。3⃣️自旋，尝试自旋固定时间。固定次数。4⃣️lua脚本用于执行复杂操作，并保证原子性。5⃣️redis分布式锁不完全可靠，主从复制，主节点同步到从节点之前崩溃，从节点升级，又获取到锁。</p>
</li>
<li><p>redis集群：1⃣️自动分片：数据划分为多个哈希槽，每个节点负责多个哈希槽。2⃣️无中心架构：节点对等，无中心节点。3⃣️主从复制：一个节点可以有多个从节点，实现故障恢复、数据冗余、读写分离。</p>
</li>
<li><p>redis两种同步策略：全量RDB文件、增量同步AOF</p>
</li>
<li><p>redis持久化：redis数据存在内存中，持久化机制将数据存储到磁盘文件。RDB快照是某个时间点数据的二进制全量备份。AOF日志是修改内存数据的指令记录。</p>
</li>
<li><p>redis的RDB：redis是单线程的，为了不阻塞请求响应，fork子线程进行快照持久化，持久化期间，两线程共享一份实体资源，只有在写操作发生时，共享的内存页会被复制，副本供写操作使用（写时复制），最小化对主进程影响。</p>
</li>
<li><p>redis的AOF：使用fsync命令将指令记录存入AOF文件，每1s执行一次</p>
</li>
<li><p>redis重启使用哪种持久化：都开启的话使用AOF持久化，因为包含更完整的操作历史记录。</p>
</li>
<li><p>redis哨兵机制：保证高可用，实现集群监控故障转移。多个sentinel节点。1⃣️监控：sential节点与其他master&#x2F;slave&#x2F;sentinel节点发送PING做心跳检测，交换信息监控主从拓扑。2⃣️主观客观下线：主观一台认为，客观大多数认为。3⃣️哨兵选举：sentinel选出一个leader做故障转移，raft算法，1.节点认为主管下线就申请成为leader，2.其他节点没有答应别人就答应他，3.票数达标就成为leader。4⃣️故障转移：根据从节点优先级选择新的master节点，sentinel leader向其他节点发送命令，并关注原master。</p>
</li>
<li><p>redis双写一致性：更新操作同时写入数据库和缓存，因为分布式系统中网络延迟、系统故障等原因，导致两者数据不一致，解决：1.先写数据库再删缓存：高并发可能会多次缓存穿透，增加数据库压力。2.先写数据库再更新缓存：不会缓存穿透，但是更新缓存操作需要并发控制防止竞争。更高级：消息队列保障顺序、分布式锁。</p>
</li>
<li><p>redis延时双删：在删除数据时，防止删除不能完全同步，首先删除数据库记录，再第一次删除缓存记录，延时短暂时间后，再删一次缓存。避免缓存网络抖动未删除。如果之间又写入，缓存穿透一次读到数据库。</p>
</li>
<li><p>redis缓存击穿：单个key访问并发过高，过期时请求直接打在DB上，数据库压力大。解决：加锁，缓存没有就对key加锁查库后更新缓存、将过期时间也写在value中，异步刷新过期时间、接口限流降级熔断。</p>
</li>
<li><p>redis缓存穿透：查询在缓存和DB不存在的数据时，都打到DB，就像缓存不存在。解决：在请求缓存前加布隆过滤器，筛掉一定不存在的数据。</p>
</li>
<li><p>redis缓存雪崩：大批量数据同时过期，大量请求直接打到DB。解决：缓存数据过期时间设置随机，热点数据均匀分布在不同缓存数据库。</p>
</li>
<li><p>布隆过滤器：快读判断一个元素是否在集合中，可能误判不会漏判。实现：长度m的位数组、k个哈希函数得到k个位置，将对应位置为1。查找时看是不是所有哈希函数得到的位都是1.</p>
</li>
<li><p>RDBMS和NoSQL：关系型数据库（组织化结构，行列格式）、Not only sql（数据存储没有固定格式，可横向扩展）。RDBMS：固定查询语言、事务一致性ACID。NoSQL：无固定查询语言、键值redis、列存储HBase、文档MongoDB、图形存储Neo4j、最终一致性BASE。</p>
</li>
<li><p>redis：远程字典服务，键值对，数据缓存在内存，周期性持久化到磁盘、主从同步、哨兵机制高可用。应用：高速缓存、计数器。</p>
</li>
<li><p>redis数据结构：1⃣️String：最大512M，实现：未使用C语言字符串，自己实现简单动态字符串SDS，带长度信息，embstr编码和raw编码，字符串修改时检查字符串长度避免缓冲区溢出，减少内存重新分配次数。2⃣️列表List：双向链表型数据结构，可两端插入弹出，可指定下标&#x2F;范围获取。实现消息队列、分页。实现：quikList，外层是双向链表linkedList，每个节点是zipList压缩列表，将多个元素序列化存储在一块连续内存中。3⃣️Set集合：不允许重复，没有顺序，支持多集合间并集交集差集操作。实现：如果元素都整数且数量较少，使用intset整数集合压缩数据结构。否则使用hashTable。4⃣️zset有序集合：给每个元素多设置一个分数，作为排序的依据。实现：hashTable存储元素到分数的映射，快速查询和更新分数。跳跃表skiplist维护元素的有序性，并提供高效范围查询。5⃣️hash：存储key-value记录。实现：当字段和值数量不多时，使用压缩列表zipList。否则使用哈希表hashtable，每项都包含指向键的指针和指向值的指针。</p>
</li>
<li><p>redis为什么快：1.完全基于内存 2.单线程无上下文切换成本 3.基于C语言，优化过的数据结构 4.基于非阻塞的IO多路复用和事件驱动模型，使用Seletor监视所有注册的通道，IO事件发生时进行通知。单线程高效处理大量并发连接。</p>
</li>
<li><p>redis6.0改用多线程：依然使用单线程处理客户端请求，只是多线程处理数据读写和协议解析。redis性能瓶颈在网络IO而非CPU。</p>
</li>
<li><p>redis热key问题：某个key大量并发打到一台服务器，达到网卡上线，宕机。缓存雪崩。解决：热key打散在不同服务器。提前加载热key到内存，内存做二级缓存。</p>
</li>
<li><p>redis设置过期时间：expire key seconds；set key value EX seconds；底层采用过期字典存储键的过期时间。</p>
</li>
<li><p>redis过期策略：1⃣️惰性删除：查询key时才对过期时间检测，已过期删除。2⃣️定期删除：定期执行过期键的扫描和删除，避免消耗过多计算资源，使用采样的过程随机抽取，如果过期的多就再抽样。3⃣️都没删除的：等redis内存淘汰机制。</p>
</li>
<li><p>redis内存淘汰：LRU最近最久未使用，淘汰最长时间没有访问的。链表&#x2F;哈希表+双向链表。redis中使用近似的LRU，随机抽取一些键，检查最后访问时间戳，淘汰最久未访问的。</p>
</li>
<li><p>redis高可用：主从架构、哨兵、持久化</p>
</li>
<li><p>redis事务：1⃣️事务是一组命令的集合，数据库事务通过ACID保证，undo log撤销日志。2⃣️redis中事务机制：通过MULTI、EXEC、WATCH 和 DISCARD 四个命令提供。MULTI开启事务，输入多个命令，不会立即执行而是放入一个队列，调用EXEC命令才会将队列中命令原子执行。3⃣️事务监控：WATCH命令设置监控的键，在事务操作之前就监控，如果EXEC之前键被其他客户端修改，则不执行DISCARD。是一种CAS乐观锁的机制。</p>
</li>
<li><p>redis操作一个命令最耗时的地方：网络IO延迟：尽可能使用长连接或连接池。数据持久化延迟：合理配置RDB快照和AOF Rewrite时机（每秒？每条指令？），避免频繁的fork带来的延迟。数据淘汰引发的延迟：避免同一时间大量key过期。</p>
</li>
</ul>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><ul>
<li><p>RDBMS和NoSQL：RDBMS关系型数据库（组织化结构，表格行列格式，Mysql、Oracle、PostgreSQL）、Not only sql非关系型数据库（数据存储没有固定格式，可横向扩展）。1⃣️数据结构：结构化与非结构化，键值redis、列存储HBase、文档MongoDB、图形存储Neo4j。2⃣️数据关联：sql中多张表可关联，nosql数据之间无关联。3⃣️查询语言：sql固定查询语言，nosql不固定查询语言。4⃣️事务一致性：sql提供强一致性和完整事务支持，nosql提供BASE基本可用、软状态、最终一致性。5⃣️存储方式：sql存在磁盘，nosql存在内存。6⃣️扩展性：sql垂直扩展，升级单个服务器的内存cpu存储空间。nosql可水平扩展，分布式存储。</p>
</li>
<li><p>数据库事务：一条&#x2F;多条语句组成，要么全部执行要么全部不执行的执行单元。1⃣️原子性：最小执行单元，操作失败时undo log来回滚。2⃣️一致性：事务执行前后数据保持一致。3⃣️隔离性：并发执行的事务之间不会互相干扰，MVCC、锁机制实现不同隔离级别。4⃣️持久性：事务一旦提交对数据库的修改是永久的，系统崩溃时使用redo日志来恢复。</p>
</li>
<li><p>redo日志和undo日志：1⃣️redo log：重做日志，保障持久性，系统崩溃时恢复数据。物理日志，记录数据页的物理修改操作。更新先写入redo log，再空闲时更新到磁盘，预写式技术减少IO频率。2⃣️undo log：撤销日志，保障原子性，回滚时恢复数据。逻辑日志，记录数据操作的逆向操作。还提供一致性读，即使数据被修改也能从undo log访问到修改前的数据。</p>
</li>
<li><p>事务的隔离级别：事务隔离级别定义了一个事务可能受其他事务影响的程度。1⃣️读未提交：可能脏读（读到其他事务未提交的修改）。2⃣️读已提交：不可重复度（事务内两次读到数据不一致）。3⃣️可重复度：默认的，幻读（可能读到第一次读没有的新纪录，行数不一致）。4⃣️串行化：事务串行执行，强制锁定事务访问的数据，锁竞争。（表级锁）</p>
</li>
<li><p>解决不可重复度：MVCC多版本并发控制，同一时刻不同事务读取到不同版本的数据。实现：隐藏列、undo log、版本链。每行数据多个隐藏列（版本号、删除时间、指向undo log的指针），undo log通过回滚指针把一个数据行所有快照连接起来形成一个版本链，使用事务版本号比较来控制数据版本。优点：避免加锁，允许读写操作并发执行。</p>
</li>
<li><p>mysql的锁：表锁、行锁（Innodb有，通过给索引项加锁实现，如果没有索引相当于表锁）。共享锁、排他锁。insert、update、delete操作innodb会自动给涉及到的数据加排他锁。select for update加排他锁。select lock in share mode加共享锁。</p>
</li>
<li><p>间隙锁：Innodb中的，用于锁定一个范围，不是固定的行数据。Innodb中可重复读及更高级别使用的锁机制。可以避免幻读，避免其他事务在该范围内插入。</p>
</li>
<li><p>意向锁：Innodb中的锁机制，用来事务获行锁之前表明锁定意图，分为意向共享锁和意向排他锁。意向锁是表级锁，获行锁之前先获取对应意向锁，不需要检查每行的锁状态，通过意向锁了解表的锁使用情况。意向共享锁不阻塞其他意向共享锁，意向排他锁不阻塞其他意向排他锁。意向共享锁（IS）或意向排他锁（IX）会阻塞整个表的排他锁。</p>
</li>
<li><p>快照读和当前读：快照读：执行普通的select查询，Innodb使用MVCC进行快照读，不加行锁，不会阻塞其他事务的读写操作，提供一致性的非阻塞读取。当前读：显式加锁select、update、delete，会对对应数据行加排他锁，获取数据的最新版本。</p>
</li>
<li><p>Innodp和Myisam：InnoDB支持事务处理、行级锁定和外键约束，适合于高并发和需要强数据完整性的应用。MyISAM拥有较高的读取速度和全文索引支持，但不支持事务处理，只有表级锁定。</p>
</li>
<li><p>Mysql索引：数据库表中一个特殊的数据结构，帮助提高数据检索速率。使用B树和B+树作为索引的数据结构。Innodb中主键索引使用聚簇索引，B+树叶子结点存储表的实际行数据。非主键索引使用B+树，叶子结点存储对应行主键而不是行数据本身。Myisam中都是非聚簇索引，B+树叶子结点存储行数据的指针。</p>
</li>
<li><p>Mysql索引缺点：空间成本、维护成本（数据插入删除更新时索引也需要更新，导致更新操作变慢）。索引通常以索引文件的形式存储在磁盘。</p>
</li>
<li><p>Mysql中有哪些索引：主键索引、唯一索引、普通索引、全文索引、空间索引、组合索引、外键索引</p>
</li>
<li><p>B树和B+树区别：都是多路搜索树，自平衡。B+树所有的值存储在叶子结点，并且形成有序链表，适合范围查询，内部节点存储键和指向叶子结点的指针。更胖更低，IO效率高。B树每个节点都存储键和值，对于点查询更为高效。</p>
</li>
<li><p>哈希索引：Memory存储引擎使用，基于内存。散列算法使用哈希表很快O(1)，适合等值比较查询，不适合范围查询。如果重复的键会哈希冲突。Innodb中自适应哈希索引。</p>
</li>
<li><p>红黑树：自平衡的二叉搜索树，节点要么红色要么黑色，根节点黑色，红节点的子节点都是黑色，叶子结点都是黑色空节点。通过旋转、重新着色来维持平衡。</p>
</li>
<li><p>聚簇索引和非聚簇索引：聚簇索引：数据存储和索引放在一块，索引结构的叶子结点保存了行数据（主键索引）、非聚簇索引：数据和索引分开，索引结构的叶子结点存储行数据的指针（辅助索引）。聚簇索引中，表中数据的物理顺序和索引顺序一致，所以一个表只能有一个聚簇索引。</p>
</li>
<li><p>最左前缀匹配：联合索引中，查询时使用的where子句中的条件必须包含联合索引中最左边的列索引才能生效，如果跳过或使用范围查询，则后面列不能有效使用索引。因为B+树是有序的。</p>
</li>
<li><p>sql语句执行过程：1.建立连接 2.mysql8.0查看是否开启缓存 3.解析器进行语法解析，生成解析树，检查语法正确 4.优化器生成执行计划，查看是否可优化。5.执行引擎执行sql。</p>
</li>
<li><p>数据库三范式：1.列不可分割 2.所有非主键字段都依赖于主键 3.所有非主键字段直接依赖于主键。</p>
</li>
<li><p>回表查询和覆盖索引：回表查询是普通索引，先定位主键，再定位行记录，扫描两遍索引树。覆盖索引是索引中包含了查询所需的所有字段，直接从索引中获取数据，不需要回表查询，减少磁盘IO。</p>
</li>
<li><p>explain：展示如何执行select语句：如何使用索引、表连接顺序、估计扫描行数。</p>
</li>
<li><p>数据库优化：1.建索引，where order by group by涉及的列建立索引。2.索引优化，最左匹配原则，不使用like “%abc”。3.建立分区，如时间字段4.利用缓存redis，缓存热数据5.查询限定数据范围，如查询一个月内的6.读写分离7.分库分表，垂直拆分水平拆分8.数据异构到es9.冷热数据分离10.升级OceanBase</p>
</li>
<li><p>无法使用索引：!&#x3D;、is null、or、&gt;&lt;、in、not in</p>
</li>
<li><p>mysql中char和varchar的区别：char是固定长度的字符串，即使存储数据短于设计长度，会用空格填充，所以可以快速查询。varchar可变长度的字符串，只占用必要空间加一个额外的长度字节，节省空间但影响查询性能。</p>
</li>
<li><p>delete和truncate：delete删除表时会增加大量undo日志和redo日志，truncate会立即删除表中所有数据，不能回滚，快速释放占用的空间。</p>
</li>
<li><p>mysql主从复制：主服务器将变更记录到二进制日志（binary log）文件，从服务器连接到主服务器后，请求从上次停止的位置开始传送日志，存到中继日志relay log，开线程重放。数据冗余、读写分离、高可用性。</p>
</li>
<li><p>主从复制的数据一致性问题：主从复制有延时，可能造成读到不一致的数据。根据数据复制到从服务器对主服务器事务提交的影响，分为：1.异步复制（写入二进制日志之后确认事务提交，从服务器落后于主服务器，不一致风险高）2.半同步复制（等待至少一个从服务器收到二进制日志，主服务器故障时可以找到这个从服务器成为主）3.同步复制（等待所有从服务器，较高的数据一致性）</p>
</li>
<li><p>mysql集群架构：1⃣️一主多从架构：写操作都主库，从库负责读。2⃣️多级复制架构：一主和多从之间增加一个master2主库，表都是空表，仅负责转发binlog。减轻主库负担。3⃣️双主架构：master1和master2互为主从。</p>
</li>
<li><p>mysql分库分表：将数据分散在多个数据库和表中。垂直拆分：按照表的列来进行拆分，将一个表分割成多个表。水平拆分：按照表的行进行拆分，用某个id做哈希取余进行分散。挑战：数据一致性、跨库或跨表的事务处理、数据迁移和重新分片等问题。解决：两阶段提交会锁定资源。XA协议。事务补偿。</p>
</li>
<li><p>跨库事务：tddl不支持跨库事务提交，强一致性需要使用切面事务实现。最终一致性可以用状态机+定时任务实现。</p>
</li>
<li><p>自增id：1.redis提供incr命令，单线程。2.雪花id：41位时间戳（毫秒，能用70年），10位机器标识，12位序列号。</p>
</li>
<li><p>分库分表之主键id：需要一个全局唯一的分布式id：1⃣️数据库自增长id，根据表的数量设置步长，但是不能扩表了。2⃣️redis incr&#x2F;incrby命令生成自增长id。数据存在内存，实例宕机可能丢数据。3⃣️uuid：本地生产不占用网络资源，缺点是太长，不具备有序性。适合用于编号。4⃣️雪花算法：有序增长，全局唯一。每秒可生成四百多万id。分三段：时间毫秒级、集群+机器id、序列号。可灵活分配比特位。缺点：强依赖机器时钟，可能导致发号重复。美团Leaf分布式id中，引入zookeeper，服务向zookeeper获取机器id，zookeeper检测时间是否正确。</p>
</li>
<li><p>mysql和Oracle的区别：1⃣️oracle数据库是一个重量级对象关系数据库管理系统（ORDBMS），收费的。mysql是一个轻量级开源的关系数据库管理系统（RDBMS），开源的免费的。2⃣️安全性上：oracle验证用户的参数有很多，有着较强的安全性，mysql验证用户的参数只有三个（用户名、密码、位置），安全性较弱。3⃣️对事务的支持：MySQL在innodb存储引擎的行级锁的情况下才可支持事务，而Oracle则完全支持事务。4⃣️mysql的诊断调优方法较少，主要有慢查询日志。Oracle有各种成熟的性能诊断调优工具。5⃣️并发性：mysql虽然InnoDB引擎的表可用行级锁，但行级锁机制依赖于表的索引，如果表没有索引，或者sql语句没有使用索引，将使用表级锁。Oracle使用行级锁，对资源锁定粒度更小，不依赖于索引。6⃣️应用：Oracle应用于大型复杂的企业级应用，性能、可伸缩性、可靠性更强大。mysql应用于中小型应用。</p>
</li>
<li><p>mysql当前读和快照读：1⃣️快照读是指读取数据不需要等待其他事务对数据锁的释放，通过MVCC允许读取数据的历史版本，提供一致性视图，实现了非阻塞的读。普通的select操作就是快照读，RR可重复读和RC读已提交下的select是快照读。2⃣️当前读：读取数据的最新版本，并对读取的数据加锁（行锁或间隙锁）。常用于需要修改数据的场景，例如update、delete、select for update。在串行化隔离级别下，即使普通select也是当前读。</p>
</li>
<li><p>索引优化：建立合适的联合索引，达到覆盖索引，尽量保持区分度高的在最左</p>
</li>
<li><p>mysql的delete文件大小不变：Innodb采用延迟空间回收，删除数据仅做标记，不立即回收磁盘空间，避免频繁磁盘操作。数据文件以数据页为单位组织。而且delete会记录redo和undo日志，消耗IO资源和存储空间。使用：Truncate table删除表的所有数据并初始化。drop重建表，删除后重建。</p>
</li>
<li><p>drop、delete、truncate：delete可回滚，会触发表上的触发器。truncate删除表中所有数据，不能回滚，更快，占用空间小。drop删除表，触发器不会触发。</p>
</li>
<li><p>适合&#x2F;不适合建立索引：适合：频繁使用的、用来缩小查询范围的、需要排列的。不适合：查询中很少涉及的、重复值比较多的、特殊的数据类型如text的。</p>
</li>
<li><p>mybatis是否支持延迟加载：延迟加载是用到数据时才进行加载，避免一次性加载大量关联数据，提高查询效率。配置文件中可以设置延迟加载，按需取材。底层使用CGLIB动态代理实现，创建目标对象的代理对象，目标对象是开启延迟加载的mapper所映射的实体类。通过字节码技术运行时生成代理类，调用目标方法时，进入拦截器的invoke方法，执行sql查询以获取关联数据，注入到对象属性中。</p>
</li>
</ul>
<h2 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h2><ul>
<li>Mybatis保证跨库数据一致性？：Mybatis是一个持久层框架，不直接提供跨库调用数据一致性的解决方案。需要借助外部分布式事务解决方案：分布式事务框架、两阶段提交、最终一致性、分布式事务中间件XA协议。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/23/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bjava2024/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/23/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bjava2024/" class="post-title-link" itemprop="url">那些年背过的面试题之java2024</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-23 00:44:10" itemprop="dateCreated datePublished" datetime="2025-07-23T00:44:10+08:00">2025-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-24 22:22:18" itemprop="dateModified" datetime="2025-07-24T22:22:18+08:00">2025-07-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><ul>
<li>jvm内存模型：线程共有：堆（对象实例和数组）、方法区（被虚拟机加载的类信息、方法信息、字段信息、常量、静态变量、即时编译器编译后的代码缓存）、直接内存（非运行时数据，IO操作）。线程私有：虚拟机栈（一个方法一个栈帧：局部变量表、操作数栈、动态链接、返回地址）、本地方法栈（native方法）、PC程序计数器（下一条指令位置的指针）</li>
<li>jmm内存模型：多线程环境下对共享变量的同步，保证多线程环境下的可见性、有序性。主内存和工作内存，可见性volatile线程更改了工作内存中的共享变量其他线程能够立马看到，有序性volatile禁止指令重排synchronized锁，原子性synchronized和CAS无锁的原子操作</li>
</ul>
<h2 id="锁、并发编程"><a href="#锁、并发编程" class="headerlink" title="锁、并发编程"></a>锁、并发编程</h2><ul>
<li><p>java有哪些锁：内置锁synchronized、重入锁ReentrantLock、读写锁ReadWriteLock、条件锁Condition</p>
</li>
<li><p>synchronized：内置锁，控制对共享资源访问的同步机制，修饰实例方法、静态方法、代码块，原理：对象头MarkWord，记录hashCode、锁标志、GC年龄。修饰代码块monitorenter和monitorexist字节码指令。修饰方法flags指令，锁的计数器。锁升级：无锁、偏向锁（记录线程指针）、轻量级锁（CAS自旋）、重量级锁（阻塞线程）</p>
</li>
<li><p>volatile：轻量级的synchronized，保证共享变量的可见性，读写操作直接对主内存进行，不会引起线程上下文的切换和调度。禁止指令重排。lock前缀指令，相当于内存屏障。保证原子操作线程安全。非原子操作不保证，用AtomicInteger、CAS。</p>
</li>
<li><p>CAS：无锁的原子操作，用来在并发编程中实现无锁同步。非阻塞的，减少锁开销。ABA问题，导致自旋，消耗CPU，只能一个变量的原子操作。</p>
</li>
<li><p>ReentrantLock：可重入的互斥锁，可重入、API层面锁、可响应中断、可公平不公平、Condition分离对象的等待集合。原理：队列同步器AQS，中volatile变量state记录锁的状态和重入次数，CAS操作更新状态变量和加入等待队列和更新队列头节点，FIFO队列管理等待锁的线程。</p>
</li>
<li><p>Condition：条件锁，与ReentrantLock结合使用，更精细控制等待唤醒，有选择地唤醒等待中的线程。</p>
</li>
<li><p>公平锁和非公平锁：公平锁所有线程都会被阻塞，非公平锁获锁之前不管等待队列，减少唤醒线程上下文切换开销。</p>
</li>
<li><p>信号量Semaphore：控制对有限资源访问的计数器，实现资源池，控制并发数。permit为1时互斥锁。</p>
</li>
<li><p>闭锁CountDownLatch：用于等待一组线程都完成之后才继续操作，不可重用。</p>
</li>
<li><p>栅栏CyclicBarrier：一组线程互相等待都达到某个屏障点再继续执行，可重用。</p>
</li>
<li><p>读写锁ReadWriteLock：可同时读，写操作互斥，原理AQS，状态变量按位切割记录多个线程状态。锁降级：在释放写锁之前先获取读锁，避免在释放写锁和获取读锁之间其他线程修改变量，保证可见性。因为同一线程，所以允许获取读锁。</p>
</li>
<li><p>AQS：AbstractQueuedSynchronizer队列同步器，基于FIFO等待队列的同步框架，volatile和CAS实现同步状态管理，内置FIFO队列实现线程排队等待机制。构建各种阻塞性质的同步器。</p>
</li>
<li><p>锁优化：1.减小锁粒度：大锁变为不同的小锁来减少锁竞争提高并发，例如ConcurrentHashMap的分段锁。2.锁分离：读写分离ReadWriteLock读锁共享写锁独占。3.锁消除：不必要的不加锁，减少锁持有时间。4.锁粗化：短时间重复获取同一锁，将锁范围扩大，减少锁开销。5.使用无锁数据结构：CopyOnWriteArrayList，atomic下的原子类，volatile+cas，实现无锁的线程安全操作。</p>
</li>
<li><p>CopyOnWriteArrayList：线程安全的ArrayList。写时复制。读取的时候在当前数组进行，修改的时候，复制当前列表，在新列表上修改，然后将原列表引用指向新的列表。这个更新操作是原子性的，使用volatile 变量来存储底层数组的引用，写操作在读操作之前完成。</p>
</li>
<li><p>悲观锁和乐观锁：悲观锁认为冲突普遍存在，阻止并发访问保证一致性。乐观锁通过数据版本号来检测冲突，冲突之后撤销或重试。</p>
</li>
<li><p>死锁：多线程互相持有和等待对方的资源，形成循环等待。互斥条件、请求与保持条件、不可剥夺条件、循环等待条件。CAS破坏互斥条件，银行家算法分配资源之前先检查是否会死锁，破坏循环等待。</p>
</li>
<li><p>线程池：管理一系列线程的资源池，避免线程频繁创建销毁开销，提高响应速度。1.ThreadPoolExecutor构造函数创建（核心线程数、最大线程数、阻塞队列、最大线程存活时间、threadFactory、饱和策略）2.Executors工具类创建（不推荐，使用无界阻塞队列OOM，CachedThreadPool使用同步队列创建线程数无限制OOM）</p>
</li>
<li><p>线程池饱和策略：AbortPolicy抛出异常来拒绝、CallerRunsPolicy调用线程中运行、DiscardPolicy直接丢弃、DiscardOldestPolicy丢弃最早未处理的。</p>
</li>
<li><p>线程池阻塞队列：ArrayBlockingQueue基于数组结构的有界阻塞队列FIFO、LinkedBlockingQueue基于链表的无界阻塞队列、SynchronousQueue同步队列无容量、DelayQueue延迟无界阻塞队列，延迟期满时从队列取出、PriorityBlockingQueue支持优先级排序的无界阻塞队列。</p>
</li>
<li><p>线程池处理顺序：核心线程、任务队列、最大线程、饱和策略</p>
</li>
<li><p>ThreadPoolExecutor的execute和submit：1.execute是Executor方法，submit是ExecutorService方法。2.execute只接收Runnable，出现异常原地抛出。submit接收Runnable和Callable，返回Future，捕获异常在future.get方法中抛出。</p>
</li>
<li><p>happens-before：向程序员提供跨线程的内存可见性保证。volatile规则：对一个volatile的写happens - before后续对这个volatile的读。监视器规则：对一个锁的解锁happens - before随后对这个锁的加锁。线程生命周期规则：start、join。</p>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li>Thread的run方法和start方法：1.new一个Thread，调用start方法，表示启动一个线程，进入就绪状态，等待分配到时间片后运行。是多线程工作。2.直接执行run方法不会以多线程方式执行。</li>
<li>创建线程方式：1⃣️继承Thread类，重写run方法，创建对象调用start方法。2⃣️实现Runnable接口，重写run方法，创建对象作为参数传递给Thread的构造方法，调用start。或者传递给线程池的submit&#x2F;execute方法。3⃣️实现Callable接口，重写call方法，有返回，创建FutureTask对象，callable对象作为参数传递给FutureTask构造函数。将FutureTask对象作为参数传递给Thread构造函数，调用start。执行futureTask.get()方法获取线程执行的结果。</li>
<li>Runnable和Thread：1⃣️java单继承，Thread类有局限性。Thread类实现了Runnable接口。2⃣️Runnable更容易可以实现多个线程间的资源共享，提交给Thread同一个Runnable对象，共享其中的private对象。（只是共享，线程安全要加同步）。多个thread对象共享static变量。</li>
<li>Runnable和Callable：1.方法签名不同，Runnable是run方法，Callable是call方法。2.返回值类型不同，Runnable无返回，Callable的call方法返回指定类型结果，通过Future接口获取执行结果。3.异常处理不同：Runnable异常原地抛出，Callable的call方法通过Future.get方法来捕获异常信息。</li>
<li>线程状态：创建、就绪、运行、阻塞、等待、定时等待、终止。1⃣️start方法后等待JVM调度，就绪。调度到之后是运行。2⃣️运行到就绪：Thread.yield方法使线程从运行状态变为就绪状态，让出CPU资源给其他线程执行。3⃣️阻塞状态：线程运行过程中，发出I&#x2F;O请求时，该线程进入阻塞状态。当线程运行过程中尝试获取同步锁时，却被另一个线程获取，此时JVM把当前线程存到对象的锁池中，该线程进入阻塞状态。4⃣️阻塞到运行：获取到锁。5⃣️运行到等待：调用o.wait()方法和thread.join()方法（表示等待调用join方法的线程结束，当前线程才继续执行），进入等待状态。6⃣️定时等待：Thread.sleep方法进入等待状态，不释放锁。o.wait方法进入等待状态，释放同步锁，wait方法需要在同步方法&#x2F;代码块中。7⃣️notify方法唤醒在此对象监视器上等待的单个线程，进入就绪状态。</li>
<li>进程和线程：进程是操作系统资源分配的基本单元。线程是处理器任务调度和执行的基本单元。多个线程共享进程的堆和方法区，不共享栈和程序计数器。</li>
<li>ThreadLocal：是线程局部变量，线程私有，实现线程之间的数据隔离，避免使用共享变量的线程安全问题。注意在线程池中，线程被复用，需要及时清理，避免内存泄漏。</li>
<li>ThreadLocal和ThreadLocalMap的关系：ThreadLocalMap是ThreadLocal的内部数据结构，每个Thread对象有一个ThreadLocalMap对象，用于存储线程局部变量的键值对，键是ThreadLoca对象，值是ThreadLocal对象存的局部变量。每个线程可以有多个ThreadLocal对象。</li>
<li>ThreadLocal为什么内存泄露：每个线程的ThreadLocalMap，key是ThreadLocal对象（弱引用），value是存入的值（强引用）。ThreadLocal对象作为key是弱引用，外部强引用消失后，GC直接回收，但value还被强引用锁死。线程池中的线程反复利用，ThreadLocalMap跟着长寿。Map里的废弃物品（null key + value）越积越多，直到OOM。不调用set&#x2F;get&#x2F;remove，ThreadLocalMap不会自动清理null key的Entry。</li>
<li>ThreadLocal为什么不用强引用：用强引用→ThreadLocal对象永不回收，泄漏更严重！弱引用至少能回收key，给程序员一个补救机会。所以，用完必须要remove。线程结束会自动清理，但是线程池中的线程永不结束。</li>
</ul>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><ul>
<li>SPI：service provider interface，服务加载机制，META-INF中配置接口和实现，ServiceLoader运行时发现和加载实现，可动态替换服务实现。提供可扩展的方式，使得第三方服务可以提供新的实现或自定义功能，解耦接口和服务实现。应用：JDBC驱动加载，日志框架选择。</li>
</ul>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><ul>
<li>IO：涉及到数据的存储、交换，都用IO，文件IO、网络IO</li>
<li>BIO：同步阻塞IO，每来一个新连接就需要创建一个线程，数据的读取写入都需要阻塞在线程中。浪费线程资源，不适合单机过多连接。</li>
<li>NIO：同步非阻塞IO，线程发起IO操作，如果数据还没准备好，可立即返回执行其他任务。数据写入读取不再阻塞，但是需要等待IO操作完成，可同时处理多个Socket请求。适用连接多且比较短的。</li>
<li>NIO多路复用：背景：应用程序询问数据是否就绪需要系统调用。因此为了解决频繁系统调用，一次向内核传递多个需要询问的Socket是否就绪（Seletor）。select、poll实现多路复用的机制，监控多个网络连接的IO事件，poll没有最大连接数限制。epoll提供了更高效的事件通知机制，在内核态开辟了两个集合，空间换时间，不需要每次传入整个Socket集合，减少拷贝，不需要主动地对所有文件描述符进行轮询。（单线程监控多个网络通道，轮询通道是否准备好，epoll通道准备好时得到通知）</li>
<li>epoll：1⃣️epoll_create:在内核申请一块内存区域用于存储需要监控的fd，红黑树存储。2⃣️epoll_ctl:将需要监控的fd添加到创建的集合中。3⃣️epoll_wait:调用epoll_wait以等待事件发生，这个调用会阻塞直到有事件发生，或者超时。返回就绪的fd集合，链表存储。开发者只需要遍历这个列表并处理每个事件。</li>
<li>IO多路复用的多线程版本：一个线程监听新连接的接入。若干个线程负责多个Socket的读写。</li>
<li>AIO：异步非阻塞IO，jdk1.7升级，发起IO请求后立即继续执行后续代码，不需要等待IO操作完成。完成通过回调事件通知来告知调用者。windows中操作系统实现，Linux中使用自建线程池实现。</li>
<li>Socket；网络通信基本概念，两程序连接进行数据交换</li>
<li>Channel：能进行读写操作的IO通道。</li>
<li>Selector：可以监视多个Channel的IO事件。Channel注册在Selector上，允许单线程管理多个网络连接。</li>
<li>FD：Linux中一切皆文件。无论文件、Socket、设备文件。File Descriptor文件描述符，看作文件的id。进程级别的资源句柄，提供访问文件的抽象层。</li>
<li>Linux系统分三层：User、Kernel、Hardware</li>
<li>用户态和内核态：内核态是控制计算机硬件资源，例如协调CPU分配内存空间。用户态是提供应用程序运行的空间。内核提供的一组通用的访问内核管理资源的接口是系统调用。系统调用需要内核态和用户态的切换，涉及到CPU中断、堆栈切换、寄存器保存。</li>
</ul>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><ul>
<li><p>死亡对象判断方法：1.引用计数法：给对象加一个引用计数器，被引用+1，引用失效-1，无法解决循环引用问题。2.可达性分析法：GC Root作为起始点，从它们向下搜索，走过的路径叫做引用链，一个对象与所有GC Root都不相连，需要被回收。</p>
</li>
<li><p>可达性分析中的两次标记：可达性分析中不可达的对象，并不是非死不可，而是缓刑，需要两次标记。一次标记筛选是否需要执行finalize方法，需要进入下一次标记。第二次标记查看对象finalize方法中对象是否被其他存活的对象引用，如果是那么该对象将变成可达的。finalize用来做外部资源清理，被try finally取代。</p>
</li>
<li><p>垃圾收集算法：1⃣️标记清除：标记要回收的对象，然后统一回收。会产生不连续的内存碎片。2⃣️标记复制：young使用，内存分为两块儿，一块儿使用完后，将存活的复制到另一块儿，然后清除。内存压缩一半，复制效率低。3⃣️标记整理：old使用，把存活对象向一端移动，然后清除边界外的内存。解决不连续内存碎片，但是移动存活对象并更新引用负担大。停顿时间长。4⃣️分代：新生代：每次存活对象较少，复制操作少，用标记复制，新生代分为较大的eden和两个较小的survivor，每次使用eden和一块儿survivor，回收时将存活对象复制到另一块儿survivor。回收时不用中断应用程序执行，避免碎片化问题。老年代存活率较高，没有额外空间分配担保，选用标记清除&#x2F;标记整理。</p>
</li>
<li><p>eden、survivor、old分配顺序：对象优先在eden区分配，大对象和长期存活的对象进入老年代。一次minor gc之后存活在survivor中的对象1岁，此后每在survivor中熬过一次minor gc就+1岁，达到阈值或一半超过同一年龄就晋升老年代。</p>
</li>
<li><p>空间分配担保：在minor gc之前，虚拟机检查老年代的最大可用连续空间是否大于新生代所有对象总空间，如果成立，minor gc安全。如果不成立，看虚拟机是否允许担保失败，允许的话检查之前历次晋升老年代对象的平均大小，如果大于则尝试minor gc。如果小于或不允许担保失败直接full gc。</p>
</li>
<li><p>几个gc：1⃣️minor gc：也叫young gc，在新生代空间不足时触发。2⃣️major gc：老年代空间不足时触发，通常涉及整个堆的回收。CMS中不会停止所有线程。3⃣️full gc：停止应用程序执行，整个堆和方法区的垃圾收集。老年代不足、元空间不足、显示调用System.gc、担保失败。</p>
</li>
<li><p>垃圾收集器CMS：Concurrent Mark Sweep，jdk8的，关注最短垃圾回收停顿时间，老年代使用多线程的标记清除算法。第一次实现垃圾收集与用户线程同时工作，第一款真正意义上的并发收集器。新生代使用标记复制ParNew 垃圾收集器，Serial收集器的多线程版本。1⃣️初始标记：暂停所有其他线程，标记所有直接与GC Roots相连的对象，速度很快。2⃣️并发标记：从根对象开始，遍历对象图，标记所有存活的对象。3⃣️重新标记：修正并发标记期间发生变动的对象引用，停顿。4⃣️并发清除：对未标记的对象进行清除。优点：并发、低停顿。缺点：对CPU资源敏感、无法处理浮动垃圾、产生内存碎片。</p>
</li>
<li><p>垃圾收集器G1：Garbage-First，jdk9的，精准控制停顿时间，G1整体来看是标记整理，局部来看是标记复制。保留分代的概念，把堆分为若干固定大小的region，每个region扮演eden、survivor、old，维护优先级列表，每次根据允许的收集时间，优先选择垃圾最多的区域回收。不再固定收集某个区域，而是灵活组成回收集。1⃣️初始标记：暂停工作线程，标记从GC Roots直接可达的对象。2⃣️并发标记：遍历对象图，标记所有存活的对象。3⃣️最终标记：修正在并发标记阶段由于应用程序继续运行导致标记信息变化的部分。4⃣️筛选回收：制定回收计划，构成回收集，把存活对象复制到空的region中，再清理旧的region。涉及到存活对象移动，需要暂停工作线程。这里多条收集器线程并行完成。</p>
</li>
<li><p>CMS和G1：1.专注不同：CMS专注于并发清除低延迟，只需处理老年代到新生代的引用，会内存碎片。G1指定最大停顿时间，分Region的内存布局，按收益动态确定回收集，不会产生内存碎片。2.小内存CMS占优，大内存G1占优，分界线6-8G。3.CMS分配大对象空间不足时full gc，G1期望停顿时间设置很小，垃圾回收赶不上分配时full gc。</p>
</li>
<li><p>垃圾收集器ZGC：jdk11的，低延迟垃圾收集。基于Region内存布局，不设分代，使用读屏障、染色指针，实现并发标记整理。着色笔：在对象头中增加额外内存，加快标记过程。读屏障：解决垃圾回收和应用程序同时进行时，应用程序读取到被回收的对象。在对象头部增加标识位表示对象是否正在被垃圾收集器访问。</p>
</li>
<li><p>java对象引用：1.强引用：传统的引用，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。2.软引用：用于维护一些可有可无的对象。只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。3.弱引用：拥有更短的生命周期，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。4.虚引用：一种形同虚设的引用，它主要用来跟踪对象被垃圾回收的活动。</p>
</li>
<li><p>jvm调优从哪里入手：1⃣️堆内存设置，-Xms设置初始堆大小，-Xmx设置最大堆大小，过小导致频繁的垃圾回收和OOM，过大导致长时间的垃圾回收停顿。2⃣️垃圾收集器选择，串行、并行、CMS、G1回收器，衡量指标：内存占用、吞吐量、延迟。监控GC活动：使用监控工具：jstat、VisualVM、YourKit和GC日志。3⃣️线程堆栈大小：-Xss调整，影响栈深度。4⃣️调优代码、调整元空间的大小，排查内存泄漏风险、系统级优化（CPU、内存、磁盘IO）。</p>
</li>
</ul>
<h2 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h2><ul>
<li>jvm排查线程cpu问题：1.ps -ef|grep java 或者 jps 查找出进程id。2.top -Hp 进程id 查找出最耗cpu的线程id。 top -c看进程的。3.printf “%x\n” 线程id ，转换为16进制的id。4.使用jstack 进程id | grep 16进制线程id 查找出堆栈信息，分析。另外，arthas也可以打印出前多少个线程及占有cpu情况thread -n 5。</li>
<li>jvm性能监控工具：1⃣️jps：输出jvm中运行的进程状态信息。2⃣️jstack：生成 Java 进程的线程堆栈信息，用于分析线程状态和死锁等问题。jstack 进程id | grep 16进制线程id。3⃣️jstat：JVM统计监测工具，排查gc，jstat -gc 进程id 250 4。4⃣️jmap和jhat：生成 Java 内存快照，分析内存使用和内存泄漏。用jmap把进程内存使用情况dump到文件中，再用jhat分析查看。</li>
<li>机器慢了怎么排查：CPU、内存、磁盘、磁盘IO、网络IO。</li>
<li>排查工具：1.df -h查看磁盘使用情况。2.free -h &#x2F; vmstat显示系统内存使用情况。3.mpstat命令查看cpu使用情况，输出各种cpu时间百分比。4.netstat -s查看网络状态，显示各种网络协议的统计信息，接收发送数据包数等。5.iostat -x查看IO统计信息。6.top命令实时显示Linux系统中进程的动态运行信息，包括CPU和内存的使用情况。top -Hp $pid用于显示特定进程的线程信息。</li>
<li>OOM排查：除了程序计数器，其他内存存储都可能OOM。原因：1.内存泄漏：程序未能释放不再使用的内存。2.Java堆分配空间不足导致内存溢出。排查：使用jmap -dump命令dump文件，在内存分析工具如VisualVM、MAT中观察对象引用关系、对象数量大小。可能未正确释放资源、关闭文件流、断开网络连接、销毁对象引用。定位到代码排查。</li>
<li>jvm调优：分配jvm内存需要考虑应用需求，是否处理大量数据。考虑垃圾收集器。16g机器将JVM最大堆内存设置为12G（Xms12G -Xmx12G），使用G1垃圾收集器。元空间存储类的元数据，设置初始值256M，最大值512M。线程堆栈大小，几百KB到1MB，取决于有没有深层递归（-Xss256k）。</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li><p>ArrayList和LinkedList：ArrayList基于动态数组，连续内存，适合遍历和查找元素，不适合增删，增删创建新数组。LinkedList基于双向链表，适合增删，不适合随机查找。</p>
</li>
<li><p>HashSet和TreeSet：HashSet底层基于HashMap。TreeSet基于红黑树，元素处于排序状态，支持有序集合操作。</p>
</li>
<li><p>队列：Queue接口是FIFO队列，Deque扩展Queue是双端队列接口。ArrayDeque是Deque的实现，双端队列。LinkedList也是Deque的实现，可以做双端队列。Stack栈，继承自Vector。Vector是同步集合，使用synchronized。</p>
</li>
<li><p>HashMap：数组+链表+红黑树。链表长度&gt;8数组长度&gt;64时变红黑树。链表解决哈希冲突，bucket。键和值都允许为空。</p>
</li>
<li><p>HashMap为什么使用红黑树：哈希函数质量不高&#x2F;存储大量数据，链表变长，影响搜索效率。所以jdk8之后，链表长度超过8时，链表变红黑树，自平衡的二叉查找树，搜索元素时间复杂度O(logn)，提高搜索效率。</p>
</li>
<li><p>HashMap扩容底层数组为什么扩为两倍保持2的幂次：1.方便利用位运算替代取模运算来计算元素索引位置。2.减少冲突：二进制位增加一位，只看最高位要么移动要么不变，确保分布均匀。 </p>
</li>
<li><p>ConcurrentHashMap：线程安全的HashMap，jdk7使用分段锁，分16段，一段一把锁。jdk8使用synchronized和CAS保证线程安全。</p>
</li>
<li><p>如何提高链表查询效率：1.使用双向链表。2.使用跳表，在链表上增加多级索引。3.元素存到哈希表进行映射。</p>
</li>
<li><p>B+树：索引数据记录在叶子结点，形成有序链表，方便范围查询。极端退化形成链表。具有更低的树高，降低磁盘寻址次数，减少IO次数。</p>
</li>
<li><p>跳表：skip list，分层结构多级链表，随机化的数据结构，用于存储有序元素。提供对数时间复杂度。每一层都是下一层的快照，只包含部分元素，每层元素通过指针相连。查找先从顶层查找，从而快速跨越多个不必要元素。应用：redis中zset使用hash+跳表。</p>
</li>
<li><p>大顶堆小顶堆：基于完全二叉树（除最底层外每一层都是满的，最底层从左向右填充），层序遍历用数组表示，用来实现优先队列。大顶堆中父节点大于子节点，根节点最大，同层没有顺序。</p>
</li>
<li><p>LRU：最近最久未使用。实现：1.链表，头部是要淘汰的，每次页面访问将页面移动到链表尾部。2.哈希表+双向链表，哈希表用来快速查找页面对应的链表节点。3.时间戳：每个页面分配时间戳，被访问时更新时间戳。</p>
</li>
<li><p>操作系统的页面淘汰算法：1.FIFO先进先出，使用队列。2.LFU最不常用，使用计数器跟踪每个页面访问次数，每次淘汰访问次数最少的，不考虑时间局部性。3.LRU最近最久未使用。4.时钟算法clock，LRU近似实现，维护循环列表。</p>
</li>
<li><p>八种基本数据类型及封装类：byte有符号整数（8bit，-128-127）、short有符号16bit整数、int有符号32bit整数、long有符号64bit整数、float32bit单精度浮点数、double64bit双精度浮点数、char16bit的unicode字符、boolean</p>
</li>
<li><p>装箱和拆箱：装箱：基本数据类型自动转换为对应封装类对象（编译器转换为Integer.valueOf）。拆箱：封装类对象自动转换为基本数据类型（编译器转换为o.intValue()）。</p>
</li>
<li><p>String、StringBuilder、StringBuffer：1⃣️String是不可变的，每次修改都是创建一个新的对象，性能较低。2⃣️StringBuilder可变，内部维护一个自动扩容的字符串数组，不是线程安全的。3⃣️StringBuffer可变，线程安全的，synchronized。</p>
</li>
<li><p>String不可变的设计原理：1⃣️内部使用私有的final字符数组存储字符串数据，创建之后引用不会指向另一个数组。2⃣️虽然数组本身可变，但是String没有提供方法修改数组内容。3⃣️虚拟机维护字符串池，相同内容的字符串可共享同一内存地址。创建时首先检查字符串池是否有相同内容字符串对象，有则返回引用。</p>
</li>
<li><p>String不可变的好处：1⃣️安全性：防止被恶意修改导致的安全漏洞。2⃣️线程安全：String对象本身线程安全。指向String对象的引用变量不是。3⃣️实现字符串常量池成为可能，重用字符串，节省内存开销。4⃣️创建字符串的哈希码缓存：字符串不可变，哈希码也不会变，适合作为键使用在哈希表中HashMap。</p>
</li>
<li><p>HashMap和TreeMap：HashMap基于哈希表，使用哈希函数提供O1的快速访问，不保证元素顺序。数组+链表&#x2F;红黑树。TreeMap基于红黑树，键值对按照键的自然顺序或指定比较器顺序Ologn复杂度排序。两者都是非线程安全的。</p>
</li>
<li><p>反射怎么创建对象：1⃣️Class的newInstance方法为无参构造器的类创建：Class&lt;?&gt; clazz &#x3D; Class.forName(“com.Demo”); Object o &#x3D; clazz.newInstance(); 2⃣️先获取Constructor，再newInstance。可以获取指定构造参数的构造器。3⃣️私有方法，可以constructor.setAccessible(true); 来设置可访问。</p>
</li>
<li><p>ArrayList 和 LinkedList怎么线程安全：1⃣️使用Collections.synchronizedList(list)将任何List转换为线程安全的List。（所有操作都使用相同的对象锁进行同步）。2⃣️使用显式的同步块，每次访问操作时加相同的锁。3⃣️使用concurrent包中的并发集合，CopyOnWriteArrayList，写时复制，适用于遍历操作远多于修改操作。ConcurrentHashMap、ConcurrentLinkedQueue。</p>
</li>
<li><p>java.util.concurrent包下有哪些：1⃣️Executor：线程调度框架：任务Runnable，Callable、任务执行ExecutorService，ThreadPoolExecutor ScheduledThreadPoolExecutor、异步计算结果Future，FutureTask。2⃣️同步器：CountDownLatch，CyclicBarrier，Semaphore。3⃣️并发集合：ConcurrentHashMap，ConcurrentLinkedQueue，CopyOnWriteArrayList，CopyOnWriteArraySet，以及支持阻塞的线程安全队列ArrayBlockingQueue等。4⃣️原子变量AtomicInteger等。5⃣️锁Lock：ReentrantLock，ReadWriteLock。</p>
</li>
</ul>
<h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><ul>
<li>java异常体系：一个以Throwable类为根的类层次结构，两个分支：1⃣️Error和Exception。Error错误代表了JVM无法预期或难以恢复的严重问题，比如OOM、StackOverflowError、线程死锁等，一般无需捕捉。Exception异常包括：2⃣️Checked Exceptions受检异常，又叫编译时异常，在编写可能会抛出它们的方法时需要显式地进行处理（通过try-catch块）或声明（通过throws关键字），这些异常通常是外部错误，如文件未找到（FileNotFoundException）、网络问题（IOException）、SQL异常等。3⃣️Unchecked Exceptions非受检异常，又叫运行时异常，包括RuntimeException及其子类，不需要显示处理或声明，通常是程序错误，例如数组越界、空指针。</li>
</ul>
<h2 id="变量修饰"><a href="#变量修饰" class="headerlink" title="变量修饰"></a>变量修饰</h2><ul>
<li><p>static：静态</p>
<ul>
<li>应用于变量：静态变量或类变量，变量属于类而不是对象，所有该类的对象共享同一个静态变量。</li>
<li>应用于方法：静态方法，表示该方法属于类，可以不依赖于对象实例被调用。只能访问static变量和方法。</li>
<li>定义静态代码块：在类被加载到JVM时仅执行一次，常用于初始化静态变量。</li>
<li>应用于类：只能用来修饰内部类，可以不依赖于外部类的实例被创建和使用，可以访问外部类的所有静态成员和静态方法。</li>
</ul>
</li>
<li><p>final：常量，用于创建不可变对象、防止方法或类被更改</p>
<ul>
<li>修饰变量：表示该变量一旦被初始化后就不能被修改，对于基本数据类型，变量的值不能改变，对于引用类型，变量不能再指向另一个对象，但所指向的对象内容本身可以变化。</li>
<li>当final应用于方法时，该方法不能被子类覆盖（重写）。</li>
<li>当final应用于类时，它表明该类不能被继承。</li>
</ul>
</li>
<li><p>类加载机制：运行时动态加载，类加载器（ClassLoader）负责将类的字节码Class文件从不同的来源（例如文件系统、网络等）加载到Java虚拟机中。1⃣️加载阶段：类加载器读取二进制数据（.class文件）并生成对应的java.lang.Class对象。2⃣️验证：确保加载的类的字节码是合法的，检查字节码的格式、语法、数据流、符号引用等。3⃣️准备：为类变量分配内存并初始化为默认值，方法区中分配。4⃣️解析：将常量池内的符号引用转换为直接引用的过程。5⃣️初始化：执行静态变量的赋值操作和静态代码块内的代码。</p>
</li>
<li><p>符号引用和直接引用：符号引用就是一组符号来描述所引用的目标，直接引用就是直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。</p>
</li>
<li><p>java编译阶段和运行阶段：编译阶段是源代码（.java文件）被编译器转换成字节码（.class文件）的过程，由Java编译器（ javac）负责。运行阶段是将.class 文件加载到JVM并执行的过程。类加载在运行阶段，支持运行时绑定（或晚期绑定），是Java动态链接和多态的基础。</p>
</li>
<li><p>常量池：运行时常量池位于方法区。它是类文件中每个类或接口的常量池表的运行时表示，用于存储编译器生成的字面量和符号引用。字符串常量池最初位于方法区，在Java 7以后被移到堆内存。它是一种特殊的常量池，用于存储字符串字面量和引用，目的是避免重复创建相同内容的字符串对象，以节省内存和提升性能。</p>
</li>
<li><p>双亲委派模型：JVM中的双亲委派是一种类加载机制，通过一层一层的父子关系将类的加载工作委派给上层的ClassLoader。这种机制的目的是为了避免类的重复加载，保证类的加载安全和类的共享。</p>
</li>
<li><p>想加载两个全路径相同的类：1.使用不具有父子关系的类加载器。2.打破双亲委派模型，自定义类加载器，并重写 loadClass() 方法，改变类加载的委派逻辑。</p>
</li>
<li><p>java接口中可以有非抽象方法吗：非抽象方法即具体实现的方法，java8之前只能包含抽象方法。java8引入了默认方法和静态方法。默认方法：default修饰。静态方法：static修饰，可以通过接口名直接调用。java9还提供了private私有方法。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/12/myblog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%A5%BF%E7%93%9C%E4%B9%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/12/myblog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%A5%BF%E7%93%9C%E4%B9%A6/" class="post-title-link" itemprop="url">西瓜书</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-02-12 21:55:33 / Modified: 22:01:29" itemprop="dateCreated datePublished" datetime="2025-02-12T21:55:33+08:00">2025-02-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><ul>
<li>什么是机器学习：在计算机上从数据中产生模型的算法，即学习算法。计算机科学是研究关于算法的学问，机器学习是研究关于学习算法的学问。</li>
<li>基本术语：样本的集合-数据集，属性张成的空间-属性空间&#x2F;样本空间，一个样本在坐标轴上表示-特征向量，一个样本的特征数-维数。聚类：将样本分簇，学习过程中使用的训练样本无标记信息。训练数据无标记信息-无监督学习：聚类为代表。监督学习：回归分类为代表。模型适用于新样本的能力，适用于整个样本空间-泛化能力。</li>
<li>归纳：从特殊到一般的泛化过程。演绎：从一般到特殊的特化过程。</li>
<li>广义的归纳学习相当于从样本中学习，狭义的归纳学习要求从训练数据中学得概念，概念学习。学得泛化性能好又语义明确的概念太困难，常用的技术是产生黑箱模型。从样例中学习就是广义的归纳学习。</li>
<li>假设空间：指模型可能学习到的所有函数或解的集合。学习过程可以看作在所有假设组成的空间中进行搜索的过程，学习得到的模型对应了假设空间中的一个假设。存在与训练集一致的假设集合，称为版本空间，其中可能多个假设空间。</li>
<li>机器学习算法在学习过程中对某种类型假设的偏好，称为归纳偏好。任何有效的机器学习算法都有归纳偏好，否则无法产生确定的学习结果。奥卡姆剃刀：选择最简单的。实际上，选择与问题相匹配的归纳偏好，才会起决定性作用。</li>
<li>人工智能发展历程：推理期（逻辑推理能力） - 知识期（专家系统，人把知识总结再教给计算机）- 机器学习（研究最多的是从样例中学习，广义的归纳学习）。机器学习：符号主义学习（决策树和基于逻辑的学习，决策树学习以信息论为基础，以信息熵最小化为目标，模拟了人类对概念进行判定的树形流程，简单易用。但是逻辑学习表示能力太强，假设空间太大，复杂度高问题规模大）- 基于神经网络的连接主义学习（与符号主义产生明确概念不同，连接主义产生的是黑箱模型，最大的局限性是试错性，参数调节对结果影响很大）- 统计学习（支持向量机SVM和核方法） - 连接主义带着深度学习卷土重来（很多层的神经网络，模型复杂度高，但是下功夫调参，性能就能好）</li>
<li>数据挖掘是从海量数据中发掘知识，数据库领域为数据挖掘提供数据管理技术，机器学习和统计学的研究为数据挖掘提供数据分许技术。</li>
<li>萨缪尔，跳棋程序。提出机器学习，是不显式编程地赋予计算机能力的研究。</li>
</ul>
<h1 id="第二章-模型评估与选择"><a href="#第二章-模型评估与选择" class="headerlink" title="第二章 模型评估与选择"></a>第二章 模型评估与选择</h1><ul>
<li>误差：训练误差或经验误差：学习器在训练集上的误差；泛化误差：学习器在新样本上的误差。</li>
<li>过拟合与欠拟合：过拟合是由于学习能力过于强大,以至于把训练样本所包含的不太一般的特性都学到了（无法完全避免）；欠拟合是由于学习能力低下而造成的（神经网络中增加训练轮次）。</li>
<li>评估方法：泛化误差无法直接获得，测试集上的测试误差作为泛化误差的近似。1、留出法： 直接将数据划分为两个互斥集合，<strong>一个集合作为训练集，另一个作为互斥集</strong>，若干次随机划分。2、交叉验证法：先将数据集划分为<strong>k</strong>个大小相似的互斥子集，每次用<strong>k-1</strong>个子集的并集作为训练集，余下那个子集作为测试集。k折交叉验证，p次随机划分，p次k折交叉验证。3、自助法：每次从数据集D中挑选一个样本，再将该样本放回初始数据集D中，重复m次，得到包含m个样本的数据集D’。初始数据集D中约有36.8%的样本未出现在D’中。小数据集中有用，但是自助法产生的数据集改变了初始数据集的分布。</li>
<li>性能度量：查准率：所预测的正例有多少是正确的概率；查全率：在真实正例条件下，有多少正例被预测出来。</li>
<li>P-R曲线：以查全率为横坐标，查准率为纵坐标。</li>
<li>出现交点时，引入平衡点(Break-Event Point, BEP)来度量学习器的优劣。是查准率&#x3D;查全率时的取值。P是查准率，R是查全率。调整阈值实现变化的。</li>
<li>F1度量：调和平均，F1 &#x3D; 2<em>P</em>R&#x2F;(P+R)。为表达对P和R的偏好，引入贝塔，F1度量的一般形式。</li>
<li>ROC曲线和AUC面积：ROC曲线的纵轴是“真正例率”(True Positive Rate, TPR)，横轴是“假正例率”(False Positive Rate, FPR)。AUC为曲线下的面积。</li>
<li>代价敏感错误率和代价曲线：分类任务中，不同错误造成的损失不同，也就是非均等代价，所以引入代价矩阵，最小化总体代价。</li>
<li>t分布：统计学中的概率分布，是一种对称的、钟形的概率分布，其形状与正态分布类似，但尾部更厚。</li>
<li>偏差与方差：偏差、方差、噪声，是影响模型性能的三个核心概念，它们共同决定了模型的泛化能力。1、偏差是模型预测值的期望（多个训练集训练的多个模型）与真实值之间的差异，反映了模型对数据的拟合能力，高偏差意味着欠拟合，需要使用更复杂的模型和增加特征数量。2、方差是模型预测值的变化程度，反映了模型对训练数据的敏感性。不同训练集训练模型的预测值与真实值的方差。高方差意味着模型过于复杂，过度拟合训练数据中的噪声。低方差意味着模型对训练数据的变化不敏感，泛化能力较强。降低方差需要使用正则化，增加训练数据量。3、噪声是数据中无法被模型捕捉的随机误差，不可避免的，与模型无关。例如图像可能包含模糊或遮挡。</li>
<li>偏差度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力;方差度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响;噪声则表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。</li>
<li>偏差-方差分解说明，泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的。给定学习任务，为了取得好的泛化性能，则需使偏差较小，即能够充分拟合数据，并且使方差较小，即使得数据扰动产生的影响小。</li>
<li>训练不足时，学习器拟合能力不足，偏差主导了泛化误差。训练程度加深，训练数据的扰动能够被学习器学习到，方差主导了泛化误差。</li>
</ul>
<h1 id="第三章-线性模型"><a href="#第三章-线性模型" class="headerlink" title="第三章 线性模型"></a>第三章 线性模型</h1><ul>
<li>线性回归：用于建模因变量与自变量之间的线性关系。非线性模型可在线性模型的基础上引入层次结构和高维映射得到。简单线性回归只有一个因变量属性，多元线性回归有多个。目标：使得模型的预测值与真实值之间的误差最小。 均方误差：差平方的平均，对应欧几里得距离。参数估计方法：最小二乘法【解析法】（基于均方误差最小化来求导进行模型求解，对异常值非常敏感）、梯度下降【迭代法】（通过迭代优化逐步调整回归系数，使损失函数最小化）线性回归优点：简单可解释性强；缺点：无法捕捉非线性关系，对异常值敏感。</li>
<li>对数线性回归：通过对因变量取对数，将其转换为线性模型的形式，从而利用线性回归的方法进行建模因变量与自变量之间的对数线性关系。通常用于处理因变量是计数数据或频率数据的情况。</li>
<li>对数几率回归：分类算法，通过将线性回归的输出映射到概率空间，并使用对数几率来建模分类问题。简单高效、可解释性强，应用于二分类问题，但只能建模线性决策边界。实际上是用线性回归模型的预测结果去逼近真实标记的对数几率，对数几率是：log(p&#x2F;1-p)</li>
<li>sigmoid函数：因其形状类似于字母“S”而得名，核心作用是将任意实数映射到 [0, 1] 区间，常用于表示概率或作为激活函数。σ(z)&#x3D;1&#x2F;1+e−z。输出范围是0-1，具有单调性、非线性、平滑性。应用：对数几率回归中用于将线性回归的输出映射到 [0, 1] 区间，表示概率。在神经网络中，Sigmoid 函数常用于隐藏层或输出层的激活函数，引入非线性能力。缺点：存在梯度消失和计算复杂度较高。</li>
<li>线性判别分析LDA：核心思想是通过将数据投影到低维空间，使得同类样本尽可能接近，不同类样本尽可能远离，从而实现分类或降维。目标是找到一个投影方向（或超平面），使得在该方向上，类内距离最小化，类间距离最大化。</li>
<li>拉格朗日乘子法：一种用于求解约束优化问题的数学方法。核心思想是通过引入拉格朗日乘子，将约束条件融入目标函数，从而将约束优化问题转化为无约束优化问题。通过求解拉格朗日函数的极值，可以得到原约束优化问题的解。对因变量和拉格朗日乘子求偏导之后解方程。</li>
<li>多分类问题：1、直接多分类方法：Softmax 回归，使用 Softmax 函数将线性模型的输出转换为概率分布。神经网络中在输出层使用 Softmax 激活函数，将输出转换为概率分布。2、间接多分类方法：将多分类任务拆为若干个二分类任务求解，一对一（需训练N(N - 1)&#x2F;2个分类器）、一对其余（需训练N 个分类器）。</li>
<li>类别不平衡问题：指在分类任务中，不同类别的样本数量分布不均衡，其中一个或少数类别的样本数量远远少于其他类别。影响：模型偏向多数类、准确率评价指标失效。解决：数据层面，过采样随机复制少数类样本增加少数类样本的数量，欠采样减少多数类样本的数量，混合采样。算法层面，为不同类别分配不同的误分类代价，使模型更关注少数类。</li>
</ul>
<h1 id="第四章-决策树"><a href="#第四章-决策树" class="headerlink" title="第四章 决策树"></a>第四章 决策树</h1><ul>
<li>决策树：通过一系列规则对数据进行划分，使得每个子集尽可能纯净（即属于同一类别或具有相似的值），构建一棵树形结构。构建过程可以看作是一个递归的“分而治之”过程。</li>
<li>决策树的构建过程：1、根据某种准则（如信息增益、基尼指数等），选择最优特征进行划分。2、根据最优特征的取值，将数据集划分为多个子集。3、对每个子集递归地重复上述过程，直到满足停止条件（如子集纯净、达到最大深度等）。4、当满足停止条件时，生成叶节点，叶节点的值为该子集中多数类别（分类任务）或平均值（回归任务）。</li>
<li>决策树用于选择最有划分特征的准则：分类任务：信息增益（表示划分前后信息熵的减少量，信息熵&#x3D;plogp，信息增益越大，就认为用属性a来进行划分所获得的纯度提升最大）、增益率（通过引入固有值对信息增益进行归一化处理，克服了信息增益对取值数目较多的特征的偏好问题）、基尼指数（表示从数据集中随机抽取两个样本，其类别标签不一致的概率。基尼指数越小，数据集的纯度越高）。回归任务：均方误差MSE（选择使均方误差最小的特征进行划分）。</li>
<li>决策树的剪枝：决策树容易过拟合，因此需要通过剪枝（Pruning）来提高泛化能力。预剪枝：节点划分前先进行估计，计算划分前和划分后的验证集精度，只有划分后精度变大了，才会划分，其他的就直接一刀切不再划分。后剪枝：先生成一颗完整的决策树，从叶节点向上剪枝，通过验证集评估剪枝前后的性能，决定是否保留。</li>
<li>决策树的连续与缺失值处理：决策树通常用于处理离散特征，如果要处理连续属性：二分法和多分法。需要注意，与连续属性不同，若当前结点划分属性为连续属性，则该属性还可作为其后代节点的划分属性。对于缺失值（样本的某些属性值缺失），通过忽略、填补或单独分支处理缺失值。</li>
<li>决策树的分类边界：决策树的分类边界有一个明显的特点：轴平行，即它的分类边界由若干个与坐标轴平行的分段组成。每一段划分都直接对应了某个属性取值。</li>
<li>多变量决策树：非叶节点不再仅对某个属性，而是对属性的线性组合进行划分，实现斜划分，与传统的单变量决策树不同，多变量决策树不是为每个非叶结点寻找一个最优划分属性，而是试图建立一个合适的线性分类器。</li>
</ul>
<h1 id="第五章-神经网络"><a href="#第五章-神经网络" class="headerlink" title="第五章 神经网络"></a>第五章 神经网络</h1><ul>
<li>神经网络：一种模仿生物神经系统结构和功能的计算模型，通过多层神经元的相互连接和权重调整，能够学习复杂的非线性关系。</li>
<li>神经元：通过加权求和和激活函数处理后输出</li>
<li>激活函数：引入非线性，使神经网络能够学习复杂模式，Sigmoid、ReLU、SoftMax。</li>
<li>神经网络的学习过程，就是根据训练数据来调整神经元之间的”连接权”以及每个功能神经元的阈值。输入层神经元仅仅是接受输入，而隐层与输出层则都包含功能神经元（有激活函数）。</li>
<li>感知器：由两层神经元组成，输入层接受外界输入信号后传递给输出层，输出层是神经元，也叫做“阈值逻辑单元”。局限性：能实现与或非逻辑运算，只能解决线性可分问题（存在一个线性超平面能将它们分开），无法处理非线性分类任务（如异或问题）。</li>
<li>多层网络：通过堆叠多个感知器层，能够学习复杂的非线性关系。包括：输入层（接收输入数据，每个节点对应一个特征）、隐藏层（通过非线性变换提取特征，可以有多层）、输出层（输出预测结果，节点数取决于任务类型，如分类任务中节点数等于类别数）。神经网络的前一层的每一个神经元都与后一层的所有神经元相连–全连接神经网络。</li>
<li>多层前馈神经网络：先将输入提供给输入层神经元，然后逐层将信号前传（前向传播），直到产生输出层的结果。然后计算输出层的误差（损失函数，如均方误差、交叉熵），再将误差逆向传播至隐层神经元（误差逆传播算法，使用链式法则逐层传播误差），最后根据隐层神经元的误差来对权值和阈值进行调整（基于梯度下降策略，以目标的负梯度方向对参数进行调整）。该迭代过程循环进行，直到达到某些停止条件为止，例如训练误差己达到一个很小的值。</li>
<li>累积误差逆向传播：基于累积误差最小化进行更新</li>
<li>只需包含足够多神经元的隐层，多层前馈网络就能以任意精度逼近任意复杂度的连续函数，通过试错法调整隐层神经元的个数。</li>
<li>解决过拟合：早停：将数据分成训练集和验证集，训练集用来计算梯度、更新连接权和阈值，验证集用来估计误差，若连续多轮训练集误差降低但验证集误差升高，则停止训练，同时返回具有最小验证集误差的连接权和阈值。正则化：在损失函数中加入额外的惩罚项，限制模型参数的大小或复杂度。</li>
<li>神经网络类型：前馈神经网络FNN：最简单的神经网络，信息单向传播。卷积神经网络CNN：用于图像处理，通过卷积核提取局部特征。循环神经网络RNN：用于序列数据（如文本、时间序列），具有记忆能力。生成对抗网络GAN：由生成器和判别器组成，用于生成数据。</li>
<li>如何避免陷入局部最小：从多个不同的初始点开始搜索、动量法通过引入历史梯度信息，加速梯度下降并帮助跳出局部最小值、使用自适应学习率方法动态调整学习率、使用模拟退火，通过引入逐渐降低的“温度”参数，控制搜索过程中的随机性，从而在早期探索更多解空间，后期逐渐收敛到全局最优解、使用SGD随机梯度，通过引入噪声帮助跳出局部最小值。（都是启发式的）</li>
<li>模拟退火：每一步以一定概率接受比当前解更差的结果，接受次优解的概率随着时间的推移逐渐降低，从而保证算法稳定。</li>
<li>RBF网络：一种单隐层前馈神经网络，使用径向基函数作为隐层神经元激活函数，输出层则是对隐层神经元输出的线性组合。常用于函数逼近、分类和回归任务，具有结构简单、训练速度快的特点。RBF 径向基函数的核心思想是通过距离度量（通常是欧氏距离）来计算输入数据点与某个中心点之间的相似性。常见的RDF函数有高斯函数，具有径向对称性、平滑性的特点。</li>
<li>竞争型学习：神经网络中一种常用的无监督学习策略，在使用该策略时，网络的输出神经元相互竞争，每一时刻仅有一个竞争获胜的神经元被激活，其他神经元的状态被抑制。这种机制亦称”胜者通吃” (winner-take-all) 原则。</li>
<li>ART（自适应共振理论网络）网络：竞争型学习的代表，该网络由比较层、识别层、识别阈值和重置模块构成。在接收到比较层的输入信号后识别层神经元之间相互竞争以产生获胜神经元。竞争的最简单方式是计算输入向量与每个识别层神经元所对应的模式类的代表向量之间的距离，距离最小者胜。获胜神经元将向其他识别层神经元发送信号，抑制其激活。若输入向量与获胜神经元所对应的代表向量之间的相似度大于识别阈值，则当前输入样本将被归为该代表向量所属类别，同时，网络连接权将会更新，使得以后在接收到相似输入样本时该模式类会计算出更大的相似度，从而使该获胜神经元有更大可能获胜。若相似度不大于识别阈值，则重置模块将在识别层增设一个新的神经元，其代表向量就设置为当前输入向量。</li>
<li>ART网络是一种基于自适应共振理论的无监督学习神经网络，能够动态地学习和分类输入数据，同时保持对之前学习模式的稳定性。可以进行增量学习。它适用于模式识别、数据聚类和异常检测等任务，尽管参数敏感和计算复杂度较高，但在动态学习任务中表现出色。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/20/myblog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E4%BA%8Etensorflow%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/20/myblog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E4%BA%8Etensorflow%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">基于tensorflow的深度学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-20 15:57:17" itemprop="dateCreated datePublished" datetime="2023-08-20T15:57:17+08:00">2023-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-02-12 21:56:16" itemprop="dateModified" datetime="2025-02-12T21:56:16+08:00">2025-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一章-Numpy常用操作"><a href="#第一章-Numpy常用操作" class="headerlink" title="第一章 Numpy常用操作"></a>第一章 Numpy常用操作</h2><p>tensorflow：深度学习框架<br>python本身含有列表list和数组array。<br>list列表的元素可以是任何对象，因此列表中保存的是对象的指针，浪费内存和CPU计算时间。<br>array不支持多维，没有各种运算函数。</p>
<p>numpy提供ndarray（存储单一数据类型的多维数组）和ufunc（对数组进行处理的函数）</p>
<p>1.将列表转换为ndarray。<br>2.np函数，截取ndarray<br>3.numpy中的random函数<br>4.numpy中的矩阵操作<br>5.ndarray的合并和展平<br>6.使用numpy和math的比较，使用向量化矩阵运算可以避免循环语句<br>7.numpy的广播机制：方便不同shape的数组进行数学运算。原则是对齐维度，对数组进行扩充到可以进行运算，利用自动复制等方法把低维数据补齐。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">print(np.arange(10))</span><br><span class="line">print(np.arange(0, 10))</span><br><span class="line">print(np.arange(1, 4, 0.5))</span><br><span class="line">print(np.arange(9, -1, -1))</span><br><span class="line"></span><br><span class="line">nd1 = np.arange(10)</span><br><span class="line">print(nd1)</span><br><span class="line">print(nd1[3:6])</span><br><span class="line">print(nd1[1:6:2])</span><br><span class="line">print(nd1[::-2])</span><br><span class="line"></span><br><span class="line">np2 = np.arange(25).reshape([5,5])</span><br><span class="line">print(np2)</span><br><span class="line">print(np2[[1,2]]) #1、2行</span><br><span class="line">print(np2[1:3, :])</span><br><span class="line">print(np2[:, 1:3])</span><br><span class="line">import numpy as np</span><br><span class="line">from numpy import random</span><br><span class="line"></span><br><span class="line">a = np.arange(1, 25, dtype=float)</span><br><span class="line">print(a)</span><br><span class="line">c1 = random.choice(a, size=(3,4))</span><br><span class="line">print(c1)</span><br><span class="line">print(np.sum(a))</span><br><span class="line">print(a / np.sum(a))</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">nd3 = np.arange(9).reshape([3,3])</span><br><span class="line">print(np.transpose(nd3))</span><br><span class="line">print(nd3.trace)</span><br><span class="line">print(np.linalg.det(nd3))</span><br><span class="line">print(np.linalg.solve(nd3, np.eye(3)))</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">print(time.process_time())</span><br></pre></td></tr></table></figure>

<h2 id="第二章-Theano基础"><a href="#第二章-Theano基础" class="headerlink" title="第二章 Theano基础"></a>第二章 Theano基础</h2><p>Theano是python的一个库，对于解决大量数据的问题，使用Theano可以获取与手工用C实现差不多的性能。符号计算图。<br>conda install theano<br>符号变量&#x3D;张量Tensor。<br>张量是标量、向量、矩阵的统称。<br>Theano是一个通用的符号计算框架，将复杂的符号表达式编译成函数模型。<br>1.定义符号变量<br>import theano<br>from theano import tensor<br>2.符号计算图模型来描述变量间的运算关系，把符号表达式转换为一个计算图来处理。<br>3.函数：提供一个接口，把函数计算图编译为可调用的函数对象。Theano进行了编译优化，执行的是优化后保存在图结构中的模型，提升速度，不好调试。<br>自动求导：对于每个op都定义了根据输入计算出偏导数，使用链式法则，就可以计算出梯度了。<br>更新共享变量参数：深度学习中通常需要迭代多次，每次迭代都需要更新参数。theano.function中的updates参数就是包含两个元素的列表或tuple。<br>条件：ifelse、switch<br>循环：scan用来构建循环Graph的方法<br>4.共享变量：是实现机器学习算法参数更新的重要机制。shared函数会返回共享变量，这种变量的值可以在多个函数中直接使用。用function中的updates参数进行更新。</p>
<h2 id="第三章-线性代数"><a href="#第三章-线性代数" class="headerlink" title="第三章 线性代数"></a>第三章 线性代数</h2><p>1.标量、向量、矩阵、张量<br>2.可逆矩阵、对角矩阵、对称矩阵、单位向量、正交向量、正交矩阵<br>0范数(L0范数)-向量中非0元素的个数。<br>1范数(L1范数)-向量中各个元素绝对值之和。<br>2范数(L2范数)-向量的模长。<br>无穷范数(最大范数)-向量中各个元素绝对值的最大值。</p>
<p>3.向量组、线性组合、向量空间。向量组线性相关。最大线性无关组、向量组的秩。矩阵的行秩和列秩相等。<br>4.向量的大小用范数来表示。<br>5.特征值分解，特征值，特征向量。<br>6.奇异值分解：分解成三个矩阵的乘积。可以拓展矩阵求逆到非方矩阵上。SVD<br>7.迹运算：矩阵对角元素的和 Tr<br>8.主成分分析：PCA：通过正交变换将一组可能存在相关性的变量转换为一组线性不相关的变量，转换后的这组变量叫做主成分。属于特征降维。<br>在减少需要分析的指标或维度的同时，尽量减少原指标所含信息的损失，以达到对所收集数据进行全面分析的目的。<br>for i in range(10):<br>    print(i)</p>
<h2 id="第四章-概率与信息论"><a href="#第四章-概率与信息论" class="headerlink" title="第四章 概率与信息论"></a>第四章 概率与信息论</h2><p>机器学习、深度学习的三大基石：线性代数、概率与信息论、数值分析。<br>机器学习大部分时候处理的都是不确定量或随机量。</p>
<p>1.信息论主要研究对一个信号包含信息的多少进行量化。<br>样本空间：一个实验或随机试验所有可能结果的集合，每个可能结果为一个样本点。<br>随机变量：随机事件的结果：离散随机变量、连续随机变量。n维随机变量&#x2F;随机向量。</p>
<p>2.概率分布<br>通常关心随机变量落在某一区间的概率：分布函数F<br>离散型随机变量：两点分布、二项分布、poisson分布<br>连续型随机变量：用概率密度函数来描述变量的概率分布fx。正态分布&#x3D;高斯分布，钟形曲线，平均值和标准差，标准差大的更分散。正态分布是一种理想分布。<br>scipy库进行统计</p>
<p>3.边缘概率：定义在多维随机变量的子集上的概率分布称为边缘概率分布。对于连续型随机变量，可以通过联合密度函数来得到边缘密度函数。<br>4.条件概率，条件概率的链式法则<br>5.独立性与条件独立性<br>6.期望、方差、协方差。<br>期望描述数据的大小，但无法描述数据的离散程度。<br>方差可以用来衡量随机变量取值的离散程度。<br>协方差可以衡量随机变量间的相关性强度。如果X和Y独立，那么它们的协方差为0.反之不一定成立，独立性比协方差为0的条件更强。如果X和Y都是正态分布，此时独立和协方差为0是一个概念。<br>相关系数将每个变量的贡献进行归一化，在协方差的基础上进行正则化，把相关系数限制在-1到1之间。如果等于1，表示线性正相关。<br>协方差推广到n个随机或n维随机变量的情况，对于n维，就是n*n的协方差矩阵。协方差矩阵是对称矩阵，协方差矩阵的对角元素为方差。<br>用numpy的相关函数、数据分析库pandas、画图库matplotlib、sns。<br>7.贝叶斯定理<br>与条件概率和边缘概率有关，通过已知的三个概率函数推出第四个。<br>分类器：近邻分类器、线性分类器、支撑向量机分类器、神经网络分类器、随机森林分类器<br>损失函数：多类支撑向量机损失、交叉熵损失、L1损失、L2损失<br>线性分类器，层级结构形成神经网络，高纬映射形成支撑向量机 - 非线性模型<br>线性分类器的权值：可以看作是一种模版，分界面（决策边界）<br>分类器的损失函数：搭建了模型性能与模型参数之间的桥梁。<br>多类支撑向量机损失：正确类别的得分比不正确类别的得分高出1分，就无损失，否则产生损失。</p>
<h2 id="第五章-概率图模型"><a href="#第五章-概率图模型" class="headerlink" title="第五章 概率图模型"></a>第五章 概率图模型</h2><p>1.概率图模型是一种用图的形式表示随机变量之间条件依赖关系的概率模型，是概率论与图论的结合。<br>有向概率图模型：贝叶斯网络：表达随机变量间的依赖关系和相互关系<br>无向概率图模型：马尔可夫网络：表达随机变量间的相互关系</p>
<p>2.贝叶斯网络分为静态贝叶斯网络和动态贝叶斯网络<br>动态贝叶斯网络可用于处理随时间变化的动态系统中的推断和预测等问题。其中隐马尔可夫模型HMM，被广泛用于语音识别、自动分词与词性标注和统计机器翻译等领域。</p>
<p>3.隐马尔可夫模型<br>初始状态项链、状态转移概率矩阵、观测概率矩阵<br>状态序列（标记序列）和观测序列。<br>隐马尔可夫模型可解决三个基本问题：评估问题、解码问题、学习问题<br>实例：掷骰子，多种骰子<br>解码问题：知道骰子有几种（隐含状态数量），每种骰子是什么（转换概率），根据掷骰子的结果（可见状态链），想知道每次掷出来的都是哪种骰子（隐含状态链）。</p>
<p>4.马尔可夫网络<br>无向概率图模型，关于一组有马尔可夫性质随机变量X的全联合概率分布模型。<br>重点是其中的一种：马尔可夫随机场MRF。<br>马尔可夫随机场有一组势函数，也称因子，是定义在变量子集上的非负函数。<br>条件随机场。</p>
<h2 id="第六章-机器学习基础"><a href="#第六章-机器学习基础" class="headerlink" title="第六章 机器学习基础"></a>第六章 机器学习基础</h2><p>机器学习分为监督学习、无监督学习、半监督学习（强化学习）。</p>
<h3 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/22/myblog/spring/springboot%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/22/myblog/spring/springboot%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">springboot学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-22 18:37:23" itemprop="dateCreated datePublished" datetime="2022-12-22T18:37:23+08:00">2022-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-20 15:40:41" itemprop="dateModified" datetime="2023-08-20T15:40:41+08:00">2023-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="springboot创建工程"><a href="#springboot创建工程" class="headerlink" title="springboot创建工程"></a>springboot创建工程</h2><p>微服务体系下不可或缺。<br>ssm(spring+springMvc+mybatis) -&gt; springboot -&gt; springcloud</p>
<p>springboot：约定优于配置，不用专注于配置。2014年发布。</p>
<p>springboot的位置：是spring的顶级项目，和springFramework(ioc、aop)是同等级的。</p>
<p>springboot使用最小配置快速构建spring项目。springboot不是spring功能上的增强，而是提供一种快速开发spring项目的方式。</p>
<p>spring缺点：<br>&lt;1&gt; 写配置文件，繁琐<br>&lt;2&gt; 依赖繁琐，maven坐标版本问题</p>
<p>springboot提供的优点：<br>&lt;1&gt; 自动配置，应用程序启动时的过程<br>&lt;2&gt; 起步依赖，坐标pom打包到一起，对其他库的依赖传递<br>&lt;3&gt; 其他：嵌入式服务器，安全，健康检测</p>
<hr>
<p>✅ 用springboot搭建一个web项目：<br>&lt;1&gt; 创建maven项目<br>&lt;2&gt; 引入起步依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--springboot工程需要继承的父工程   --&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.1&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--  web开发的起步依赖  --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>&lt;3&gt; 写一个controller</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.liuxuan.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-12-22 23:28</span><br><span class="line"> **/</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/h&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;hello!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;4&gt; 写引导类，springboot项目入口，然后运行main方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.liuxuan;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-12-22 23:38</span><br><span class="line"> **/</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class StartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(StartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>✅ 快速构建</p>
<p>用idea，选Spring Initializr，选maven project，选jar打包方式，勾选依赖。</p>
<h2 id="springboot起步依赖"><a href="#springboot起步依赖" class="headerlink" title="springboot起步依赖"></a>springboot起步依赖</h2><p>spring-boot-starter-parent，往里看源码，最终是spring-boot-dependency包，其中pom文件中<code>&lt;dependencyManagement&gt;</code> 是版本锁定，父工程中定义的版本信息，自己工程中就可以不写版本号。</p>
<p>spring-boot-starter-web，往里看，发现引入了spring-web、spring-webmvc。</p>
<p>总结：<br>1.在spring-boot-starter-parent中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。<br>2.在各种starter中，定义了完成该功能的坐标合集，其中大部分版本信息来自于父工程。<br>3.我们工程继承自parent，引入starter，通过依赖传递，就可以简单方便获取需要的jar包，并且不会存在版本冲突问题。</p>
<h2 id="springboot配置"><a href="#springboot配置" class="headerlink" title="springboot配置"></a>springboot配置</h2><p>配置文件分类：properties文件、yaml&#x2F;yml文件。<br>profile文件，三种环境动态切换。</p>
<p>springboot基于约定，配置有默认值，替换的话，用application.properties&#x2F;application.yml文件来配置。resource根目录下，application.properties&#x2F;yml&#x2F;yaml 文件里面放程序自动识别的内容，也可以写自己定义的内容。</p>
<p>同一级目录下，配置文件的加载顺序：properties &gt; yml &gt; yaml</p>
<p>yaml：不是一个标记语言，是直观的能被电脑识别的数据序列化格式，以数据为核心，比xml更加简洁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xml:</span><br><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;port&gt;8080&lt;/port&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line"></span><br><span class="line">yml:</span><br><span class="line">server:</span><br><span class="line">    port: 8080</span><br><span class="line"></span><br><span class="line">properties:</span><br><span class="line">server.port=8080</span><br></pre></td></tr></table></figure>

<p>yaml语法：大小写敏感、数据值前必须有空格（至少一个）、缩进表示层级关系，缩进空格个数不重要，但要左对齐、#注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line"></span><br><span class="line">person:</span><br><span class="line">  name: liu</span><br><span class="line">  address: [beijing, shanghai]</span><br><span class="line"></span><br><span class="line">msg1: &quot;hello \n world&quot;  #双引号识别转义字符</span><br><span class="line">msg2: &#x27;hello \n world&#x27;  #单引号原样输出</span><br><span class="line"></span><br><span class="line">参数引用：$&#123;name&#125;</span><br></pre></td></tr></table></figure>


<p>读取配置文件内容：</p>
<p>1.@Value方法，单个属性注入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;person.name&#125;&quot;)</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">@Value(&quot;$&#123;person.address[0]&#125;&quot;)</span><br><span class="line">private String address;</span><br></pre></td></tr></table></figure>

<p>2.Environment</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private Environment env;    </span><br><span class="line"></span><br><span class="line">env.getProperty(&quot;person.name&quot;)</span><br></pre></td></tr></table></figure>

<p>3.@ConfigurationProperties，对象和配置的绑定</p>
<p>在实体类Person上加注解 <code>@ConfigurationProperties(prefix=&quot;person&quot;)</code></p>
<hr>
<p>profile：一套程序通常需要部署在不同的环境下，开发测试生产，如果每次打包都要修改配置文件，麻烦，profile提供进行动态配置切换的方式。</p>
<p>配置方式：<br>1.多profile文件方式：提供多个配置文件，每个代表一个环境<br>application-dev.properties&#x2F;yml<br>application-test.properties&#x2F;yml<br>application-pro.properties&#x2F;yml</p>
<p>2.yml单文件方式<br>用—分割不同环境配置</p>
<p>激活方式：<br>1.配置方式：<br><code>spring.profiles.active=dev</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    profiles:</span><br><span class="line">        active: dev</span><br></pre></td></tr></table></figure>

<p>2.虚拟机参数<br>在VM option中输入：<code>-Dspring.profiles.active=test</code></p>
<p>3.命令行参数<br>先package打包<br><code>java -jar ...jar --spring.profiles.active=test</code></p>
<hr>
<p>打包过程中，遇到：jar中没有主清单属性</p>
<p>原因：打包后的jar文件中的MANIFEST.MF缺少项目启动项，即没有Main-Class</p>
<p>解决方案：<br>1、指定MANIFEST.MF路径<br>项目打包前：<br>第一步 file–&gt;project structure 弹框后选中Atifacts—&gt; + —-&gt;jar—-&gt;from module with dependenceis<br>第二步 选择一个Main Class，选的StartApplication文件</p>
<p>2、项目pom.xml文件中添加插件spring-boot-maven-plugin</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>内部配置加载顺序：</p>
<p>1.项目根目录下的config文件夹下<br>2.项目根目录（idea点project files的根目录）下<br>3.classPath（resource目录下）的config文件夹下<br>4.classPath（resource目录下）下</p>
<p>前两个不会打进jar包里</p>
<hr>
<p>外部配置加载顺序：</p>
<p>1.命令行指定端口号：<code>java -jar spring-boot-study-api-1.0-SNAPSHOT.jar --server.port=8086</code><br>指定默认前缀路径：<code>--server.servlet.context-path=/default</code><br>2.指定外部配置文件路径：<code>--spring.config.location=路径</code><br>3.在jar包同目录下（target文件夹下），加一个配置文件<code>application.properties</code>，同样生效，外部配置优先生效</p>
<h2 id="springboot整合其他框架"><a href="#springboot整合其他框架" class="headerlink" title="springboot整合其他框架"></a>springboot整合其他框架</h2><h3 id="springboot整合Junit"><a href="#springboot整合Junit" class="headerlink" title="springboot整合Junit"></a>springboot整合Junit</h3><p>1.引入spring-boot-starter-test 起步依赖<br>2.在测试类上加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class) //springboot2不用加</span><br><span class="line">@SpringBootTest(classes = StartApplication.class) //如果与StartApplication在一个包下，可以不加括号里的</span><br></pre></td></tr></table></figure>


<h3 id="springboot整合redis"><a href="#springboot整合redis" class="headerlink" title="springboot整合redis"></a>springboot整合redis</h3><p>1.引入spring-boot-starter-data-redis依赖<br>2.连接本地的redis，不需要任何配置<br>3.直接用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">redisTemplate.boundValueOps(&quot;name&quot;).set(&quot;liu&quot;);</span><br><span class="line">Object o = redisTemplate.boundValueOps(&quot;name&quot;).get();</span><br></pre></td></tr></table></figure>
<p>4.其他ip的，需要配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    port: 6379</span><br></pre></td></tr></table></figure>


<h3 id="spring整合mybatis"><a href="#spring整合mybatis" class="headerlink" title="spring整合mybatis"></a>spring整合mybatis</h3><p>1.引入mybatis起步依赖 <code>mybatis-spring-boot-starter</code> （不同于其他，这个是mybatis提供的，用3.0.1的有点问题，改用2.1.0），添加mysql驱动 <code>mysql-connector-java</code><br>2.配置datasource和mybatis</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql:///test?serverTimezone=UTC</span><br><span class="line">    #db.url=jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    username: liuxuan</span><br><span class="line">    password: jade</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>
<p>3.创建表，并编写实体类<br>4.纯注解开发</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">@Repository</span><br><span class="line">public interface StudentMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from student&quot;)</span><br><span class="line">    public List&lt;Student&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5 .xml映射文件形式开发<br>Mapper接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">@Repository</span><br><span class="line">public interface StudentXmlMapper &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;Student&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xml配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.liuxuan.repository.mapper.StudentXmlMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.liuxuan.repository.domain.Student&quot;</span>&gt;</span></span><br><span class="line">        select * from student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>增加mybatis配置(不在spring下)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  # Mapper映射文件路径</span><br><span class="line">  mapper-locations: classpath:mapper/*Mapper.xml</span><br><span class="line">  # 包扫描</span><br><span class="line">  type-aliases-package: com.liuxuan.repository.domain</span><br></pre></td></tr></table></figure>


<h2 id="springboot原理分析"><a href="#springboot原理分析" class="headerlink" title="springboot原理分析"></a>springboot原理分析</h2><h3 id="springboot自动配置"><a href="#springboot自动配置" class="headerlink" title="springboot自动配置"></a>springboot自动配置</h3><p>Condition是spring4.0增加的条件判断功能，可以实现选择性地创建Bean操作。</p>
<h4 id="✅需求1-创建bean增加条件"><a href="#✅需求1-创建bean增加条件" class="headerlink" title="✅需求1:创建bean增加条件"></a>✅需求1:创建bean增加条件</h4><p>1.自定义条件类，继承Condition接口，实现matches方法，方法中进行逻辑判断，参数context可以获取上下文容器等，metadata可以获取注解属性。<br>2.判断条件，初始化bean时使用@Conditional(条件类.class)注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">需要加注解@Conditional：</span><br><span class="line">@Configuration</span><br><span class="line">public class UserConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @Conditional(ClassCondition.class)</span><br><span class="line">    public User user() &#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">自己定义一个实现了Condition接口的类，里面实现条件判断matches方法：</span><br><span class="line">public class ClassCondition implements Condition &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        // 写创建bean的条件：导入jedis坐标后创建bean</span><br><span class="line">        try &#123;</span><br><span class="line">            Class cls = Class.forName(&quot;redis.clients.jedis.Jedis&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">获取bean：</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class StartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 启动springboot应用，获取spring的ioc容器</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br><span class="line"></span><br><span class="line">        // 获取bean</span><br><span class="line">        Object user = context.getBean(&quot;user&quot;);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="✅需求2-用自定义注解实现动态Condition"><a href="#✅需求2-用自定义注解实现动态Condition" class="headerlink" title="✅需求2:用自定义注解实现动态Condition"></a>✅需求2:用自定义注解实现动态Condition</h4><p>定义自定义注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Conditional(ClassCondition.class)</span><br><span class="line">public @interface ConditionOnClass &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Config中加注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class UserConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">//    @Conditional(ClassCondition.class)</span><br><span class="line">    @ConditionOnClass(&quot;redis.clients.jedis.Jedis&quot;)</span><br><span class="line">    public User user() &#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承Condition接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ClassCondition implements Condition &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param context  上下文对象。用于获取环境、Ioc容器、classLoader对象</span><br><span class="line">     * @param metadata 注解元对象，可以用于获取注解定义的属性值</span><br><span class="line">     * @return boolean</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        // 需求1：写创建bean的条件：导入jedis坐标后创建bean</span><br><span class="line">//        try &#123;</span><br><span class="line">//            Class cls = Class.forName(&quot;redis.clients.jedis.Jedis&quot;);</span><br><span class="line">//        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">//            return false;</span><br><span class="line">//        &#125;</span><br><span class="line">//        return true;</span><br><span class="line"></span><br><span class="line">        // 需求2：通过注解属性值value指定坐标后创建bean</span><br><span class="line">        Map&lt;String, Object&gt; map = metadata.getAnnotationAttributes(ConditionOnClass.class.getName());</span><br><span class="line">        String[] value = (String[])map.get(&quot;value&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            for (String className : value) &#123;</span><br><span class="line">                Class&lt;?&gt; cls = Class.forName(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看包spring-boot-anto-configuration中，springboot已经定义好了很多condition注解，例如：@ConditionalOnClass。</p>
<hr>
<h4 id="✅切换内置服务器"><a href="#✅切换内置服务器" class="headerlink" title="✅切换内置服务器"></a>✅切换内置服务器</h4><p>spring-boot-starter-web</p>
<p>spring-boot-autoconfiguration 包的web的embedded中内置了四种服务器，包括jetty、netty、tomcat、undertom。</p>
<p>里面还有个类负责选择web服务器，原理也是用了@ConditionalOnClass注解，看导入了什么坐标来选择服务器。</p>
<p>用<exclusions> 把spring-boot-starter-web 中的 spring-boot-starter-tomcat 排除掉。再引入jetty的依赖，就会切换为jetty服务器。</p>
<hr>
<h4 id="✅-Enable-注解"><a href="#✅-Enable-注解" class="headerlink" title="✅ @Enable*注解"></a>✅ @Enable*注解</h4><p>SpringBoot提供了很多@Enable开头的注解，用于动态启动某些功能(获取一些bean)，其底层原理是使用@Import注解导入一些配置类，实现Bean的动态加载。</p>
<p>看注解 @SpringBootApplication</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration --内部@Configuration可配置bean</span><br><span class="line">@EnableAutoConfiguration --重点</span><br><span class="line">@ComponentScan(   --包扫描</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public @interface SpringBootApplication</span><br><span class="line"></span><br><span class="line">其中Enable注解下：</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">重要的是Import注解</span><br></pre></td></tr></table></figure>

<p>⚠️启动子模块的启动类，无法启动父工程的controller。</p>
<p>springboot工程不可以直接获取其他jar包中定义的bean，比如redisTemplate。</p>
<p>原因：@ComponentScan 包扫描的范围是：当前引导类所在包及其子包，其他项目配置Bean的包不在该范围内。</p>
<p>尝试：另外创建一个子模块，子模块引入另一个子模块的pom，然后尝试获取另一个子模块的bean。<br>报错：NoSuchBeanDefinitionException。</p>
<p>如何获取Bean：<br>1.在启动类上加@ComponentScan注解，扫描要引入Bean的包。<br>缺点：要写包太累赘<br>2.使用@Import注解加载要导入bean的配置类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Import &#123;</span><br><span class="line">    Class&lt;?&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>value中的这些类会被spring创建并放入IOC容器中。<br>缺点：要记类的名字<br>3.对Import注解进行封装<br>自定义一个Enable注解，把Import注解封装进去，要想用这个bean的时候，直接用Enable注解就可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Import(UserConfig.class)</span><br><span class="line">public @interface EnableUser &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) //排除此类的AutoConfig</span><br><span class="line">//@ComponentScan(&quot;com.liuxuan.condition&quot;)</span><br><span class="line">//@Import(UserConfig.class)</span><br><span class="line">@EnableUser</span><br><span class="line">public class StartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 启动springboot应用，获取spring的ioc容器</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br><span class="line"></span><br><span class="line">        // 获取bean</span><br><span class="line">        Object user = context.getBean(&quot;user&quot;);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>😊<code>@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class&#125;)</code></p>
<p>exclude，排除此类的AutoConfig，即禁止 SpringBoot 自动注入数据源配置。</p>
<p>DataSourceAutoConfiguration.class 会自动查找 application.yml 或者 properties 文件里的 spring.datasource.* 相关属性并自动配置单数据源「注意这里提到的单数据源」。</p>
<p>那么问题来了，排除了自动配置，Spring还怎么识别到数据库配置呢？</p>
<p>答：显然接下来就需要手动配置，如果你发现项目中存在这个排除的操作，可以在项目中搜一下Java关键字@ConfigurationProperties(“spring.datasource)，你可能会发现手动配置数据源的类。</p>
<p>再来回答为何要手动配置数据源，因为要配置多数据源，上边有提到DataSourceAutoConfiguration.class默认会帮我们自动配置单数据源，所以，如果想在项目中使用多数据源就需要排除它，手动指定多数据源。</p>
<p>@SpringBootApplication注解中exclude参数使用及原理:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/csdn_20150804/article/details/116104742">https://blog.csdn.net/csdn_20150804/article/details/116104742</a></p>
<h4 id="✅-Import注解"><a href="#✅-Import注解" class="headerlink" title="✅ @Import注解"></a>✅ @Import注解</h4><p>@Enable*底层依赖@Import注解导入一些类，使用@Import导入的类会被Spring加载到IOC容器中，@Import提供四种用法：</p>
<p>1.导入Bean</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StartApplication上：</span><br><span class="line">@Import(User.class)</span><br><span class="line"></span><br><span class="line">StartApplication中：</span><br><span class="line">// 根据类型获取bean</span><br><span class="line">Object user = context.getBean(User.class);</span><br><span class="line">System.out.println(user);</span><br><span class="line">// 获取bean名称</span><br><span class="line">Map&lt;String, User&gt; map = context.getBeansOfType(User.class);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>

<p>2.导入配置类<br>这种方式，配置类上的@Configuration注解可以不加</p>
<p>3.导入ImportSelect实现类。一般用于加载配置文件中的类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Import(MyImportSelector.class)</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">public class MyImportSelector implements ImportSelector &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        return new String[]&#123;&quot;com.liuxuan.condition.User&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.导入ImportBeanDefinitionRegistrar实现类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Import(MyImportBeanDefinitionRegistrar.class)</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(User.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(&quot;beanName&quot;, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="✅-EnableAutoConfiguration注解"><a href="#✅-EnableAutoConfiguration注解" class="headerlink" title="✅@EnableAutoConfiguration注解"></a>✅@EnableAutoConfiguration注解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@EnableAutoConfiguration</span><br><span class="line"></span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line"></span><br><span class="line">AutoConfigurationImportSelector中：</span><br><span class="line">public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    if (!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        return NO_IMPORTS;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">        return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">核心代码：getAutoConfigurationEntry</span><br><span class="line">List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line"></span><br><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">    return configurations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">意思是：从spring-boot-autoconfiguration的jar包下面的META-INF/spring.factories文件中加载。</span><br><span class="line">看到这个文件中可以看到：</span><br><span class="line"> # Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">有很多配置文件类</span><br></pre></td></tr></table></figure>

<p>总结：<br>@EnableAutoConfiguration 如何实现自动配置<br>1.@EnableAutoConfiguration注解内部使用@Import({AutoConfigurationImportSelector.class}) 来加载配置类<br>2.配置文件位置：META-INF&#x2F;spring.factories，该配置文件中定义了大量的配置类，当springboot应用启动时，会自动加载这些配置类，初始化bean<br>3.并不是所有的bean都会被初始化，在配置类中使用Condition来加载满足条件的bean</p>
<h4 id="✅自定义starter实现"><a href="#✅自定义starter实现" class="headerlink" title="✅自定义starter实现"></a>✅自定义starter实现</h4><p>看mybatis-spring-boot-starter如何实现：<br>1.看到mybatis-spring-boot-starter包下没什么，只有一个pom文件，里面引入mybatis-spring-boot-autoconfigure包<br>2.mybatis-spring-boot-autoconfigure包的META-INF&#x2F;spring.factories文件中定义了MybatisAutoConfiguration<br>3.@EnableAutoConfiguration会自动识别到META-INF&#x2F;spring.factories文件，从而识别到MybatisAutoConfiguration，模块中初始化的bean就创建出来</p>
<p>需求：自定义redis-starter，当导入redis-starter坐标时，springboot自动创建jedis的bean。</p>
<p>1.创建一个redis-autoconfiguration模块，在里面提供jedis的bean，并实现自动配置。</p>
<p>⚠️亲测，一个模块的配置了8082端口，另一个模块没配置端口，但是运行该模块的StartApplication，要用的是8082端口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RedisAutoConfiguration.class:</span><br><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(RedisProperties.class) //RedisProperties被spring识别，创建bean</span><br><span class="line">@ConditionalOnClass(Jedis.class)  //疑问：没有Jedis坐标则不配置，创建之前不是没这个Bean吗？导入坐标和有bean的关系？</span><br><span class="line">public class RedisAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(name = &quot;jedis&quot;)  //已经定义了就不定义</span><br><span class="line">    public Jedis getJedisBean(RedisProperties redisProperties) &#123;</span><br><span class="line">        System.out.println(&quot;RedisAutoConfiguration...&quot;);</span><br><span class="line">        return new Jedis(redisProperties.getIp(), redisProperties.getPort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RedisProperties.class:</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ConfigurationProperties(prefix = &quot;redis&quot;) //与配置文件中对应</span><br><span class="line">public class RedisProperties &#123;</span><br><span class="line">    private String ip = &quot;localhost&quot;; //没提供时给默认值</span><br><span class="line">    private Integer port = 6379;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建META-INF&#x2F;spring.factories文件，其中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">    com.liuxuan.redis.configuration.RedisAutoConfiguration</span><br></pre></td></tr></table></figure>

<p>3.创建redis-starter模块，pom文件中引入redis-configuration依赖。</p>
<p>4.在另一个模块中，pom文件中引入redis-starter依赖。在StartApplication中尝试获取bean。这个模块中导入了Jedis依赖，但是并没有Jedis的bean的配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br><span class="line">Jedis jedis = context.getBean(Jedis.class);</span><br><span class="line">System.out.println(jedis);</span><br><span class="line"></span><br><span class="line">jedis.set(&quot;hello&quot;, &quot;hi&quot;);</span><br><span class="line">System.out.println(jedis.get(&quot;hello&quot;));</span><br></pre></td></tr></table></figure>

<p>5.可以在使用的模块中进行配置redis的ip和host</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis.port=6379</span><br><span class="line">redis.ip=localhost</span><br></pre></td></tr></table></figure>

<p>总结：StartApplication上的@SpringBootApplication注解中的@EnableAutoConfiguration中的@Import({AutoConfigurationImportSelector.class})中会自动去找jar包中的META-INF&#x2F;spring.factories文件，识别到需要加载的配置类，再获取配置类创建的bean，从而实现自动配置bean。</p>
<p>看spring-boot-autoconfiguration包下的data下的redis下的文件中，就定义了RedisAutoConfiguration，和上面实现类似。</p>
<h3 id="springboot监听机制"><a href="#springboot监听机制" class="headerlink" title="springboot监听机制"></a>springboot监听机制</h3><p>springboot的监听机制，其实是对java提供的事件监听机制的封装。</p>
<p>java中的事件监听机制定义了以下几个角色：<br>1.事件：Event，继承java.util.EventObject类的对象<br>2.事件源：Source，任意对象Object<br>3.监听器：Listener，实现java.util.EventListener接口的对象</p>
<p>springboot不需要这么麻烦，springboot在项目启动时，会对几个监听器进行回调，我们可以实现这些监听器接口，在项目启动时完成一些操作。</p>
<p>ApplicationContextInitializer、SpringApplicationRunListener、CommandLineRunner、ApplicationRunner</p>
<p>1 .继承这些接口，重写方法，并打印对应操作，@Component注册bean。</p>
<p>2 .启动发现只有后两个有打印。<br>CommandLineRunner、ApplicationRunner在项目启动后执行run方法，可以帮助做一些事情，比如：缓存预热(提前把数据库的数据加到缓存)<br>打印这两个方法的args，发现是空数组，在配置中的environment中的program arguments中添加hello world，就会返回[hello, world]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyCommandLineRunner implements CommandLineRunner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;MyCommandLineRunner run...&quot;);</span><br><span class="line">        System.out.println(&quot;MyCommandLineRunner args:&quot; + Arrays.asList(args));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyApplicationRunner implements ApplicationRunner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(ApplicationArguments args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;MyApplicationRunner run...&quot;);</span><br><span class="line">        System.out.println(&quot;MyApplicationRunner args:&quot; + Arrays.asList(args.getSourceArgs()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3 .其他两个监听器怎么用：在META-INF&#x2F;spring.factories（固定的写法，工程启动时会被自动扫描到）中配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">  com.liuxuan.listener.MyApplicationContextInitializer</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">  com.liuxuan.listener.MySpringApplicationRunListener</span><br></pre></td></tr></table></figure>

<p>MyApplicationContextInitializer的initialize方法：项目还没有准备ioc容器之前，可以检测一些资源是否存在。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyApplicationContextInitializer implements ApplicationContextInitializer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void initialize(ConfigurableApplicationContext applicationContext) &#123;</span><br><span class="line">        System.out.println(&quot;MyApplicationContextInitializer project start..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>MySpringApplicationRunListener 报错：<code>java.lang.NoSuchMethodException: com.liuxuan.listener.MySpringApplicationRunListener.&lt;init&gt;(org.springframework.boot.SpringApplication, [Ljava.lang.String;)</code><br>表示需要一个构造方法。<br>看一下代码中提供的一个实现类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//入参SpringApplication表示项目启动时的事件源</span><br><span class="line">public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered &#123;</span><br><span class="line">    private final SpringApplication application;</span><br><span class="line">    private final String[] args;</span><br><span class="line">    private final SimpleApplicationEventMulticaster initialMulticaster;</span><br><span class="line"></span><br><span class="line">    public EventPublishingRunListener(SpringApplication application, String[] args) &#123;</span><br><span class="line">        this.application = application;</span><br><span class="line">        this.args = args;</span><br><span class="line">        this.initialMulticaster = new SimpleApplicationEventMulticaster();</span><br><span class="line">        Iterator var3 = application.getListeners().iterator();</span><br><span class="line"></span><br><span class="line">        while(var3.hasNext()) &#123;</span><br><span class="line">            ApplicationListener&lt;?&gt; listener = (ApplicationListener)var3.next();</span><br><span class="line">            this.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，加一个构造方法，并把@Component去掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class MySpringApplicationRunListener implements SpringApplicationRunListener &#123;</span><br><span class="line"></span><br><span class="line">    public MySpringApplicationRunListener(SpringApplication application, String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void starting(ConfigurableBootstrapContext bootstrapContext) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 项目启动中...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 环境对象开始准备中(还不能获取配置信息)...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextPrepared(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 上下文对象开始准备(还没加载ioc容器)...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextLoaded(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 上下文对象开始加载(创建springboot启动的bean)...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void started(ConfigurableApplicationContext context, Duration timeTaken) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 加载完成...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void started(ConfigurableApplicationContext context) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void ready(ConfigurableApplicationContext context, Duration timeTaken) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void running(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 项目启动完成开始运行...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void failed(ConfigurableApplicationContext context, Throwable exception) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 项目启动失败...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看spring-boot包下的context下的event包下的一些定义好的事件Event，往里看都是继承自java的util包下的EventObject的。所以说springboot的事件监听是对java事件监听的封装。</p>
<h3 id="springboot启动流程"><a href="#springboot启动流程" class="headerlink" title="springboot启动流程"></a>springboot启动流程</h3><p>观察者模式：观察者和被观察者，被观察者：事件和事件源，观察者：监听器。</p>
<h4 id="✅初始化"><a href="#✅初始化" class="headerlink" title="✅初始化"></a>✅初始化</h4><p>debug一下启动类StartApplication中的<code>SpringApplication.run</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123;</span><br><span class="line">    return (new SpringApplication(primarySources)).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个SpringApplication对象（事件源对象）。</p>
<p>SpringApplication构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">    this.sources = new LinkedHashSet();</span><br><span class="line">    this.bannerMode = Mode.CONSOLE;</span><br><span class="line">    this.logStartupInfo = true;</span><br><span class="line">    this.addCommandLineProperties = true;</span><br><span class="line">    this.addConversionService = true;</span><br><span class="line">    this.headless = true;</span><br><span class="line">    this.registerShutdownHook = true;</span><br><span class="line">    this.additionalProfiles = Collections.emptySet();</span><br><span class="line">    this.isCustomEnvironment = false;</span><br><span class="line">    this.lazyInitialization = false;</span><br><span class="line">    this.applicationContextFactory = ApplicationContextFactory.DEFAULT;</span><br><span class="line">    this.applicationStartup = ApplicationStartup.DEFAULT;</span><br><span class="line">    this.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);</span><br><span class="line">    this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));  //有没有主类</span><br><span class="line">    this.webApplicationType = WebApplicationType.deduceFromClasspath();   //是否是web环境</span><br><span class="line">    this.bootstrapRegistryInitializers = new ArrayList(this.getSpringFactoriesInstances(BootstrapRegistryInitializer.class));</span><br><span class="line">    this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));  //从springfactory文件中加载initializers</span><br><span class="line">    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));  //从springfactory配置文件中加载listener（放到set集合中）</span><br><span class="line">    this.mainApplicationClass = this.deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/springboot%E5%90%AF%E5%8A%A8.png"></p>
<h4 id="✅run方法"><a href="#✅run方法" class="headerlink" title="✅run方法"></a>✅run方法</h4><p>StartApplication的run方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">    long startTime = System.nanoTime();  //监控耗时，也可以用StopWatch</span><br><span class="line">    DefaultBootstrapContext bootstrapContext = this.createBootstrapContext();</span><br><span class="line">    ConfigurableApplicationContext context = null;  //定一个容器</span><br><span class="line">    this.configureHeadlessProperty();  //加载东西</span><br><span class="line">    SpringApplicationRunListeners listeners = this.getRunListeners(args);  //获取RunListener</span><br><span class="line">    listeners.starting(bootstrapContext, this.mainApplicationClass);  //调用runListener的starting方法</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">        ConfigurableEnvironment environment = this.prepareEnvironment(listeners, bootstrapContext, applicationArguments);  //准备环境，回调runListener的prepareEnvironment方法，环境对象Environment就有信息了</span><br><span class="line">        this.configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = this.printBanner(environment);  //打印spring图标，可以替换banner.txt</span><br><span class="line">        context = this.createApplicationContext();  //创建ioc容器</span><br><span class="line">        context.setApplicationStartup(this.applicationStartup);</span><br><span class="line">        this.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);  //加载ioc容器</span><br><span class="line">        // 可以看context里的beanFactory里的beanDefinitionMap，里面是真正的bean，这时还没加载bean</span><br><span class="line">        this.refreshContext(context);  //这里从配置文件里找，创建bean（耗时操作）</span><br><span class="line">        this.afterRefresh(context, applicationArguments);</span><br><span class="line">        Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">        if (this.logStartupInfo) &#123;</span><br><span class="line">            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), timeTakenToStartup);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        listeners.started(context, timeTakenToStartup);  //项目启动成功，加载成功</span><br><span class="line">        this.callRunners(context, applicationArguments);  //commandLineRunner和applicationRunner 回调执行</span><br><span class="line">    &#125; catch (Throwable var12) &#123;</span><br><span class="line">        this.handleRunFailure(context, var12, listeners);</span><br><span class="line">        throw new IllegalStateException(var12);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">        listeners.ready(context, timeTakenToReady);</span><br><span class="line">        return context;</span><br><span class="line">    &#125; catch (Throwable var11) &#123;</span><br><span class="line">        this.handleRunFailure(context, var11, (SpringApplicationRunListeners)null);</span><br><span class="line">        throw new IllegalStateException(var11);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>以上，通过debug源码的方式，探索了springboot启动流程，看了监听器方法在哪里执行回调。</p>
<h2 id="springboot监控"><a href="#springboot监控" class="headerlink" title="springboot监控"></a>springboot监控</h2><h3 id="url方式"><a href="#url方式" class="headerlink" title="url方式"></a>url方式</h3><p>SpringBoot自带监控功能Actuator，可以帮助实现对程序内部运行情况监控，比如监控状况、Bean加载情况、配置属性 、日志信息等。</p>
<p>使用步骤</p>
<p>① 导入依赖坐标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>② 访问<a target="_blank" rel="noopener" href="http://localhost:8080/actuator">http://localhost:8080/actuator</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_links&quot;:&#123;</span><br><span class="line">        &quot;self&quot;:&#123;</span><br><span class="line">            &quot;href&quot;:&quot;http://localhost:8082/actuator&quot;,</span><br><span class="line">            &quot;templated&quot;:false</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;health-path&quot;:&#123;</span><br><span class="line">            &quot;href&quot;:&quot;http://localhost:8082/actuator/health/&#123;*path&#125;&quot;,</span><br><span class="line">            &quot;templated&quot;:true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;health&quot;:&#123;</span><br><span class="line">            &quot;href&quot;:&quot;http://localhost:8082/actuator/health&quot;,</span><br><span class="line">            &quot;templated&quot;:false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">路径	描述</span><br><span class="line">/beans	描述应用程序上下文里全部的Bean，以及它们的关系</span><br><span class="line">/env	获取全部环境属性</span><br><span class="line">/env/&#123;name&#125;	根据名称获取特定的环境属性值</span><br><span class="line">/health	报告应用程序的健康指标，这些值由HealthIndicator的实现类提供</span><br><span class="line">/info	获取应用程序的定制信息，这些信息由info打头的属性提供</span><br><span class="line">/mappings	描述全部的URI路径，以及它们和控制器(包含Actuator端点)的映射关系</span><br><span class="line">/metrics	报告各种应用程序度量信息，比如内存用量和HTTP请求计数</span><br><span class="line">/metrics/&#123;name&#125;	报告指定名称的应用程序度量值</span><br><span class="line">/trace	提供基本的HTTP请求跟踪信息(时间戳、HTTP头等)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">info:</span><br><span class="line">  name: hello</span><br><span class="line">  age: 23</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  #开启健康检查的完整信息</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: always</span><br><span class="line">  #将所有的监控endPoints暴漏出来</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: *</span><br></pre></td></tr></table></figure>

<h3 id="Spring-Boot-Admin"><a href="#Spring-Boot-Admin" class="headerlink" title="Spring Boot Admin"></a>Spring Boot Admin</h3><p>监控的可视化界面，只不过需要自己再起个监控服务。</p>
<p>Spring Boot Admin是一个开源社区项目，用于管理和监控SpringBoot应用程序。</p>
<p>Spring Boot Admin 有两个角色，客户端(Client)和服务端(Server)。</p>
<p>应用程序作为Spring Boot Admin Client向为Spring Boot Admin Server注册</p>
<p>Spring Boot Admin Server 的UI界面将Spring Boot Admin Client的Actuator Endpoint上的一些监控信息.</p>
<p>使用步骤：</p>
<p>admin-server（监控服务）</p>
<p>① 创建 admin-server 模块</p>
<p>② 导入依赖坐标 admin-starter-server</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>③ 在引导类上启用监控功能@EnableAdminServer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableAdminServer</span><br><span class="line">public class SpringbootAdminServerApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootAdminServerApplication.class, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>admin-client（被监控服务）</p>
<p>① 创建 admin-client 模块</p>
<p>② 导入依赖坐标 admin-starter-client</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>③ 配置相关信息：server地址等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指定admin.server地址，server在9000端口号，相当于向server注册</span><br><span class="line">spring.boot.admin.client.url=http://localhost:9000</span><br><span class="line">展示健康检查详细详细展示出来</span><br><span class="line">management.endpoint.health.show-details=always</span><br><span class="line">开启所有配置</span><br><span class="line">management.endpoints.web.exposure.include=*</span><br></pre></td></tr></table></figure>

<p>④ 启动server和client服务，访问server<br><a target="_blank" rel="noopener" href="http://localhost:9000/applications">http://localhost:9000/applications</a></p>
<hr>
<p>出现问题：<br>Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured.</p>
<p>原因：当前项目没有配置DataSource相关配置。springboot自动配置时，检测到添加了mysql的依赖包，但是配置文件中却没添加数据库的相关配置。<br>该案例中：mysql依赖在父pom中引入，该子工程不用mysql。</p>
<p>解决办法：@SpringBootApplication(exclude &#x3D; DataSourceAutoConfiguration.class) 排除自动注入数据库配置</p>
<hr>
<p>不知道是不是包的版本不对，有的版本报错，有的版本运行了却没显示。<br>idea中点EndPoins就可以图形化界面的方式来监控，不用那么麻烦，</p>
<h2 id="springboot项目部署"><a href="#springboot项目部署" class="headerlink" title="springboot项目部署"></a>springboot项目部署</h2><p>SpringBoot 项目开发完毕后，支持两种方式部署到服务器：</p>
<p>① jar包(官方推荐) 用内置的tomcat启动</p>
<p>② war包</p>
<h3 id="jar打包方式"><a href="#jar打包方式" class="headerlink" title="jar打包方式"></a>jar打包方式</h3><p>将当前模块打包：idea右边maven中选择要打包的模块，点lifecycle，点package。</p>
<p>打好的jar包在项目的target目录下。直接<code>java -jar .\jar包名称</code>，启动成功。</p>
<h3 id="war打包方式"><a href="#war打包方式" class="headerlink" title="war打包方式"></a>war打包方式</h3><p>pom.xml里更改打包方式：<code>&lt;packaging&gt;war&lt;/packaging&gt;</code><br>如果想改war包的名字：<code>&lt;finalName&gt;</code>标签</p>
<p>在引导类继承SpringBootServletInitializer类，并重写configure方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootDeployApplication extends SpringBootServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootDeployApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123;</span><br><span class="line">        return builder.sources(SpringBootDeployApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行，打好的war包可以被外部tomcat识别，将其放在tomcat目录下的webapps目录下，启动tomcat即可（startup.bat），浏览器访问需要加项目的包名称，因为WEB-INF文件在其之下。并且，内置项目的端口号配置就不生效了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/05/myblog/java/Page%E5%88%86%E9%A1%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/05/myblog/java/Page%E5%88%86%E9%A1%B5/" class="post-title-link" itemprop="url">Page分页</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-05 12:55:45" itemprop="dateCreated datePublished" datetime="2022-11-05T12:55:45+08:00">2022-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-23 23:09:22" itemprop="dateModified" datetime="2023-02-23T23:09:22+08:00">2023-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="spring整合mybatis"><a href="#spring整合mybatis" class="headerlink" title="spring整合mybatis"></a>spring整合mybatis</h2><p>新建一个子工程web-repository。</p>
<p>mybatis依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.35&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>项目结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--web-repository</span><br><span class="line"> --src</span><br><span class="line">  --main</span><br><span class="line">   --java</span><br><span class="line">     --config</span><br><span class="line">       --SpringConfig.java</span><br><span class="line">     --domain</span><br><span class="line">       --StudentDO.java</span><br><span class="line">     --StudentDao.java</span><br><span class="line">   --resource</span><br><span class="line">     --mapper</span><br><span class="line">  --test</span><br></pre></td></tr></table></figure>

<p>✅spring配置类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &#123;&quot;org.example&quot;&#125;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要引入spring依赖。</p>
<p>spring配置：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fengyupinglan/p/14517267.html">https://www.cnblogs.com/fengyupinglan/p/14517267.html</a></p>
<p>✅spring整合mybatis</p>
<p>首先，spring配置文件可以是xml文件在resource文件夹下，也可以是注解方式的java文件。先写一个spring配置文件，自动装配搞上去。还有mybatis的一些bean要配置上去。</p>
<h3 id="xml方式"><a href="#xml方式" class="headerlink" title="xml方式"></a>xml方式</h3><p>xml文件方式，spring-mybatis.xml<br>开启自动扫描和配置bean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描,扫描多个包用,隔开--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启Aspect生成代理对象 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--加载properties文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">ignore-unresolvable</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">location</span>=<span class="string">&#x27;classpath:dbconfig.properties&#x27;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1.配置阿里druid连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置数据库基本信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.maxActive&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.initialSize&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2.配置spring的数据源，声明事务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3.配置 mybatis，扫描mapper.xml文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 3.1 配置 mybatis config --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 3.2 配置扫描mybatis映射文件路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4.类似于 jdbcTemplate 帮助类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描了所有的*Mapper.xml对应的mapper接口文件，这样就不用一个一个手动配置Mapper的映射了，只要Mapper接口类和Mapper映射文件对应起来就可以了。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.example.mysql&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>druid需要依赖包：druid<br>SqlSessionFactoryBean 需要依赖包：spring-jdbc<br>还需要 ibatis-common</p>
<p>dbconfig.properties:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.url=jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">db.driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">db.password=jade</span><br><span class="line">db.username=liuxuan</span><br><span class="line">db.maxActive=5</span><br><span class="line">db.initialSize=1</span><br></pre></td></tr></table></figure>

<p>mybatis配置文件，mybatis-config.xml<br>一些configuration setting</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//ybatis.org//DTD SQL Map Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;REUSE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>xml方式spring整合mybatis，mybatis配置项的意义：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45797116/article/details/117105095">https://blog.csdn.net/qq_45797116/article/details/117105095</a></p>
<p>xml文件中如果想引入其他xml文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;import resource=&quot;.../...xml&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><p>注解方式，SpringConfig.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package org.example.mysql.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.ImportResource;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &#123;&quot;org.example&quot;&#125;)</span><br><span class="line">@ImportResource(&quot;classpath:spring-mybatis.xml&quot;) //导入xml配置项</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，可以用@Import导入其他注解方式的配置文件，以及用@ImportResource导入xml方式的配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Import(CDPlayerConfig.class)  </span><br><span class="line">@ImportResource(&quot;classpath:cons-injec.xml&quot;) //导入xml配置项</span><br></pre></td></tr></table></figure>

<p>注解方式倒入配置文件：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42107384/article/details/116475637">https://blog.csdn.net/weixin_42107384/article/details/116475637</a></p>
<p>纯注解方式的整合spring和mybatis配置：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44226181/article/details/127343597">https://blog.csdn.net/weixin_44226181/article/details/127343597</a></p>
<p>还有一个一行代码的基于注解整合的：<br><a target="_blank" rel="noopener" href="https://www.pudn.com/news/62f1dcb95425817ffc22c172.html">https://www.pudn.com/news/62f1dcb95425817ffc22c172.html</a></p>
<h3 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package org.example;</span><br><span class="line"></span><br><span class="line">public class StudentDaoTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectById() &#123;</span><br><span class="line"></span><br><span class="line">        // xml：</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        UserMapper mapper = (UserMapper) context.getBean(&quot;userMapper&quot;);</span><br><span class="line"></span><br><span class="line">        // 注解：</span><br><span class="line">        ApplicationContext context =new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        StudentDao studentDao = (StudentDao) context.getBean(&quot;studentDao&quot;);</span><br><span class="line"></span><br><span class="line">        StudentDO studentDO = studentDao.selectById(1L);</span><br><span class="line">        System.out.println(studentDO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试验证及xml中配置SqlSessionFactory的bean和扫描的bean：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_28082757/article/details/103488364">https://blog.csdn.net/qq_28082757/article/details/103488364</a></p>
<p>配置数据库连接池有几种方法，上面用的是ali的druid连接池，关于Druid连接池：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chy18883701161/p/12594889.html">https://www.cnblogs.com/chy18883701161/p/12594889.html</a></p>
<p>注解方式配置JdbcConfig中 PlatformTransactionManager 是事务管理，在spring-jdbc包下。<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/903c01cb2a77">https://www.jianshu.com/p/903c01cb2a77</a></p>
<p>@Mapper注解，难道是spring-boot才能用的？<br>mybatis支持的映射方式有基于xml的mapper.xml文件、基于java的使用Mapper接口class。<br>从mybatis3.4.0开始加入了@Mapper注解，目的就是为了不再写mapper映射文件。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46369022/article/details/122755858">https://blog.csdn.net/weixin_46369022/article/details/122755858</a><br>需要依赖包：mybatis-spring-boot-starter</p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>✅ @Value里的字段报红</p>
<p>原因：自动导入了lombok里的@Value，要用的是SpringFramework下的@Value。</p>
<p>✅ xml配置文件加载不到properties属性问题</p>
<p>原因：spring中没有成功加载相应的配置文件</p>
<p>解决：进入File-Project Struccture，进入Facets中进行配置，.在右边的spring目录下，找到对应的爆红问题所在配置文件，选择xml文件，点击修改符合（下图中的小铅笔），在跳出来的弹框中，选择添加（加号），然后选择Additioonal properties files。然后找到需要加载进spring中的配置文件，点击OK，添加成功。</p>
<p>来自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaogot/article/details/103224088">https://blog.csdn.net/zhaogot/article/details/103224088</a></p>
<p>✅ xml配置文件中的问题：根元素 “beans” 必须匹配 DOCTYPE 根 “null”</p>
<p>在<code>&lt;beans&gt;</code>标签那里报出来。</p>
<p>原因：mybatis在扫描Mapper.xml文件时，扫描到非mapper文件。比如本次报错扫描到了自己。spring.xml的根元素是<code>&lt;beans&gt;&lt;/beans&gt;</code>当然不会有DOCTYPE了。<br>所以当Mybatis扫描到了Spring.xml这个非Mapper.xml文件时，自然找不到DOCTYPE，所以会有“DOCTYPE 根 “null””这个错误。</p>
<p>粗心：应该扫的是mybatis-config.xml文件，结构写成了自己。</p>
<p>来自：<a target="_blank" rel="noopener" href="https://www.codeleading.com/article/7746743165/">https://www.codeleading.com/article/7746743165/</a></p>
<p>✅ org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)</p>
<p>原因：mapper接口和xml文件没匹配上，有可能是文件名方法名没匹配上，这里是在配置文件里没加扫描接口，加了就好了。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43570367/article/details/103147854">https://blog.csdn.net/weixin_43570367/article/details/103147854</a></p>
<p>✅ properties文件 java.lang.NumberFormatException</p>
<p>明明是数字类型，但是说我从String转为int发生异常。</p>
<p>需要在xml配置文件中加载properties配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载properties文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">ignore-unresolvable</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">location</span>=<span class="string">&#x27;classpath:dbconfig.properties&#x27;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>spring加载properties文件的几种方式：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/chuige2013/article/details/121759088">https://blog.csdn.net/chuige2013/article/details/121759088</a></p>
<p>✅ java.sql.SQLException: com.mysql.cj.jdbc.Driver</p>
<p>mysql连接驱动依赖的版本不匹配问题，一般出现在使用低版本连接驱动连接高版本mysql情况下，解决方法是在maven中央仓库中下载高版本的mysql连接驱动.</p>
<p>mysql-connector-java 换8.0.21的包，自动引入没成功，手动下载装到.m2的。</p>
<p>✅ init datasource error, url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8</p>
<p>db.url换成：<code>jdbc:mysql://localhost:3306/mysql?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</code></p>
<p>✅ Table ‘mysql.student’ doesn’t exist</p>
<p>上面mysql换成库名。</p>
<p>😄终于成功了，不容易。</p>
<h2 id="com-github-pagehelper"><a href="#com-github-pagehelper" class="headerlink" title="com.github.pagehelper"></a>com.github.pagehelper</h2><p>背景：使用Pige时，从数据库中获取到list之后，removeIf筛选，但是分页得到的效果不对，条目总数total是从数据库得到的list size。</p>
<p>原因：Page与Mybatis强耦合，不是先从数据库获取再分页，而是先获取某页要获取的条目，耦合到sql中查询。</p>
<p>难道只能是spring-boot用的？ pagehelper-spring-boot-starter 依赖包中。</p>
<p>PageHelper分页：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43958747/article/details/103822761">https://blog.csdn.net/weixin_43958747/article/details/103822761</a></p>
<p>其中有个参数为CallBack接口。</p>
<p>⚠️使用中的一个case：<br>Pageed中的list的元素得和数据库dao返回的数据结构一样，得是DO。获取了Paged之后再转为vo，因为分页Page和mybatis是强耦合的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/11/myblog/java/java%20web%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/11/myblog/java/java%20web%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">java web相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-11 14:46:24" itemprop="dateCreated datePublished" datetime="2022-09-11T14:46:24+08:00">2022-09-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-23 00:15:16" itemprop="dateModified" datetime="2025-07-23T00:15:16+08:00">2025-07-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网页502"><a href="#网页502" class="headerlink" title="网页502"></a>网页502</h2><p>502 Bad Gateway是指错误网关，无效网关；在互联网中表示一种网络错误。表现在WEB浏览器中给出的页面反馈。</p>
<p>服务端代码下掉，重新部署的间隙，访问接口会502.</p>
<h2 id="504错误"><a href="#504错误" class="headerlink" title="504错误"></a>504错误</h2><p>504错误代表网关超时 （Gateway timeout），是指服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p>
<p>接口504超时，是服务端这边超时断开请求了，需要看一下nginx配置。如果是tomcat，看一下conf中配置的请求超时时间。</p>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><h3 id="✅nginx是什么？"><a href="#✅nginx是什么？" class="headerlink" title="✅nginx是什么？"></a>✅nginx是什么？</h3><blockquote>
<p>Nginx是十分轻量级的HTTP服务器。Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP&#x2F;POP3&#x2F;SMTP 代理服务器。</p>
<p>Ngnix 是互联网企业使用最为广泛的代理服务器。它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务。</p>
<p>Nginx是lgor Sysoev为俄罗斯访问量第二的rambler.ru站点设计开发的。从2004年发布至今，凭借开源的力量，已经接近成熟与完善。<br>Nginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。<br>Nginx的稳定性、功能集、示例配置文件和低系统资源的消耗让他后来居上，在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。</p>
</blockquote>
<p>nginx是服务器，代理服务器，负载均衡，反向代理，服务器架构。</p>
<p>Nginx凭借其稳定性、低资源消耗、简单配置和丰富的功能，从十多年前名不见经传的Web服务器软件，发展到如今能够跟Apache匹敌的地位。</p>
<p>1、作为Web服务器，Nginx处理静态文件、索引文件，自动索引的效率非常高</p>
<p>2、作为代理服务器，Nginx可以实现无缓存的反向代理加速，提高网站运行速度</p>
<p>3、作为负载均衡服务器，Nginx既可以在内部直接支持Rails和PHP，也可以支持HTTP代理服务器对外进行服务，同时还支持简单的容错和利用算法进行负载均衡</p>
<p>4、在性能方面，Nginx是专门为性能优化而开发的，实现上非常注重效率。它采用内核Poll模型，可以支持更多的并发连接，最大可以支持对5万个并发连接数的响应，而且只占用很低的内存资源</p>
<p>5、在稳定性方面，Nginx采取了分阶段资源分配技术，使得CPU与内存的占用率非常低。Nginx官方表示，Nginx保持1万个没有活动的连接，而这些连接只占用2.5MB内存，因此，类似DOS这样的攻击对Nginx来说基本上是没有任何作用的</p>
<p>6、在高可用性方面，Nginx支持热部署，启动速度特别迅速，因此可以在不间断服务的情况下，对软件版本或者配置进行升级，即使运行数月也无需重新启动，几乎可以做到7x24小时不间断地运行<br>————————————————<br>解读nginx：<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_60274825/article/details/122101640">https://blog.csdn.net/weixin_60274825/article/details/122101640</a></p>
<h3 id="✅什么是代理服务器？"><a href="#✅什么是代理服务器？" class="headerlink" title="✅什么是代理服务器？"></a>✅什么是代理服务器？</h3><p>代理服务器是介于客户端和Web服务器之间的另一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页，而是通过向代理服务器发送请求，信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。</p>
<p><img src="/images/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8.png"></p>
<p>代理位于Web客户端和Web服务器之间，扮演“中间人”的角色。<br>HTTP的代理服务器既是Web服务器又是Web客户端。</p>
<h3 id="✅什么是正反向代理"><a href="#✅什么是正反向代理" class="headerlink" title="✅什么是正反向代理"></a>✅什么是正反向代理</h3><p>正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取的内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端，客户端必须要进行一些特别的设置才能使用正向代理。</p>
<p>正向代理代理的对象是客户端，正向代理中，proxy和client同属一个LAN，对server透明 （客户端服务端多对一？）</p>
<p>反向代理服务器：在服务器端接收客户端的请求，然后把请求分发给具体的服务器进行处理，然后再将服务器的响应结果反馈给客户端。Nginx就是其中的一种反向代理服务器软件。</p>
<p>反向代理代理的对象是服务端，反向代理中，proxy和server同属一个LAN，对client透明  （客户端服务端多对多）</p>
<p>正向代理客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。<br>反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间中的内容发送普通请求，接着反向代理将判断向哪个原始服务器转交请求，并将获得的内容返回给客户端。<br>————————————————<br>解读nginx：<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_60274825/article/details/122101640">https://blog.csdn.net/weixin_60274825/article/details/122101640</a></p>
<h3 id="✅nginx与tomcat什么关系"><a href="#✅nginx与tomcat什么关系" class="headerlink" title="✅nginx与tomcat什么关系"></a>✅nginx与tomcat什么关系</h3><p>nginx是上面做web代理服务器的，而tomcat是上面做真正web服务器的。</p>
<p>nginx常用做静态内容服务和代理服务器，直面外来请求转发给后面的应用服务（tomcat，django什么的），tomcat更多用来做做一个应用容器，让java web app跑在里面的东西，对应同级别的有jboss,jetty等东西。</p>
<p>但是事无绝对，nginx也可以通过模块开发来提供应用功能，tomcat也可以直接提供http服务，通常用在内网和不需要流控等小型服务的场景。</p>
<p>严格的来说，Apache&#x2F;Nginx 应该叫做「HTTP Server」；而 Tomcat 则是一个「Application Server」，或者更准确的来说，是一个「Servlet&#x2F;JSP」应用的容器（Ruby&#x2F;Python 等其他语言开发的应用也无法直接运行在 Tomcat 上）。</p>
<p>一个 HTTP Server 关心的是 HTTP 协议层面的传输和访问控制，所以在 Apache&#x2F;Nginx 上你可以看到代理、负载均衡等功能。客户端通过 HTTP Server 访问服务器上存储的资源（HTML 文件、图片文件等等）。通过 CGI 技术，也可以将处理过的内容通过 HTTP Server 分发，但是一个 HTTP Server 始终只是把服务器上的文件如实的通过 HTTP 协议传输给客户端。</p>
<p>而应用服务器，则是一个应用执行的容器。它首先需要支持开发语言的 Runtime（对于 Tomcat 来说，就是 Java），保证应用能够在应用服务器上正常运行。其次，需要支持应用相关的规范，例如类库、安全方面的特性。对于 Tomcat 来说，就是需要提供 JSP&#x2F;Sevlet 运行需要的标准类库、Interface 等。为了方便，应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44517990/article/details/100712182">https://blog.csdn.net/weixin_44517990/article/details/100712182</a></p>
<h3 id="✅-springboot内置tomcat-和-tomcat"><a href="#✅-springboot内置tomcat-和-tomcat" class="headerlink" title="✅ springboot内置tomcat 和 tomcat"></a>✅ springboot内置tomcat 和 tomcat</h3><p>1.内置的tomcat没有tomcat的主页页面<a target="_blank" rel="noopener" href="http://localhost:9999/%EF%BC%8C%E8%80%8C%E6%88%91%E4%BB%AC%E5%B9%B3%E6%97%B6%E7%94%A8%E7%9A%84%E5%A4%96%E7%BD%AE%E7%9A%84tomcat%E6%98%AF%E6%9C%89%E7%9A%84">http://localhost:9999/，而我们平时用的外置的tomcat是有的</a></p>
<p>2.内置的tomcat可以用main跑项目，而如果要用外置的tomcat就需要把项目打成war包，然后拷贝到webapp下进行运行</p>
<p>Tomcat：<br>Tomcat是一个Web应用服务器，也是Servlet容器。它的作用是，解析客户端client发起的request，并组装出HttpRequest、创建HttpResponse，将二者交于内部的HttpServlet处理和填充</p>
<p>Tomcat映射处理请求的Servlet是通过web.xml做的。</p>
<p>SpringMVC使用一个DispatcherServlet来接收所有的请求，并把它们分发到不同的controller中来做进一步处理。</p>
<p>SpringMVC &#x3D; Spring + Web框架，Spring这部分主要是AOP&#x2F;IOC容器。</p>
<p>SpringBoot是Spring的扩展，简化了Spring的配置，通过starter的方式简化了常用组件依赖的引入，使其更加易用。</p>
<p>SpringBoot内置了tomcat。</p>
<h3 id="✅tomcat和spring-mvc"><a href="#✅tomcat和spring-mvc" class="headerlink" title="✅tomcat和spring mvc"></a>✅tomcat和spring mvc</h3><p>tomcat既是Http服务器（不用代理的话，其实是应用服务器），Http服务器与Servlet容器的功能界限是：可以把HTTP服务器想象成前台的接待，负责网络通信和解析请求，Servlet容器是业务部门，负责处理业务请求。</p>
<p>Tomcat和Servlet作为Web服务器和Servlet容器的结合，可以接受网络http请求解析为Servlet规范的请求对象和响应对象。比如，HttpServletRequest对象是Tomcat提供的，Servlet是规范，Tomcat是实现规范的Servlet容器。tomcat监听了端口，请求过来后，根据url等信息，确定要将请求交给哪个servlet去处理;然后调用那个servlet的service方法，service方法返回一个response对象;<br>tomcat再把这个response返回给客户端。</p>
<p>SpringMVC是处理Servlet请求的应用，其中DispatcherServlet实现了Servlet接口，Tomcat负责加载和调用DispatcherServlet。同时，DispatcherServlet有自己的容器（SpringMVC）容器，这个容器负责管理SpringMVC相关的bean，比如Controler和ViewResolver等。同时，Spring中还有其他的Bean比如Service和DAO等，这些由全局的Spring IOC容器管理，因此，Spring有两个IOC容器。</p>
<p>如果只是使用spring(不包含springmvc)，那么是tomcat容器解析xml文件，通过反射实例化对应的类，根据这些servlet规范实现类，触发对应的代码处理逻辑，这个时候tomcat负责http报文的解析和servlet调度的工作。</p>
<p>如果使用spring mvc，那么tomcat只是解析http报文，然后将其转发给dispatchsetvlet，然后由springmvc根据其配置，实例对应的类，执行对应的逻辑，然后返回结果给dispatchservlet，最后由它转发给tomcat,由tomcat负责构建http报文数据。</p>
<p>DispatcherServlet：是Spring MVC中的一个类，实现了Servlet接口。所以部署在Tomcat中的Spring项目，对Tomcat来说，都是一个servlet。</p>
<p>————————————————<br>spring mvc还需要tomcat吗？<br>版权声明：本文为CSDN博主「黄泥川水猴子」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40277163/article/details/124730530">https://blog.csdn.net/qq_40277163/article/details/124730530</a></p>
<h3 id="✅nginx与域名解析DNS什么关系"><a href="#✅nginx与域名解析DNS什么关系" class="headerlink" title="✅nginx与域名解析DNS什么关系"></a>✅nginx与域名解析DNS什么关系</h3><p>首先，nginx是web服务器和反向代理服务器。 dns是域名解析服务器。nginx不带dns。</p>
<p>作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。访问域名，dns帮忙解析到ip，然后访问这个地址的资源呈现给你。hosts和nginx在后面用到。</p>
<p>hosts文件：<br>hosts文件是个本地域名解析文件，不管你是windwos还是linux，那都是有的，他里面的有效内容，就是一个个的ip和域名映射关系。<br>windows一般在：C:&#x2F;Windows&#x2F;System32&#x2F;drivers&#x2F;etc&#x2F;hosts<br>Linux的hosts文件路径一般：&#x2F;etc&#x2F;hosts<br>比如：127.0.0.1 localhost<br>这个文件其实也是配置了ip和域名之间的映射关系的数据库，本地要是有这个文件，就优先用这个文件中的配置去解析，如果没有，那就通过dns解析。<br>注意：hosts文件只能配置ip和域名的映射关系，但是不能配置端口号，默认访问80端口</p>
<p>因为要解决端口问题，这里就得使用反向代理软件nginx，nginx中的每个server就是一个反向代理配置，可以有多个server。</p>
<p>理解：<em><strong>客户端请求 - dns解析域名 - 解析到nginx服务器的ip - nginx代理到tomcat服务器+端口 - tomcat将请求给servlet - servlet的service处理请求。</strong></em></p>
<h3 id="✅nginx与CDN内容分发网络什么关系"><a href="#✅nginx与CDN内容分发网络什么关系" class="headerlink" title="✅nginx与CDN内容分发网络什么关系"></a>✅nginx与CDN内容分发网络什么关系</h3><p>cdn是网络，nginx是服务器也是负载均衡。</p>
<p>cdn：<br>1、CDN的全称是Content Delivery Network，即内容分发网络。<br>2、其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。<br>3、通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。<br>4、其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度**。<br>5、内容分发网络是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。</p>
<p>cdn的工作原理：<br>CDN这个技术其实说起来并不复杂，最初的核心理念，就是将内容缓存在终端用户附近。</p>
<p>内容源不是远么？那么，我们就在靠近用户的地方，建一个缓存服务器，把远端的内容，复制一份，放在这里，不就OK了？</p>
<p>具体来说，CDN就是采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。（有点像电商的本地仓吧？）</p>
<p>大家可能觉得，这个不就是“镜像服务器”嘛？其实不一样。镜像服务器是源内容服务器的完整复制。而CDN，是部分内容的缓存，智能程度更高。</p>
<p><img src="/images/CDN.png"></p>
<p>借用阿里云官网的例子，来简单介绍CDN的工作原理。</p>
<p>假设通过CDN加速的域名为 <a href="http://www.a.com，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：">www.a.com，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：</a></p>
<p>1、当终端用户（北京）向<a target="_blank" rel="noopener" href="http://www.a.com下的指定资源发起请求时,首先向ldns(本地dns)发起域名解析请求./">www.a.com下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。</a></p>
<p>2、LDNS检查缓存中是否有<a target="_blank" rel="noopener" href="http://www.a.com的ip地址记录.如果有,则直接返回给终端用户;如果没有,则向授权dns查询./">www.a.com的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。</a></p>
<p>3、当授权DNS解析<a target="_blank" rel="noopener" href="http://www.a.com时,返回域名cname/">www.a.com时，返回域名CNAME</a> <a target="_blank" rel="noopener" href="http://www.a.tbcdn.com对应ip地址./">www.a.tbcdn.com对应IP地址。</a></p>
<p>4、域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。</p>
<p>5、LDNS获取DNS返回的解析IP地址。</p>
<p>6、用户获取解析IP地址。</p>
<p>7、用户向获取的IP地址发起对该资源的访问请求。</p>
<p>8、如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤7和8，请求结束。</p>
<p>9、如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。</p>
<p>所以：<br>（1）CDN的加速资源是跟域名绑定的。<br>（2）通过域名访问资源，首先是通过DNS分查找离用户最近的CDN节点（边缘服务器）的IP<br>（3）通过IP访问实际资源时，如果CDN上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上，这样，用户下一次访问时，该CDN节点就会有对应资源的缓存了。</p>
<hr>
<p>nginx负载均衡：负载均衡实际上就是将大量请求进行分布式处理的策略</p>
<p>Nginx 作为一个基于 C 实现的高性能 Web 服务器，可以通过系列算法解决上述的负载均衡问题。并且由于它具有高并发、高可靠性、高扩展性、开源等特点，成为开发人员常用的反向代理工具</p>
<p>1、正向代理</p>
<p>正向代理（Forward Proxy）最大的特点是，客户端非常明确要访问的服务器地址，它代理客户端，替客户端发出请求。比如：科学上网。</p>
<p>假设客户端想要访问 Google，它明确知道待访问的服务器地址是 <a target="_blank" rel="noopener" href="https://www.google.com/%EF%BC%8C%E4%BD%86%E7%94%B1%E4%BA%8E%E6%9D%A1%E4%BB%B6%E9%99%90%E5%88%B6%EF%BC%8C%E5%AE%83%E6%89%BE%E6%9D%A5%E4%BA%86%E4%B8%80%E4%B8%AA%E8%83%BD%E5%A4%9F%E8%AE%BF%E9%97%AE%E5%88%B0">https://www.google.com/，但由于条件限制，它找来了一个能够访问到</a> Google 的”朋友”：代理服务器。客户端把请求发给代理服务器，由代理服务器代替它请求 Google，最终再将响应返回给客户端。这便是一次正向代理的过程，该过程中服务器并不知道真正发出请求的是谁。<br>（客户端 - 正向代理 - 服务器）</p>
<p>2、反向代理</p>
<p>随着请求量的爆发式增长，服务器觉得自己一个人始终是应付不过来，需要兄弟服务器们帮忙，于是它喊来了自己的兄弟以及代理服务器朋友。此时，来自不同客户端的所有请求实际上都发到了代理服务器处，再由代理服务器按照一定的规则将请求分发给各个服务器。这就是反向代理（Reverse Proxy），反向代理隐藏了服务器的信息，它代理的是服务器端，代其接收请求。换句话说，反向代理的过程中，客户端并不知道具体是哪台服务器处理了自己的请求。如此一来，既提高了访问速度，又为安全性提供了保证<br>（一堆客户端 - 反向代理 - 一堆服务器）</p>
<p>在这之中，反向代理需要考虑的问题是，如何进行均衡分工，控制流量，避免出现局部节点负载过大的问题。通俗的讲，就是如何为每台服务器合理的分配请求，使其整体具有更高的工作效率和资源利用率。</p>
<p>3、负载均衡常用算法</p>
<p>轮询 （round-robin）<br>轮询为负载均衡中较为基础也较为简单的算法，它不需要配置额外参数。假设配置文件中共有 台服务器，该算法遍历服务器节点列表，并按节点次序每轮选择一台服务器处理请求。当所有节点均被调用过一次后，该算法将从第一个节点开始重新一轮遍历。特点：由于该算法中每个请求按时间顺序逐一分配到不同的服务器处理，因此适用于服务器性能相近的集群情况，其中每个服务器承载相同的负载。但对于服务器性能不同的集群而言，该算法容易引发资源分配不合理等问题。</p>
<p>加权轮询<br>为了避免普通轮询带来的弊端，加权轮询应运而生。在加权轮询中，每个服务器会有各自的 weight。一般情况下，weight 的值越大意味着该服务器的性能越好，可以承载更多的请求。该算法中，客户端的请求按权值比例分配，当一个请求到达时，优先为其分配权值最大的服务器。特点：加权轮询可以应用于服务器性能不等的集群中，使资源分配更加合理化。</p>
<p>IP 哈希（IP hash）<br>ip_hash 依据发出请求的客户端 IP 的 hash 值来分配服务器，该算法可以保证同 IP 发出的请求映射到同一服务器，或者具有相同 hash 值的不同 IP 映射到同一服务器。特点：该算法在一定程度上解决了集群部署环境下 Session 不共享的问题。</p>
<p>所以：<br>Nginx 作为一款优秀的反向代理服务器，可以通过不同的负载均衡算法来解决请求量过大情况下的服务器资源分配问题。较为常见的负载均衡算法有轮询、加权轮询、IP 哈希等等，可分别应对不同的请求场景。</p>
<p>————————————————<br>好文章：从对CDN的理解到Nginx负载均衡<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40409143/article/details/118330238">https://blog.csdn.net/qq_40409143/article/details/118330238</a></p>
<h3 id="✅nginx与RPC远程过程调用什么关系？"><a href="#✅nginx与RPC远程过程调用什么关系？" class="headerlink" title="✅nginx与RPC远程过程调用什么关系？"></a>✅nginx与RPC远程过程调用什么关系？</h3><p>RPC是远程过程调用，是一种计算机通信思想。</p>
<p>nginx是代理服务器。它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务。</p>
<p>Nginx 和后端服务之间的交互在本质上也可以理解为 RPC 数据交互。也许你会争辩说 Nginx 和后端服务之间使用的是 HTTP 协议，走的是短连接，严格上不能算是 RPC 调用。 Nginx 和后端服务之间还可以走其它的协议，比如 uwsgi 协议、fastcgi 协议等，这两个协议都是采用了比 HTTP 协议更加节省流量的二进制协议。</p>
<p>讲RPC、RPC与nginx、RPC与HTTP间的关系的好文章：<br><a target="_blank" rel="noopener" href="https://www.kancloud.cn/machh03/server/2096716">https://www.kancloud.cn/machh03/server/2096716</a></p>
<h3 id="✅与gateway有什么关系？"><a href="#✅与gateway有什么关系？" class="headerlink" title="✅与gateway有什么关系？"></a>✅与gateway有什么关系？</h3><p>网关(Gateway)就是一个网络连接到另一个网络的“关口”。</p>
<p><img src="/images/gateway.png"></p>
<p>1、nginx也可以做网关，是用户访问的总入口，也就是前端页面的容器，流量网关。</p>
<p>流量网关是定义全局性的、跟具体的后端业务应用和服务完全无关的策略网关。<br>流量网关通常只专注于全局的Api管理策略，比如全局流量监控、日志记录、全局限流、黑白名单控制、接入请求到业务系统的负载均衡等，有点类似防火墙。</p>
<p>2、gateway的定义是针对每一个业务微服务来得，属于业务网关。是介于nignx以及业务应用之间的中间层，主要负责将请求路由到不同的微服务中以及对请求的合法性进行校验。</p>
<p>业务网关针对具体的业务需要提供特定的流控策略、缓存策略、鉴权认证策略等等。<br>业务网关一般部署在流量网关之后、业务系统之前，比流量网关更靠近业务系统。通常API网指的是业务网关。 有时候我们也会模糊流量网关和业务网关，让一个网关承担所有的工作,所以这两者之间并没有严格的界线。</p>
<hr>
<p>网关可以看做系统与外界联通的入口，我们可以在网关进行处理一些非业务逻辑的逻辑，比如权限验证，监控，缓存，请求路由等等。</p>
<p>1、nginx是用户到 前端工程 的网关，对外网关<br>nginx是用C语言写的<br>nginx做网关，更多的是做总流量入口，反向代理，负载均衡等，还可以用来做web服务器。<br>Nginx在其中扮演的角色是什么？<br>反向代理<br>负载均衡</p>
<p>2、gateway 是前端工程 到 后台服务器之间的一个 对内网关<br>gateway是java语言的一个框架，可以在框架上进行代码的扩展与控制，例如：安全控制，统一异常处理，XXS,SQL注入等；权限控制，黑白名单，性能监控，日志打印等<br>gateway的主要功能有，路由，断言，过滤器，利用它的这些特性，可以做流控。<br>SpringGateway在其中扮演的角色是什么？<br>统一鉴权</p>
<p>nginx与gateway：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yangbindxj/article/details/125040773">https://blog.csdn.net/yangbindxj/article/details/125040773</a></p>
<hr>
<p>网关服务的端口号默认是80或者443.<br>相同点：都是可以实现对api接口的拦截，负载均衡、反向代理、请求过滤等，可以实现和网关一样的效果。<br>Nginx实现负载均衡的原理属于服务器端负载均衡器。<br>Gateway实现负载均衡原理采用本地负载均衡器的形式。</p>
<h3 id="✅nginx与统一接入有什么关系？"><a href="#✅nginx与统一接入有什么关系？" class="headerlink" title="✅nginx与统一接入有什么关系？"></a>✅nginx与统一接入有什么关系？</h3><p>统一接入层是：指的是设置专属一层，统一接入所有流量，包括 PC 流量、无线流量、IoT 流量。在应用层之上的一层。</p>
<p>如果没有统一接入层，之前的业务方，例如购物车、商品等都要自己维护一个网关，这就涉及到维护成本和机器成本。例如卸载 HTTPS，如果所有业务方都要申请证书，那造成的应用成本是非常高的。可如果将所有功能全放在这一层进行，好处非常明显：一方面是机器集中管理节省成本；另外一方面，如果遇到新的瓶颈可以在统一接入层集中优化，如请求响应 Body 统一在这一层进行压缩减少带宽消耗，压缩会消耗 CPU，可以在这一层通过硬件加速的方式集中优化等。</p>
<p>阿里统一接入层：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/96510277?hmsr=toutiao.io">https://zhuanlan.zhihu.com/p/96510277?hmsr=toutiao.io</a></p>
<p>统一接入层方案：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Leo_wl/archive/2012/10/17/2728541.html">https://www.cnblogs.com/Leo_wl/archive/2012/10/17/2728541.html</a></p>
<p>统一接入层是网关中最前端的服务，统一接入到集群中。<br>所以，统一接入层应该是在web代理服务器nginx前的。</p>
<h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><h3 id="nginx配置文件结构"><a href="#nginx配置文件结构" class="headerlink" title="nginx配置文件结构"></a>nginx配置文件结构</h3><p>Main 位于 nginx.conf 配置文件的最高层；<br>Main 层下可以有 Event、HTTP 层；<br>Http 层下面允许有多个 Server 层，用于对不同的网站做不同的配置；<br>Server 层下面允许有多个 Location，用于对不同的路径进行不同模块的配置。</p>
<p>1、main（最上面）<br>全局配置部分用来配置对整个 server 都有效的参数。主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等<br>全局Main配置<br>user nginx;<br>worker_processes 1; #设置值和CPU核心数一致</p>
<p>error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn; #日志位置和日志级别<br>pid       &#x2F;var&#x2F;run&#x2F;nginx.pid;</p>
<p>2.event<br>events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 worker process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 worker process 可以同时支持的最大连接数等。<br>Event配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、http<br>http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。<br>http配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  include       /etc/nginx/mime.types;</span><br><span class="line">  default_type application/octet-stream;</span><br><span class="line">  log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                    &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                    &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">  access_log /var/log/nginx/access.log main;</span><br><span class="line">  sendfile       on;</span><br><span class="line">  #tcp_nopush     on;</span><br><span class="line">  keepalive_timeout 65;</span><br><span class="line">  #gzip on;</span><br><span class="line">  include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、server<br>Server 块也被叫做“虚拟主机”部分，它描述的是一组根据不同 server_name 指令逻辑分割的资源，这些虚拟服务器响应 HTTP 请求，因此都包含在 http 部分。最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。一个 server 块可以配置多个 location 块。<br>server配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  location / &#123;</span><br><span class="line">      root   /usr/share/nginx/html;</span><br><span class="line">      index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">  error_page   500 502 503 504 /50x.html;</span><br><span class="line">  location = /50x.html &#123;</span><br><span class="line">      root   /usr/share/nginx/html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nginx配置结构：<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1729793004418584302&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1729793004418584302&amp;wfr=spider&amp;for=pc</a></p>
<p>菜鸟nginx配置：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/nginx-setup-intro.html">https://www.runoob.com/w3cnote/nginx-setup-intro.html</a></p>
<p>nginx配置详细介绍：<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_12218973/2457715">https://blog.51cto.com/u_12218973/2457715</a></p>
<h3 id="nginx超时配置"><a href="#nginx超时配置" class="headerlink" title="nginx超时配置"></a>nginx超时配置</h3><p>Nginx主要有四类超时设置：客户端超时设置、DNS解析超时设置、代理超时设置，如果使用ngx_lua，则还有lua相关的超时设置。</p>
<p>1、客户端超时</p>
<p>客户端超时主要设置有读取请求头超时时间、读取请求体超时时间、发送响应超时时间、长连接超时时间。通过客户端超时设置避免客户端恶意或者网络状况不佳造成连接长期占用，影响服务端的可处理的能力。</p>
<p><strong>client_header_timeout time</strong>：设置读取客户端请求头超时时间，默认为60s，如果在此超时时间内客户端没有发送完请求头，则响应408（RequestTime-out）状态码给客户端。</p>
<p><strong>client_body_timeout time</strong>：设置读取客户端内容体超时时间，默认为60s，此超时时间指的是两次成功读操作间隔时间，而不是发送整个请求体的超时时间，如果在此超时时间内客户端没有发送任何请求体，则响应408（RequestTime-out）状态码给客户端。</p>
<p><strong>send_timeout time</strong>：设置发送响应到客户端的超时时间，默认为60s，此超时时间指的也是两次成功写操作间隔时间，而不是发送整个响应的超时时间。如果在此超时时间内客户端没有接收任何响应，则Nginx关闭此连接。</p>
<p><strong>keepalive_timeout timeout [header_timeout]</strong>：设置HTTP长连接超时时间，其中，第一个参数timeout是告诉Nginx长连接超时时间是多少，默认为75s。第二个参数header_timeout是用于设置响应头“Keep-Alive: timeout&#x3D;time”，即告知客户端长连接超时时间。如果timeout设置为0，则表示禁用长连接。</p>
<p>2、DNS解析超时</p>
<p><strong>resolver_timeout 30s</strong>：设置DNS解析超时时间，默认为30s</p>
<p>3、代理超时</p>
<p>主要有三组配置：网络连接&#x2F;读&#x2F;写超时设置、失败重试机制设置、upstream存活超时设置</p>
<p><strong>proxy_connect_timeout time</strong>：与后端&#x2F;上游服务器建立连接的超时时间，默认为60s，此时间不超过75s。</p>
<p><strong>proxy_read_timeout time</strong>：设置从后端&#x2F;上游服务器读取响应的超时时间，默认为60s，此超时时间指的是两次成功读操作间隔时间，而不是读取整个响应体的超时时间，如果在此超时时间内上游服务器没有发送任何响应，则Nginx关闭此连接。</p>
<p><strong>proxy_send_timeout time</strong>：设置往后端&#x2F;上游服务器发送请求的超时时间，默认为60s，此超时时间指的是两次成功写操作间隔时间，而不是发送整个请求的超时时间，如果在此超时时间内上游服务器没有接收任何响应，则Nginx关闭此连接。</p>
<p><strong>proxy_next_upstream_tries number</strong>：设置重试次数，默认0表示不限制，注意此重试次数指的是所有请求次数（包括第一次和之后的重试次数之和）。</p>
<p><strong>proxy_next_upstream_timeout time</strong>：设置重试最大超时时间，默认0表示不限制。</p>
<p>Nginx超时配置：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiao__jia__jia/article/details/124075274">https://blog.csdn.net/xiao__jia__jia/article/details/124075274</a></p>
<h2 id="PoolingHttpClientConnectionManager"><a href="#PoolingHttpClientConnectionManager" class="headerlink" title="PoolingHttpClientConnectionManager"></a>PoolingHttpClientConnectionManager</h2><p>HttpClien高并发请求连接池 - PoolingHttpClientConnectionManager</p>
<p>连接池：<br>连接池技术作为创建和管理连接的缓冲池技术，目前已广泛用于诸如数据库连接等长连接的维护和管理中，能够有效减少系统的响应时间，节省服务器资源开销。其优势主要有两个：其一是减少创建连接的资源开销，其二是资源的访问控制。连接池管理的对象是长连接。</p>
<p>PoolingHttpClientConnectionManager是通过租用连接和收回链接的方式来实现的。解决了http请求的多线程问题。</p>
<p>依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>实现http连接池：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34484062/article/details/109470135">https://blog.csdn.net/qq_34484062/article/details/109470135</a></p>
<h2 id="rpc"><a href="#rpc" class="headerlink" title="rpc"></a>rpc</h2><p>远程过程调用（Remote Procedure Call，缩写为 RPC）允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。 如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用，比如 Java RMI。</p>
<p>远程过程调用是一个分布式计算的客户端-服务器（Client&#x2F;Server）的例子，它简单而又广受欢迎。 远程过程调用总是由客户端对服务器发出一个执行若干过程请求，并用客户端提供的参数。执行结果将返回给客户端。 由于存在各式各样的变体和细节差异，对应地派生了各式远程过程调用协议，而且它们并不互相兼容。</p>
<p>为了允许不同的客户端均能访问服务器，许多标准化的 RPC 系统应运而生了。其中大部分采用接口描述语言（Interface Description Language，IDL），方便跨平台的远程过程调用。<br>有些实现扩展了远程调用的模型，实现了双向的服务调用，但是不管怎样，调用过程还是由一个客户端发起，服务器端提供响应，基本模型没有变化。</p>
<p>服务的调用过程为：<br>1、client调用client stub，这是一次本地过程调用<br>2、client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做 marshalling<br>3、client所在的系统将消息发送给server<br>4、server的的系统将收到的包传给server stub<br>5、server stub解包得到参数。 解包也被称作 unmarshalling<br>6、最后server stub调用服务过程. 返回结果按照相反的步骤传给client</p>
<hr>
<p>RPC (Remote Procedure Call)即远程过程调用，是分布式系统常见的一种通信方法，已经有 40 多年历史。当两个物理分离的子系统需要建立逻辑上的关联时，RPC 是牵线搭桥的常见技术手段之一。除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存。</p>
<p>其中 RPC 和 HTTP 调用是没有经过中间件的，它们是端到端系统的直接数据交互。<strong>HTTP 调用其实也可以看成是一种特殊的 RPC，只不过传统意义上的 RPC 是指长连接数据交互，而 HTTP 一般是指即用即走的短链接。</strong></p>
<p>RPC 在我们熟知的各种中间件中都有它的身影。Nginx&#x2F;Redis&#x2F;MySQL&#x2F;Dubbo&#x2F;Hadoop&#x2F;Spark&#x2F;Tensorflow 等重量级开源产品都是在 RPC 技术的基础上构建出来的，我们<strong>这里说的 RPC 指的是广义的 RPC，也就是分布式系统的通信技术</strong>。RPC 在技术中的地位好比我们身边的空气，它无处不在，但是又有很多人根本不知道它的存在。</p>
<p>例如数据库：<br>子系统和数据库之间的交互也是通过 RPC 进行的，只不过这里是三个子系统之间复杂的组合消息交互罢了。如果再深入进去，你会发现，这里的数据库不是那种单机数据库，而是具备主从复制功能的数据库，比如 MySQL。在互联网企业里一般都会使用这种主从读写分离的数据库。一个业务子系统将数据写往主库，主库再将数据同步到从库，然后另一个业务子系统又从从库里将数据取出来。这时又可以进一步将它们看成是四个子系统之间进行的更加复杂的 RPC 数据交互。</p>
<hr>
<p>一些分布式场景中RPC的使用：（广义上的RPC）</p>
<p>✅nginx<br>Ngnix 是互联网企业使用最为广泛的代理服务器。它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务。Nginx 和后端服务之间的交互在本质上也可以理解为 RPC 数据交互。也许你会争辩说 Nginx 和后端服务之间使用的是 HTTP 协议，走的是短连接，严格上不能算是 RPC 调用。不过 Nginx 和后端服务之间还可以走其它的协议，比如 uwsgi 协议、fastcgi 协议等，这两个协议都是采用了比 HTTP 协议更加节省流量的二进制协议。</p>
<p>✅Hadoop<br>在大数据技术领域，RPC 也占据了非常重要的地位。大数据领域广泛应用了非常多的分布式技术，分布式意味着节点的物理隔离，隔离意味着需要通信，通信意味着 RPC 的存在。大数据需要通信的量比业务系统更加庞大，所以在数据通信优化上做的更深。比如最常见的 Hadoop 文件系统 hdfs，一般包括一个 NameNode 和多个 DataNode，NameNode 和 DataNode 之间就是通过一种称为 Hadoop RPC 的二进制协议进行通讯。</p>
<p>✅TensorFlow<br>在人工智能领域，RPC 也很重要，著名的 TensorFlow 框架如果需要处理上亿的数据，就需要依靠分布式计算力，需要集群化，当多个分布式节点需要集体智慧时，就必须引入 RPC 技术进行通讯。Tensorflow Cluster 的 RPC 通讯框架使用了 Google 内部自研的 gRPC 框架。</p>
<p>转自：<a target="_blank" rel="noopener" href="https://www.kancloud.cn/machh03/server/2096716">https://www.kancloud.cn/machh03/server/2096716</a><br>里面还有实现rpc</p>
<h2 id="理解http和rpc"><a href="#理解http和rpc" class="headerlink" title="理解http和rpc"></a>理解http和rpc</h2><p>HTTP1.0 协议时，HTTP 调用还只能是短链接调用，一个请求来回之后连接就会关闭。HTTP1.1 在 HTTP1.0 协议的基础上进行了改进，引入了 KeepAlive 特性可以保持 HTTP 连接长时间不断开，以便在同一个连接之上进行多次连续的请求，进一步拉近了 HTTP 和 RPC 之间的距离。</p>
<p>当 HTTP 协议进化到 2.0 之后，Google 开源了一个建立在 HTTP2.0 协议之上的通信框架直接取名为 gRPC，也就是 Google RPC，这时 HTTP 和 RPC 之间已经没有非常明显的界限了。</p>
<p>HTTP 与 RPC 的关系就好比普通话与方言的关系。要进行跨企业服务调用时，往往都是通过 HTTP API，也就是普通话，虽然效率不高，但是通用，没有太多沟通的学习成本。但是在企业内部还是 RPC 更加高效，同一个企业公用一套方言进行高效率的交流，要比通用的 HTTP 协议来交流更加节省资源。整个中国有非常多的方言，正如有很多的企业内部服务各有自己的一套交互协议一样。好比开源 RPC 协议中 Protobuf 和 Thrift 一样，它们两应该是 RPC 协议中使用最为广泛的两个。</p>
<p>rpc基于什么实现网络传输？<br>1.rpc可以基于tcp直接开发自己的协议，这个是可以保持长连接的，tcp的传输效率高，并且可以一直维持链接</p>
<p>2.自定义协议可以优化数据的传输，例如更大的压缩比。分布式系统中非常有用。</p>
<p>3.http协议1.x一般情况下一个来回就关闭连接，虽然提供了keep-alive可以保持长连接，但是依然不方便，所以就出现了http2.0， http2.0基本上可以当做tcp协议使用了。所以grpc就会使用http2.0开发。</p>
<h2 id="rest和restful"><a href="#rest和restful" class="headerlink" title="rest和restful"></a>rest和restful</h2><p>REST，英文全称Representational State Transfer（表述性状态转移），是一组架构约束条件和原则（注意，REST是设计风格而不是标准）。满足这些约束条件和原则的应用程序或设计就是RESTful。可以降低开发的复杂性，提高系统的可伸缩性。体现在Web开发中就是通过HTTP方法中的POST、DELETE、PUT、GET来对资源进行操作。</p>
<p>一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p>在 REST 样式的 Web 服务中，每个资源都有一个地址。资源本身都是方法调用的目标，方法列表对所有资源都是一样的。这些方法都是标准方法，包括 HTTP GET、POST、PUT、DELETE，还可能包括 HEADER 和 OPTIONS。</p>
<p>Representation（表现层）<br>资源的信息载体形式。它可以是文本、XML、JSON或者是一个二进制文件。它的表现形式应该在HTTP请求的头信息中用Accept和Content-Type字段指定描述。</p>
<p>State Transfer（状态转移）<br>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转移”。</p>
<p>在 HTTP 中，我们一般通过四种 HTTP 动词来对应资源的变化：<br>POST（新建资源，也可用于更新资源）<br>DELETE（删除资源）<br>PUT（更新资源）<br>GET（获取资源）</p>
<p>REST架构原则：<br>对网络上所有资源都有一个资源标识符<br>对资源的操作不会改变标识符<br>同一资源有多种表现形式，如XML、JSON…<br>所有操作都是无状态的（Stateless）</p>
<p>RESTful，是一种网络应用程序的设计风格和开发方式。RESTful可以通过一套统一的接口为Web，iOS和Android提供服务。比如微博开放平台，微信开放平台等，它们不需要有显式的前端，只需要一套提供服务的接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">在使用RESTful风格之前，我们通常是这样操作用户数据:</span><br><span class="line">//创建用户信息</span><br><span class="line">http://localhost:8080/user/createUser</span><br><span class="line">//删除id为1的用户信息</span><br><span class="line">http://localhost:8080/user/deleteUser/1</span><br><span class="line">//修改id为2的用户信息</span><br><span class="line">http://localhost:8080/user/updateUser/2</span><br><span class="line">//获取所有用户信息</span><br><span class="line">http://localhost:8080/user/getUsers</span><br><span class="line"></span><br><span class="line">使用RESTful风格之后:</span><br><span class="line">//创建用户信息</span><br><span class="line">POST http://localhost:8080/user</span><br><span class="line">//删除id为1的用户信息</span><br><span class="line">DELETE http://localhost:8080/user/1</span><br><span class="line">//修改id为2的用户信息</span><br><span class="line">PUT http://localhost:8080/user/2</span><br><span class="line">//获取所有用户信息</span><br><span class="line">GET http://localhost:8080/user获取所有用户信息</span><br><span class="line">通过约定不同的HTTP方法来实现不同的业务，有一个更加直观的了解。</span><br><span class="line">1、看URL就知道要操作什么</span><br><span class="line">2、看HTTP方法就知道要如何操作</span><br><span class="line">3、看HTTP状态码就知道返回结果如何</span><br></pre></td></tr></table></figure>

<p>参考：<br>rest与restful：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44316527/article/details/106276655">https://blog.csdn.net/weixin_44316527/article/details/106276655</a></p>
<hr>
<p>rpc与restful：</p>
<p>RPC（Remote Procedure Call Protocol）就是远程调用。最简单的想法，应该就是把HTTP协议当做RPC来用。比如我们把网址作为一个借口，传入的参数作为函数参数，response的数据作为返回信息。这其实就是一个调用。</p>
<p>RESTful和RPC最大的区别应该就是面向对象了。<br>从设计上来看，RPC，所谓的远程过程调用 ，是面向方法的 ；<br>REST：所谓的 Representational state transfer ，是面向资源的；<br>除此之外，还有一种叫做 SOA，所谓的面向服务的架构，它是面向消息的。<br>很多人只知道GET和POST，因为现在最常用的就是GET和POST了。虽说这应该是违背了HTTP设计的初衷。</p>
<p>序列化协议的区别：<br>接口调用通常包含两个部分，序列化和通信协议。<br>通信协议，上面已经提及了，REST 是 基于 HTTP 协议，而 RPC 可以基于 TCP&#x2F;UDP，也可以基于 HTTP 协议进行传输的。<br>常见的序列化协议，有：json、xml、hession、protobuf、thrift、text、bytes等，REST 通常使用的是 JSON或者XML，而 RPC 使用的是 JSON-RPC，或者 XML-RPC。</p>
<p>什么时候用？<br>REST 接口更加规范，通用适配性要求高，建议对外的接口都统一成 REST。而组件内部的各个模块，可以选择 RPC，一个是不用耗费太多精力去开发和维护多套的HTTP接口，一个RPC的调用性能更高。从性能角度看，由于HTTP本身提供了丰富的状态功能与扩展功能，但也正由于HTTP提供的功能过多，导致在网络传输时，需要携带的信息更多，从性能角度上讲，较为低效。而RPC服务网络传输上仅传输与业务内容相关的数据，传输数据更小，性能更高。</p>
<p>转自：<br><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/53677">https://developer.aliyun.com/article/53677</a></p>
<hr>
<p>restful和http：</p>
<p>REST 是一种软件架构风格。这种风格的典型应用，就是HTTP。其因为简单、扩展性强的特点而广受开发者的青睐。</p>
<p>某种意义下，我们说 REST 可以其实就是指代 HTTP 协议。</p>
<hr>
<p>总结：rpc、http、rest</p>
<p>rpc是一种协议还是，还是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想？更是后者<br>rpc包含：服务发现、负载、容器、网络传输、序列化等组件。<br>rpc指明了程序如何进行网络传输和序列化。</p>
<p>关于rpc和http的比较：<br>rpc的网络传输是如何实现的，rpc是连接，http是短连接。<br>http是一种rpc（广义上），还是rpc可以基于http实现？<br>RPC可以基于TCP协议也可以基于HTTP协议。<br>HTTP需要携带的信息更多，低效，RPC仅传输与业务相关的数据，传输数据更小，性能更高</p>
<p>关于rpc和restful的比较：<br>rpc面向方法，restful面向资源。<br>日常写的接口，更多基于rpc面向方法的，虽然有的是rpc接口，有的是http接口。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sweetwater"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">Sweetwater</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sweetwater</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
