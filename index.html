<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Sweetwater&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Sweetwater&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Sweetwater">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Sweetwater's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sweetwater's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/10/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%B8%8D%E9%82%A3%E4%BA%9B%E5%B9%B4%E4%BA%86%E5%BC%80%E5%A7%8B%E5%88%B7%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/10/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E4%B8%8D%E9%82%A3%E4%BA%9B%E5%B9%B4%E4%BA%86%E5%BC%80%E5%A7%8B%E5%88%B7%E9%A2%98/" class="post-title-link" itemprop="url">不那些年之开始刷LetCode题米</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-10 23:32:54" itemprop="dateCreated datePublished" datetime="2025-08-10T23:32:54+08:00">2025-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-15 00:09:03" itemprop="dateModified" datetime="2025-08-15T00:09:03+08:00">2025-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p>动态规划，dp表示以当前数结尾的最大连续和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a>旋转链表</h2><p>旋转多少就是把后面多少节点搬到前面。注意k是链表长度整数倍时不需要动。1.先计算长度。2.取余。3.找新的尾节点。4.重新拼接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 本质：旋转多少就是把后面多少节点搬到前面。注意k是链表长度整数倍时不需要动。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 1.先计算长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (tail.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            len ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.取余</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> k % len;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// 3.找新的尾节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newTail</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len - n; i ++) &#123;</span><br><span class="line">            newTail = newTail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.重新拼接</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> newTail.next;</span><br><span class="line">        newTail.next = <span class="literal">null</span>;</span><br><span class="line">        tail.next = head;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><p>DFS深度优先搜索</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 用DFS深度优先搜索，三种情况：p和q在最近公共祖先的左右子树、p是公共祖先q是子节点、q是公共祖先p是子节点</span></span><br><span class="line">        <span class="comment">// 返回条件：到叶子节点/遇到了pq就不用往下了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == root || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">// 递归函数返回的是最近公共祖先的候选</span></span><br><span class="line">        <span class="comment">// 如果left和right都不空，证明是第一种情况，在左右子树，返回root</span></span><br><span class="line">        <span class="comment">// 如果其中一个为空，证明在当前root的一边，返回非空的</span></span><br><span class="line">        <span class="comment">// 都为null，就是遍历到叶子结点了，返回null</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != left &amp;&amp; <span class="literal">null</span> != right) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != left) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h2><p>想着用DFS，但是时间复杂度是O(2^n)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;</span><br><span class="line">        <span class="comment">// 深度优先搜索+回溯</span></span><br><span class="line">        res = Integer.MAX_VALUE;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, triangle, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> layer, <span class="type">int</span> index, List&lt;List&lt;Integer&gt;&gt; triangle, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer == triangle.size()) &#123;</span><br><span class="line">            res = Math.min(res, sum);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(layer + <span class="number">1</span>, index, triangle, sum + triangle.get(layer).get(index));</span><br><span class="line">        dfs(layer + <span class="number">1</span>, index + <span class="number">1</span>, triangle, sum + triangle.get(layer).get(index));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用动态规划，并进行空间优化，时间复杂度是O(n^2)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;</span><br><span class="line">        <span class="comment">// 可以用动态规划，n行n列的dp数组表示，双层遍历状态转移，然后从根节点找最小的。</span></span><br><span class="line">        <span class="comment">// 动态规划可进行空间优化，只用两行的数组表示dp。</span></span><br><span class="line">        <span class="comment">// 用一行，行不行，状态转移index依赖index和index-1，所以从左到右遍历不行，得从右到左。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> triangle.size();</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">layer</span> <span class="operator">=</span> <span class="number">1</span>; layer &lt; n; layer ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> layer; index &gt;= <span class="number">0</span>; index --) &#123;</span><br><span class="line">                <span class="comment">// 注意边界，左边的只能index，右边的只能index-1，left表示从左边下来</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> index == layer? Integer.MAX_VALUE : dp[index] + triangle.get(layer).get(index);</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index == <span class="number">0</span>? Integer.MAX_VALUE : dp[index - <span class="number">1</span>] + triangle.get(layer).get(index);</span><br><span class="line">                dp[index] = Math.min(left, right);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Arrays.toString(dp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) res = Math.min(res, dp[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/10/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E5%9C%BA%E6%99%AF%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/10/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E5%9C%BA%E6%99%AF%E9%A2%98/" class="post-title-link" itemprop="url">那些年背过的面试题之场景题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-10 23:29:57" itemprop="dateCreated datePublished" datetime="2025-08-10T23:29:57+08:00">2025-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-13 22:35:01" itemprop="dateModified" datetime="2025-08-13T22:35:01+08:00">2025-08-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="设计一个多人在线协同文本编辑系统"><a href="#设计一个多人在线协同文本编辑系统" class="headerlink" title="设计一个多人在线协同文本编辑系统"></a>设计一个多人在线协同文本编辑系统</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/10/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BPython/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/10/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BPython/" class="post-title-link" itemprop="url">那些年背过的面试题之Python</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-10 08:30:05" itemprop="dateCreated datePublished" datetime="2025-08-10T08:30:05+08:00">2025-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-13 23:01:22" itemprop="dateModified" datetime="2025-08-13T23:01:22+08:00">2025-08-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><p>Django 是一个用 Python 编写的高级 Web 框架，倡导“开箱即用”和快速开发。它内置了 ORM（对象关系映射）、URL 路由、模板引擎、表单处理、用户认证和强大的后台管理（Admin）等核心功能，能有效处理 Web 开发中的常见任务。Django 遵循 **MVT（模型-视图-模板）**设计模式，结构清晰，代码复用性高。它注重安全性，能自动防范 CSRF、XSS 等常见攻击。凭借其完备的生态系统和严谨的设计，Django 非常适合构建数据驱动、安全可靠的中大型 Web 应用，让开发者更专注于业务逻辑的实现。</p>
<p><strong>使用 Django 开发的步骤</strong>：1. <strong>安装</strong>：<code>pip install django</code>。2. <strong>创建项目</strong>：<code>django-admin startproject mysite</code>，生成项目骨架。3. <strong>创建应用</strong>：<code>python manage.py startapp myapp</code>，Django 鼓励功能模块化。4. <strong>定义模型</strong>：在 <code>models.py</code> 中用 Python 类定义数据结构，Django ORM 映射到数据库。5. <strong>注册应用</strong>：将应用名添加到 <code>settings.py</code> 的 <code>INSTALLED_APPS</code> 中。6. <strong>设计 URL</strong>：在项目和应用中配置 <code>urls.py</code>，将 URL 路由到视图。7. <strong>编写视图</strong>：在 <code>views.py</code> 中处理请求并返回响应（如渲染模板）。8. <strong>创建模板</strong>：在 <code>templates</code> 目录下编写 HTML 模板。9. <strong>迁移数据库</strong>：<code>makemigrations</code> 生成迁移文件，<code>migrate</code> 同步模型到数据库。10. <strong>运行</strong>：<code>python manage.py runserver</code> 启动开发服务器。</p>
<p><strong>在Docker内运行</strong>：编写 <code>Dockerfile</code> 定义Python环境、安装依赖（包括Django）；创建 <code>docker-compose.yml</code> 配置Web服务和数据库（如PostgreSQL）；将代码复制到镜像；暴露端口（如8000）；使用 <code>docker-compose up</code> 构建并运行容器，Django应用即在隔离环境中启动。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/10/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/10/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">那些年背过的面试题之算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-10 08:30:05" itemprop="dateCreated datePublished" datetime="2025-08-10T08:30:05+08:00">2025-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-14 08:47:08" itemprop="dateModified" datetime="2025-08-14T08:47:08+08:00">2025-08-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="MinHash与MinHashLSH"><a href="#MinHash与MinHashLSH" class="headerlink" title="MinHash与MinHashLSH"></a>MinHash与MinHashLSH</h2><p>MinHash 是一种用于快速估计两个集合（如文档、网页等）之间相似度的算法，特别是在处理高维数据或海量数据时非常高效。主要用于计算 Jaccard 相似度（集合交集与并集的比值）。Jaccard 相似度需要遍历整个集合，耗费时间和内存。</p>
<p>MinHash 提供了一种近似计算的方法，通过构造 “简化签名” 来高效估算集合之间的相似性，而无需直接操作整个集合。 </p>
<p>计算步骤：输入分词集合，定义n个哈希函数，集合中每个元素使用哈希函数计算，得到对应最小值，生成n大小的签名矩阵，比较签名中相同值的占比，得到近似的Jaccard相似度。 特点：minhash签名固定大小，降低计算复杂度；近似方法允许误差；适用于大规模文档去重、相似性查找等。 </p>
<p>MinhashLSH：局部敏感哈希，在MinHash的基础上进一步优化，通过分桶的方式将高相似度的数据快速归类到相同的桶中，减少不必要的相似性计算。 </p>
<p><strong>实战操作</strong>：首先将文本使用集合或者向量来表示，将文本进行分词，但是单纯分词变为集合没有考虑词间顺序问题，所以分词之后再用ngram来考虑顺序。然后使用jaccard系数表示两个集合的相似性，交集&#x2F;并集。 这样有两个问题：文本数量非常大、文本本身篇幅非常长。所以有两个优化方向：减少集合的长度、减少计算相似度的次数。 </p>
<p>使用minhash：根据分词组成的集合产生经过某种处理后的一组哈希值，相近的文本生成的哈希值相似度比较高。常用两种方法生成哈希值：1）使用一个哈希函数进行哈希后再进行多次重排。2）使用不同的哈希函数进行多次哈希。 </p>
<p>1）使用一个哈希函数进行哈希后再进行多次重排：用一个基础哈希函数对集合中元素求hash，然后使用多个简单的数学变换模拟重排，然后每次排列中取最小值作为每次打乱的代表。n次排列生成n序列哈希值。 </p>
<p>2）使用不同的哈希函数进行多次哈希（常用）：选取一批相互独立的哈希函数，每个函数对集合中元素求hash，选取该次哈希变换后集合中数值的最小值。不同的哈希函数相当于不同的投影规则。n个哈希函数生成n序列哈希值。 </p>
<p>minhash解决了文本向量表示维度的问题，但是两两比较次数太多的问题还在。如果能识别出相近的和不相近的，可以大大减少计算量。做法：借助局部敏感哈希( (Locality Sensitive Hashing，LSH) 来先进行一次分组或者聚类，让相近的文本分到一组去。 </p>
<p>LSH做法：通过minhash生成固定长度的签名，对签名分组，每组包含多个连续的哈希值，表示一个带band，对每个band应用一个哈希函数，映射到对应的桶中，一个文档会落入多个桶。接下来只需要在同一分桶中的数据之间计算相似性。 python中实现：用datasketch包中的MinHash, MinHashLSH。.update哈希化。insert（Hash名称，minHash值）载入LSH系统。</p>
<p>python实现MinHash和MinHashLSH：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datasketch <span class="keyword">import</span> MinHash, MinHashLSH</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 定义文档 ---</span></span><br><span class="line"><span class="comment"># 我们创建一些明显相似的文档</span></span><br><span class="line">documents = &#123;</span><br><span class="line">    <span class="string">&quot;doc1&quot;</span>: <span class="string">&quot;The quick brown fox jumps over the lazy dog near the river.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc2&quot;</span>: <span class="string">&quot;A quick brown fox leaps over a lazy dog by the riverside.&quot;</span>,  <span class="comment"># 与 doc1 高度相似</span></span><br><span class="line">    <span class="string">&quot;doc3&quot;</span>: <span class="string">&quot;The swift brown fox jumps over the sleepy dog close to the stream.&quot;</span>, <span class="comment"># 与 doc1 高度相似</span></span><br><span class="line">    <span class="string">&quot;doc4&quot;</span>: <span class="string">&quot;A fast brown fox jumps over a lazy hound near the water.&quot;</span>,   <span class="comment"># 与 doc1 较相似</span></span><br><span class="line">    <span class="string">&quot;doc5&quot;</span>: <span class="string">&quot;The cat sat on the mat and looked at the sun.&quot;</span>,             <span class="comment"># 与 doc1 不相似</span></span><br><span class="line">    <span class="string">&quot;doc6&quot;</span>: <span class="string">&quot;Dogs are loyal animals that make great companions.&quot;</span>,        <span class="comment"># 与 doc1 不相似</span></span><br><span class="line">    <span class="string">&quot;doc7&quot;</span>: <span class="string">&quot;Programming in Python is both powerful and enjoyable.&quot;</span>,     <span class="comment"># 与 doc1 不相似</span></span><br><span class="line">    <span class="string">&quot;doc8&quot;</span>: <span class="string">&quot;Data science involves statistics, programming, and domain expertise.&quot;</span>, <span class="comment"># 不相似</span></span><br><span class="line">    <span class="comment"># 添加大量不相关的文档来模拟“海量数据”场景</span></span><br><span class="line">    <span class="string">&quot;doc9&quot;</span>:  <span class="string">&quot;Machine learning models require large amounts of labeled data for training.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc10&quot;</span>: <span class="string">&quot;Cloud computing provides scalable resources over the internet.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc11&quot;</span>: <span class="string">&quot;Cybersecurity is essential for protecting digital information.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc12&quot;</span>: <span class="string">&quot;The solar system consists of the sun and the celestial bodies that orbit it.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc13&quot;</span>: <span class="string">&quot;Photosynthesis is the process by which green plants use sunlight to synthesize nutrients.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc14&quot;</span>: <span class="string">&quot;The human brain is a complex organ responsible for cognition and emotion.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc15&quot;</span>: <span class="string">&quot;Renewable energy sources include solar, wind, and hydroelectric power.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc16&quot;</span>: <span class="string">&quot;The internet has revolutionized communication and access to information.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc17&quot;</span>: <span class="string">&quot;Artificial intelligence aims to create machines that can perform tasks requiring human intelligence.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc18&quot;</span>: <span class="string">&quot;The history of the internet began with the development of ARPANET in the 1960s.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc19&quot;</span>: <span class="string">&quot;Quantum mechanics describes the behavior of matter and energy at atomic and subatomic scales.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc20&quot;</span>: <span class="string">&quot;The theory of evolution by natural selection was proposed by Charles Darwin.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 预处理和创建 MinHash 签名 ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preprocess_text</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;简单的文本预处理：转小写，分割成词&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> text.lower().split()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_minhash</span>(<span class="params">text, num_perm=<span class="number">128</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;为文本创建 MinHash 签名&quot;&quot;&quot;</span></span><br><span class="line">    m = MinHash(num_perm=num_perm)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> preprocess_text(text):</span><br><span class="line">        m.update(word.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正在为所有文档创建 MinHash 签名...&quot;</span>)</span><br><span class="line">minhashes = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> doc_id, text <span class="keyword">in</span> documents.items():</span><br><span class="line">    minhashes[doc_id] = create_minhash(text)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MinHash 签名创建完成。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 方法 1: MinHash LSH (近似搜索) ---</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n=== 方法 1: 使用 MinHash LSH 查找相似文档 ===&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 LSH 索引，设置相似度阈值</span></span><br><span class="line"><span class="comment"># threshold=0.5 表示我们希望找到 Jaccard 相似度 &gt;= 0.5 的文档</span></span><br><span class="line">lsh = MinHashLSH(threshold=<span class="number">0.5</span>, num_perm=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有文档的 MinHash 签名插入 LSH 索引</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正在构建 LSH 索引...&quot;</span>)</span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> doc_id, minhash <span class="keyword">in</span> minhashes.items():</span><br><span class="line">    lsh.insert(doc_id, minhash)</span><br><span class="line">lsh_build_time = time.time() - start_time</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;LSH 索引构建耗时: <span class="subst">&#123;lsh_build_time:<span class="number">.4</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择 doc1 作为查询文档</span></span><br><span class="line">query_doc_id = <span class="string">&quot;doc1&quot;</span></span><br><span class="line">query_text = documents[query_doc_id]</span><br><span class="line">query_minhash = minhashes[query_doc_id]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n查询文档 (<span class="subst">&#123;query_doc_id&#125;</span>): &#x27;<span class="subst">&#123;query_text&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正在使用 LSH 查找相似文档...&quot;</span>)</span><br><span class="line">start_time = time.time()</span><br><span class="line">similar_docs_lsh = lsh.query(query_minhash)</span><br><span class="line">lsh_query_time = time.time() - start_time</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;LSH 查询耗时: <span class="subst">&#123;lsh_query_time:<span class="number">.6</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;LSH 找到 <span class="subst">&#123;<span class="built_in">len</span>(similar_docs_lsh)&#125;</span> 个候选相似文档: <span class="subst">&#123;similar_docs_lsh&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 方法 2: 精确计算所有相似度 (全量比较) ---</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n=== 方法 2: 精确计算所有文档的相似度 (全量比较) ===&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;正在计算查询文档 &#x27;<span class="subst">&#123;query_doc_id&#125;</span>&#x27; 与其余 <span class="subst">&#123;<span class="built_in">len</span>(documents)-<span class="number">1</span>&#125;</span> 个文档的精确相似度...&quot;</span>)</span><br><span class="line">start_time = time.time()</span><br><span class="line">exact_similar_docs = []</span><br><span class="line">exact_similarities = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> doc_id, minhash <span class="keyword">in</span> minhashes.items():</span><br><span class="line">    <span class="keyword">if</span> doc_id == query_doc_id:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># 使用 MinHash 签名估算 Jaccard 相似度</span></span><br><span class="line">    similarity = query_minhash.jaccard(minhash)</span><br><span class="line">    exact_similarities[doc_id] = similarity</span><br><span class="line">    <span class="keyword">if</span> similarity &gt;= <span class="number">0.5</span>: <span class="comment"># 使用相同的阈值</span></span><br><span class="line">        exact_similar_docs.append(doc_id)</span><br><span class="line">exact_calc_time = time.time() - start_time</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;精确计算耗时: <span class="subst">&#123;exact_calc_time:<span class="number">.4</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;精确方法找到 <span class="subst">&#123;<span class="built_in">len</span>(exact_similar_docs)&#125;</span> 个相似文档: <span class="subst">&#123;exact_similar_docs&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 输出详细结果 ---</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n=== 详细结果 ===&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;LSH 找到的文档内容:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> doc_id <span class="keyword">in</span> similar_docs_lsh:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  <span class="subst">&#123;doc_id&#125;</span>: &#x27;<span class="subst">&#123;documents[doc_id]&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n精确方法找到的文档内容:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> doc_id <span class="keyword">in</span> exact_similar_docs:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  <span class="subst">&#123;doc_id&#125;</span>: &#x27;<span class="subst">&#123;documents[doc_id]&#125;</span>&#x27; (相似度: <span class="subst">&#123;exact_similarities[doc_id]:<span class="number">.3</span>f&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 性能与准确性比较 ---</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n=== 性能与准确性比较 ===&quot;</span>)</span><br><span class="line">lsh_set = <span class="built_in">set</span>(similar_docs_lsh)</span><br><span class="line">exact_set = <span class="built_in">set</span>(exact_similar_docs)</span><br><span class="line">true_positives = lsh_set &amp; exact_set</span><br><span class="line">false_positives = lsh_set - exact_set</span><br><span class="line">false_negatives = exact_set - lsh_set</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;召回率 (Recall): <span class="subst">&#123;<span class="built_in">len</span>(true_positives)&#125;</span>/<span class="subst">&#123;<span class="built_in">len</span>(exact_set)&#125;</span> = <span class="subst">&#123;<span class="built_in">len</span>(true_positives)/<span class="built_in">len</span>(exact_set) <span class="keyword">if</span> exact_set <span class="keyword">else</span> <span class="number">1.0</span>:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;假阳性 (False Positives): <span class="subst">&#123;false_positives&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;假阴性 (False Negatives): <span class="subst">&#123;false_negatives&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n=== 执行时间总结 ===&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;LSH 总耗时 (构建 + 查询): <span class="subst">&#123;lsh_build_time + lsh_query_time:<span class="number">.4</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;精确计算耗时:            <span class="subst">&#123;exact_calc_time:<span class="number">.4</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;LSH 相对于精确计算的查询加速比: <span class="subst">&#123;exact_calc_time / lsh_query_time:<span class="number">.0</span>f&#125;</span>x&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;注意: LSH 的优势在于索引可重用。如果进行10次查询，&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;     LSH 总时间约为: <span class="subst">&#123;lsh_build_time + <span class="number">10</span> * lsh_query_time:<span class="number">.4</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;     精确方法总时间:    <span class="subst">&#123;<span class="number">10</span> * exact_calc_time:<span class="number">.4</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 关键观察 ---</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n=== 关键观察 ===&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1. LSH 的查询时间 (微秒级) 远快于精确计算 (毫秒级)，即使在小数据集上。&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;2. LSH 是近似算法，可能漏掉一些相似文档 (假阴性) 或包含不相似文档 (假阳性)。&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;3. 一旦 LSH 索引构建完成，后续所有查询都极快，而精确方法每次查询都需全量计算。&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;4. 在需要频繁查询的海量数据场景下，LSH 的优势将呈数量级放大。&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="Transform-的架构，Encoder-和-Decoder"><a href="#Transform-的架构，Encoder-和-Decoder" class="headerlink" title="Transform 的架构，Encoder 和 Decoder"></a>Transform 的架构，Encoder 和 Decoder</h2><p>Transformer架构是一种用于序列数据处理的深度学习模型，特别适用于自然语言处理任务。它摒弃了传统的循环神经网络（RNN）和卷积神经网络（CNN），完全基于注意力机制（Attention Mechanism）构建。</p>
<p><strong>Encoder（编码器）</strong>：由多个相同的层堆叠而成，每层包括一个多头自注意力机制（Multi-Head Self-Attention）和一个位置前馈神经网络（Position-wise Feed-Forward Network）。编码器负责将输入序列转换为隐藏表示，这些表示捕捉了序列中元素之间的依赖关系，并且每个位置的信息都能被传递到下一个层次。</p>
<p><strong>Decoder（解码器）</strong>：同样由多个相同层组成，除了包含与编码器类似的组件外，还增加了一个额外的多头注意力层，称为“编码器-解码器注意力”层。这个层允许解码器关注到编码器的所有输出，帮助生成目标序列。此外，解码器在每个时间步只能访问到当前及之前的时间步信息，以保证预测的正确顺序。</p>
<p>通过这种结构，Transformer能够高效地并行训练，并显著提升处理长距离依赖问题的能力。</p>
<h2 id="FastText原理及实践"><a href="#FastText原理及实践" class="headerlink" title="FastText原理及实践"></a>FastText原理及实践</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/05/myblog/python/python%E4%B9%8B%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/05/myblog/python/python%E4%B9%8B%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" class="post-title-link" itemprop="url">python之零碎知识点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-05 00:00:31" itemprop="dateCreated datePublished" datetime="2025-08-05T00:00:31+08:00">2025-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-06 08:46:59" itemprop="dateModified" datetime="2025-08-06T08:46:59+08:00">2025-08-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">python语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="python通过执行命令获取参数"><a href="#python通过执行命令获取参数" class="headerlink" title="python通过执行命令获取参数"></a>python通过执行命令获取参数</h2><p>1、sys.argv：获取脚本运行时的命令行参数，是一个列表，第一个元素是脚本名称 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Script name:&quot;</span>, sys.argv[<span class="number">0</span>])  <span class="comment"># 脚本名称 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Arguments:&quot;</span>, sys.argv[<span class="number">1</span>:])  <span class="comment"># 参数列表 </span></span><br><span class="line">运行命令：python script.py arg1 arg2 arg3</span><br></pre></td></tr></table></figure>

<p>2、argparse：高级命令行参数解析 </p>
<p>首先使用argparse.ArgumentParser创建解析器。然后定义参数（如位置参数、可选参数等）。最后解析参数并访问其值。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建解析器 </span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;A simple argument parser example.&quot;</span>) </span><br><span class="line"><span class="comment"># 添加参数 </span></span><br><span class="line">parser.add_argument(<span class="string">&quot;name&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;User&#x27;s name&quot;</span>) </span><br><span class="line">parser.add_argument(<span class="string">&quot;--age&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&quot;User&#x27;s age&quot;</span>, default=<span class="number">18</span>) </span><br><span class="line">parser.add_argument(<span class="string">&quot;--verbose&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Enable verbose mode&quot;</span>) </span><br><span class="line"><span class="comment"># 解析参数 </span></span><br><span class="line">args = parser.parse_args() </span><br><span class="line"><span class="comment"># 访问参数 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;args.name&#125;</span>!&quot;</span>) </span><br><span class="line"><span class="comment"># 一个可选参数。只要它出现在命令行中，args.verbose 的值就会被设置为 True。</span></span><br><span class="line"><span class="keyword">if</span> args.verbose: </span><br><span class="line">运行命令：python script.py Alice --age <span class="number">25</span> --verbose</span><br></pre></td></tr></table></figure>



<h2 id="动态加载模块"><a href="#动态加载模块" class="headerlink" title="动态加载模块"></a>动态加载模块</h2><p>importlib: 用于动态加载模块。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">importlib.import_module <span class="comment"># 在运行时根据条件或配置导入不同模块 </span></span><br><span class="line">module = import_module(<span class="string">&#x27;math&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(module.sqrt(<span class="number">4</span>)) </span><br></pre></td></tr></table></figure>

<p>pkgutil.iter_modules：用于动态地列出指定包或路径中的所有模块 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> module_info <span class="keyword">in</span> pkgutil.iter_modules():    </span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&quot;Name: <span class="subst">&#123;module_info.name&#125;</span>, Is Package: <span class="subst">&#123;module_info.ispkg&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>inspect.getmembers ：用于获取对象（模块、类、实例等）的所有成员属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods = inspect.getmembers(MyClass, predicate=inspect.isfunction) </span><br><span class="line">inspect.ismethod	实例方法 </span><br><span class="line">inspect.isfunction	普通函数 </span><br><span class="line">inspect.isclass	类对象 </span><br><span class="line">inspect.isdatadescriptor	数据描述符（如<span class="built_in">property</span>） </span><br><span class="line">inspect.isgenerator	生成器对象</span><br></pre></td></tr></table></figure>



<h2 id="OutputNamedTuple"><a href="#OutputNamedTuple" class="headerlink" title="OutputNamedTuple"></a>OutputNamedTuple</h2><p>命名元组，命名元组是由 <code>collections.namedtuple()</code> 函数创建的数据类型。命名元组本质上是一个类的实例，这个类是从内置的元组类型继承而来的，但与普通元组不同的是，它的元素可以通过名字来访问，而不仅仅是通过索引位置。</p>
<p>特性：<strong>可命名性</strong>、<strong>不可变性</strong>、<strong>轻量级对象</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个命名元组类型 &#x27;Person&#x27;</span></span><br><span class="line">Person = namedtuple(<span class="string">&#x27;Person&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 Person 实例</span></span><br><span class="line">person = Person(name=<span class="string">&#x27;Alice&#x27;</span>, age=<span class="number">30</span>, gender=<span class="string">&#x27;female&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过名称访问字段</span></span><br><span class="line"><span class="built_in">print</span>(person.name)   <span class="comment"># 输出: Alice</span></span><br><span class="line"><span class="built_in">print</span>(person.age)    <span class="comment"># 输出: 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样也可以通过索引访问</span></span><br><span class="line"><span class="built_in">print</span>(person[<span class="number">0</span>])     <span class="comment"># 输出: Alice</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解包操作</span></span><br><span class="line">name, age, gender = person</span><br><span class="line"><span class="built_in">print</span>(gender)        <span class="comment"># 输出: female</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为字典</span></span><br><span class="line">person_dict = person._asdict()</span><br><span class="line"><span class="built_in">print</span>(person_dict)   <span class="comment"># 输出: OrderedDict([(&#x27;name&#x27;, &#x27;Alice&#x27;), (&#x27;age&#x27;, 30), (&#x27;gender&#x27;, &#x27;female&#x27;)])</span></span><br></pre></td></tr></table></figure>



<h2 id="元组和字典"><a href="#元组和字典" class="headerlink" title="元组和字典"></a>元组和字典</h2><p><strong>元组</strong>：是一个有序的、不可变的数据集合。元组中的元素通过索引来访问，支持重复值。<br>一旦创建后，其内容不能被修改。这被称为“不可变性”，意味着你不能添加、删除或更改元组中的元素。<br>使用场景：多返回值函数、固定集合等。此外，元组占用的空间相对较小，适合用于存储少量但固定的项目。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tuple_example = (<span class="number">1</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="number">3.14</span>)</span><br><span class="line"><span class="built_in">print</span>(tuple_example[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p><strong>字典</strong>：是一个无序的键值对集合，键必须是唯一的且不可变（如字符串、数字或元组），而值可以是任何类型的数据。字典通过键来访问对应的值。<br>是可变的，你可以随时添加、删除或更新字典中的键值对。<br>使用场景：适用于需要频繁查找、插入和删除操作的场合，尤其是在键值对应关系明显时特别有效。但是，字典会消耗更多的内存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict_example = &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">3.14</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict_example[<span class="string">&#x27;name&#x27;</span>])</span><br></pre></td></tr></table></figure>



<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p><code>class BaseClass(metaclass=abc.ABCMeta)</code> 这行代码定义了一个<strong>抽象基类</strong>（Abstract Base Class）。</p>
<p><strong><code>metaclass=abc.ABCMeta</code></strong>：</p>
<ul>
<li><code>metaclass</code>（元类）是创建类的“类”。它控制着类的创建过程。</li>
<li><code>abc.ABCMeta</code> 是 Python <code>abc</code> (Abstract Base Classes) 模块提供的一个特殊元类。</li>
<li>通过将 <code>BaseClass</code> 的元类指定为 <code>abc.ABCMeta</code>，我们告诉 Python <code>BaseClass</code> 应该被当作一个<strong>抽象基类</strong>来处理。</li>
</ul>
<p><strong>抽象基类的核心特点和作用：</strong></p>
<ul>
<li><strong>不能直接实例化</strong>：你不能直接创建 <code>BaseClass</code> 的实例（例如 <code>obj = BaseClass()</code> 会抛出错误）。</li>
<li><strong>定义接口（契约）</strong>：它的主要目的是定义一组方法（称为抽象方法），这些方法<strong>必须</strong>由它的子类（继承它的类）来实现。</li>
<li><strong>强制子类实现</strong>：如果一个子类继承了 <code>BaseClass</code>，但没有实现其所有的抽象方法，那么尝试创建这个子类的实例时，Python 会抛出 <code>TypeError</code> 错误。</li>
<li><strong>如何定义抽象方法</strong>：在 <code>BaseClass</code> 内部，使用 <code>@abstractmethod</code> 装饰器来标记哪些方法是抽象的。</li>
<li><strong>非抽象方法</strong>：这些方法在抽象基类中提供了具体的实现。子类<strong>可以</strong>直接继承并使用这些方法，也可以根据需要选择**重写（覆盖）**它们。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span>(metaclass=abc.ABCMeta):</span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;这是一个抽象方法，子类必须实现它。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_another_thing</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;这是另一个抽象方法。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 这是一个非抽象方法（具体方法）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">common_function</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;这是一个非抽象方法，子类可以直接继承使用。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is a common function provided by the base class.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误：不能实例化抽象基类</span></span><br><span class="line"><span class="comment"># instance = BaseClass()  # TypeError!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass</span>(<span class="title class_ inherited__">BaseClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Doing something!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注意：这里没有实现 do_another_thing</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误：ConcreteClass 没有实现所有抽象方法，不能实例化</span></span><br><span class="line"><span class="comment"># obj = ConcreteClass()  # TypeError!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FullyImplementedClass</span>(<span class="title class_ inherited__">BaseClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Doing something!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_another_thing</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Doing another thing!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确：可以实例化，因为所有抽象方法都被实现了</span></span><br><span class="line">obj = FullyImplementedClass()</span><br><span class="line">obj.do_something()  <span class="comment"># 输出: Doing something!</span></span><br><span class="line">obj.do_another_thing()  <span class="comment"># 输出: Doing another thing!</span></span><br></pre></td></tr></table></figure>

<p>现代 Python 更推荐使用 <code>abc.ABC</code> 作为基类，效果相同，但写法更简洁</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span>(abc.ABC):</span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/27/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bjava2025/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/27/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bjava2025/" class="post-title-link" itemprop="url">那些年背过的面试题之java2025</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-27 19:18:28" itemprop="dateCreated datePublished" datetime="2025-07-27T19:18:28+08:00">2025-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-10 23:28:30" itemprop="dateModified" datetime="2025-08-10T23:28:30+08:00">2025-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Reactor响应式编程和Reactor线程模型"><a href="#Reactor响应式编程和Reactor线程模型" class="headerlink" title="Reactor响应式编程和Reactor线程模型"></a>Reactor响应式编程和Reactor线程模型</h2><p>Reactor 是一个响应式编程库，提供了非阻塞、高效的异步数据流处理能力。Project Reactor应用于Spring生态系统（Spring WebFlux），用于处理 HTTP 请求和响应的异步流式数据。</p>
<p><strong>特点</strong>：<br>非阻塞：通过事件驱动的方式处理数据流，避免线程阻塞。<br>背压支持：允许消费者控制生产者的速率，防止资源过载。<br>高效性：适合高并发场景，能够更好地利用系统资源。<br>函数式风格：提供丰富的操作符，可以通过链式调用对数据流进行转换和处理。</p>
<p><strong>适用场景</strong>：响应式系统（如 Spring WebFlux）、数据流处理（如实时日志分析、事件流处理）。</p>
<p>Reactor 提供了<strong>两个核心类</strong>：<br>Flux：表示可以发射 0到N个元素 的异步数据流。<br>Mono：表示可以发射 0或1个元素 的异步数据流。<br>Flux 是 Reactor 中的一个核心类，用于表示可以发射多个元素的异步数据流。发射 0到N个元素，并最终以完成或错误信号结束。Flux 提供了丰富的操作符，可以轻松地对数据流进行转换、过滤、合并和错误处理。<br>——————————————————————<br>Reactor线程模型：一种经典的IO多路复用设计模式，用于高效处理大量并发连接。核心思想是通过一个或多个线程监听 I&#x2F;O 事件（如读写就绪），并将这些事件分发给相应的处理器进行处理。</p>
<p><strong>特点</strong>：<br>事件驱动：通过监听 I&#x2F;O 事件（如 select、poll 或 epoll）来避免阻塞等待。<br>单线程或多线程模型：单线程 Reactor 模型：所有事件由一个线程处理。多线程 Reactor 模型：使用多个线程来处理事件，适合高并发场景。<br>非阻塞 I&#x2F;O：避免因等待 I&#x2F;O 操作完成而阻塞线程，从而提高吞吐量。</p>
<p><strong>典型实现</strong>：Java NIO、Netty 等框架基于 Reactor 模型构建。</p>
<p><strong>核心组件</strong>：<br>Acceptor：负责接收新的连接请求，并将其注册到事件监听器中。<br>Dispatcher：负责监听 I&#x2F;O 事件并分发给对应的处理器。<br>Handler：处理具体的业务逻辑。</p>
<p><strong>适用场景</strong>：高并发网络服务（如 Web 服务器、消息队列等）、需要高效处理大量短连接或长连接的场景。<br>——————————————————————<br>Project Reactor和Reactor线程模型的联系：<br>**Project Reactor 提供了更高层次的抽象，专注于业务逻辑的响应式处理，而 Reactor线程模型则更关注底层 I&#x2F;O 事件的分发，处理网络层IO。**都是非阻塞的，都是事件驱动的。</p>
<h2 id="record关键字"><a href="#record关键字" class="headerlink" title="record关键字"></a>record关键字</h2><p>record：一种用于<strong>定义不可变数据载体类</strong>的特殊类形式，是 Java 14 引入的一个关键字，正式在 Java 16 标准化。</p>
<p>record 是<strong>一种简化数据类的语法，目的是存储数据而不对这些数据进行复杂的操作或修改的场景。自动生成了包括构造函数，getter、toString、equals、hashCode 等方法。</strong></p>
<p>它是一种不可变（Immutable）的类，所有字段都是 final，创建后状态不能更改。</p>
<p><strong>用法</strong>：<br>1、作为独立的类文件<br><code>public record Film(String name, String desc) &#123;&#125;</code></p>
<p>2、嵌套在其他类中，类似静态内部类<br><code>public static record Film</code></p>
<p>3、方法内部<br>从 Java 16 开始，record 可以被定义为局部类（即在方法内部定义）。这种用法适合<strong>仅在某个方法中使用的临时数据结构</strong>。直接record Film</p>
<p>PS：静态内部类和非静态内部类：静态内部类不依赖于外部类的实例，可以直接通过外部类名访问。只能访问外部类的静态成员。非静态内部类依赖于外部类的实例，必须通过外部类的实例来创建。可以访问外部类的所有成员，因为内部类持有一个对外部类实例的隐式引用。</p>
<h2 id="线上redis机器爆了，如何优化"><a href="#线上redis机器爆了，如何优化" class="headerlink" title="线上redis机器爆了，如何优化"></a>线上redis机器爆了，如何优化</h2><p>如果在生产环境中发现 Redis 出现异常，比如内存爆了或者响应变慢，首先通过 Redis 的 INFO 命令（<strong>redis-cli info</strong>）和监控平台查看当前的资源使用情况，确认是<strong>内存、CPU、连接数还是某个慢查询</strong>引起的。</p>
<p>如果是** Big Key **（存储的数据体积很大，如一个Hash包含上万个字段）或者热 Key 造成的，我会进行数据结构优化、拆分 Key、引入本地缓存；如果是连接数过高，我会检查连接池配置，适当增加连接池大小或引入连接复用。</p>
<p>如果是 QPS 过高导致 Redis 成为瓶颈，我会考虑引入<strong>Redis 集群、读写分离、或者对热点数据进行缓存</strong>。</p>
<p>此外，我也会加强缓存的<strong>失效策略</strong>、防止缓存穿透和击穿，并结合布隆过滤器等手段保护后端数据库。</p>
<h2 id="spring声明式事务-Transactional"><a href="#spring声明式事务-Transactional" class="headerlink" title="spring声明式事务@Transactional"></a>spring声明式事务@Transactional</h2><p>在Spring中事务管理的方式有两种，编程式事务和声明式事务。编程式事务将业务代码和事务代码耦合到一块，当发生异常的时候还得需要手动回滚事务，不优雅。</p>
<p>声明式事务：<strong>基于AOP，设置好切点，当我们调用事务方法时，会调用到生成的代理对象，代理对象中加入了事务提交和回滚的逻辑。当方法执行成功时提交事务，当方法发生异常时回滚事务。</strong></p>
<p>@Transactional可以用在类，方法，接口上：</p>
<ol>
<li>用在类上，该类的所有public方法都具有事务</li>
<li>用在方法上，方法具有事务。当类和方法同时配置事务的时候，方法的属性会覆盖类的属性</li>
<li>用在接口上，一般不建议这样使用，因为只有基于接口的代理会生效，如果Spring AOP使用cglib来实现动态代理，会导致事务失效（因为注解不能被继承）</li>
</ol>
<p><strong>@Transactional失效的场景</strong></p>
<ol>
<li>@Transactional注解应用到非public方法（除非特殊配置，例如使用AspectJ 静态织入实现 AOP）</li>
<li>自调用，因为@Transactional是基于动态代理实现的，自调用时，方法执行不会经过代理对象</li>
<li>异常在代码中被你自己try catch了，不抛异常进入不了回滚的逻辑</li>
<li>异常类型不正确，默认只支持RuntimeException和Error，不支持检查异常，如果抛出任何异常都回滚，可以配置rollbackFor为Exception</li>
<li>事务传播配置不符合业务逻辑</li>
</ol>
<p><strong>为什么只有public方法上的@Transactional注解才会生效？</strong></p>
<p>首先JDK动态代理肯定只能是public，因为接口的权限修饰符只能是public。cglib代理的方式是可以代理protected方法的（private不行，子类访问不了父类的private方法）如果支持protected，可能会造成当切换代理的实现方式时表现不同，增大出现bug的可能性，所以统一一下。</p>
<p>Transactional的事务传播行为默认为Propagation.REQUIRED。<strong>「如果当前存在事务，则加入该事务。如果当前没有事务，则创建一个新的事务」</strong></p>
<p>Propagation.REQUIRES_NEW**「创建一个新事务，如果当前存在事务，则把当前事务挂起」**</p>
<h2 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h2><ul>
<li><p><strong>继承类不同</strong>：HashTable继承Dictionary类，HashMap继承AbstractMap类</p>
</li>
<li><p><strong>线程安全级别不同</strong>：HashTable是线程安全的类，每个public方法都有Synchronized修饰，HashMap不是线程安全的</p>
</li>
<li><p><strong>是否允许null的要求不同</strong>：HashTable：key不允许为null，value不允许为null。HashMap：key允许为null，value允许为null。</p>
</li>
<li><p><strong>底层数据结构不同</strong>：在JDK1.8以后，HashMap的底层数据结构改成了数组+链表+红黑树的实现，在链表的节点大于TREEIFY_THRESHOLD&#x3D;8时，链表转为红黑树，在树节点小于UNTREEIFY_THRESHOLD&#x3D;6时，红黑树转变为链表。（之所以有8和6两个阈值是为了避免某个链表在临界点频繁插入删除，导致转换频繁降低性能）。而Hashtable的底层实现就是数组+链表，而没有红黑树，因此各种操作都要简单很多。</p>
</li>
<li><p><strong>容量和扩容不同</strong>：Hashtable的容量是直接使用用户输入的容量initialCapacity。HashMap在用户输入的基础上，强制将容量转换为大于输入容量的最小2的幂次方数值。扩容方面，<code>HashMap</code> 自动扩容为 2 的幂，利于位运算提升性能，而 <code>Hashtable</code> 扩容为原容量的 2 倍加 1。</p>
</li>
<li><p><strong>索引计算上</strong>，<code>HashMap</code> 使用 <code>hash &amp; (length - 1)</code>，比 <code>Hashtable</code> 的取模运算更高效。</p>
</li>
<li><p><code>HashMap</code> 的迭代器为 fail-fast 类型，当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出并行修改异常，但迭代器本身的remove()方法移除元素则不会抛出。而 <code>Hashtable</code> 的 <code>Enumerator</code> 不是。</p>
</li>
</ul>
<h2 id="什么是零拷贝"><a href="#什么是零拷贝" class="headerlink" title="什么是零拷贝"></a>什么是零拷贝</h2><p>零拷贝（Zero-Copy）是一种高效的I&#x2F;O操作技术，旨在<strong>减少数据在内核空间与用户空间之间不必要的复制</strong>，从而提升数据传输性能。传统I&#x2F;O操作中，数据通常需从磁盘读取到内核缓冲区，再复制到用户缓冲区，处理后再写回内核缓冲区并发送到网络，涉及多次上下文切换和数据拷贝。零拷贝通过系统调用（如Linux的<code>sendfile</code>、<code>splice</code>或<code>mmap</code>），让<strong>数据直接在内核内部从文件系统缓冲区传输到网络协议栈</strong>，避免了用户空间的中转。这不仅<strong>减少了CPU的拷贝开销，也降低了上下文切换次数</strong>，显著提高了大文件传输、网络服务等场景的效率，是高性能系统设计中的关键技术。</p>
<p>例如Netty：使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝，避免了 JVM 堆内存与系统内存之间的数据拷贝。Netty的Zero-copy完全是在用户态（Java应用层）的，偏向于优化数据操作。OS层面的Zero-copy通常是避免在用户态和内核态之间的拷贝数据。</p>
<p>例如RocketMQ：在消息存储与传输过程中，RocketMQ 利用零拷贝技术优化消息的发送性能。当消费者拉取消息时，通过 <code>mmap</code> 将消息文件映射到内存，或使用 <code>transferTo</code> 调用实现数据从文件通道直接传输到网络通道，避免内核与用户空间的多次拷贝。这不仅减少了内存占用，也加快了消息传输速度，支持高吞吐量的消息处理。</p>
<h2 id="Redis字典的实现方式和冲突处理"><a href="#Redis字典的实现方式和冲突处理" class="headerlink" title="Redis字典的实现方式和冲突处理"></a>Redis字典的实现方式和冲突处理</h2><p>Redis字典基于哈希表实现，其核心结构是一个数组，每个元素是指向<code>dictEntry</code>链表的指针。每个<code>dictEntry</code>存储键值对及下一个节点的指针，通过**链地址法（拉链法）**处理哈希冲突：当多个键映射到同一槽位时，它们被链接在同一链表中。</p>
<p>Redis使用MurmurHash2算法计算键的哈希值，再通过<code>hash &amp; (size-1)</code>确定索引位置，确保分布均匀。</p>
<p>为应对数据增长，Redis支持动态扩容与缩容。当负载因子过高（如超过1）或过低时，会触发rehash。Redis采用<strong>渐进式rehash</strong>机制：分配新哈希表，每次访问字典时顺带迁移部分数据，直至全部完成。这避免了集中迁移带来的性能阻塞。也就是说，Redis字典内部维护两个哈希表（ht[0]和ht[1]），在rehash期间两者并存，查找、删除操作会兼顾访问两个表，确保数据一致性。插入操作仅作用于ht[1]。rehash完成后，ht[1]成为主表，ht[0]被清空。 </p>
<p>此外，Redis在哈希表扩容时，新表大小为大于当前容量的最小2的幂，确保位运算高效定位。</p>
<h2 id="介绍MVC机制"><a href="#介绍MVC机制" class="headerlink" title="介绍MVC机制"></a>介绍MVC机制</h2><p>MVC（Model-View-Controller，模型-视图-控制器）是一种软件架构模式，用于分离应用程序的逻辑与界面。</p>
<p>模型（Model）代表数据和业务逻辑，处理核心的数据管理和规则定义，并在数据发生变化时通知视图（View）。</p>
<p>视图（View）负责展示信息给用户，它从模型获取数据显示给用户，但不直接与模型交互，而是通过控制器（Controller）。</p>
<p>控制器接收用户的输入，解释这些输入并将它们转换为对模型或视图的操作命令，如更新数据或请求视图刷新。</p>
<p>这种分离使得代码更加模块化、易于维护和扩展，特别适合于开发复杂用户界面的应用程序，同时提高了灵活性和可重用性。MVC广泛应用于Web应用框架中，如Django（<strong>一个高级的Python Web框架，遵循模型-模板-视图（Model-Template-View, MTV）架构模式，模型（Model）定义数据结构；模板（Template）控制页面展示逻辑；视图（View）则是业务逻辑层，决定了哪些数据被呈现。</strong>）、Ruby on Rails等。</p>
<h2 id="Flink和Spark的区别"><a href="#Flink和Spark的区别" class="headerlink" title="Flink和Spark的区别"></a>Flink和Spark的区别</h2><p>Apache Flink 和 Apache Spark 都是分布式计算框架，Flink流处理，Spark批处理。</p>
<p>处理模型</p>
<ul>
<li><strong>Flink</strong> 主要支持流处理，并以流处理为基础扩展到批处理。这意味着它首先被设计用于实时数据处理，能够提供低延迟的数据处理能力，适用于需要即时响应的应用场景。</li>
<li><strong>Spark</strong> 最初是作为一个批处理框架而设计的，后来通过Spark Streaming增加了对流处理的支持。Spark Streaming采用微批处理的方式（mini-batch），即把流数据按时间窗口分割成一系列小批次来处理，这使得它的延迟比Flink稍高一些。</li>
</ul>
<p>吞吐量</p>
<p>关于吞吐量，两者都有很高的处理效率，但在不同场景下表现各异：</p>
<ul>
<li><strong>Flink</strong> 由于其原生的流处理架构，在处理持续不断的数据流时具有更高的吞吐量和更低的延迟。对于要求严格实时性的应用，比如欺诈检测、在线推荐系统等，Flink通常是更好的选择。</li>
<li><strong>Spark</strong> 在批处理任务上表现出色，尤其是在处理大规模静态数据集时。尽管Spark Streaming可以通过增加批次大小来提高吞吐量，但这样做会增加处理延迟。因此，对于那些可以容忍一定延迟的大规模数据分析任务，Spark可能更为合适。</li>
</ul>
<h2 id="介绍JVM"><a href="#介绍JVM" class="headerlink" title="介绍JVM"></a>介绍JVM</h2><p>JVM（Java虚拟机）是运行Java应用程序的虚拟机，它使得Java程序具有“一次编写，到处运行”的能力。JVM的主要任务是将编写的Java字节码（.class文件）转换成本地计算机的机器码并执行。通过提供一个跨平台的运行环境，JVM隐藏了底层操作系统的差异，确保了Java程序可以在任何安装有相应JVM的设备上运行。</p>
<p>JVM包含类加载器、运行时数据区（包括方法区、堆、栈等）、执行引擎等关键组件。类加载器负责加载程序所需的类文件；运行时数据区为程序执行提供内存空间；执行引擎则负责解释或即时编译字节码为机器码执行。此外，JVM还包含了垃圾回收机制，自动管理内存，释放不再使用的对象所占用的空间。JVM不仅支持Java语言，还支持其他可以编译成Java字节码的语言，如Kotlin和Scala。</p>
<h2 id="JVM调优经验"><a href="#JVM调优经验" class="headerlink" title="JVM调优经验"></a>JVM调优经验</h2><p>主要目标是优化内存使用、减少GC停顿时间以及提高系统吞吐量。</p>
<ol>
<li><strong>合理设置堆大小</strong>：根据应用的实际需求和服务器资源，合理配置<code>-Xms</code>（初始堆大小）和<code>-Xmx</code>（最大堆大小），避免频繁的GC。通常建议将初始堆和最大堆设置为相同值，以减少动态扩展带来的开销。16G机器设置12G。</li>
<li><strong>选择合适的垃圾回收器</strong>：<ul>
<li>对于低延迟要求的应用，可以选择G1或ZGC等低延迟回收器。</li>
<li>对于高吞吐量要求的批处理任务，可以使用CMS并发清除。</li>
</ul>
</li>
<li><strong>监控与分析GC日志</strong>：通过启用GC日志，结合工具如<code>GCViewer</code>或<code>GCEasy</code>分析GC行为，识别是否存在频繁的Full GC或长时间的停顿。jstat监控GC。</li>
<li><strong>优化新生代比例</strong>：通过<code>-XX:NewRatio</code>和<code>-XX:SurvivorRatio</code>调整新生代与老年代的比例，确保大多数对象在Minor GC中被回收，减少晋升到老年代的对象数量。</li>
<li><strong>合理使用元空间</strong>：JDK 8以后，永久代被元空间取代，使用本地内存存储类信息。可通过<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>控制其大小，防止因加载过多类导致内存溢出。</li>
<li><strong>线程栈大小调整</strong>：对于线程数较多的应用，适当减小<code>-Xss</code>（线程栈大小）可节省内存，但需确保不会导致栈溢出。</li>
</ol>
<h2 id="JVM的堆分为哪几部分"><a href="#JVM的堆分为哪几部分" class="headerlink" title="JVM的堆分为哪几部分"></a>JVM的堆分为哪几部分</h2><p>JVM的堆是内存管理的核心区域，用于存放对象实例，主要分为三部分：</p>
<ol>
<li><strong>新生代（Young Generation）</strong>：新创建的对象首先分配在此。它又分为Eden区、From Survivor区和To Survivor区。大多数对象在Eden区分配，经过几次垃圾回收后仍存活的对象将被移到Survivor区。</li>
<li><strong>老年代（Old Generation）</strong>：存放从新生代晋升过来的长期存活对象。当对象经历多次GC未被回收，或占用空间较大时，会被移入老年代。</li>
<li><strong>永久代&#x2F;元空间（PermGen&#x2F;Metaspace）</strong>：方法区，JDK 8之前为永久代，用于存储类信息、常量、静态变量等；JDK 8及以后改为元空间，使用本地内存管理，避免了永久代的内存溢出问题。</li>
</ol>
<p>堆由垃圾回收器统一管理，是GC的主要区域。</p>
<h2 id="数据仓库和传统数据库有什么区别"><a href="#数据仓库和传统数据库有什么区别" class="headerlink" title="数据仓库和传统数据库有什么区别"></a>数据仓库和传统数据库有什么区别</h2><p>用途：传统数据库主要用于OLTP（on-line transaction processing）翻译为联机事务处理，即即时的系统交互，数据仓库主要用于OLAP（On-Line Analytical Processing）翻译为联机分析处理，从字面上来看OLTP是做事务处理，OLAP是做分析处理。从对数据库操作来看，OLTP主要是对数据的增删改，OLAP是对数据的查询。</p>
<p>建模：传统数据库主要使用范式建模，数据仓库可以根据需要采用范式建模或者现在互联网普遍使用的星形模型等。</p>
<p>使用技术：传统数据库一般使用mysql等关系型数据库，数据仓库目前互联网行业更多的是使用hadoop等大数据技术，也有使用mysql等，可以根据实际情况搭建。 </p>
<p>存储的数据：传统数据库只存储当前状态的数据，数据仓库需要存储历史状态的数据，用户对历史数据的回溯分析。  </p>
<p>ODPS设计用于大规模数据存储、处理和分析，支持包括批处理、流计算、交互式查询在内的多种计算模式，更接近于数仓。</p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>IO多路复用是一种允许单个进程监视多个文件描述符的技术，使得系统在单线程的情况下可以同时处理多个客户端请求。一旦某个描述符就绪（通常是读就绪或写就绪），就能进行相应的IO系统调用。其核心机制依赖于操作系统提供的系统调用，如select、poll和epoll（Linux）。通过这些调用，程序可以一次性监听多个socket或其他IO资源的状态，避免了为每个连接创建独立线程或进程的开销。</p>
<p>epoll相对于select的改进：</p>
<p>1.select单进程打开的最大的fd是有限制的，默认是1024个，对于需要支持上万TCP连接的服务器来说太少。epoll没有这个限制，支持的最大fd上限是操作系统最大文件句柄数。1G内存的机器大约是10万个句柄。</p>
<p>2.IO效率不会随着FD增加而线性下降。select和poll缺点是当有很大的socket集合时，任意时刻只有少部分的socket是活跃的，select和poll每次调用都会扫描全部集合，导致效率下降。epoll以空间换时间，更高效的事件通知机制。</p>
<p>3.epoll通过mmap（内存映射）技术将内核空间中的事件就绪列表映射到用户空间，从而让应用程序可以直接访问这个列表，减少了内核与用户空间之间的数据复制和上下文切换的开销，加速了消息传递过程。这种方式提高了处理大量并发连接时的效率和性能。</p>
<h2 id="Java和Python的区别"><a href="#Java和Python的区别" class="headerlink" title="Java和Python的区别"></a>Java和Python的区别</h2><p><strong>语法与开发效率</strong>：Python 语法简洁直观，适合快速开发；Java 语法较严谨，代码量通常更多。</p>
<p><strong>类型系统</strong>：Python 是动态类型语言，变量类型在运行时确定；Java 是静态类型语言，需在编译时声明类型，类型安全更强。</p>
<p><strong>执行方式</strong>：Python 是解释型语言，通过解释器执行；Java 是编译型语言，先编译成字节码，再由 JVM 解释或 JIT 编译执行。</p>
<p><strong>性能</strong>：Java 通常性能更高，得益于 JVM 的优化；Python 在计算密集型任务中相对较慢。</p>
<p><strong>应用场景</strong>：Java 常用于大型企业级应用、Android 开发；Python 广泛应用于数据科学、AI、脚本和Web开发。</p>
<h2 id="Seata分布式事务解决方案"><a href="#Seata分布式事务解决方案" class="headerlink" title="Seata分布式事务解决方案"></a>Seata分布式事务解决方案</h2><p>Seata是蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。</p>
<p><strong>分布式事务</strong>：是指在分布式系统中，一次操作需要跨多个节点、服务或数据库协调完成，要求这些操作要么全部成功，要么全部失败，以保证数据的一致性。</p>
<p>其中三个重要角色： <strong>TC</strong> **事务协调者：**维护全局和分支事务的状态，协调全局事务提交或回滚。  **TM ** **事务管理器：**定义全局事务的范围、开始全局事务、提交或回滚全局事务。  **RM ** **资源管理器：**管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>
<p>四种不同的分布式事务解决方案：</p>
<ul>
<li>XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入 </li>
<li>TCC模式：最终一致的分阶段事务模式，通过业务层面定义尝试、确认和取消操作，实现灵活的补偿型事务。（柔性事务）</li>
<li>AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式 </li>
<li>SAGA模式：将长事务拆分为多个本地事务，每个步骤执行后记录状态，出错时通过补偿操作回滚前面已完成的步骤。（柔性事务）</li>
</ul>
<h2 id="Redis实现防超卖"><a href="#Redis实现防超卖" class="headerlink" title="Redis实现防超卖"></a>Redis实现防超卖</h2><p>使用Redis可以有效地管理库存并保证数据一致性。</p>
<p>一种常见的做法是利用Redis的<code>WATCH</code>机制结合事务来确保库存扣减操作的原子性和一致性。首先，将商品库存存储在Redis中。当有购买请求时，客户端先通过<code>WATCH</code>命令监控库存键的状态。然后，在事务中尝试执行库存检查和扣减操作（如<code>DECR</code>）。如果在这期间没有其他客户端修改该库存键，则<code>EXEC</code>命令会成功执行事务；如果有其他客户端在此期间修改了库存值，则当前事务会被放弃，需要重新尝试整个过程。</p>
<p><strong>为什么只用INCR&#x2F;DECR不行</strong>：虽然Redis的<code>INCR</code>和<code>DECR</code>命令本身是原子性的，可以直接用于增加或减少数值，但在并发环境下仅依赖这些命令无法完全避免超卖问题。这是因为：</p>
<ul>
<li><strong>缺乏前置条件判断</strong>：直接使用<code>DECR</code>可能会导致库存变为负数，即超过实际库存数量的商品被卖出。</li>
<li><strong>无回滚机制</strong>：一旦后续业务逻辑失败（例如订单创建失败），无法自动恢复已扣减的库存，造成数据不一致。</li>
</ul>
<p><strong>使用WATCH和事务：</strong></p>
<ul>
<li><strong>确保数据一致性</strong>：通过<code>WATCH</code>监控关键资源，在并发情况下只有在资源未被其他进程修改的前提下才执行事务，保证了多个步骤作为一个整体执行，避免了竞态条件。</li>
<li><strong>提供乐观锁功能</strong>：<code>WATCH</code>机制是一种实现乐观锁的方式。它允许客户端在执行事务前监视一个或多个键，如果在事务执行前这些键被其他客户端修改过，则事务将失败不会执行任何操作。这种机制非常适合读多写少的场景。一种无锁机制来解决并发问题。</li>
</ul>
<h2 id="高并发项目中的限流和熔断"><a href="#高并发项目中的限流和熔断" class="headerlink" title="高并发项目中的限流和熔断"></a>高并发项目中的限流和熔断</h2><p><strong>限流</strong>：目的是控制请求量，防止系统过载。常用算法包括令牌桶和漏桶算法。通过设定速率阈值，如每秒处理请求数（RPS），超过限制的请求将被拒绝或排队。例如，使用Guava的RateLimiter类实现平滑限流。阿里巴巴的Sentinel，实现对特定资源的精准限流，确保系统在高并发场景下的稳定性和可靠性。</p>
<p><strong>熔断</strong>：用于避免故障扩散。当服务调用失败率超过阈值时（如50%请求失败），启动熔断器，快速失败而不是尝试执行可能耗时的操作。一段时间后，允许部分请求通过进行试探性恢复。Hystrix是一个流行的熔断库，它提供了开箱即用的熔断、降级等功能。</p>
<h2 id="优化多节点流程编排，优化工作流引擎性能"><a href="#优化多节点流程编排，优化工作流引擎性能" class="headerlink" title="优化多节点流程编排，优化工作流引擎性能"></a>优化多节点流程编排，优化工作流引擎性能</h2><p><strong>多节点流程编排优化：</strong></p>
<ol>
<li><strong>并行执行</strong>：识别可以并行处理的任务，通过合理的任务调度机制（如DAG调度）最大化并发度，减少整体执行时间。</li>
<li><strong>减少节点间通信开销</strong>：尽量减少跨节点的数据传输量，使用高效的序列化&#x2F;反序列化格式（如Protocol Buffers或Avro），并对数据进行压缩。</li>
<li><strong>智能路由与负载均衡</strong>：根据各节点当前的负载情况动态分配任务，避免某些节点过载而其他节点闲置。</li>
<li><strong>缓存中间结果</strong>：对于重复计算的部分，可以在适当的位置增加缓存机制，存储中间结果以供后续步骤直接使用。</li>
<li><strong>重试机制</strong>：为可能失败的操作设置合理的重试策略，包括指数退避算法等，以提高系统的容错能力。</li>
</ol>
<p><strong>工作流引擎性能优化：</strong></p>
<ol>
<li><strong>异步处理</strong>：尽可能采用异步调用代替同步等待，降低请求间的耦合度，加快响应速度。</li>
<li><strong>数据库优化</strong>：使用索引加速查询。对于频繁读写的表，考虑分库分表策略。</li>
<li><strong>批处理</strong>：对于大批量的数据操作，应采用批量提交而非逐条处理的方式，减少IO次数。</li>
<li><strong>资源池管理</strong>：有效管理连接池、线程池等资源，防止因资源耗尽导致的服务不可用。</li>
</ol>
<h2 id="双写一致性问题"><a href="#双写一致性问题" class="headerlink" title="双写一致性问题"></a>双写一致性问题</h2><p>双写一致性问题主要出现在使用缓存与数据库共同存储数据的场景中，两个独立的数据存储系统，在并发更新时难以保证操作的原子性和顺序性。当应用同时写入缓存和数据库时，由于网络延迟、系统故障或并发读写，可能导致两者数据不一致。</p>
<p>例如，如果<strong>先更新数据库再更新缓存</strong>，在这期间若有其他请求读取了旧的缓存数据，则会导致短暂的数据不一致。缓存更新失败也会导致不一致。同样，若<strong>先更新缓存再更新数据库</strong>，而此时数据库更新失败或出现网络问题，也会造成缓存与数据库数据的差异。此外，并发操作加剧了这一问题，多个客户端可能同时对同一数据进行读写操作，如果没有适当的同步机制，很容易导致部分客户端读取到未更新或错误的数据版本。<strong>先删缓存再更新数据库</strong>存在并发窗口期，可能使旧数据重新加载进缓存。</p>
<p><strong>如何解决</strong>：</p>
<p><strong>先更新数据库，再删除缓存</strong>，结合延迟双删或消息队列异步补偿，确保最终一致。</p>
<ol>
<li><strong>先更新数据库，后删除缓存</strong>：最常用。当需要更新数据时，首先更新数据库，然后立即删除对应的缓存项。下次查询时会从数据库加载最新数据到缓存中。在更新数据库之后和删除缓存之前，有短暂的不一致窗口。但是降低了因并发引起的复杂性和潜在的数据不一致风险。</li>
<li><strong>延迟双删策略</strong>：在更新数据库之后，不仅立即删除缓存，还会设置一个小延迟（如50ms），再次删除同一缓存项。因为当一个线程正在更新数据库并删除缓存时，另一个并发线程可能已经从旧缓存中读取了数据，并在更新操作完成之前将其重新写入缓存，导致缓存中的数据比数据库还旧，这是缓存重建行为。</li>
<li><strong>消息队列同步</strong>：利用消息队列确保操作顺序执行。将所有对数据库的修改通过消息队列进行异步处理，确保每个操作按序到达并更新缓存和数据库，适用于对一致性要求较高的场景。</li>
<li><strong>使用分布式事务或Saga模式</strong>：对于复杂的业务逻辑，可以采用分布式事务或者Saga模式来管理跨服务的数据一致性，但这通常增加了系统的复杂度。</li>
</ol>
<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>CAP理论帮助开发者理解分布式系统的取舍。CAP理论指出，在分布式系统中，<strong>一致性（Consistency）</strong>、<strong>可用性（Availability）</strong> 和 <strong>分区容错性（Partition tolerance）</strong> 三者不可兼得，最多只能同时满足其中两项。</p>
<ul>
<li><strong>一致性</strong>：所有节点在同一时间看到的数据是相同的。</li>
<li><strong>可用性</strong>：每个请求都能在合理时间内收到成功或失败的响应，不保证数据最新。</li>
<li><strong>分区容错性</strong>：系统在部分节点间通信中断（网络分区）时仍能继续运行。</li>
</ul>
<p>由于网络故障难以避免，分区容错性通常是必须保证的。因此，系统设计通常在 <strong>CP（如ZooKeeper）</strong> 和 <strong>AP（缓存系统，一般会追求AP可用，并通过一些手段尽可能保证弱一致性和最终一致性）</strong> 之间权衡：CP系统在分区发生时保证数据一致但可能拒绝服务；AP系统保持可用，但允许数据暂时不一致。</p>
<h2 id="RocketMQ事务消息"><a href="#RocketMQ事务消息" class="headerlink" title="RocketMQ事务消息"></a>RocketMQ事务消息</h2><p>可以利用事务消息轻松地实现分布式事务，采用2PC的思想来实现提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息。</p>
<p>RocketMQ实现事务消息主要分为两个阶段：正常事务的发送及提交、事务信息的补偿流程 整体流程为：</p>
<ul>
<li>正常事务发送与提交阶段：1、生产者发送一个半消息给MQServer（半消息是指消费者暂时不能消费的消息） 2、服务端响应消息写入结果，半消息发送成功 3、生产者开始执行本地事务 4、执行完本地事务后再告诉MQServer本地事务的执行状态，确认消息究竟是Commit还是Rollback</li>
<li>事务信息的补偿流程 1、如果MQServer长时间没收到本地事务的执行状态，会向生产者发起一个确认回查的操作请求 2、生产者收到确认回查请求后，检查本地事务的执行状态 3、MQServer根据检查后的结果执行Commit或者Rollback操作。补偿阶段主要是用于解决生产者在发送Commit或者Rollback操作时发生超时或失败的情况。</li>
</ul>
<p>例如场景：用户请求订单微服务 <code>order-service</code> 接口删除订单（退货），删除订单后需要发送消息给用户服务<code>account-service</code>，用户微服务收到消息后会给用户账户增加余额。这个需求跟钱相关，肯定要保证消息的事务性。</p>
<p>事务消息相对普通消息最大的特点就是一阶段发送的消息对用户是不可见的，也就是说消费者不能直接消费。实现方法是改变主题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/27/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%81%9A%E8%BF%87%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B9%8BLetcode100/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/27/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%81%9A%E8%BF%87%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B9%8BLetcode100/" class="post-title-link" itemprop="url">那些年做过的编程题之Letcode100</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-27 17:07:02" itemprop="dateCreated datePublished" datetime="2025-07-27T17:07:02+08:00">2025-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-30 22:34:30" itemprop="dateModified" datetime="2025-07-30T22:34:30+08:00">2025-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目 通用：数组初始化后填充某个数：Arrays.fill(arr, 0);    数组排序：Arrays.sort(names, Collections.reverseOrder());  数组装箱：Integer[] boxedNums = Arrays.stream(nums).boxed().toArray(Integer[]::new);  反转数组：需要先变为List，List list = Arrays.asList(arr);   Collections.reverse(list);    arr = list.toArray(new Integer[0]); (变为Integer[]) 或者 resList.stream().mapToInt(Integer::intValue).toArray();  (变为int[]) 小顶堆：PriorityQueue minHeap = new PriorityQueue&lt;&gt;();   PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; minHeap =          new PriorityQueue&lt;&gt;(Comparator.comparingInt(Map.Entry::getValue)); 大顶堆：PriorityQueue maxHeap = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());    heap.offer插入 poll删除元素 堆顶元素peek。 s.substring(startIndex, endIndex) 左闭右开 int sum = Arrays.stream(nums).sum(); 求和 回文链表：先把元素遍历出来到数组list，然后前后双指针进行对比。还可以使用递归，使用递归反向迭代节点，同时使用递归函数外的变量向前迭代。 环形链表：方法一：使用HashSet记录走过的节点，如果之前走过，则环形链表。方法二：快慢指针，有换一定会遇到，遇到后，一个指针从起始节点出发，一个指针从相遇节点出发，相同速度移动，撞见就是环形相交节点。 合并两个有序链表：双指针，while条件里可以是两个其中之一不为null，也可以是两个都不为null，然后next直接指向剩余的那个ListNode。注意ListNode a = new Listnode(1);  然后ListNode b = a; a/b再变，另一个是不跟着变得，因为不是ab指向的对象发生了变化，而是b指向了别的东西。 两数相加：while循环中求当前数和进位数，最后判断进位是否为0，也就是是否要加一个数。 删除链表的倒数第N个结点：双指针，得模拟一下，快指针移动几步（n步），然后慢指针停止的条件是什么（fast!=null）。考虑只有一个结点的情况，得用preHead。 两两交换链表中的节点（不能改节点的值）：跟链表翻转类似，遍历过程中模拟翻转的过程，需要定义哪些临时节点进行记录。注意要用preHead。链表翻转就不用preHead。 k个一组翻转链表：是翻转链表的复杂版本，不光要翻转，翻转之后连接分段，所以要在遍历过程中记录头节点和尾节点。首先判断分段是否够，顺便遍历到tail节点。子函数进行分段翻转，传入preHead和k，遍历用k，提前定义pre和cur，循环中1保存next，2箭头翻转，3移动pre和cur。然后连线，再移动。 排序链表：二分，归并排序（递归）先用快慢指针找到链表中点，分割进行递归，终止条件是只有一个节点。递归排序后进行merge，双指针法进行合并，得用preHead。 合并k个升序链表：优先级队列PriorityQueue，因为数组里的列表都是排好序的，所以先把数组中每个列表的头节点加进去，然后取队列里最小的，然后把取到的节点的next加入优先级队列，直到优先级队列为空了 LinkedHashMap：LinkedHashMap继承自HashMap，在 HashMap 的基础上增加了对元素顺序的维护能力，既可以按照插入顺序排序，也可以按照访问顺序排序。底层实现：HashMap（实现O(1) 时间复杂度的插入、删除和查找操作）+ 双向链表（用于记录键值对的顺序，链表的头节点表示最早插入或最久未访问的元素，尾节点表示最近插入或最近访问的元素。当哈希表需要扩容时，LinkedHashMap 会重新分配桶中的节点，但不会影响双向链表的顺序。扩容时机：当哈希表中的元素数量超过 容量 × 负载因子（默认0.75） 时，触发扩容操作。扩容为原数组容量的两倍。LinkedHashMap默认不移除元素，重写removeEldestEntry方法进行移除来实现LRU。 为什么LRU得是双向链表：涉及到找到节点，然后把节点移动到链表尾部，双向链表实现该操作只需要O1时间复杂度，单向链表无法获取上一个节点，是On复杂度。 实现LRU缓存：存放的是key-value对，自定义双向链表，节点内维护key和value，HashMap是用来快速找到节点的，所以key就是key，value是Node节点。需要自定义双向链表类，get方法中，首先判断在不在map中，如果在则移动节点到尾部。put方法中，首先判断容量是否达到上限，如果达到则移除头部节点（伴随改变size和map），然后添加节点到尾节点（伴随改变size和map）。注意前后都要哨兵节点，并且相连。 层序遍历：用队列来实现。每次访问一层，并把下一层加入到队列中。 栈： Stack 类由于继承自 Vector 导致的性能问题，不推荐使用。Deque（双端队列）接口提供了更灵活和高效的栈实现方法。ArrayDeque 和 LinkedList 是最常用的 Deque 实现类。 Deque stack = new ArrayDeque&lt;&gt;(); stack.pop()、 stack.peek()、 stack.push(num) 队列：使用Queue 队列：Queue queue = new ArrayDeque&lt;&gt;(); queue.offer(num)、queue.poll()、queue.peek() Queue 是一个接口，表示队列（FIFO，先进先出）的数据结构。 单向队列，offer()、poll() 和 peek() Deque 是一个接口，表示双端队列的数据结构。 addFirst()、addLast()、pollFirst()、pollLast()、用作栈，通过 push() 、 pop() 、peek() Deque 继承了 Queue 接口。 ArrayDeque 和 LinkedList 都实现了 Deque 接口，因此它们都可以用作双端队列或普通队列。 ArrayDeque：基于动态数组实现。不支持存储 null 元素。不是线程安全的。 LinkedList：基于双向链表实现。支持存储 null 元素。不是线程安全的。 前/中/后序遍历：方法一：递归法，递归的时候隐式地维护了一个栈。方法二：迭代法，显式地将这个栈模拟出来。前序遍历先把root节点压进去，然后遍历中pop加到res里，再右左节点压进去。后序遍历，先把root节点压进去，然后左右节点，这样是前右左顺序，再Collections.reverse(result)一下。中序遍历先一直压左边的，压到头了，再加到res，再压右节点，注意while里的条件是栈不空或root不为null，pop后，压pop节点的右节点。 广度优先搜索：一种逐层遍历的方式，从根节点开始，先访问当前层的所有节点，然后再访问下一层的所有节点。使用队列Queue来实现。 深度优先搜索：一种沿着树的深度方向尽可能深入访问节点的方式，直到到达叶子节点后再回溯。使用递归或者栈。 二叉树的最大深度：深度优先搜索，递归，终止条件是null节点返回0，不然看左右谁大。也可以用广度优先搜索，类似层序遍历，看有多少层。 翻转二叉树：深度优先搜索，递归，终止条件是null，返回null，然后左右节点递归，然后左右节点互换。 对称二叉树：递归，输入两个节点，一左一右，比较。 二叉树的直径：树中任意两个节点之间最长路径的长度。其实跟左子树深度和右子树深度(节点数)有关。但是需要注意，最大直径不一定需要经过根节点！!因此在递归中需要记录结果。递归返回节点数，边就在节点数基础上 - 1。 将有序数组转换为二叉搜索树：高度平衡的二叉树，不能选择中点之后直接做一支右一支，用递归，左边右边分别再递归。其实就是根据中序遍历恢复二叉树，只不过指定中点。 验证二叉树：使用递归，但是不能单纯地只判断左子树和右子树，递归输入中还得传最大值和最小值，不能只比父节点，父节点的父节点也得比，就传一个max一个min。 二叉搜索树中第k小的元素：中序遍历是顺序数列，先中序遍历再找数。拓展：如果一个数要频繁地找第k小，怎么优化，每个节点记录以该节点为根的节点数，然后再找。 二叉树的右视图：类似层序遍历，但是只记录每层的最后一个数。用队列。 二叉树展开为链表：先序遍历的方式，右指针是next。可以先先序遍历，然后再展开为列表。方法二是同时进行，但是要用迭代方式的前序遍历，用栈把右子树节点记录下来。 从前序与中序遍历序列构造二叉树：递归，前提条件是遍历中没有重复元素。前序遍历第一个节点是根节点，再从中序遍历中拆出左子树的中序遍历和右子树的中序遍历。 在中序遍历中找节点，用一个hash来快速找，通过数来找索引 路径总和：用递归解决，但是要注意从根节点到叶子结点，叶子结点得是left和right都为null的 路径总和2：需要找出从根节点到叶子结点的符合要求的所有路径。注意1:添加结果时需要添加结果的拷贝，因为是引用传递。注意2:需要回溯，就是在返回上一层前list去掉该节点。 路径总和3：不限制从根节点到叶子结点，但是需要从上到下，也就是从父节点到叶子结点。 解法1:暴力法，每个节点都走一遍递归。dfs函数，计算的是以root为开始，不管谁为结束的符合要求的数量，会存在整数溢出的问题，把dfs函数的targetSum参数类型变为long就行了。解法2: 用前缀和，就是用一个Map记录之前路径上从根节点到某节点的和对应的数量，这样只需要用从根节点到当前节点的和来解决问题了。dfs递归过程中记录根节点到目前的总和。dfs表示以当前节点为尾节点。依然要用Long解决溢出问题。 二叉树的最近公共祖先：用递归，递归函数的输出的是最近公共祖先，退出条件是如果当前节点是 p 或 q 或 空，则直接返回当前节点。在左右子树中分别递归查找 p 和 q：如果左子树返回非空结果且右子树返回非空结果，则当前节点就是最近公共祖先。如果只有左子树返回非空结果，则返回左子树的结果。如果只有右子树返回非空结果，则返回右子树的结果。脑子里模拟一下这个过程，一个函数就解决。 二叉树中的最大路径和：用递归，不限制父节点到子节点，所以，当前节点路径=当前节点+左路径+右路径，对比全局最大。注意，递归函数是包含root节点的单边的。 岛屿数量：递归dfs，递归使相邻的置为0。也可以使用并查集，并查集的核心思想是通过树形结构维护集合关系，并通过路径压缩优化查找效率。第一步初始化父节点和深度节点列表，然后合并，合并过程中寻找root节点是否相同，不相同则需要合并，find的过程中递归。深度小的往深度大的合并，提高查找根结点的效率。将rank较小的根节点指向rank较大的根节点，以保持树的平衡。如果两个根节点的rank相同，则可以将其中一个根节点作为另一个根节点的子节点，并将rank增加1。 腐烂的橘子：广度优先搜索，用到队列，将最开始腐烂的橘子加入到队列中，然后一层层往外遍历。注意，while判断里，除了queue不为空，还需要新鲜橘子数量大于0. 课程表：判断图中有没有环。用邻接表来表示图，维护节点状态：未访问、正在访问、已访问，用深度优先搜索，遍历所有节点，递归遍历后序节点（反个方向是不是也行？）。其实就是判断图中有没有环。首先，构建邻接表，放的是节点的后置节点。其次，创建初始状态，0未访问，1访问中，2已访问。然后进行DFS。 List转换为Integer[]：list.toArray(new Integer[list.size()]) List转换为int[]：res.stream().mapToInt(Integer :: intValue).toArray() 课程表输出顺序：注意，应该在递归回溯的时候再往结果里放入，如果遍历的是后序节点，还应该Collections.reverse(list)。 全排列：给的元素无重复，同一个元素不能重复使用。用递归DFS，但是需要记录哪些元素已经使用过了。在回溯的时候需要移除List和移除记录使用元素的Set。拷贝一个list：new ArrayList&lt;&gt;(list)。 子集：给的元素无重复，返回所有子集，不能包含重复的子集。不是看排列了，而是看子集了。使用递归DFS，但是不用记录使用set了，需要记录开始递归位置start。 电话号码的字母组合：递归DFS，带start，初始化map，new HashMap&lt;&gt;()&#123;&#123;put(1,&quot;a&quot;); put...)&#125;&#125;，注意得是两个大括号。遍历字符串中的字符：for(char c : s.toCharArray())。s.substring(start, end)。 组合总和：给的是无重复的数组，返回和为target的组合方案，一个数可以使用多次。用DFS，先给数组排个序，DFS中如果大于target就False，后面就不遍历了。为了避免重复，应该用start来限制开始遍历的数字。注意：1.写入结果传副本。2.先排序，大了就不用往后走了。3.回溯后移除节点。4.传start避免结果重复。 括号生成：给出一个n，返回可能的括号组合。DFS中两种情况：放左括号和放右括号。 单词搜索：深度优先搜索，不能光遍历四周，遍历过的还不能再遍历了，不然一直在dfs。用set维护路径。最开始的想法：从头开始DFS，用Set记录走过的路径防止重复遍历。但是比较字符串需要比较结尾。改进方法：DFS，dfs起点：每个点；dfs需要携带的：匹配上的字符长度；dfs出口：字符不一样/字符长度达到。已经用过的字母不能再用：向下一个递归之前变为其他字符，递归完之后再变回来 分割回文串：给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。 解法：DFS+回溯，要传start记录切割位置，for横向遍历，dfs纵向遍历。把一个字符串分割成若干个回文串，DFS，目标是挨个遍历，遍历到回文串存一个，然后继续向后遍历，出递归的条件是遍历到了末尾。要用start记录遍历到了哪里，注意单个字符也算回文。 N皇后：输入n，求得所有可能的排布。使用回溯，用什么表示：用一个数组，数组表示index行的皇后放在value列。什么时候记录：所有行都完备了添加。需要有检查排布是否可以的方法。用StringBuilder，s.setCharAt(track[i], &#x27;Q&#x27;); 二分查找：mid = l + (r - l) /2; 要注意while里的条件是l&lt;=r。l要更新为mid-1。r要更新为r+1。 搜索二维矩阵：先用一遍二分找在哪个行，注意所在行是最后的l-1。再用二分找在哪个列。 在排序数组中查找元素的第一个和最后一个位置：先二分查找找到目标，再前后移动找位置. 寻找旋转排序数组中的最小值：直接遍历虽然能解，但是复杂度要求达不到，要用二分。画张图举个例子好理解，中间节点和两边节点判断可过滤不可能的，注意和传统二分区别：while里条件l&lt;r。 寻找两个正序数组的中位数：限制时间负责度logm+n，所以双指针前后遍历是不行的，得二分。思路：扩展到获取第k大的数，分别获取两个数组k/2的位置，小的左边就能淘汰。第一步：出递归条件：如果一个数组已经被淘汰没了，则直接从另一个获取。第二步：递归：获取每个数组的第k/2位置数做比较，可能越界，所以得判断。注意得是index=s1+k/2-1，然后淘汰index及之前的。先要看k是不是等于1，等于1则可以直接判断。 有效的括号：构件一个map和左括号list，用栈，为空或者为左括号则加入，为右括号则pop出来看是否匹配，最后返回栈是否为空。Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;()&#123;&#123;put(&#x27;)&#x27;, &#x27;(&#x27;);   List left = Arrays.asList(&#x27;(&#x27;, &#x27;&#123;&#x27;, &#x27;[&#x27;);  Deque stack = new ArrayDeque&lt;&gt;();   遍历string：char c : s.toCharArray() 字符串解码：重复次数可能是多位的，开始使用一个栈记录重复次数和字符串，有点乱。使用两个栈分别记录。使用两个栈：一个存重复次数，一个存之前的解码结果。注意3[a2[c]这种，左括号的时候进行压栈，右括号的时候pop栈，这时候需要重复的是currentStr，栈里pop出的是需要在前面的，重复完之后要更新currentStr。判断一个char为数字的两种办法：Character.isDigit()、c - &#x27;0&#x27;&lt;=9。 每日温度：一个数组表示温度，返回数组表示对于i天，下一个更高温度出现在几天后，如果不会升高则0。使用栈，纠结于如何记录结果，其实栈中存放的元素不是温度，而是索引。栈里的元素应该是从大到小的，遍历过程中，元素大于栈顶就pop。注意，栈里放的是索引，不是实际温度。 柱状图中最大的矩形：一个数组表示柱状图的高度，返回能勾勒出矩形的最大面积。思考暴力情况下如何解决：对每一个柱子，向左向右扩展，直到遇到比它矮的，那么以当前柱子高度为高的矩形的宽度就确认出来，这样再全局比较。所以，关键点在于找左边第一个比它小的位置和右边第一个比它小的位置。用单调栈，栈中依然保存索引。每当遇到一个比栈顶元素小的高度时，说明找到了栈顶元素的右边界；弹出栈顶元素，此时它的左边是前一个栈顶元素（即左边界）。注意，获取左边界时stack为空，则left=-1可以。还需要管最后一个元素的结果，所以for循环边界是heights.length，搞个最后的0作为哨兵节点。 数组中的第k个最大元素：使用最小堆，优先级队列。如果堆大小为k，则需要对比堆顶元素和当前元素哪个更大。其实不用，先插入，大于k则弹出堆顶元素即可。 前k个高频元素：先用Map记录频率，然后用小顶堆记录k个Map.Entry，表示键值对项，其他和k个最大元素一样。 买卖股票的最佳时机：贪心，遍历过程中记录历史最低点，同时记录最大收益。 跳跃游戏：判断是否能到达最后一个下标。遍历过程中记录最远能跳到哪里，如果当前索引小于maxReach则直接返回false。 跳跃游戏2：返回最少跳跃数。最少跳跃数，两种方法：一种用动态规划记录最少跳跃数，然后双层遍历外层遍历数组，内层遍历该位置跳跃范围。另一种是贪心，双层循环，外层while从后往前遍历能跳到的位置，内层从前往后找最少跳跃位置。前提是一定能跳到，不然会死循环，所以pos &gt; 0。 划分字母区间：同一个字母最多出现在一个片段中，返回表示每个字符串片段长度的列表。用一个map记录每个字符最后出现的位置，然后遍历字符串进行切分，记录start和end，遍历过程中更新end，如果i==end则表示可以切分。 爬楼梯：每次爬1或2阶，总共有多少种爬台阶的方法。动态规划，dp[n+1]，初始化0和1，然后遍历。 杨辉三角：动态规划，List创建时初始化：List list = Arrays.asList(&quot;apple&quot;)。List获取get(index). 打家劫舍：不能偷窃相邻的房屋，动态规划，dp[i]表示偷到i的最大收益，初始化前两个。 完全平方数：返回和为n的完全平方数的最少数量，可重复使用的。动态规划，一个一维数组初始化比较大的值。双层遍历，外层遍历1-n/2的平方数，内层遍历dp数组。如果大于平方数，则更新。 零钱兑换：给定一个可用零钱面值数组和总金额，返回需要的最少硬币数量，都是可重复使用的，思路和完全平方数一样。注意初始化用Integer.MAX_VALUE-1。 单词拆分：给一个字符串，一个字符串列表，判断能否用列表中的字符串拼接出该字符串，可重复使用。是背包问题。完全平方数是先遍历平方数，再遍历数。这里需要先遍历字符串再遍历物品列表。因为这里对物品顺序是有要求的。dp[i]表示以字符串i-1索引结尾的结果。// 检查以i-1结尾的字符往前倒的字符串，和wordDict[j]是不是一样。 最长递增子序列：子序列是顺序不能变，可以删掉部分元素组成。动态规划dp[i]表示以i结尾的最长递增子序列，双层遍历。 乘积最大子数组：得是连续的最大子数组。用动态规划，两维数组记录i-j的连续乘积，要双层遍历，感觉不是最优。正解：关键点：因为负数的存在，最大和最小可能一下反转。记录阶段最大值和阶段最小值（也就是以上一个数为尾部的最大值最小值）。因为负数存在，当遍历到负数时，最大数和最小数要做交换。遍历过程中记录最大的阶段最大值。 分割等和子集：给一个数组，能否分成两个和相等的子集，不要求连续。是一个背包问题，维护dp[i][j]，i表示考虑0-i的物品，j表示容量为j，dp值表示背包最大能放的重量。初始化i=0的时候，j为多少能放下改物品。不需要提前排序的。遍历时候双层循环，外层物品，内层重量。内层也得从1开始遍历。两种选择：一种不放这个，一种放这个。 最长有效括号：只包含()的字符串，找出最长有效的连续字串长度。用栈保存左括号的索引，初始化时，栈先压入 -1，表示“有效括号子串起点前的位置”。遇到右括号则弹出栈顶，如果弹出后栈空了，说明遇到不能配对的右括号，把当前位置下标入栈（新起点）。否则，当前有效括号长度为i - 栈顶下标，更新最大长度。这里记录不是遇到不有效再记录，而是每次遇到有效时记录。 不同路径：多维动态规划，简单。 最小路径和：依然多维路径规划，初始化左边和上边，直接在原数组上操作。 最长回文子串：多维数组表示i-j的子串是否是回文子串，推演关系决定遍历顺序，ij依赖i+1,j-1，所以从左下角开始遍历。如果ij字符相等，相差&lt;=1，或者dp[i+1][j-1]为true，则为回文，记录结果 最长公共子序列：两位数组表示text1的i-1结尾和text2的j-1结尾的最长公共子序列长度。注意字符不等于的时候，Math.max(dp[i - 1][j], dp[i][j - 1]). 编辑距离：插入、删除、替换。思路：二维动态数组，长度len1+1*len2+1，表示i-1结尾和j-1结尾的。为什么数组长度要+1，因为0的位置需要遍历，初始化不好初始化，只能用-1的初始化，初始化为对应的ij。状态转移：字符相等则等于dp[i-1][j-1]，不想等则删除：dp[i-1][j], dp[i][j-1]，修改：dp[i-1][j-1]，其中取最小然后+1。 只出现一次的数字：遍历，用map可以，但是最好的是用异或运算，^，相同异或为0，与0异或为自己。 多数元素：使用投票机制，记录一个结果数和一个数量，如果数量等于0则换数，否则看当前数是否等于结果数，决定投票+1/-1。 颜色分类：三色国旗问题，双指针，都从0开始遍历，一个指针用来换1，一个指针用来换0，但是换0需要注意，可能把1换出去了，所以换完0之后如果p0&lt;p1就得交换i和p1。 下一个排列：举个例子123654，124653，先要从后往前找到第一个升序的，然后从后往前找到第一个比升序对第一个数大的，然后交换，变成了124653，然后反转i+1到末尾这段。 </span><br></pre></td></tr></table></figure>

<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</span><br><span class="line">你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</span><br><span class="line">你可以按任意顺序返回答案。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, map.get(target - nums[i])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="## 字母异位词分组"></a>## 字母异位词分组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</span><br><span class="line">示例 1:</span><br><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用stream聚合strs</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = Arrays.stream(strs)</span><br><span class="line">                .collect(Collectors.groupingBy(str -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 对数组排序</span></span><br><span class="line">                    <span class="type">char</span>[] array = str.toCharArray();</span><br><span class="line">                    Arrays.sort(array);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">                &#125;));</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</span><br><span class="line">请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] != nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                maxLen = Math.max(maxLen, preLen);</span><br><span class="line">                preLen = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                preLen ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = Math.max(maxLen, preLen);</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</span><br><span class="line"></span><br><span class="line">例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</span><br><span class="line">整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</span><br><span class="line"></span><br><span class="line">例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。</span><br><span class="line">类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。</span><br><span class="line">而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</span><br><span class="line">给你一个整数数组 nums ，找出 nums 的下一个排列。</span><br><span class="line"></span><br><span class="line">必须 原地 修改，只允许使用额外常数空间。</span><br></pre></td></tr></table></figure>

<p><strong>纯找规律，举例：123654，从后往前找到第一个正向升序的，就是36，然后从后往前找第一个比3大的数，就是4，然后交换，交换之后反转i+1到末尾这段。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 举例：123654，纯找规律，从后往前找到第一个正向升序的，就是36，然后从后往前找第一个比3大的数，就是4，然后交换，交换之后反转i+1到末尾这段。</span></span><br><span class="line">        <span class="comment">// 1.找第一个正向升序的</span></span><br><span class="line">        <span class="comment">// 没有找到就不做第二步交换，比如321，得反转</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">record</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                record = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.从后向前找比record大的数</span></span><br><span class="line">        <span class="keyword">if</span> (record &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bigger</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[bigger] &lt;= nums[record] &amp;&amp; bigger &gt; record) &#123;</span><br><span class="line">                bigger --;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(record, bigger, nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.翻转record+1到末尾的</span></span><br><span class="line">        reverse(record + <span class="number">1</span>, nums.length - <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            swap(i, j, nums);</span><br><span class="line">            i ++;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a>寻找重复数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</span><br><span class="line">假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</span><br><span class="line">你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,3,4,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>不能用map、set，数组中如果没有重复的数，那就是一对一的关系，有重复的就是多个下标对应一个数的关系。和环形链表类似，使用快慢指针。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 衍生为环形链表问题，用快慢指针找到环的入口。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到相遇处</span></span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[nums[fast]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 慢指针从0出发，快指针从原地出发，都+1行走</span></span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E5%A4%A7%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E5%A4%A7%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">那些年背过的面试题之大数据</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-24 22:27:03 / Modified: 22:29:54" itemprop="dateCreated datePublished" datetime="2025-07-24T22:27:03+08:00">2025-07-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>谷歌的“三架马车”：谷歌文件系统GFS（2003），MapReduce（2004）和Big Table（2006），奠定了大数据时代的基础。</li>
<li>离线计算：Hadoop（Mapreduce）、Hive、Spark</li>
<li>2006年实现了由HDFS分布式文件系统和MapReduce计算框架组成的Hadoop，成为了离线数据处理的核心。</li>
<li>HDFS：Hadoop的存储部分，一个分布式文件系统，将数据文件分块存储在集群的节点上。HDFS可以实现在整个集群上高效地存储和访问数据。</li>
<li>MapReduce：大数据处理技术，属于离线计算的一种。将数据处理任务分成两个阶段：Map阶段，数据被切分成小块，并在计算机集群的各个节点上进行并行处理。Reduce阶段，将Map阶段的结果进行合并和汇总，生成最终的输出结果。</li>
<li>2007年Hive：起源于FaceBook，是基于Hadoop的一个数据仓库工具，用来进行数据提取、转化、加载ETL，一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制。能将结构化的数据文件映射为一张数据库表，并提供SQL查询功能，能将SQL语句转变成MapReduce任务来执行。</li>
<li>2010年Spark：Hadoop缺点：MapReduce框架在每个计算阶段都需进行磁盘读写导致较高的磁盘IO开销、对于迭代计算效率低下。Spark是加州大学伯克利分校开源的类Hadoop MapReduce的通用并行框架，与MapReduce不同：中间输出结果可以保存在内存中，从而不再需要读写HDFS，避免大部分磁盘IO开销，提高计算性能。同时Spark能更好的适用于数据挖掘与机器学习等需要迭代的MapReduce的算法。Spark通过使用RDD（弹性分布式数据集）、DAG切分的多阶段计算过程来实现高效的数据并行处理，支持大规模数据集的分布式计算和分析任务，是离线计算（批处理）领域的主流技术栈。</li>
<li>Spark拥有一个丰富的生态系统：Spark SQL（用于SQL查询）、Spark Streaming（用于实时流处理）、MLlib（用于机器学习）、GraphX（用于图计算）等。是一个强大且灵活的分布式计算框架，它通过内存计算和统一的编程模型，为大规模数据处理提供了高效的解决方案，适用于各种数据处理任务和应用场景。</li>
<li>实时计算：Storm、Spark Streaming、Flink</li>
<li>实时计算：在早期，基于Hadoop的数据处理主要采用批处理方式，也就是离线计算的方式：数据会先存储在分布式文件系统中，然后通过批处理作业进行处理和分析，数据处理的延迟较高，需要等待一段时间才能获取结果。</li>
<li>离线&#x3D;批处理，实时&#x3D;流式处理。流式处理技术将数据分成小的批次进行处理，在数据到达时立即进行处理和分析，流式处理技术又分为两种：原生流、微批拟流（Spark Streaming）</li>
<li>Storm是一个免费开源、分布式、高容错的实时计算系统。Storm最早于2011年诞生于Twitter。早期Storm用于实时计算，Hadoop用于离线计算。已不推荐使用。在Storm中，先要设计一个用于实时计算的图状拓扑（Topology），一个Topology是由多个Spout（数据输入处理模块）和Bolt（输出处理模块）通过Stream连接起来的有向无环图。</li>
<li>Spark Streaming：2013年Spark 2.0推出了Spark Streaming。但由于不是原生流处理技术栈，认为流是批的特例，将输入数据切分成一个个小的切片，存在时延，且高级功能不如Flink，已不是主流技术栈，不推荐使用。</li>
<li>Flink最初是由德国柏林工业大学开发。Apache Flink是分布式流式处理引擎，用于无界和有界数据流的有状态计算。Flink创造性地统一了流处理和批处理，作为流处理看待时输入数据流是无界的，而批处理被作为一种特殊的流处理，只是它的输入数据流被定义为有界的。</li>
<li>分布式存储HBase：一个分布式的、面向列的开源数据库，建立在 HDFS 之上。HBase 的计算和存储能力取决于 Hadoop 集群。它介于NoSql和RDBMS之间，仅能通过主键(row key)和主键的range来检索数据，仅支持单行事务。</li>
<li>OLAP 和 OLTP：OLTP（联机事务处理）对数据库的增删改。OLAP（联机分析处理）对数据的查询。</li>
<li>OLAP的分类：ROLAP（关系型联机分析处理）、MOLAP（多维联机分析处理）、HOLAP（混合型OLAP）。ROLAP：传统关系型数据库、MPP分布式数据库以及Hadoop的Spark。实时根据用户提出的需求对数据进行计算后返回给用户。使用灵活，可以随意选择维度组合进行实时计算。有性能问题。MOLAP：将客户的需求计算好以结果的形式存下来，提出需求后，找到对应的结果返回即可。需要的磁盘存储空间大。</li>
<li>MPP（Massive Parallel Processing,海量并行处理）：是一种基于共享磁盘的并行数据库处理架构，通过将数据分布到多个节点上进行并行处理，从而实现对大规模数据的快速分析和查询。只负责计算，不负责存储。</li>
<li>MapReduce和MPP架构：都是分布式并行处理，将任务并行的分散到多个服务器节点上，在每个节点上计算完成后，将各自部分的结果汇总到一起。不同的是，MapReduce任务的tasks会动态的分配在空闲的Executor上，执行慢的Executor会分配到更少的task。缺点是MapReduce将一个任务分解成有依赖关系的tasks（DAG），task是异步执行的，因此必须通过写入中间数据共享内存来解决数据的依赖，性能有所损耗。MPP每个处理数据的task被绑定在持有该数据切片的指定Executor上，单一的Executor只处理单一的task，不需要将中间数据写入磁盘，直接将数据Stream到下一个执行阶段，性能好。缺点是如果某个Executor执行过慢或者故障，整个集群的性能就会受限于这个异常节点，所以MPP架构的集群节点不宜过多。</li>
<li>Lambda架构：一种用于数据处理的架构设计模式，结合了实时计算和批处理两种方法，以满足不同的数据分析需求。L由三个层级组成：批处理层、速度层和服务层。批处理层负责离线处理大量数据，通常通过批处理系统（如Hadoop、Spark等）处理数据，并将结果存储在数据仓库中。速度层用于处理实时数据流，通常采用流式处理技术（如Storm、Spark Streaming等），以快速处理数据并产生实时结果。服务层负责将批处理层和速度层的结果整合，并为用户提供统一的数据查询和分析接口。优点：可扩展性强、能够处理大规模数据、满足实时和离线数据处理需求。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BSpring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BSpring/" class="post-title-link" itemprop="url">那些年背过的面试题之Spring</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-24 22:25:25 / Modified: 22:26:41" itemprop="dateCreated datePublished" datetime="2025-07-24T22:25:25+08:00">2025-07-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><ul>
<li><p>Spring的架构：1⃣️控制反转IOC容器，负责管理对象的生命周期。2⃣️AOP面向切面编程，实现跨应用程序的共有关注点，代码前后做增强。3⃣️简化数据访问，如JDBC，提供一致的数据访问。4⃣️Web层，Spring MVC提供一个分离的模型-视图-控制器实现，用于构建Web应用。</p>
</li>
<li><p>spring bean的加载过程&#x2F;生命周期：1⃣️启动spring应用上下文。2⃣️加载bean定义：读取xml文件、java注解、java配置类，为每个声明的Bean创建一个BeanDefinition对象，包含bean的所有定义信息。 3⃣️实例化bean：调用构造函数、依赖注入、BeanPostProcessor 的前处理。4⃣️初始化bean：调用bean的初始化方法：@PostConstruct注解的方法、指定的init-method、InitializingBean的afterPropertiesSet方法。5⃣️使用bean。6⃣️销毁：容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy方法。</p>
</li>
<li><p>spring IOC：控制反转，通过spring来管理对象的创建、配置、生命周期，把控制权交给spring。提供BeanFactory和ApplicationContext两种IOC容器，实现对bean的管理。实现原理：依赖注入DI、Bean生命周期管理。</p>
</li>
<li><p>spring AOP：面向切面编程，一种编程范式，代码前后做增强操作，提高代码模块性。实现：基于动态代理，实现接口用JDK动态代理，否则CGLIB动态代理。@Aspect注解和@Around切入点实现切面。</p>
</li>
<li><p>JDK和CGLIB动态代理：JDK动态代理针对类实现某个接口，基于反射生成实现同样接口的代理类。CGLIB底层基于asm第三方框架，通过修改字节码生成一个子类。</p>
</li>
<li><p>Spring AOP和AspectJ AOP：Spring AOP 基于动态代理实现，只能在运行时织入，性能比AspectJ编译织入慢。AspectJ只支持编译前后和类加载时织入，性能更好，功能更加强大。</p>
</li>
<li><p>java反射：对于任何一个类，都能知道这个类所有的属性和方法；对于任何一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。getField(属性名字)和getDeclaredField（忽略访问控制）获取属性Field。getMethod获取方法Method。invoke执行。</p>
</li>
<li><p>BeanFactory和ApplicationContext：都是Spring中管理Bean的容器。BeanFactory是Spring IoC容器的基础接口，ApplicationContext实现BeanFactory，提供更丰富功能：国际化、事件发布、注解支持。BeanFactory 采用懒加载（延迟初始化）策略，只有在请求获取 Bean 时才会创建和初始化该 Bean。ApplicationContext采用即时加载策略，容器启动时会预先创建和初始化所有 Singleton Bean。</p>
</li>
<li><p>FactoryBean和BeanFactory：BeanFactory是IOC容器，负责生产和管理Bean对象：读取bean配置、加载bean、依赖注入、bean生命周期管理。FactoryBean是工厂Bean，可以实现该接口来自定义Bean的创建过程。重写getObject方法控制Bean的创建，getBean获取Bean实例。</p>
</li>
<li><p>Spring事务的传播机制：用来定义业务方法之间事务处理方式的机制，根据给定的事务规则来创建和控制事务的边界和范围，保证数据一致性。@Transactional注解的propagation属性指定。例如银行转账操作中有个审计方法，这个方法异常不想影响转账事务的回滚，就用REQUIRES_NEW创建新事务。一共有七种：1.REQUIRED：默认的，存在就加入该事务，没有事务就创建新的。2.REQUIRES_NEW：无论存不存在都创建新的。3.NOT_SUPPORTED：非事务方式执行，存在事务则挂起。4.SUPPORTS：存在则加入事务，不存在则非事务。5.NESTED：如果存在事务，则在嵌套事务（可独立提交，外部事务回滚它也得回滚）内执行。如果没有事务，则按REQUIRED属性执行。6.NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。7.MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p>
</li>
<li><p>@Autowired和@Resource：都是用来实现依赖注入的注解。@Autowired是spring的注解，默认根据类型注入，多个类型相同则进一步根据名称。如果按照类型匹配接口不同实现类需要结合@Qualifier。提供required属性允许找不到bean时是否抛出异常。@Resource是j2ee的注解，默认按byName自动注入，不能用于构造函数。</p>
</li>
<li><p>Spring核心注解：@SpringBootApplication：组合注解，用于启动Spring Boot应用，包含@Configuration、@EnableAutoConfiguration和@ComponentScan。@Component：标注一个类为需要Spring管理的bean。@Configuration：表明该类是用于定义Bean的配置类，配合@Bean来在容器中注册自定义的Bean，方法返回对象被容器管理。@Transactional：用于声明一个方法或类需要事务管理。</p>
</li>
<li><p>Spring依赖注入注解：@Autowired、@Qualifier、@Resource、@Value：注入普通类型的属性。</p>
</li>
<li><p>Spring组件扫描注解：@Service：用于Service层的组件。@Repository：用于DAO层的组件。@Controller：用于标记控制层组件。</p>
</li>
<li><p>spring bean生命周期：1.创建bean的实例，在堆中开辟一块内存空间给这个对象，生成实例对象。2.填充bean的成员属性。3.调用initializeBean方法初始化bean（调用@PostConstruct、实现Aware接口的方法、before…方法、init-method方法、afterPropertiesSet方法）。</p>
</li>
<li><p>spring的三级缓存：用来解决单例bean循环依赖问题，提前拿到未初始化完全的对象。第一级缓存：用来保存实例化、初始化都完成的对象。第二级缓存：用来保存实例化完成但是未初始化完成的对象。第三级缓存：保存创建早期bean的工厂ObjectFactory，getObject()创建一个对该bean的早期引用，这个引用可以被二级缓存使用，确保bean可以按需要的代理和增强创建出来。原理：实例化和初始化流程分开，在Bean完全初始化之前，可以暴露一个早期的bean引用，从而打破循环依赖。</p>
</li>
<li><p>二级缓存行不行：当涉及AOP或其他代理增强时，仅凭二级缓存不够，因为要在返回代理对象前确保执行所有增强的逻辑。所以，如果一个bean需要被代理，它首先应该通过三级缓存的ObjectFactory被创建，该工厂负责处理所有的代理相关逻辑。一旦经过这个步骤得到的bean被放入二级缓存中，它就可以被其他bean使用了。</p>
</li>
<li><p>spring解决循环依赖的具体流程：1.单例bean首先检查一级缓存，存在则直接返回。2.不存在则实例化对象，还未属性注入和初始化。3.创建好bean实例后，将ObjectFactory放入三级缓存。4.属性注入，请求创建依赖的bean，如果有循环依赖，通过三级缓存创建一个早期的bean引用，并放到二级缓存，同时删除三级缓存。5.完成注入及初始化，bean创建成功。6.bean放入一级缓存，并从二级和三级缓存中移除。</p>
</li>
<li><p>spring bean：根据作用域，Singleton：默认的作用域，整个容器中只有一个实例，适用于配置类、工具类、服务类。Prototype：原型bean，每次请求都会创建一个新的实例。spring容器仅负责实例化，不管生命周期。Request：每个HTTP请求都会创建一个Bean，仅适用于web应用。Session：每个HTTP Session都会创建一个Bean，仅适用于web应用。</p>
</li>
<li><p>@PostConstruct：Java EE 5引入的注解，在Bean的实例化和依赖注入完成后被自动调用。用来执行必要的初始化代码，例如资源分配，加载数据。通过容器来控制初始化。修饰无参数无返回值方法，每个类只能有一个该方法。InitializingBean接口的afterPropertiesSet和配置bean时的init-method也有类似功能。@PostConstruct先于他俩。</p>
</li>
<li><p>InitializingBean：接口，定义了afterPropertiesSet方法，这个方法会在bean的所有属性都设置好之后执行，用于在依赖注入后执行某些初始化操作。</p>
</li>
<li><p>ApplicationContextAware：用于方便获取ApplicationContext，spring会自动调用setApplicationContext(ApplicationContext applicationContext)方法，可将ApplicationContext实例注入到bean中，用于获取其他bean、访问资源文件、发布事件。</p>
</li>
<li><p>spring事务的实现原理：两种事务的实现方式：编程式（通过代码控制事务处理逻辑）、声明式（@Transactional注解实现）。事务的操作本由数据库自动控制，为方便业务逻辑操作，由spring框架控制。spring事务的实现原理是通过AOP实现，生成代理对象，代理会在方法执行前后织入事务管理的相关操作：事务开始，先把事务的自动提交给关闭、提交事务、异常回滚。可以设置事务的传播行为、隔离级别、超时设置。总之，Spring AOP 提供了声明式事务管理的基础，使得事务管理逻辑能够以切面的形式，织入到业务逻辑中。</p>
</li>
<li><p>a方法加了@Transactional，b方法没加，b内部调用a，会有事务产生吗：@Transactional声明式事务，事务的传播行为决定事务如何传播和边界所在。由于spring的事务管理是基于AOP，通过代理实现的，分两种情况：第一种，如果方法在同一个类中，自调用，a方法的调用不会通过spring生成的代理对象调用，不会开始新的事务。第二种，在不同的类中，a方法通过spring的代理对象调用，开始一个新事务。</p>
</li>
</ul>
<h2 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h2><ul>
<li>什么是springboot：基于spring的开源框架，用于快速创建独立的生产级别的可运行的Spring应用程序。不是Spring功能上的增强，而是提供一种快速开发Spring项目的方式。spring问题：写配置文件繁琐，依赖繁琐，maven坐标版本问题。springboot提供的优点：自动配置、起步依赖、安全。约定优于配置的理念，开发者不需要手动配置大量spring配置文件，而是自动配置。提供一系列的起步依赖starter，快速构建出一些常用的应用程序，整合Junit、redis、mybatis等很方便。帮助管理jar包版本，避免依赖版本不一致的问题。</li>
<li>Spring、Spring MVC和SpringBoot区别：Spring是Java开发框架，用于创建企业级的java应用程序，提供IOC和AOP等功能。Spring MVC是Spring框架的一个模块，用于创建Web应用程序，使用控制器、视图和模型来实现MVC设计模式。Spring Boot是一个基于Spring框架的快速开发工具，使用自动配置快速创建Spring应用程序。总结：Spring是基础框架，Spring MVC是基于Spring的Web框架，而Spring Boot则是基于Spring的快速开发框架。Spring Boot内嵌了Tomcat、Jetty等Web容器，可以直接运行Web应用程序，而Spring MVC需要部署到Web容器中才能运行。</li>
<li>springboot自动配置的原理：基于Spring的条件化配置功能实现，Condition接口和@Conditional注解。以及springboot的一系列自动配置类，Spring Boot应用的入口类会使用@SpringBootApplication注解，它包含@SpringBootConfiguration，@EnableAutoConfiguration和@ComponentScan注解，@EnableAutoConfiguration是自动配置的核心。@EnableAutoConfiguration利用Spring的@Import注解来加载配置类，META-INF&#x2F;spring.factories配置文件中定义了大量的配置类，springboot应用启动时会自动加载这些配置类。并且在配置类中使用Condition来加载满足条件的bean，如DataSource、JdbcTemplate等。（总结：1.条件注解 2.@EnableAutoConfiguration）</li>
<li>springboot核心注解：@SpringBootApplication：复合注解，标识springboot应用的主类。@Configuration表明该类是java配置类。@ EnableAutoConfiguration开启自动配置功能。@ComponentScan用于自动扫描和注册bean。</li>
<li>spring boot starter：是预配置的依赖管理器，将一组库&#x2F;依赖捆绑在一起，便于开发特定类型的应用程序。简化依赖管理，提供开箱即用的配置，是约定优于配置的应用，集成常用技术和库。spring-boot-starter-web：开发Web应用，包含Spring MVC、Tomcat容器等。spring-boot-starter-data-jpa：使用JPA的Starter，包含Hibernate、Spring Data JPA、Spring ORM等依赖。spring-boot-starter-data-redis：使用Redis的Starter，包含Jedis客户端和Spring Data Redis等依赖。spring-boot-starter-test：适用于测试的Starter，包含JUnit、Mockito、Spring Test等依赖。spring-boot-starter-actuator：监视器，适用于监控和管理Spring Boot应用程序的Starter，包含Spring Boot Actuator等依赖。</li>
<li>spring-boot-starter-parent：springboot官方提供的一个Maven父工程，是springboot项目的父工程，parent元素设置为它，继承一些常用依赖和插件，减少手动配置。统一管理springboot中的常用依赖版本号，确保版本兼容性。</li>
<li>如何自定义spring boot starter：在项目的src&#x2F;main&#x2F;resources目录下创建META-INF&#x2F;spring.factories文件，内容如下：org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;com.example.my_starter.MyAutoConfiguration，告诉springboot启动时自动加载配置类。创建MyAutoConfiguration配置类，并在类上加上@Configuration注解，在其中定义需要自动配置的Bean。然后打包上传Maven仓库。</li>
<li>spring-boot-maven-plugin：用于将SpringBoot应用，以及依赖项和配置文件打包成可执行的Jar包或War包，包含嵌入式的Tomcat容器或Jetty容器。方便部署和运行。</li>
<li>springboot打成的jar包和普通jar包区别：1⃣️springboot的jar包是可执行的jar包，包含了内嵌的Tomcat、Jetty等Web服务器，可直接运行。普通jar包纸包含类、资源等，需要在外部环境中手动配置Web服务器运行。2⃣️springboot打的jar包中包含了启动类的main方法，可直接运行。普通jar包需要指定启动类。3⃣️springboot的jar包中包含一些默认的配置文件，如application.properties，用于配置属性、数据源等。普通jar包不包含。</li>
<li>springboot实现热部署：使用Spring DevTools工具，支持应用程序代码修改后自动重新加载应用程序上下文和服务器。spring loaded也行，避免反复构建和部署。</li>
<li>springboot可以兼容老spring项目吗：可以使用@ImportResource注解来加载老的xml配置文件，用于@Configuration或@SpringBootApplication类上。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="post-title-link" itemprop="url">那些年背过的面试题之中间件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-24 22:23:55 / Modified: 22:28:31" itemprop="dateCreated datePublished" datetime="2025-07-24T22:23:55+08:00">2025-07-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><ul>
<li><p>微服务是什么：架构风格，大型服务-多个小服务，轻量级通信机制协作。模块儿化，独立部署扩展维护、可靠、技术异构。</p>
</li>
<li><p>微服务组件：服务、通信机制、服务发现与注册、负载均衡、API网关</p>
</li>
<li><p>微服务间如何通信：http、消息队列、rpc</p>
</li>
</ul>
<h2 id="rpc、HSF"><a href="#rpc、HSF" class="headerlink" title="rpc、HSF"></a>rpc、HSF</h2><ul>
<li><p>rpc：远程过程调用，就像调用本地函数一样调用远程服务，通信协议、序列化协议，http、自定义报文tcp，文本xml json 二进制protobuf hessian。</p>
</li>
<li><p>自定义报文？http消息头复杂，短链接</p>
</li>
<li><p>HSF：高速服务框架，分布式rpc服务框架。统一服务的发布&#x2F;订阅&#x2F;调用方式，解决服务间的高效调用。</p>
</li>
<li><p>HSF架构：服务提供者、服务消费者、地址注册中心configServer（注册服务、订阅服务、向消费者推送服务提供者地址）、持久化配置中心diamond（configServer的类型和地址、订阅路由规则等）、元数据存储中心redis（服务上报元数据：方法列表参数结构）、控制台（服务查询治理测试运维）</p>
</li>
<li><p>HSF服务发布源码：核心是HSFSpringProviderBean，通过@Import注解引入配置类，配置类实现ImportBeanDefinationRegistrar来创建复杂的bean并注册到spring容器中。HSFSpringProviderBean的afterPropertiesSet()方法中进行服务初始化（初始化调用链，两条链，一是protocolFilterChain: Protocol，它专注于流程编排，在publish()流程顺序执行；一是invocationHandler链，用于后续处理hsf请求调用）、服务发布（使用线程池，Future阻塞等待服务发布成功。使用调用链进行，上报元数据到Redis，启动并监听tcp&#x2F;http端口、分配服务线程池、服务注册。使用Protocol进行流程编排，初始化时编排流程顺序。注册信息：ip&#x2F;port&#x2F;序列化方式&#x2F;路由规则&#x2F;应用名称&#x2F;超时时间。HSFProtocol中开启netty服务，设置tcp相关协议）。</p>
</li>
<li><p>HSF消费源码：1.服务初始化，初始化调用链，初始化HSF代理对象jdk。2.服务调用，同样使用调用链，在IO传输层使用netty长连接，使用hessian序列化，在服务提供方使用反射调用（运行时动态获取类的信息）。</p>
</li>
<li><p>HSF相比SpringCloud优势：1.HSF使用高性能的异步事件驱动的NIO框架Netty。2.序列化协议hession相比json。3.HSF只需将二方包暴露给用户 4.HSF使用代理机制，将协议封装、选址、远程调用封装，用户只需Spring配置。</p>
</li>
<li><p>HSF源码心得：从服务端初始化、服务注册、客户端初始化、调用服务，使用Netty、Hession、ProtocolFilter、InvocationHandler链式调用过程进行流程编排、灵活配置的注册中心、事件监听机制、通过随机数的方式实现随机负载均衡。高内聚低耦合的设计方法。</p>
</li>
<li><p>一次完整的HSF调用：服务寻址、网络连接、序列化传输、反射调用</p>
</li>
<li><p>一个rpc框架最重要的是什么部分：通信机制（传输协议自定义tcp报文还是http、负载均衡、容错机制）、序列化反序列化协议（网络只能传输字节流，需要将对象转换为字节流），还需要服务发现与注册机制、服务治理机制。</p>
</li>
<li><p>shell脚本查询对应错误出现次数：grep “2024-01-01*error” error.log ｜ wc -l</p>
</li>
</ul>
<h2 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h2><ul>
<li><p>dubbo：高性能RPC框架，阿里开源，netty网络框架，异步IO，线程池</p>
</li>
<li><p>dubbo框架：服务提供者启动时向注册中心注册服务，服务消费者启动时订阅服务，注册中心Registry向消费者推送服务提供者地址列表，如果发生变化通过长链接推送变更，消费者用负载均衡选择地址，监控中心Monitor，消费者和提供者定时发送统计数据（调用次数调用时间）</p>
</li>
<li><p>dubbo负载均衡：随机、轮询、最少活跃调用、一致性哈希、权重</p>
</li>
<li><p>dubbo中的Filter：责任链模式的实现，根据配置生成Filter链，实现对Dobbo代码的拦截和扩展，类似于AOP，优雅的代码增强手段，逻辑分层，代码解耦。应用：日志、鉴权、限流、负载均衡。</p>
</li>
<li><p>dubbo中的spi扩展：服务扩展机制，可以在运行时动态加载实现类。提供丰富的SPI扩展点，类似java SPI，可以自定义扩展实现，配置方式替换框架中的组件。使用了url总线设计，url参数识别用哪个接口实现。使用@SPI注解指定扩展点名。面向接口编程。</p>
</li>
<li><p>dubbo的SPI实现：1.ExtensionLoader单例工厂类，负责加载和管理扩展点实现类。2.不仅通过接口名获取，还有一个key。3.Adaptive自适应扩展，可以在运行时通过传入参数动态选择合适的扩展实现。</p>
</li>
<li><p>dubbo的SPI应用：Protocol协议、Cluster集群容错策略、LoadBalance负载均衡策略。都是根据配置动态切换。</p>
</li>
<li><p>dubbo中的url总线设计：为了各层解耦，交换参数不用Model，用url参数，方便扩展。底层netty。</p>
</li>
<li><p>dubbo启动过程：注册中心（加载配置、启动定时、NettyServer启动netty）提供者（DubboProtocol提供远程服务，RemoteRegistry建立与注册中心连接）消费者（RemoteRegistry，RegistryDirectory订阅服务，创建代理，实际调用InvokerInvocationHandler）</p>
</li>
<li><p>dubbo服务治理：负载均衡（请求均匀分配）、集群容错（调用失败时切换机器重试）、服务降级（负载过高时屏蔽部分服务保障核心）、路由策略（选择最优服务提供者）、监控管理（监控报警）</p>
</li>
<li><p>dubbo中的设计模式：ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();是工厂模式，Adaptive运行时动态决定调用哪个实现，代理模式。使用调用链Filter责任链模式。ClassLoaderFilter在主功能上添加功能装饰器模式。注册中心向消费者发送notify消息表示服务更新，观察者模式。</p>
</li>
<li><p>dubbo总结：Dubbo考虑了框架可扩展性，url总线设计，层次划分。一个调用链路中存在很多Filter拦截，相对HSF性能差，但是可以将自己逻辑整合到调用链中。</p>
</li>
<li><p>dubbo限流：服务治理的一种，确保服务提供者不会因为过高请求负载而崩溃。基于令牌桶算法，以恒定速率向桶中添加令牌，每个请求需要从桶中消耗令牌，Guava中RateLimiter实现令牌桶。基于信号量Semaphore，控制同时执行服务的线程数。</p>
</li>
<li><p>dubbo序列化有哪些：Hessian2序列化，紧凑且效率高，二进制序列化协议，跨语言，dubbo中默认的。java内置序列化。Fastjson序列化，将对象序列化为json字符串，适合web通信场景。Protobuf序列化，使用.proto文件定义数据结构，生成二进制格式存储数据，跨语言。</p>
</li>
<li><p>dubbo比spring cloud优势：1.轻量级和高性能：基于RPC和Netty框架。强调性能。2.灵活的服务治理：路由规则、负载均衡、故障转移、集群支持。3.独立的注册中心：zookeeper等可选，提供分离的服务发现设计。4.支持跨语言的服务调用，gRpc、Hessian集成。5.简单易用，二方包的形式</p>
</li>
<li><p>Spring Cloud：基于Spring Boot，一整套微服务解决方案，提供一系列用于构建微服务应用的工具和框架。相对更重。基于REST原则，基于HTTP&#x2F;REST的服务通信。</p>
</li>
</ul>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ul>
<li>分布式：多台计算机位于不同地理位置，分布式存储处理数据和应用程序。组件之间通过网络连接。</li>
<li>分布式优点：可扩展性、容错性、地理分散降低延时。</li>
<li>分布式难点：数据一致性、系统管理（部署、管理、容灾、处理节点故障）、跨节点事务</li>
<li>分布式事务：事务的操作分布在不同节点，跨库事务，需要确保事务ACID（原子性、一致性、隔离性、持久性）</li>
<li>分布式事务方法：两阶段提交2PC（准备阶段询问所有参与者是否可提交，根据答复指示所有参与者提交&#x2F;回滚，所有ok才提交）、三阶段提交3PC（增加预提交，参与者将事务操作记录写入日志，即使协调者失去响应，参与者也有足够的信息来完成或回滚事务。减少因协调者故障导致的阻塞，提高容错）、分布式事务框架（XA事务协议）、事务补偿、BASE理论（宽松，基本可用，软状态，最终一致性）</li>
<li>分布式锁：分布式系统中同步访问共享资源的机制，避免多节点同时修改同一数据的冲突。1⃣️基于数据库锁，select for update对特定行上行级锁。2⃣️基于redis，SETNX命令，expire过期时间。3⃣️基于zookeeper，分布式协调服务，创建一个独特的节点表示获锁。保障原子性和唯一性。</li>
</ul>
<h2 id="metaq"><a href="#metaq" class="headerlink" title="metaq"></a>metaq</h2><ul>
<li>metaq：分布式的，基于队列模型的消息队列中间件，基于发布订阅模式，有push&#x2F;pull两种消费模式。支持严格的消息顺序，亿级别堆积能力，支持消息回溯。延时消息。</li>
<li>消息队列三大场景：异步、解耦、削峰。</li>
<li>metaq架构：NameServer（路由注册中心，实例彼此独立，用于服务发现和Topic的注册中心，每个节点维护topic和broker的映射关系）、Broker（实际消息存储的服务器，分master和slave，每个Broker与所有的NameServer建立长连接，定时注册Topic信息到NameServer。主节点读写，从节点提供冗余和故障转移。）、Producer（消息生产者，与NameServer其中一个建立长连接，读取Topic路由信息。与提供Topic服务的Master Broker建立长连接，并定时向其发送心跳）、Consumer（消息消费者，与NameServer其中一个建立长连接，读取Topic路由信息。从Master Broker&#x2F;Slave Broker订阅消息，与Broker建立心跳。可pull可push，可集群可广播）。</li>
<li>metaq的存储模型：1⃣️CommitLog是物理存储文件，存储所有Topic的消息元数据，是全局的顺序写入的日志文件。2⃣️ConsumerQueue逻辑队列是每个Message Queue的索引文件及存储上的体现，记录CommitLog中的消息地址（偏移量、大小、消息tag的hashcode），每个条目20字节，提供快速访问。类似B+树，CommitLog是叶子结点存储实际数据，ConsumerQueue是中间节点负责索引数据。3⃣️Message Queue是逻辑上的消息队列，是Topic的分区，分散在不同Broker。用于并行发送和接收消息。4⃣️IndexFile用于快速检索消息，维护消息键（消息ID、Key）到物理位置的映射。</li>
<li>metaq如何保证消息高可用：1⃣️Producer：支持同步异步发送方式，同步消息发送确认、消息重试。使用负载均衡选择Broker进行消息投递。快速失败：调度线程定时检查第一个节点排队时间，超过就立即返回失败，以尽快重试。故障规避机制避开上次失败的Broker。2⃣️Consumer：消息拉取确认、消费失败重试队列、消费进度存储（定期存储消费进度offset，重启或故障后从进度继续消费）、业务层实现幂等消费（重复消费也不影响）。3⃣️Broker：持久化存储机制（存储到CommitLog，顺序写入磁盘）、主从部署（主从同步、主从切换，Master和Slave故障转移）、死信队列（无法成功消费的消息进入死信队列）、使用内存映射文件MappedFile（将磁盘文件映射到内存中，以操作内存方式操作磁盘，减少CPU拷贝）</li>
<li>同步刷盘和异步刷盘：将内存中数据持久化到磁盘中，同步刷盘是将消息成功写入commitLog中之后再返回给生产者成功，更可靠。异步刷盘是写到内存后直接返回，然后通过另一个后台线程来刷盘，吞吐量更高。</li>
<li>Broker主从同步：从节点定时向主节点发送同步请求，主节点根据从节点CommitLog最大偏移量返回消息。</li>
<li>NameServer作用：Broker的动态注册与发现（心跳检测是否存活）、路由信息管理（保存整个Broker集群的路由信息，topic和Broker的映射关系）。每个NameServer有一份完整数据。</li>
<li>Raft协议和Paxos：分布式系统中用于解决一致性问题的共识算法。例如Zookeeper中的Leader选举。</li>
<li>RocketMq集群模式：1⃣️单master模式：不能故障转移和高可用。2⃣️多master模式：不能故障转移。3⃣️多maste多slave异步模式：异步复制，实时性高，Master宕机磁盘损坏情况下会丢失少量消息。4⃣️多master多slave同步模式：同步双写，写成功才返回给应用，无单点故障。</li>
<li>RocketMq顺序消息如何保证：CommitLog的写入是顺序的，消息队列FIFO，对于单个Message Queue而言，是按存储顺序顺序消费的。多个Message Queue是不保证全局顺序的。需要确保消息只分配给一个Message Queue。</li>
<li>RocketMq负载均衡：Producer负载均衡，轮询方式发送到Message Queue。Consumer负载均衡，集群模式下queue均匀分配给实例，每个queue只分给一个Consumer实例。广播模式下所有consumer分到所有queue。</li>
<li>死信队列：消息重复消费失败，达到最大重试次数，进入死信队列。一个死信队列对应一个GroupId，不分Topic。</li>
<li>消息幂等：消费者接收到消息后，根据业务唯一Key（如Message key）做幂等，即使重复消费也没事。</li>
<li>推拉消息模式：Pull：拉取型，消费者主动定期轮询Broker，请求新消息。Push：消费者注册消息监听器来接收Broker的消息推送，被动消费。但实现上，都是消费端主动拉取的方式，RocketMq的服务端不会主动推送，push模式下还是消费端拉取消息，拉取后调用回调接口，模拟推送。</li>
<li>任何一台Broker宕机怎么办：Broker采用主从架构，多副本策略。Broker宕机后主从切换，高可用。4.5开始支持Dlegder模式，基于raft分布式一致算法。</li>
<li>消息被消费后会立即删除吗：不会，消费后只是消息队列的消费进度（offset）更新，消息的删除是通过定期清理过期文件来实现的。</li>
<li>延时消息实现：是在投递到Topic这一阶段延时的。1⃣️消息投递：提供若干个延时等级。有一个专门的延时Topic，存入对应延时等级的队列中。2⃣️消息调度：Broker启动时，创建ScheduledThreadPoolExecutor线程池，每个延迟队列一个线程扫描，定期检查延时队列中的消息是否到期。3⃣️转移消息：取出消息重新进行CommitLog写入，写入对应Consumer Queue。然后正常消费。</li>
<li>metaq总结：高性能（吞吐量高并发量高，队列模型、并行消费、基于Netty）、高可靠性（消息丢失可能小，重试机制、故障规避机制、重试、死信队列）、高实时性（低延迟，快速失败、异步刷盘、零拷贝）</li>
</ul>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul>
<li>消息队列：消息队列是一个用于接收消息、存储消息并且转发消息的中间件，异步、削峰、解耦。</li>
<li>metaq中的nameserver：类似kafka中zookeeper的角色，不直接采用ZooKeeper是因为ZooKeeper有自动选举Master的功能，MetaQ的架构设计上决定了它不需要进行Master选举，而只需要使用一个轻量级的元数据服务器就可以了。</li>
<li>kafka：一个多分区、多副本且基于 ZooKeeper协调的分布式消息系统。定位为一个分布式流式处理平台，高吞吐、可持久化、可水平扩展、支持流数据处理。</li>
<li>kafka的架构：zookeeper保存broker集群元数据，对控制器进行选举操作。Producer生产消息并发送到Broker。Consumer从Broker订阅并消费消息。Broker接收生产者的消息，存储消息，为消息设置偏移量。Topic消息的主题。一个Topic细分为多个分区，在存储上看作一个可追加的Log文件。offset是消息在分区中的唯一标识，保证消息在分区的顺序性，不跨分区，也就是kafka只保证分区有序性。Replication副本，保证高可用，同一Partion在多个Broker上存多个副本，主提供读写，主失效的话，zookeeper选举controller，controller选择主。</li>
<li>kafka高可用：多分区，一个Topic主题分区数据跨越多个broker分布式存储，每个分区有多个副本，主出现故障，可以故障转移。</li>
<li>kafka一定不会丢失消息吗：只有一个副本情况下会丢失，生产者确认策略是异步的还是同步的，异步的可能在消息到达服务器之前丢失。短暂网络故障、磁盘损坏。</li>
<li>netty的优点：1⃣️Reactor模型处理并发网络事件：主Reactor线程负责接收新的客户端连接，将连接分配给从Reactor，负责监控和处理IO事件。2⃣️内存管理：池化的内存分配方式，减少内存分配和回收成本。字节缓冲区ByteBuf提供内存读写，较JDK自带的ByteBuffer具有更高的性能，引用计数。3⃣️连接管理：基于事件循环(EventLoop)的模型来管理网络连接。每个EventLoop都维护了它自己的选择器(Selector)和任务队列，能够处理成百上千的连接而不会创建与之对等的线程，降低资源消耗。链式的处理器ChannelHandler来处理网络事件。</li>
<li>tcp和udp：tcp面向连接，udp无连接。tcp提供可靠传输，流量控制，拥塞控制，udp尽力而为，不保证数据包顺序、完整性、正确性，不会自动重传。tcp点到点的，面向字节流，传输慢，首部开销大20-60字节，适合文件传输、网页。udp一对一多对一多对多一对多，面向报文，传输效率快，不可靠，首部开销小8字节，适合视频通话。</li>
</ul>
<h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><ul>
<li>Netty是什么：提供异步的基于事件驱动的网络应用程序框架。用来快速开发高性能、高可靠性的网络IO程序，最流行的NIO框架。Elasticsearch、Dubbo、gRpc、Zookeeper、Rocketmq都用Netty。NIO、Seletor选择器、事件驱动、回调异步。</li>
<li>Netty的事件驱动：事件如连接打开、数据到达、连接关闭均以异步方式处理。提供EventLoop处理IO事件，其中ChannelHandlers响应事件。发起IO后，立即返回ChannelFuture对象，开发者在上面增加监听器ChannelFutureListener，在IO完成时收到通知。回调机制和Future的异步编程模型。</li>
<li>Reactor模型：事件驱动架构的一种实现方式。一个单线程监听就绪IO事件，并将IO事件分发给回调函数。Acceptor处理新连接，Reactor分派事件分派给Handler，Handler事件处理。NIO就是。</li>
<li>Netty优点：高并发基于NIO、传输快零拷贝、封装好、内存池设计使用直接内存、高性能序列化协议Protobuf</li>
<li>Netty应用场景：RPC框架的网络通信工具、实现HTTP服务器、实现即时通讯系统、消息推送系统</li>
<li>Netty相比原生NIO优势：易用性（封装API）、稳定性（修复了select空转导致CPU100%问题）、高性能（对象池复用和零拷贝技术）、Netty异步基于事件驱动</li>
<li>Netty和Tomcat区别：Tomcat是用作Servlet容器的Web服务器，Netty是异步事件驱动的网络应用框架。通信协议上，Tomcat基于http，Netty不仅支持http，可以通过编程自定义各种协议。Tomcat需要遵循Servlet规范请求与响应模型，Netty不需要。</li>
<li>Netty体系结构：1⃣️Channel：Socket的连接依据，创建、注册到EventLoop、连接到远程节点。2⃣️EventLoop：Executor在Netty的线程模型抽象，由EventLoopGroup分配管理。一个EventLoop可以被分配给多个Channel，一个Channel的IO操作由一个线程执行。作用是负载监听网络事件并调用事件处理器进行IO操作。3⃣️EventLoopGroup：线程池，通常两个，一个用于接受新连接，另一个用于处理已接受连接的数据传输IO操作。4⃣️ChannelHandler：处理具体的业务逻辑，用户自定义事件处理逻辑，如连接打开关闭、数据读取写入。5⃣️ChannelPipeline：ChannelHandler实例链，编排Handler事件处理器链式执行。6⃣️Bootstrap：启动类，用于配置整个Netty程序，进程绑定到端口、设置线程模型、事件处理流。分为服务端ServerBootstrap和客户端Bootstrap</li>
<li>Netty运行总结：Netty的服务端通过Channel处理每次的连接请求，Channel都会注册到EventLoop线程模型中等待排队或立即执行。EventLoop由EventLoopGroup管理和分配。Channel有四种生命状态，ChannaelHandler处理具体的业务逻辑，ChannelPipeline编排所有的Handler顺序执行。Bootstrap用于将这些逻辑成为一个可运行的程序，提供一个运行入口。</li>
<li>网关：客户端和服务之间的中介，简化网络结构，对外提供统一的访问接口。功能：路由转发、负载均衡、鉴权、限流、监控。Netty可实现网关，实现WebSocketHandler，两个EventLoopGroup，通过ServerBootstrap引导，异步调用的Channel方式，执行ChannelPipeline中的ChannelHandler。</li>
<li>Netty线程模型：使用事件循环EventLoop处理IO操作，每个EventLoop绑定到一个线程，服务多个Channel，负责调度和执行ChannelPipeline中的ChannelHandler。EventLoopGroup一个接收新连接的boss和负责已连接的worker。实现Reactor模式，每个EventLoop包含一个Selector选择器来监听注册在其上的channel事件。</li>
<li>Netty服务端启动过程：1.创建主从EventLoopGroup实例 2.初始化服务端启动引导ServerBootstrap实例，配置启动参数  3.设置ChannelPipeline，添加自定义ChannelHandler来处理事件和数据交互 4.ServerBootstrap的bind方法绑定服务器监听的端口，启动服务器来接收客户端连接 5.sync方法阻塞等待直到服务器绑定操作完成，随后进入服务模式</li>
<li>Netty的无锁化体现在哪：串行无锁化设计，在IO线程内部进行多个Handler串行操作，期间不进行线程切换，避免多线程导致的锁竞争。</li>
<li>Netty如何解决epoll空轮询的：使用NIO的epoll选择器时遇到无效的文件描述符而无限循环。Netty维护一个计数器监控epoll_wait返回次数，如果没有任何IO事件情况下连续多次返回，认为空轮询，Netty会重建Selector，将原来的Channel重新注册到新的Selector上。</li>
<li>拆包和粘包：TCP面向流，没有界限的一串数据，会根据TCP缓冲区的实际情况进行包的划分。通过上层应用协议设计来解决：1.消息长度固定 2.特殊分隔符作为结束标志 3.消息头定义消息长度</li>
<li>Netty解决拆包和粘包：依靠提供的一系列解码器（Decoder），能够根据应用层协议将接收到的字节流重新组合成有意义的数据单元（消息或帧）。</li>
<li>Netty零拷贝：使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。Netty的Zero-copy完全是在用户态（Java应用层）的，偏向于优化数据操作。OS层面的Zero-copy通常是避免在用户态和内核态之间的拷贝数据。</li>
<li>TCP长连接和短连接：TCP的长连接和短连接由应用层面决定。短连接是建立连接读写完成后关闭连接，每次建立连接消耗资源。长连接是读写后不关闭连接，后续继续使用。</li>
<li>Netty长连接和心跳机制：TCP长连接中可能出现断网异常，因此引入心跳机制，在client和server之间没有数据交互时给对方发送特殊数据包，对方收到后回应一个（PING-PONG交互），表示仍然在线。</li>
<li>Netty对象池技术：对象池缓存创建好的对象，避免需要时才创建。Netty中buffer是对数据的抽象，数据拷贝时用到，代表可读写的内存区域，通过ByteBuf类实现，Netty会对其进行池化，减少内存分配和垃圾回收开销。</li>
<li>Netty序列化协议：不强制使用特定的序列化协议。它提供了灵活的编解码器机制，允许开发者根据需要使用不同的序列化协议：json&#x2F;pb。</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li>设计模式：23种，为复杂解耦，将一大坨代码拆分成职责单一的模块，满足高内聚低耦合、开闭原则（不改变现有代码的基础上扩展功能）。创建型：创建和使用解耦。结构型：不同的功能代码解耦。行为型：不同的行为代码解耦。</li>
<li>面向对象的四大特征：封装（封装成对象，隐藏实现细节，private public控制访问权限）、抽象（忽略不同，抽象相同点，继承抽象类is a和实现接口has a）、继承（继承父类的属性和方法，允许重用和扩展）、多态（重载是静态，重写Override是动态）</li>
<li>创建型模式：封装复杂的创建过程，解耦对象创建和使用。单例模式：创建全局唯一对象。工厂模式：创建不同但相关类型的对象（同一父类&#x2F;接口），给定参数决定对象类型。建造者模式：创建复杂对象，设置不同可选参数定制化对象Builder。原型模式：创建成本大，复制已有对象进行创建。</li>
<li>单例模式：一个类创建全局唯一实例，提供全局访问点。spring容器一级缓存即单例池，ApplicationContext.getBean获取bean。唯一访问性能高，不适合有状态的。</li>
<li>单例模式实现：1⃣️饿汉式：类加载时就创建，线程安全，但无法延迟加载。2⃣️懒汉式：第一次使用时才创建，延迟加载，但多线程下需要加锁保证线程安全避免创建多实例。3⃣️静态内部类：在外部类加载时不会被加载，只有第一次使用才加载并创建实例，JVM保证线程安全。4⃣️枚举类：天生单例。5⃣️双重检查锁定：既延迟加载又线程安全，同步外检查一次，同步块内检查一次，volatile+synchronized。</li>
<li>线程唯一单例怎么实现：ConcurrentHashMap、或ThreadLocal线程局部变量。</li>
<li>工厂模式：提供工厂类来代替new操作。Executors方法时静态工厂模式。1⃣️简单工厂模式：工厂类方法根据传入参数不同决定生成不同对象。2⃣️工厂方法模式：工厂接口，不同产品创建实现类，开闭原则。3⃣️抽象工厂模式：接口代表一个产品族。不同方法创建不同产品。</li>
<li>建造者模式：创建复杂对象，@Builder传入参数定制化。</li>
<li>原型模式：创建对象成本大，直接复制已有对象方式创建。浅拷贝：只对基本数据类型复制，引用数据类型进行引用传递。深拷贝：引用数据类型创建新对象并复制内容。实现：实现Cloneable接口，重写Object的clone方法。或序列化实现。</li>
<li>代理模式：结构型模式，给某对象提供代理，由代理对象控制对真实对象的访问，直接调用变间接调用，不改变原代码前提下增加功能：鉴权、统计、监控、限流。1⃣️静态代理：在运行前就创建代理类，实现相同接口&#x2F;继承实现类。2⃣️动态代理：运行期间通过反射动态创建代理类，运行前不存在代理类字节码文件。不需要为每个代理类创建代理对象。</li>
<li>适配器模式：允许不兼容的接口之间交互，创建一个中间层，将一个接口转换为适配的接口。类适配器：继承实现。对象适配器：组合实现。例如Spring MVC中提供不同的HandlerAdapter适配不同的处理器，供DispatchServlet处理HTTP请求。Spring AOP中提供不同的适配器AdvisorAdapter来封装不同类型的通知。</li>
<li>观察者模式：行为型模式，基于发布订阅，对象发生变化时进行通知。同步阻塞：阻塞消息发布者。异步非阻塞：使用消息队列，非阻塞地通知观察者。</li>
<li>模版模式：通过定义一个算法的骨架，并将一些步骤的实现延迟到子类。算法结构不变，子类重新定义算法。例如JdbcTemplate。</li>
<li>策略模式：行为型模式，定义一个算法接口，不同算法实现该接口，上下文类表示使用策略的类，维护一个指向策略接口的引用。可以轻松增加、替换算法。</li>
<li>责任链模式：多个不同的处理类对象Handler组成一条链，请求在链上传递，链上每个对象处理，返回&#x2F;传递给下一个对象。</li>
<li>Spring中的设计模式：1⃣️单例模式：Spring容器单例池，bean都是单例的。2⃣️工厂模式：BeanFactory和ApplicationContext创建Bean。3⃣️代理模式：Aop功能使用JDK动态代理和Cglib动态代理。4⃣️模版模式：JdbcTemplate提供一套模板方法来处理数据库的连接、执行 SQL 语句、处理结果集。5⃣️观察者模式：Spring事件驱动模型，ApplicationEvent事件、发布者、监听器。6⃣️适配器模式：Spring MVC中适配不同的处理器Controller。AOP中适配不同的通知Advice。</li>
<li>工作中用到的设计模式：1⃣️单例模式：数据库连接池、XStream用来进行xml序列化反序列化，反复创建回造成ygc，使用单例模式。2⃣️工厂模式：根据不同业务类型返回对应的业务处理类。实现InitializingBean接口，重写afterPropertiesSet方法，用Map维护不同业务类的引用。3⃣️观察者模式：报警系统，定义事件类继承ApplicationEvent，业务类中使用applicationContext.publishEvent(ApplicationEvent)来发送事件，定义监听器EventListener，监听消息发送报警。4⃣️责任链模式：轨迹处理流程：解析、切分、抽稀、匹配、入库，定义责任链HandlerChain，按照流程处理。</li>
</ul>
<h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><ul>
<li>zookeeper：分布式协调服务，用来管理hadoop生态圈的。为分布式应用提供一致性服务的软件，功能：配置管理、服务发现、领导者选举、集群管理。</li>
<li>zookeeper为什么使用集群：1.高可用性，单节点失败仍可运行。2.数据一致性，ZAB协议实现所有节点数据一致性。3.负载均衡，分散负载。4.可伸缩性。</li>
<li>zooleeper架构：1.Client连接到一台Server，向server获取信息，周期性发送心跳给server，server回复ack，没回复则重定向一台server。2.Server包括一台Leader和多台Follower。3.ensemble表示一组服务器，至少3台。4.Leader，服务启动时进行Leader选举，负责处理写操作，在集群中同步数据。5.Follower跟随者，处理读操作，数据冗余，转发写请求，参与投票。</li>
<li>zookeeper中数据结构：和Unix文件系统类似，看作一棵树，节点称为Znode，存储1MB数据，通过其路径唯一标识。不能存大数据。create命令创建数据，get命令获取目录的值，用多版本并发控制来解决并发，set修改。</li>
<li>zookeeper三种目录节点znode类型：1.持久目录：创建之后一直存在，直到显式删除，存储长期有效的配置信息和系统状态信息。2.临时目录：在client活动期间有效，断开自动删除，不能有子目录。常用于锁和服务发现机制，例如标记某个资源正在被使用，或一个实例的注册信息。3.顺序目录：在指定路径后增加一个单调递增的计数器作为后缀，生成唯一的标识符，用于分布式锁中的实现队列顺序。</li>
<li>zookeeper分布式锁：顺序临时节点+watch监听器。创建一个锁节点&#x2F;locks，请求获锁，需要在该目录下创建一个顺序临时节点，然后判断自己是不是最小节点，是则获取到锁，不是则创建一个监听器监听比自己小一的上一个节点，上一个节点删除（手动删或断开连接自动删除）则该节点获取到锁。</li>
<li>zookeeper的观察者模式：zookeeper&#x3D;文件系统+通知机制。zookeeper允许客户端设置对znode的监视（watch），典型的发布-订阅模式，节点发生变化时，客户端会被通知。特点：一次性（监视被触发后会被移除），可以对分布式环境中的状态变化快速做出反应。</li>
<li>zookeeper的leader选举：最小号选举法：每个节点投票给自己，节点之间互相发送自己的投票，节点收到投票后评估选择最小id的节点成为领导者。当一个节点收到超过半数节点支持同一id的投票时，节点认为领导者已选好。考虑节点id和最大的事务id（zxid），确保领导者是数据最新的节点。</li>
<li>zookeeper的ZAB协议：原子广播协议，保证数据一致性。负责服务之间的数据复制（顺序一致性的）和领导者选举过程中的状态同步。1⃣️消息广播：类似两阶段提交，Leader接收写请求，请求封装成事务，事务zxid保证顺序，发送给所有Follower，超过半数成功响应则执行commit。未响应的随后同步。2⃣️崩溃恢复：选举数据最新的节点作为Leader，与集群中其他节点同步状态。</li>
<li>zookeeper集群搭建：准备至少三台服务器，安装zookeeper，zoo.cfg配置文件中设置数据目录，设置连接端口，配置服务器列表。启动zookeeper服务。</li>
<li>zookeeper如何保证hadoop高可用的：1⃣️故障切换和Leader选举：Zookeeper故障转移控制器ZKFC监控和处理NameNode的故障切换，协助备用NameNode成为主节点保障HDFS高可用。ResourceManager也是。2⃣️集群元信息同步：zookeeper提供一致性的分布式数据管理，Hadoop的组件可以利用zookeeper维护和同步系统信息如配置信息、集群状态。3⃣️服务发现：zooKeeper 可以作为一个服务注册表，帮助客户端发现当前可用的服务地址。</li>
<li>zookeeper的应用：Kafka中zookeeper用于集群管理和协调，包括 Broker 的注册、领导者选举、集群配置管理等。还是Kafka 集群元数据的存储中心。HBase中zookeeper用于领导者选举、存储集群元数据。</li>
</ul>
<h2 id="hadoop"><a href="#hadoop" class="headerlink" title="hadoop"></a>hadoop</h2><ul>
<li>hadoop：分布式计算框架，用于在分布式服务器集群上存储和处理大数据集的框架，包括底层存储框架HDFS、分布式计算框架MapReduce、资源调度系统YARN。可以分布式运行PB级别数据。Zookeeper提供协调服务，例如HBase中集群协调领导者选举。</li>
<li>HDFS：分布式文件系统，将文件数据存储在多台机器组成的集群上，每份数据具有多个备份，更可靠。</li>
<li>HDFS架构：主从结构，一个主节点namenode，多个从节点datanode。1⃣️namenode负责接收用户请求，维护文件目录结构、管理文件和block(文件被分为块)的关系以及block和datanode的关系。2⃣️datanode负责存储文件，文件被分成block存储（128M&#x2F;256M），在不同datanode上有多个副本。文件索引与实际数据分离。对硬件要求不高，可存储超大文件，目标是高数据吞吐量。</li>
<li>mapreduce：分布式运算程序的编程框架，用于大数据集的并行运算，海量计算任务分而治之。计算任务分摊到各个计算节点并行计算，汇总得到最终结果。分布式的，抽象了并行处理的复杂度，开发者只需要实现Mapper和Reducer。</li>
<li>mapreduce核心步骤：map拆解（处理输入的键值对，执行定义的Map函数，生成中间键值对）、reduce组合（汇总每个键的值，生成最终结果）。具体可分为：Split、Map、Combiner、Shuffle、Reduce。</li>
<li>split：将输入文件切割为若干块，每一块由不同节点处理。将文章分为不同句。</li>
<li>map：将每个节点的原始数据处理为中间数据，输入输出都是kv。</li>
<li>shuffle：洗牌，因为split是随机的，导致相同key数据处理在不同节点。shuffle将map后的结果重新分组，相同key给到同一reduce节点。</li>
<li>combiner：减少shuffle需要的网络IO操作，对Map后的结果提前做一次归约，相同key组成一条。</li>
<li>mapreduce的架构：计算向数据靠拢，使用主从架构，一个JobTracker接收客户端提交的计算任务，把计算任务分给TaskTracker执行，进行调度、监控。多个TaskTracker执行分配的计算任务。</li>
<li>JobTracker：跟踪任务的执行进度、资源使用量等信息，将这些信息告诉任务调度器TaskScheduler。</li>
<li>TaskTracker：使用slot划分节点资源（CPU、内存），将slot分配给MapTask和ReduceTask。2.0用YARN来进行资源调度。</li>
<li>YARN：负责资源管理、任务调度的框架。基于主从模式的分布式架构。一个ResourceManager，多个NodeManager其中包含ApplicationMaster和Container。1⃣️ResourceManager是中控模块，负责整个集群资源的管理和分配。2⃣️NodeManager是每个节点上的资源和任务管理器，启动管理container。3⃣️ApplicationMaster每个应用的调度和协调，向RM申请资源，告诉container做什么。4⃣️Container资源容器，程序执行环境，封装任务所需的资源：cpu、内存。</li>
<li>自己使用mapreduce：在odps处理大规模数据时，map任务组织数据键值对，定义key和value，key位分组依据adcode，value为数据。reduce中数据已经按照adcode进行了分组，在分组中做数据处理计算。</li>
<li>MaxCompute：odps，大规模数据计算服务，负责存储和处理大量数据。</li>
<li>DataWorks：数据开发与管理平台，负责流程设计、调度、管理，提交到 MaxCompute中执行计算任务。</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul>
<li>10G文件1G内存怎么排序：外部排序，分隔为小的文件块，对每个小文件放入内存进行排序，排序结果写回磁盘。对多个排序结果进行归并排序，使用优先队列（最小堆），归并过程中，每次从堆中取出的最小元素被挨个写入最终的输出文件中。</li>
<li>直接选择排序：第一次从arr[0到]arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]到arr[n-1]中选取最小值，与arr[1]交换。总共n-1次。</li>
<li>插入排序：逐渐构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</li>
<li>堆排序：通过构建二叉堆，不断移除堆顶元素并重建堆，最终得到一个有序序列。</li>
<li>归并排序：归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表</li>
<li>希尔排序：希尔排序又叫缩小增量排序，把所有的数据按照下标间隔进行分组，在每个组内进行插入排序。排完之后缩小分组数，再插入排序。不断缩小组的间距。直到只分一为组。</li>
<li>排序复杂度：快排时间Onlogn空间Ologn不稳定。冒泡时间On空间O1稳定。</li>
</ul>
<h2 id="计算机原理"><a href="#计算机原理" class="headerlink" title="计算机原理"></a>计算机原理</h2><ul>
<li><p>网络分层：物理层（比特流的透明传输，中继器、集线器）、数据链路层（传送帧MAC、网卡、网桥、交换机）、网络层（选择合适的路由，IP、ICMP、路由器、防火墙）、传输层（TCP、UDP）、应用层（DNS、HTTP、SMTP、FTP）</p>
</li>
<li><p>TCP的安全性：三次握手（客户端SYN，服务端ACKSYN，客户端ACK）、四次挥手（客户端FIN、服务端ACK、服务端传输完FIN、客户端ACK）</p>
</li>
<li><p>tcp流量控制：避免发送方发送得太快接收方来不及处理，滑动窗口的方式，接收端告诉客户端确认序列号和还能接受多少数据。发送端调整滑动窗口（已发送未确认、为发送可接受）。更新窗口信息可能丢失，设置0窗口探测报文。</p>
</li>
<li><p>tcp拥塞控制：防止过多数据注入网络。慢开始（加倍达到慢开始门限）。拥塞避免（拥塞窗口+1），如果拥塞，门限减半，窗口变1，执行慢开始。快重传：接收方收到失序报文发出重复ACK，发送方收到三个重复确认，就重传。快恢复：失序报文后，慢开始门限减半，拥塞窗口设为减半后的门限，执行拥塞避免。</p>
</li>
<li><p>tcp不提供加密功能，需要应用层的TSL&#x2F;SSL。两台服务器间可以建立多个tcp连接（socket&#x3D;ip+端口号不同即可）</p>
</li>
<li><p>输入url发生什么：1.DNS解析获取ip，浏览器缓存-路由器缓存-DNS缓存。2.根据ip建立TCP连接。3.浏览器向服务器发送http请求。4.服务器响应http请求。5.浏览器进行渲染。</p>
</li>
<li><p>tcp&#x2F;ip理解：IP协议是网络层的协议，使用分组交换技术来传输数据，通过路由器进行转发，最终到达目的地。无连接性、无状态性、不保证可靠传输。TCP是传输层协议，主要负责在IP协议提供的基础上实现可靠的、有序的、有连接的和无差错的数据传输。</p>
</li>
<li><p>cookie、session、token：1⃣️cookie用来保存一些信息在客户端比如记住密码和推荐显示。2⃣️session用来标识一次会话，记录用户状态，在一次会话期间共享数据。用户首次访问服务器时创建一个session，session id设置为cookie保存在浏览器。3⃣️token用来做密钥快捷登录的。</p>
</li>
<li><p>cookie、session、token：生成位置都在服务器，cookie和token保存在客户端，session保存在服务器。鉴权过程：请求携带cookie与服务器记录cookie对比确认用户状态。session用请求中session id提取，恢复用户状态。请求携带token与服务器通过请求信息生成token对比。</p>
</li>
<li><p>http状态码：301永久重定向。302临时重定向。400服务端无法理解客户端请求。401未授权，需要用户身份认证。403禁止访问，服务端拒绝。404未找到请求的资源。500服务端内部错误。</p>
</li>
<li><p>DNS基于什么协议：DNS域名解析系统，应用层，用于将人类可读的主机名转换为机器可读的IP地址。主要基于UDP进行工作，但当响应数据大小超过报文限制，或者需要更可靠传输时，用TCP。</p>
</li>
<li><p>DNS过程：解析域名时，首先检查本地DNS缓存，如果未找到，请求将发送至配置的递归DNS服务器，递归DNS服务器会进行一系列迭代查询，从根服务器开始，逐级向下询问直到找到该域名的权威DNS服务器，获取对应IP地址。沿着查询链路返回给用户的设备。</p>
</li>
</ul>
<h2 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h2><ul>
<li>边缘计算：一种分布式计算框架，在靠近数据生成的位置（边缘）处理数据的方法。将计算能力下放到网络的边缘，边缘网络基本上由终端设备、边缘设备、边缘服务器等构成。特点：低延迟、节省带宽、提高隐私和安全性、实时数据处理。应用场景：物联网（IoT）、智慧城市、无人超市。</li>
<li>边缘计算和云计算：边缘计算采用分布式计算架构，将运算分散在靠近数据源的近端设备处理，分担云平台的工作量，不需要把数据回传云端处理，实时性更好、效率更高、延迟最短，没有网络也不妨碍。</li>
<li>k8s：Kubernetes是一个开源的容器编排系统，用于自动化部署、扩展和管理容器化应用程序。由google设计。</li>
<li>docker：容器化技术允许将应用程序及其依赖项打包到一个轻量级、可移植的容器中，使得应用程序能够在任何环境中一致地运行。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sweetwater"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">Sweetwater</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sweetwater</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
