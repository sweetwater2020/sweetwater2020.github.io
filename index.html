<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Sweetwater&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Sweetwater&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Sweetwater">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Sweetwater's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sweetwater's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/27/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%81%9A%E8%BF%87%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B9%8BLetcode100/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/27/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%81%9A%E8%BF%87%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%E4%B9%8BLetcode100/" class="post-title-link" itemprop="url">那些年做过的编程题之Letcode100</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-27 17:07:02 / Modified: 19:16:00" itemprop="dateCreated datePublished" datetime="2025-07-27T17:07:02+08:00">2025-07-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目 通用：数组初始化后填充某个数：Arrays.fill(arr, 0);    数组排序：Arrays.sort(names, Collections.reverseOrder());  数组装箱：Integer[] boxedNums = Arrays.stream(nums).boxed().toArray(Integer[]::new);  反转数组：需要先变为List，List list = Arrays.asList(arr);   Collections.reverse(list);    arr = list.toArray(new Integer[0]); (变为Integer[]) 或者 resList.stream().mapToInt(Integer::intValue).toArray();  (变为int[]) 小顶堆：PriorityQueue minHeap = new PriorityQueue&lt;&gt;();   PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; minHeap =          new PriorityQueue&lt;&gt;(Comparator.comparingInt(Map.Entry::getValue)); 大顶堆：PriorityQueue maxHeap = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());    heap.offer插入 poll删除元素 堆顶元素peek。 s.substring(startIndex, endIndex) 左闭右开 int sum = Arrays.stream(nums).sum(); 求和 回文链表：先把元素遍历出来到数组list，然后前后双指针进行对比。还可以使用递归，使用递归反向迭代节点，同时使用递归函数外的变量向前迭代。 环形链表：方法一：使用HashSet记录走过的节点，如果之前走过，则环形链表。方法二：快慢指针，有换一定会遇到，遇到后，一个指针从起始节点出发，一个指针从相遇节点出发，相同速度移动，撞见就是环形相交节点。 合并两个有序链表：双指针，while条件里可以是两个其中之一不为null，也可以是两个都不为null，然后next直接指向剩余的那个ListNode。注意ListNode a = new Listnode(1);  然后ListNode b = a; a/b再变，另一个是不跟着变得，因为不是ab指向的对象发生了变化，而是b指向了别的东西。 两数相加：while循环中求当前数和进位数，最后判断进位是否为0，也就是是否要加一个数。 删除链表的倒数第N个结点：双指针，得模拟一下，快指针移动几步（n步），然后慢指针停止的条件是什么（fast!=null）。考虑只有一个结点的情况，得用preHead。 两两交换链表中的节点（不能改节点的值）：跟链表翻转类似，遍历过程中模拟翻转的过程，需要定义哪些临时节点进行记录。注意要用preHead。链表翻转就不用preHead。 k个一组翻转链表：是翻转链表的复杂版本，不光要翻转，翻转之后连接分段，所以要在遍历过程中记录头节点和尾节点。首先判断分段是否够，顺便遍历到tail节点。子函数进行分段翻转，传入preHead和k，遍历用k，提前定义pre和cur，循环中1保存next，2箭头翻转，3移动pre和cur。然后连线，再移动。 排序链表：二分，归并排序（递归）先用快慢指针找到链表中点，分割进行递归，终止条件是只有一个节点。递归排序后进行merge，双指针法进行合并，得用preHead。 合并k个升序链表：优先级队列PriorityQueue，因为数组里的列表都是排好序的，所以先把数组中每个列表的头节点加进去，然后取队列里最小的，然后把取到的节点的next加入优先级队列，直到优先级队列为空了 LinkedHashMap：LinkedHashMap继承自HashMap，在 HashMap 的基础上增加了对元素顺序的维护能力，既可以按照插入顺序排序，也可以按照访问顺序排序。底层实现：HashMap（实现O(1) 时间复杂度的插入、删除和查找操作）+ 双向链表（用于记录键值对的顺序，链表的头节点表示最早插入或最久未访问的元素，尾节点表示最近插入或最近访问的元素。当哈希表需要扩容时，LinkedHashMap 会重新分配桶中的节点，但不会影响双向链表的顺序。扩容时机：当哈希表中的元素数量超过 容量 × 负载因子（默认0.75） 时，触发扩容操作。扩容为原数组容量的两倍。LinkedHashMap默认不移除元素，重写removeEldestEntry方法进行移除来实现LRU。 为什么LRU得是双向链表：涉及到找到节点，然后把节点移动到链表尾部，双向链表实现该操作只需要O1时间复杂度，单向链表无法获取上一个节点，是On复杂度。 实现LRU缓存：存放的是key-value对，自定义双向链表，节点内维护key和value，HashMap是用来快速找到节点的，所以key就是key，value是Node节点。需要自定义双向链表类，get方法中，首先判断在不在map中，如果在则移动节点到尾部。put方法中，首先判断容量是否达到上限，如果达到则移除头部节点（伴随改变size和map），然后添加节点到尾节点（伴随改变size和map）。注意前后都要哨兵节点，并且相连。 层序遍历：用队列来实现。每次访问一层，并把下一层加入到队列中。 栈： Stack 类由于继承自 Vector 导致的性能问题，不推荐使用。Deque（双端队列）接口提供了更灵活和高效的栈实现方法。ArrayDeque 和 LinkedList 是最常用的 Deque 实现类。 Deque stack = new ArrayDeque&lt;&gt;(); stack.pop()、 stack.peek()、 stack.push(num) 队列：使用Queue 队列：Queue queue = new ArrayDeque&lt;&gt;(); queue.offer(num)、queue.poll()、queue.peek() Queue 是一个接口，表示队列（FIFO，先进先出）的数据结构。 单向队列，offer()、poll() 和 peek() Deque 是一个接口，表示双端队列的数据结构。 addFirst()、addLast()、pollFirst()、pollLast()、用作栈，通过 push() 、 pop() 、peek() Deque 继承了 Queue 接口。 ArrayDeque 和 LinkedList 都实现了 Deque 接口，因此它们都可以用作双端队列或普通队列。 ArrayDeque：基于动态数组实现。不支持存储 null 元素。不是线程安全的。 LinkedList：基于双向链表实现。支持存储 null 元素。不是线程安全的。 前/中/后序遍历：方法一：递归法，递归的时候隐式地维护了一个栈。方法二：迭代法，显式地将这个栈模拟出来。前序遍历先把root节点压进去，然后遍历中pop加到res里，再右左节点压进去。后序遍历，先把root节点压进去，然后左右节点，这样是前右左顺序，再Collections.reverse(result)一下。中序遍历先一直压左边的，压到头了，再加到res，再压右节点，注意while里的条件是栈不空或root不为null，pop后，压pop节点的右节点。 广度优先搜索：一种逐层遍历的方式，从根节点开始，先访问当前层的所有节点，然后再访问下一层的所有节点。使用队列Queue来实现。 深度优先搜索：一种沿着树的深度方向尽可能深入访问节点的方式，直到到达叶子节点后再回溯。使用递归或者栈。 二叉树的最大深度：深度优先搜索，递归，终止条件是null节点返回0，不然看左右谁大。也可以用广度优先搜索，类似层序遍历，看有多少层。 翻转二叉树：深度优先搜索，递归，终止条件是null，返回null，然后左右节点递归，然后左右节点互换。 对称二叉树：递归，输入两个节点，一左一右，比较。 二叉树的直径：树中任意两个节点之间最长路径的长度。其实跟左子树深度和右子树深度(节点数)有关。但是需要注意，最大直径不一定需要经过根节点！!因此在递归中需要记录结果。递归返回节点数，边就在节点数基础上 - 1。 将有序数组转换为二叉搜索树：高度平衡的二叉树，不能选择中点之后直接做一支右一支，用递归，左边右边分别再递归。其实就是根据中序遍历恢复二叉树，只不过指定中点。 验证二叉树：使用递归，但是不能单纯地只判断左子树和右子树，递归输入中还得传最大值和最小值，不能只比父节点，父节点的父节点也得比，就传一个max一个min。 二叉搜索树中第k小的元素：中序遍历是顺序数列，先中序遍历再找数。拓展：如果一个数要频繁地找第k小，怎么优化，每个节点记录以该节点为根的节点数，然后再找。 二叉树的右视图：类似层序遍历，但是只记录每层的最后一个数。用队列。 二叉树展开为链表：先序遍历的方式，右指针是next。可以先先序遍历，然后再展开为列表。方法二是同时进行，但是要用迭代方式的前序遍历，用栈把右子树节点记录下来。 从前序与中序遍历序列构造二叉树：递归，前提条件是遍历中没有重复元素。前序遍历第一个节点是根节点，再从中序遍历中拆出左子树的中序遍历和右子树的中序遍历。 在中序遍历中找节点，用一个hash来快速找，通过数来找索引 路径总和：用递归解决，但是要注意从根节点到叶子结点，叶子结点得是left和right都为null的 路径总和2：需要找出从根节点到叶子结点的符合要求的所有路径。注意1:添加结果时需要添加结果的拷贝，因为是引用传递。注意2:需要回溯，就是在返回上一层前list去掉该节点。 路径总和3：不限制从根节点到叶子结点，但是需要从上到下，也就是从父节点到叶子结点。 解法1:暴力法，每个节点都走一遍递归。dfs函数，计算的是以root为开始，不管谁为结束的符合要求的数量，会存在整数溢出的问题，把dfs函数的targetSum参数类型变为long就行了。解法2: 用前缀和，就是用一个Map记录之前路径上从根节点到某节点的和对应的数量，这样只需要用从根节点到当前节点的和来解决问题了。dfs递归过程中记录根节点到目前的总和。dfs表示以当前节点为尾节点。依然要用Long解决溢出问题。 二叉树的最近公共祖先：用递归，递归函数的输出的是最近公共祖先，退出条件是如果当前节点是 p 或 q 或 空，则直接返回当前节点。在左右子树中分别递归查找 p 和 q：如果左子树返回非空结果且右子树返回非空结果，则当前节点就是最近公共祖先。如果只有左子树返回非空结果，则返回左子树的结果。如果只有右子树返回非空结果，则返回右子树的结果。脑子里模拟一下这个过程，一个函数就解决。 二叉树中的最大路径和：用递归，不限制父节点到子节点，所以，当前节点路径=当前节点+左路径+右路径，对比全局最大。注意，递归函数是包含root节点的单边的。 岛屿数量：递归dfs，递归使相邻的置为0。也可以使用并查集，并查集的核心思想是通过树形结构维护集合关系，并通过路径压缩优化查找效率。第一步初始化父节点和深度节点列表，然后合并，合并过程中寻找root节点是否相同，不相同则需要合并，find的过程中递归。深度小的往深度大的合并，提高查找根结点的效率。将rank较小的根节点指向rank较大的根节点，以保持树的平衡。如果两个根节点的rank相同，则可以将其中一个根节点作为另一个根节点的子节点，并将rank增加1。 腐烂的橘子：广度优先搜索，用到队列，将最开始腐烂的橘子加入到队列中，然后一层层往外遍历。注意，while判断里，除了queue不为空，还需要新鲜橘子数量大于0. 课程表：判断图中有没有环。用邻接表来表示图，维护节点状态：未访问、正在访问、已访问，用深度优先搜索，遍历所有节点，递归遍历后序节点（反个方向是不是也行？）。其实就是判断图中有没有环。首先，构建邻接表，放的是节点的后置节点。其次，创建初始状态，0未访问，1访问中，2已访问。然后进行DFS。 List转换为Integer[]：list.toArray(new Integer[list.size()]) List转换为int[]：res.stream().mapToInt(Integer :: intValue).toArray() 课程表输出顺序：注意，应该在递归回溯的时候再往结果里放入，如果遍历的是后序节点，还应该Collections.reverse(list)。 全排列：给的元素无重复，同一个元素不能重复使用。用递归DFS，但是需要记录哪些元素已经使用过了。在回溯的时候需要移除List和移除记录使用元素的Set。拷贝一个list：new ArrayList&lt;&gt;(list)。 子集：给的元素无重复，返回所有子集，不能包含重复的子集。不是看排列了，而是看子集了。使用递归DFS，但是不用记录使用set了，需要记录开始递归位置start。 电话号码的字母组合：递归DFS，带start，初始化map，new HashMap&lt;&gt;()&#123;&#123;put(1,&quot;a&quot;); put...)&#125;&#125;，注意得是两个大括号。遍历字符串中的字符：for(char c : s.toCharArray())。s.substring(start, end)。 组合总和：给的是无重复的数组，返回和为target的组合方案，一个数可以使用多次。用DFS，先给数组排个序，DFS中如果大于target就False，后面就不遍历了。为了避免重复，应该用start来限制开始遍历的数字。注意：1.写入结果传副本。2.先排序，大了就不用往后走了。3.回溯后移除节点。4.传start避免结果重复。 括号生成：给出一个n，返回可能的括号组合。DFS中两种情况：放左括号和放右括号。 单词搜索：深度优先搜索，不能光遍历四周，遍历过的还不能再遍历了，不然一直在dfs。用set维护路径。最开始的想法：从头开始DFS，用Set记录走过的路径防止重复遍历。但是比较字符串需要比较结尾。改进方法：DFS，dfs起点：每个点；dfs需要携带的：匹配上的字符长度；dfs出口：字符不一样/字符长度达到。已经用过的字母不能再用：向下一个递归之前变为其他字符，递归完之后再变回来 分割回文串：给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。 解法：DFS+回溯，要传start记录切割位置，for横向遍历，dfs纵向遍历。把一个字符串分割成若干个回文串，DFS，目标是挨个遍历，遍历到回文串存一个，然后继续向后遍历，出递归的条件是遍历到了末尾。要用start记录遍历到了哪里，注意单个字符也算回文。 N皇后：输入n，求得所有可能的排布。使用回溯，用什么表示：用一个数组，数组表示index行的皇后放在value列。什么时候记录：所有行都完备了添加。需要有检查排布是否可以的方法。用StringBuilder，s.setCharAt(track[i], &#x27;Q&#x27;); 二分查找：mid = l + (r - l) /2; 要注意while里的条件是l&lt;=r。l要更新为mid-1。r要更新为r+1。 搜索二维矩阵：先用一遍二分找在哪个行，注意所在行是最后的l-1。再用二分找在哪个列。 在排序数组中查找元素的第一个和最后一个位置：先二分查找找到目标，再前后移动找位置. 寻找旋转排序数组中的最小值：直接遍历虽然能解，但是复杂度要求达不到，要用二分。画张图举个例子好理解，中间节点和两边节点判断可过滤不可能的，注意和传统二分区别：while里条件l&lt;r。 寻找两个正序数组的中位数：限制时间负责度logm+n，所以双指针前后遍历是不行的，得二分。思路：扩展到获取第k大的数，分别获取两个数组k/2的位置，小的左边就能淘汰。第一步：出递归条件：如果一个数组已经被淘汰没了，则直接从另一个获取。第二步：递归：获取每个数组的第k/2位置数做比较，可能越界，所以得判断。注意得是index=s1+k/2-1，然后淘汰index及之前的。先要看k是不是等于1，等于1则可以直接判断。 有效的括号：构件一个map和左括号list，用栈，为空或者为左括号则加入，为右括号则pop出来看是否匹配，最后返回栈是否为空。Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;()&#123;&#123;put(&#x27;)&#x27;, &#x27;(&#x27;);   List left = Arrays.asList(&#x27;(&#x27;, &#x27;&#123;&#x27;, &#x27;[&#x27;);  Deque stack = new ArrayDeque&lt;&gt;();   遍历string：char c : s.toCharArray() 字符串解码：重复次数可能是多位的，开始使用一个栈记录重复次数和字符串，有点乱。使用两个栈分别记录。使用两个栈：一个存重复次数，一个存之前的解码结果。注意3[a2[c]这种，左括号的时候进行压栈，右括号的时候pop栈，这时候需要重复的是currentStr，栈里pop出的是需要在前面的，重复完之后要更新currentStr。判断一个char为数字的两种办法：Character.isDigit()、c - &#x27;0&#x27;&lt;=9。 每日温度：一个数组表示温度，返回数组表示对于i天，下一个更高温度出现在几天后，如果不会升高则0。使用栈，纠结于如何记录结果，其实栈中存放的元素不是温度，而是索引。栈里的元素应该是从大到小的，遍历过程中，元素大于栈顶就pop。注意，栈里放的是索引，不是实际温度。 柱状图中最大的矩形：一个数组表示柱状图的高度，返回能勾勒出矩形的最大面积。思考暴力情况下如何解决：对每一个柱子，向左向右扩展，直到遇到比它矮的，那么以当前柱子高度为高的矩形的宽度就确认出来，这样再全局比较。所以，关键点在于找左边第一个比它小的位置和右边第一个比它小的位置。用单调栈，栈中依然保存索引。每当遇到一个比栈顶元素小的高度时，说明找到了栈顶元素的右边界；弹出栈顶元素，此时它的左边是前一个栈顶元素（即左边界）。注意，获取左边界时stack为空，则left=-1可以。还需要管最后一个元素的结果，所以for循环边界是heights.length，搞个最后的0作为哨兵节点。 数组中的第k个最大元素：使用最小堆，优先级队列。如果堆大小为k，则需要对比堆顶元素和当前元素哪个更大。其实不用，先插入，大于k则弹出堆顶元素即可。 前k个高频元素：先用Map记录频率，然后用小顶堆记录k个Map.Entry，表示键值对项，其他和k个最大元素一样。 买卖股票的最佳时机：贪心，遍历过程中记录历史最低点，同时记录最大收益。 跳跃游戏：判断是否能到达最后一个下标。遍历过程中记录最远能跳到哪里，如果当前索引小于maxReach则直接返回false。 跳跃游戏2：返回最少跳跃数。最少跳跃数，两种方法：一种用动态规划记录最少跳跃数，然后双层遍历外层遍历数组，内层遍历该位置跳跃范围。另一种是贪心，双层循环，外层while从后往前遍历能跳到的位置，内层从前往后找最少跳跃位置。前提是一定能跳到，不然会死循环，所以pos &gt; 0。 划分字母区间：同一个字母最多出现在一个片段中，返回表示每个字符串片段长度的列表。用一个map记录每个字符最后出现的位置，然后遍历字符串进行切分，记录start和end，遍历过程中更新end，如果i==end则表示可以切分。 爬楼梯：每次爬1或2阶，总共有多少种爬台阶的方法。动态规划，dp[n+1]，初始化0和1，然后遍历。 杨辉三角：动态规划，List创建时初始化：List list = Arrays.asList(&quot;apple&quot;)。List获取get(index). 打家劫舍：不能偷窃相邻的房屋，动态规划，dp[i]表示偷到i的最大收益，初始化前两个。 完全平方数：返回和为n的完全平方数的最少数量，可重复使用的。动态规划，一个一维数组初始化比较大的值。双层遍历，外层遍历1-n/2的平方数，内层遍历dp数组。如果大于平方数，则更新。 零钱兑换：给定一个可用零钱面值数组和总金额，返回需要的最少硬币数量，都是可重复使用的，思路和完全平方数一样。注意初始化用Integer.MAX_VALUE-1。 单词拆分：给一个字符串，一个字符串列表，判断能否用列表中的字符串拼接出该字符串，可重复使用。是背包问题。完全平方数是先遍历平方数，再遍历数。这里需要先遍历字符串再遍历物品列表。因为这里对物品顺序是有要求的。dp[i]表示以字符串i-1索引结尾的结果。// 检查以i-1结尾的字符往前倒的字符串，和wordDict[j]是不是一样。 最长递增子序列：子序列是顺序不能变，可以删掉部分元素组成。动态规划dp[i]表示以i结尾的最长递增子序列，双层遍历。 乘积最大子数组：得是连续的最大子数组。用动态规划，两维数组记录i-j的连续乘积，要双层遍历，感觉不是最优。正解：关键点：因为负数的存在，最大和最小可能一下反转。记录阶段最大值和阶段最小值（也就是以上一个数为尾部的最大值最小值）。因为负数存在，当遍历到负数时，最大数和最小数要做交换。遍历过程中记录最大的阶段最大值。 分割等和子集：给一个数组，能否分成两个和相等的子集，不要求连续。是一个背包问题，维护dp[i][j]，i表示考虑0-i的物品，j表示容量为j，dp值表示背包最大能放的重量。初始化i=0的时候，j为多少能放下改物品。不需要提前排序的。遍历时候双层循环，外层物品，内层重量。内层也得从1开始遍历。两种选择：一种不放这个，一种放这个。 最长有效括号：只包含()的字符串，找出最长有效的连续字串长度。用栈保存左括号的索引，初始化时，栈先压入 -1，表示“有效括号子串起点前的位置”。遇到右括号则弹出栈顶，如果弹出后栈空了，说明遇到不能配对的右括号，把当前位置下标入栈（新起点）。否则，当前有效括号长度为i - 栈顶下标，更新最大长度。这里记录不是遇到不有效再记录，而是每次遇到有效时记录。 不同路径：多维动态规划，简单。 最小路径和：依然多维路径规划，初始化左边和上边，直接在原数组上操作。 最长回文子串：多维数组表示i-j的子串是否是回文子串，推演关系决定遍历顺序，ij依赖i+1,j-1，所以从左下角开始遍历。如果ij字符相等，相差&lt;=1，或者dp[i+1][j-1]为true，则为回文，记录结果 最长公共子序列：两位数组表示text1的i-1结尾和text2的j-1结尾的最长公共子序列长度。注意字符不等于的时候，Math.max(dp[i - 1][j], dp[i][j - 1]). 编辑距离：插入、删除、替换。思路：二维动态数组，长度len1+1*len2+1，表示i-1结尾和j-1结尾的。为什么数组长度要+1，因为0的位置需要遍历，初始化不好初始化，只能用-1的初始化，初始化为对应的ij。状态转移：字符相等则等于dp[i-1][j-1]，不想等则删除：dp[i-1][j], dp[i][j-1]，修改：dp[i-1][j-1]，其中取最小然后+1。 只出现一次的数字：遍历，用map可以，但是最好的是用异或运算，^，相同异或为0，与0异或为自己。 多数元素：使用投票机制，记录一个结果数和一个数量，如果数量等于0则换数，否则看当前数是否等于结果数，决定投票+1/-1。 颜色分类：三色国旗问题，双指针，都从0开始遍历，一个指针用来换1，一个指针用来换0，但是换0需要注意，可能把1换出去了，所以换完0之后如果p0&lt;p1就得交换i和p1。 下一个排列：举个例子123654，124653，先要从后往前找到第一个升序的，然后从后往前找到第一个比升序对第一个数大的，然后交换，变成了124653，然后反转i+1到末尾这段。 </span><br></pre></td></tr></table></figure>



<h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</span><br><span class="line"></span><br><span class="line">例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</span><br><span class="line">整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</span><br><span class="line"></span><br><span class="line">例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。</span><br><span class="line">类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。</span><br><span class="line">而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</span><br><span class="line">给你一个整数数组 nums ，找出 nums 的下一个排列。</span><br><span class="line"></span><br><span class="line">必须 原地 修改，只允许使用额外常数空间。</span><br></pre></td></tr></table></figure>

<p><strong>纯找规律，举例：123654，从后往前找到第一个正向升序的，就是36，然后从后往前找第一个比3大的数，就是4，然后交换，交换之后反转i+1到末尾这段。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 举例：123654，纯找规律，从后往前找到第一个正向升序的，就是36，然后从后往前找第一个比3大的数，就是4，然后交换，交换之后反转i+1到末尾这段。</span></span><br><span class="line">        <span class="comment">// 1.找第一个正向升序的</span></span><br><span class="line">        <span class="comment">// 没有找到就不做第二步交换，比如321，得反转</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">record</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                record = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.从后向前找比record大的数</span></span><br><span class="line">        <span class="keyword">if</span> (record &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bigger</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[bigger] &lt;= nums[record] &amp;&amp; bigger &gt; record) &#123;</span><br><span class="line">                bigger --;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(record, bigger, nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.翻转record+1到末尾的</span></span><br><span class="line">        reverse(record + <span class="number">1</span>, nums.length - <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            swap(i, j, nums);</span><br><span class="line">            i ++;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a>寻找重复数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</span><br><span class="line">假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</span><br><span class="line">你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,3,4,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>不能用map、set，数组中如果没有重复的数，那就是一对一的关系，有重复的就是多个下标对应一个数的关系。和环形链表类似，使用快慢指针。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 衍生为环形链表问题，用快慢指针找到环的入口。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到相遇处</span></span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[nums[fast]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 慢指针从0出发，快指针从原地出发，都+1行走</span></span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E5%A4%A7%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E5%A4%A7%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">那些年背过的面试题之大数据</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-24 22:27:03 / Modified: 22:29:54" itemprop="dateCreated datePublished" datetime="2025-07-24T22:27:03+08:00">2025-07-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>谷歌的“三架马车”：谷歌文件系统GFS（2003），MapReduce（2004）和Big Table（2006），奠定了大数据时代的基础。</li>
<li>离线计算：Hadoop（Mapreduce）、Hive、Spark</li>
<li>2006年实现了由HDFS分布式文件系统和MapReduce计算框架组成的Hadoop，成为了离线数据处理的核心。</li>
<li>HDFS：Hadoop的存储部分，一个分布式文件系统，将数据文件分块存储在集群的节点上。HDFS可以实现在整个集群上高效地存储和访问数据。</li>
<li>MapReduce：大数据处理技术，属于离线计算的一种。将数据处理任务分成两个阶段：Map阶段，数据被切分成小块，并在计算机集群的各个节点上进行并行处理。Reduce阶段，将Map阶段的结果进行合并和汇总，生成最终的输出结果。</li>
<li>2007年Hive：起源于FaceBook，是基于Hadoop的一个数据仓库工具，用来进行数据提取、转化、加载ETL，一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制。能将结构化的数据文件映射为一张数据库表，并提供SQL查询功能，能将SQL语句转变成MapReduce任务来执行。</li>
<li>2010年Spark：Hadoop缺点：MapReduce框架在每个计算阶段都需进行磁盘读写导致较高的磁盘IO开销、对于迭代计算效率低下。Spark是加州大学伯克利分校开源的类Hadoop MapReduce的通用并行框架，与MapReduce不同：中间输出结果可以保存在内存中，从而不再需要读写HDFS，避免大部分磁盘IO开销，提高计算性能。同时Spark能更好的适用于数据挖掘与机器学习等需要迭代的MapReduce的算法。Spark通过使用RDD（弹性分布式数据集）、DAG切分的多阶段计算过程来实现高效的数据并行处理，支持大规模数据集的分布式计算和分析任务，是离线计算（批处理）领域的主流技术栈。</li>
<li>Spark拥有一个丰富的生态系统：Spark SQL（用于SQL查询）、Spark Streaming（用于实时流处理）、MLlib（用于机器学习）、GraphX（用于图计算）等。是一个强大且灵活的分布式计算框架，它通过内存计算和统一的编程模型，为大规模数据处理提供了高效的解决方案，适用于各种数据处理任务和应用场景。</li>
<li>实时计算：Storm、Spark Streaming、Flink</li>
<li>实时计算：在早期，基于Hadoop的数据处理主要采用批处理方式，也就是离线计算的方式：数据会先存储在分布式文件系统中，然后通过批处理作业进行处理和分析，数据处理的延迟较高，需要等待一段时间才能获取结果。</li>
<li>离线&#x3D;批处理，实时&#x3D;流式处理。流式处理技术将数据分成小的批次进行处理，在数据到达时立即进行处理和分析，流式处理技术又分为两种：原生流、微批拟流（Spark Streaming）</li>
<li>Storm是一个免费开源、分布式、高容错的实时计算系统。Storm最早于2011年诞生于Twitter。早期Storm用于实时计算，Hadoop用于离线计算。已不推荐使用。在Storm中，先要设计一个用于实时计算的图状拓扑（Topology），一个Topology是由多个Spout（数据输入处理模块）和Bolt（输出处理模块）通过Stream连接起来的有向无环图。</li>
<li>Spark Streaming：2013年Spark 2.0推出了Spark Streaming。但由于不是原生流处理技术栈，认为流是批的特例，将输入数据切分成一个个小的切片，存在时延，且高级功能不如Flink，已不是主流技术栈，不推荐使用。</li>
<li>Flink最初是由德国柏林工业大学开发。Apache Flink是分布式流式处理引擎，用于无界和有界数据流的有状态计算。Flink创造性地统一了流处理和批处理，作为流处理看待时输入数据流是无界的，而批处理被作为一种特殊的流处理，只是它的输入数据流被定义为有界的。</li>
<li>分布式存储HBase：一个分布式的、面向列的开源数据库，建立在 HDFS 之上。HBase 的计算和存储能力取决于 Hadoop 集群。它介于NoSql和RDBMS之间，仅能通过主键(row key)和主键的range来检索数据，仅支持单行事务。</li>
<li>OLAP 和 OLTP：OLTP（联机事务处理）对数据库的增删改。OLAP（联机分析处理）对数据的查询。</li>
<li>OLAP的分类：ROLAP（关系型联机分析处理）、MOLAP（多维联机分析处理）、HOLAP（混合型OLAP）。ROLAP：传统关系型数据库、MPP分布式数据库以及Hadoop的Spark。实时根据用户提出的需求对数据进行计算后返回给用户。使用灵活，可以随意选择维度组合进行实时计算。有性能问题。MOLAP：将客户的需求计算好以结果的形式存下来，提出需求后，找到对应的结果返回即可。需要的磁盘存储空间大。</li>
<li>MPP（Massive Parallel Processing,海量并行处理）：是一种基于共享磁盘的并行数据库处理架构，通过将数据分布到多个节点上进行并行处理，从而实现对大规模数据的快速分析和查询。只负责计算，不负责存储。</li>
<li>MapReduce和MPP架构：都是分布式并行处理，将任务并行的分散到多个服务器节点上，在每个节点上计算完成后，将各自部分的结果汇总到一起。不同的是，MapReduce任务的tasks会动态的分配在空闲的Executor上，执行慢的Executor会分配到更少的task。缺点是MapReduce将一个任务分解成有依赖关系的tasks（DAG），task是异步执行的，因此必须通过写入中间数据共享内存来解决数据的依赖，性能有所损耗。MPP每个处理数据的task被绑定在持有该数据切片的指定Executor上，单一的Executor只处理单一的task，不需要将中间数据写入磁盘，直接将数据Stream到下一个执行阶段，性能好。缺点是如果某个Executor执行过慢或者故障，整个集群的性能就会受限于这个异常节点，所以MPP架构的集群节点不宜过多。</li>
<li>Lambda架构：一种用于数据处理的架构设计模式，结合了实时计算和批处理两种方法，以满足不同的数据分析需求。L由三个层级组成：批处理层、速度层和服务层。批处理层负责离线处理大量数据，通常通过批处理系统（如Hadoop、Spark等）处理数据，并将结果存储在数据仓库中。速度层用于处理实时数据流，通常采用流式处理技术（如Storm、Spark Streaming等），以快速处理数据并产生实时结果。服务层负责将批处理层和速度层的结果整合，并为用户提供统一的数据查询和分析接口。优点：可扩展性强、能够处理大规模数据、满足实时和离线数据处理需求。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BSpring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8BSpring/" class="post-title-link" itemprop="url">那些年背过的面试题之Spring</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-24 22:25:25 / Modified: 22:26:41" itemprop="dateCreated datePublished" datetime="2025-07-24T22:25:25+08:00">2025-07-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><ul>
<li><p>Spring的架构：1⃣️控制反转IOC容器，负责管理对象的生命周期。2⃣️AOP面向切面编程，实现跨应用程序的共有关注点，代码前后做增强。3⃣️简化数据访问，如JDBC，提供一致的数据访问。4⃣️Web层，Spring MVC提供一个分离的模型-视图-控制器实现，用于构建Web应用。</p>
</li>
<li><p>spring bean的加载过程&#x2F;生命周期：1⃣️启动spring应用上下文。2⃣️加载bean定义：读取xml文件、java注解、java配置类，为每个声明的Bean创建一个BeanDefinition对象，包含bean的所有定义信息。 3⃣️实例化bean：调用构造函数、依赖注入、BeanPostProcessor 的前处理。4⃣️初始化bean：调用bean的初始化方法：@PostConstruct注解的方法、指定的init-method、InitializingBean的afterPropertiesSet方法。5⃣️使用bean。6⃣️销毁：容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy方法。</p>
</li>
<li><p>spring IOC：控制反转，通过spring来管理对象的创建、配置、生命周期，把控制权交给spring。提供BeanFactory和ApplicationContext两种IOC容器，实现对bean的管理。实现原理：依赖注入DI、Bean生命周期管理。</p>
</li>
<li><p>spring AOP：面向切面编程，一种编程范式，代码前后做增强操作，提高代码模块性。实现：基于动态代理，实现接口用JDK动态代理，否则CGLIB动态代理。@Aspect注解和@Around切入点实现切面。</p>
</li>
<li><p>JDK和CGLIB动态代理：JDK动态代理针对类实现某个接口，基于反射生成实现同样接口的代理类。CGLIB底层基于asm第三方框架，通过修改字节码生成一个子类。</p>
</li>
<li><p>Spring AOP和AspectJ AOP：Spring AOP 基于动态代理实现，只能在运行时织入，性能比AspectJ编译织入慢。AspectJ只支持编译前后和类加载时织入，性能更好，功能更加强大。</p>
</li>
<li><p>java反射：对于任何一个类，都能知道这个类所有的属性和方法；对于任何一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。getField(属性名字)和getDeclaredField（忽略访问控制）获取属性Field。getMethod获取方法Method。invoke执行。</p>
</li>
<li><p>BeanFactory和ApplicationContext：都是Spring中管理Bean的容器。BeanFactory是Spring IoC容器的基础接口，ApplicationContext实现BeanFactory，提供更丰富功能：国际化、事件发布、注解支持。BeanFactory 采用懒加载（延迟初始化）策略，只有在请求获取 Bean 时才会创建和初始化该 Bean。ApplicationContext采用即时加载策略，容器启动时会预先创建和初始化所有 Singleton Bean。</p>
</li>
<li><p>FactoryBean和BeanFactory：BeanFactory是IOC容器，负责生产和管理Bean对象：读取bean配置、加载bean、依赖注入、bean生命周期管理。FactoryBean是工厂Bean，可以实现该接口来自定义Bean的创建过程。重写getObject方法控制Bean的创建，getBean获取Bean实例。</p>
</li>
<li><p>Spring事务的传播机制：用来定义业务方法之间事务处理方式的机制，根据给定的事务规则来创建和控制事务的边界和范围，保证数据一致性。@Transactional注解的propagation属性指定。例如银行转账操作中有个审计方法，这个方法异常不想影响转账事务的回滚，就用REQUIRES_NEW创建新事务。一共有七种：1.REQUIRED：默认的，存在就加入该事务，没有事务就创建新的。2.REQUIRES_NEW：无论存不存在都创建新的。3.NOT_SUPPORTED：非事务方式执行，存在事务则挂起。4.SUPPORTS：存在则加入事务，不存在则非事务。5.NESTED：如果存在事务，则在嵌套事务（可独立提交，外部事务回滚它也得回滚）内执行。如果没有事务，则按REQUIRED属性执行。6.NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。7.MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p>
</li>
<li><p>@Autowired和@Resource：都是用来实现依赖注入的注解。@Autowired是spring的注解，默认根据类型注入，多个类型相同则进一步根据名称。如果按照类型匹配接口不同实现类需要结合@Qualifier。提供required属性允许找不到bean时是否抛出异常。@Resource是j2ee的注解，默认按byName自动注入，不能用于构造函数。</p>
</li>
<li><p>Spring核心注解：@SpringBootApplication：组合注解，用于启动Spring Boot应用，包含@Configuration、@EnableAutoConfiguration和@ComponentScan。@Component：标注一个类为需要Spring管理的bean。@Configuration：表明该类是用于定义Bean的配置类，配合@Bean来在容器中注册自定义的Bean，方法返回对象被容器管理。@Transactional：用于声明一个方法或类需要事务管理。</p>
</li>
<li><p>Spring依赖注入注解：@Autowired、@Qualifier、@Resource、@Value：注入普通类型的属性。</p>
</li>
<li><p>Spring组件扫描注解：@Service：用于Service层的组件。@Repository：用于DAO层的组件。@Controller：用于标记控制层组件。</p>
</li>
<li><p>spring bean生命周期：1.创建bean的实例，在堆中开辟一块内存空间给这个对象，生成实例对象。2.填充bean的成员属性。3.调用initializeBean方法初始化bean（调用@PostConstruct、实现Aware接口的方法、before…方法、init-method方法、afterPropertiesSet方法）。</p>
</li>
<li><p>spring的三级缓存：用来解决单例bean循环依赖问题，提前拿到未初始化完全的对象。第一级缓存：用来保存实例化、初始化都完成的对象。第二级缓存：用来保存实例化完成但是未初始化完成的对象。第三级缓存：保存创建早期bean的工厂ObjectFactory，getObject()创建一个对该bean的早期引用，这个引用可以被二级缓存使用，确保bean可以按需要的代理和增强创建出来。原理：实例化和初始化流程分开，在Bean完全初始化之前，可以暴露一个早期的bean引用，从而打破循环依赖。</p>
</li>
<li><p>二级缓存行不行：当涉及AOP或其他代理增强时，仅凭二级缓存不够，因为要在返回代理对象前确保执行所有增强的逻辑。所以，如果一个bean需要被代理，它首先应该通过三级缓存的ObjectFactory被创建，该工厂负责处理所有的代理相关逻辑。一旦经过这个步骤得到的bean被放入二级缓存中，它就可以被其他bean使用了。</p>
</li>
<li><p>spring解决循环依赖的具体流程：1.单例bean首先检查一级缓存，存在则直接返回。2.不存在则实例化对象，还未属性注入和初始化。3.创建好bean实例后，将ObjectFactory放入三级缓存。4.属性注入，请求创建依赖的bean，如果有循环依赖，通过三级缓存创建一个早期的bean引用，并放到二级缓存，同时删除三级缓存。5.完成注入及初始化，bean创建成功。6.bean放入一级缓存，并从二级和三级缓存中移除。</p>
</li>
<li><p>spring bean：根据作用域，Singleton：默认的作用域，整个容器中只有一个实例，适用于配置类、工具类、服务类。Prototype：原型bean，每次请求都会创建一个新的实例。spring容器仅负责实例化，不管生命周期。Request：每个HTTP请求都会创建一个Bean，仅适用于web应用。Session：每个HTTP Session都会创建一个Bean，仅适用于web应用。</p>
</li>
<li><p>@PostConstruct：Java EE 5引入的注解，在Bean的实例化和依赖注入完成后被自动调用。用来执行必要的初始化代码，例如资源分配，加载数据。通过容器来控制初始化。修饰无参数无返回值方法，每个类只能有一个该方法。InitializingBean接口的afterPropertiesSet和配置bean时的init-method也有类似功能。@PostConstruct先于他俩。</p>
</li>
<li><p>InitializingBean：接口，定义了afterPropertiesSet方法，这个方法会在bean的所有属性都设置好之后执行，用于在依赖注入后执行某些初始化操作。</p>
</li>
<li><p>ApplicationContextAware：用于方便获取ApplicationContext，spring会自动调用setApplicationContext(ApplicationContext applicationContext)方法，可将ApplicationContext实例注入到bean中，用于获取其他bean、访问资源文件、发布事件。</p>
</li>
<li><p>spring事务的实现原理：两种事务的实现方式：编程式（通过代码控制事务处理逻辑）、声明式（@Transactional注解实现）。事务的操作本由数据库自动控制，为方便业务逻辑操作，由spring框架控制。spring事务的实现原理是通过AOP实现，生成代理对象，代理会在方法执行前后织入事务管理的相关操作：事务开始，先把事务的自动提交给关闭、提交事务、异常回滚。可以设置事务的传播行为、隔离级别、超时设置。总之，Spring AOP 提供了声明式事务管理的基础，使得事务管理逻辑能够以切面的形式，织入到业务逻辑中。</p>
</li>
<li><p>a方法加了@Transactional，b方法没加，b内部调用a，会有事务产生吗：@Transactional声明式事务，事务的传播行为决定事务如何传播和边界所在。由于spring的事务管理是基于AOP，通过代理实现的，分两种情况：第一种，如果方法在同一个类中，自调用，a方法的调用不会通过spring生成的代理对象调用，不会开始新的事务。第二种，在不同的类中，a方法通过spring的代理对象调用，开始一个新事务。</p>
</li>
</ul>
<h2 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h2><ul>
<li>什么是springboot：基于spring的开源框架，用于快速创建独立的生产级别的可运行的Spring应用程序。不是Spring功能上的增强，而是提供一种快速开发Spring项目的方式。spring问题：写配置文件繁琐，依赖繁琐，maven坐标版本问题。springboot提供的优点：自动配置、起步依赖、安全。约定优于配置的理念，开发者不需要手动配置大量spring配置文件，而是自动配置。提供一系列的起步依赖starter，快速构建出一些常用的应用程序，整合Junit、redis、mybatis等很方便。帮助管理jar包版本，避免依赖版本不一致的问题。</li>
<li>Spring、Spring MVC和SpringBoot区别：Spring是Java开发框架，用于创建企业级的java应用程序，提供IOC和AOP等功能。Spring MVC是Spring框架的一个模块，用于创建Web应用程序，使用控制器、视图和模型来实现MVC设计模式。Spring Boot是一个基于Spring框架的快速开发工具，使用自动配置快速创建Spring应用程序。总结：Spring是基础框架，Spring MVC是基于Spring的Web框架，而Spring Boot则是基于Spring的快速开发框架。Spring Boot内嵌了Tomcat、Jetty等Web容器，可以直接运行Web应用程序，而Spring MVC需要部署到Web容器中才能运行。</li>
<li>springboot自动配置的原理：基于Spring的条件化配置功能实现，Condition接口和@Conditional注解。以及springboot的一系列自动配置类，Spring Boot应用的入口类会使用@SpringBootApplication注解，它包含@SpringBootConfiguration，@EnableAutoConfiguration和@ComponentScan注解，@EnableAutoConfiguration是自动配置的核心。@EnableAutoConfiguration利用Spring的@Import注解来加载配置类，META-INF&#x2F;spring.factories配置文件中定义了大量的配置类，springboot应用启动时会自动加载这些配置类。并且在配置类中使用Condition来加载满足条件的bean，如DataSource、JdbcTemplate等。（总结：1.条件注解 2.@EnableAutoConfiguration）</li>
<li>springboot核心注解：@SpringBootApplication：复合注解，标识springboot应用的主类。@Configuration表明该类是java配置类。@ EnableAutoConfiguration开启自动配置功能。@ComponentScan用于自动扫描和注册bean。</li>
<li>spring boot starter：是预配置的依赖管理器，将一组库&#x2F;依赖捆绑在一起，便于开发特定类型的应用程序。简化依赖管理，提供开箱即用的配置，是约定优于配置的应用，集成常用技术和库。spring-boot-starter-web：开发Web应用，包含Spring MVC、Tomcat容器等。spring-boot-starter-data-jpa：使用JPA的Starter，包含Hibernate、Spring Data JPA、Spring ORM等依赖。spring-boot-starter-data-redis：使用Redis的Starter，包含Jedis客户端和Spring Data Redis等依赖。spring-boot-starter-test：适用于测试的Starter，包含JUnit、Mockito、Spring Test等依赖。spring-boot-starter-actuator：监视器，适用于监控和管理Spring Boot应用程序的Starter，包含Spring Boot Actuator等依赖。</li>
<li>spring-boot-starter-parent：springboot官方提供的一个Maven父工程，是springboot项目的父工程，parent元素设置为它，继承一些常用依赖和插件，减少手动配置。统一管理springboot中的常用依赖版本号，确保版本兼容性。</li>
<li>如何自定义spring boot starter：在项目的src&#x2F;main&#x2F;resources目录下创建META-INF&#x2F;spring.factories文件，内容如下：org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;com.example.my_starter.MyAutoConfiguration，告诉springboot启动时自动加载配置类。创建MyAutoConfiguration配置类，并在类上加上@Configuration注解，在其中定义需要自动配置的Bean。然后打包上传Maven仓库。</li>
<li>spring-boot-maven-plugin：用于将SpringBoot应用，以及依赖项和配置文件打包成可执行的Jar包或War包，包含嵌入式的Tomcat容器或Jetty容器。方便部署和运行。</li>
<li>springboot打成的jar包和普通jar包区别：1⃣️springboot的jar包是可执行的jar包，包含了内嵌的Tomcat、Jetty等Web服务器，可直接运行。普通jar包纸包含类、资源等，需要在外部环境中手动配置Web服务器运行。2⃣️springboot打的jar包中包含了启动类的main方法，可直接运行。普通jar包需要指定启动类。3⃣️springboot的jar包中包含一些默认的配置文件，如application.properties，用于配置属性、数据源等。普通jar包不包含。</li>
<li>springboot实现热部署：使用Spring DevTools工具，支持应用程序代码修改后自动重新加载应用程序上下文和服务器。spring loaded也行，避免反复构建和部署。</li>
<li>springboot可以兼容老spring项目吗：可以使用@ImportResource注解来加载老的xml配置文件，用于@Configuration或@SpringBootApplication类上。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="post-title-link" itemprop="url">那些年背过的面试题之中间件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-24 22:23:55 / Modified: 22:28:31" itemprop="dateCreated datePublished" datetime="2025-07-24T22:23:55+08:00">2025-07-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><ul>
<li><p>微服务是什么：架构风格，大型服务-多个小服务，轻量级通信机制协作。模块儿化，独立部署扩展维护、可靠、技术异构。</p>
</li>
<li><p>微服务组件：服务、通信机制、服务发现与注册、负载均衡、API网关</p>
</li>
<li><p>微服务间如何通信：http、消息队列、rpc</p>
</li>
</ul>
<h2 id="rpc、HSF"><a href="#rpc、HSF" class="headerlink" title="rpc、HSF"></a>rpc、HSF</h2><ul>
<li><p>rpc：远程过程调用，就像调用本地函数一样调用远程服务，通信协议、序列化协议，http、自定义报文tcp，文本xml json 二进制protobuf hessian。</p>
</li>
<li><p>自定义报文？http消息头复杂，短链接</p>
</li>
<li><p>HSF：高速服务框架，分布式rpc服务框架。统一服务的发布&#x2F;订阅&#x2F;调用方式，解决服务间的高效调用。</p>
</li>
<li><p>HSF架构：服务提供者、服务消费者、地址注册中心configServer（注册服务、订阅服务、向消费者推送服务提供者地址）、持久化配置中心diamond（configServer的类型和地址、订阅路由规则等）、元数据存储中心redis（服务上报元数据：方法列表参数结构）、控制台（服务查询治理测试运维）</p>
</li>
<li><p>HSF服务发布源码：核心是HSFSpringProviderBean，通过@Import注解引入配置类，配置类实现ImportBeanDefinationRegistrar来创建复杂的bean并注册到spring容器中。HSFSpringProviderBean的afterPropertiesSet()方法中进行服务初始化（初始化调用链，两条链，一是protocolFilterChain: Protocol，它专注于流程编排，在publish()流程顺序执行；一是invocationHandler链，用于后续处理hsf请求调用）、服务发布（使用线程池，Future阻塞等待服务发布成功。使用调用链进行，上报元数据到Redis，启动并监听tcp&#x2F;http端口、分配服务线程池、服务注册。使用Protocol进行流程编排，初始化时编排流程顺序。注册信息：ip&#x2F;port&#x2F;序列化方式&#x2F;路由规则&#x2F;应用名称&#x2F;超时时间。HSFProtocol中开启netty服务，设置tcp相关协议）。</p>
</li>
<li><p>HSF消费源码：1.服务初始化，初始化调用链，初始化HSF代理对象jdk。2.服务调用，同样使用调用链，在IO传输层使用netty长连接，使用hessian序列化，在服务提供方使用反射调用（运行时动态获取类的信息）。</p>
</li>
<li><p>HSF相比SpringCloud优势：1.HSF使用高性能的异步事件驱动的NIO框架Netty。2.序列化协议hession相比json。3.HSF只需将二方包暴露给用户 4.HSF使用代理机制，将协议封装、选址、远程调用封装，用户只需Spring配置。</p>
</li>
<li><p>HSF源码心得：从服务端初始化、服务注册、客户端初始化、调用服务，使用Netty、Hession、ProtocolFilter、InvocationHandler链式调用过程进行流程编排、灵活配置的注册中心、事件监听机制、通过随机数的方式实现随机负载均衡。高内聚低耦合的设计方法。</p>
</li>
<li><p>一次完整的HSF调用：服务寻址、网络连接、序列化传输、反射调用</p>
</li>
<li><p>一个rpc框架最重要的是什么部分：通信机制（传输协议自定义tcp报文还是http、负载均衡、容错机制）、序列化反序列化协议（网络只能传输字节流，需要将对象转换为字节流），还需要服务发现与注册机制、服务治理机制。</p>
</li>
<li><p>shell脚本查询对应错误出现次数：grep “2024-01-01*error” error.log ｜ wc -l</p>
</li>
</ul>
<h2 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h2><ul>
<li><p>dubbo：高性能RPC框架，阿里开源，netty网络框架，异步IO，线程池</p>
</li>
<li><p>dubbo框架：服务提供者启动时向注册中心注册服务，服务消费者启动时订阅服务，注册中心Registry向消费者推送服务提供者地址列表，如果发生变化通过长链接推送变更，消费者用负载均衡选择地址，监控中心Monitor，消费者和提供者定时发送统计数据（调用次数调用时间）</p>
</li>
<li><p>dubbo负载均衡：随机、轮询、最少活跃调用、一致性哈希、权重</p>
</li>
<li><p>dubbo中的Filter：责任链模式的实现，根据配置生成Filter链，实现对Dobbo代码的拦截和扩展，类似于AOP，优雅的代码增强手段，逻辑分层，代码解耦。应用：日志、鉴权、限流、负载均衡。</p>
</li>
<li><p>dubbo中的spi扩展：服务扩展机制，可以在运行时动态加载实现类。提供丰富的SPI扩展点，类似java SPI，可以自定义扩展实现，配置方式替换框架中的组件。使用了url总线设计，url参数识别用哪个接口实现。使用@SPI注解指定扩展点名。面向接口编程。</p>
</li>
<li><p>dubbo的SPI实现：1.ExtensionLoader单例工厂类，负责加载和管理扩展点实现类。2.不仅通过接口名获取，还有一个key。3.Adaptive自适应扩展，可以在运行时通过传入参数动态选择合适的扩展实现。</p>
</li>
<li><p>dubbo的SPI应用：Protocol协议、Cluster集群容错策略、LoadBalance负载均衡策略。都是根据配置动态切换。</p>
</li>
<li><p>dubbo中的url总线设计：为了各层解耦，交换参数不用Model，用url参数，方便扩展。底层netty。</p>
</li>
<li><p>dubbo启动过程：注册中心（加载配置、启动定时、NettyServer启动netty）提供者（DubboProtocol提供远程服务，RemoteRegistry建立与注册中心连接）消费者（RemoteRegistry，RegistryDirectory订阅服务，创建代理，实际调用InvokerInvocationHandler）</p>
</li>
<li><p>dubbo服务治理：负载均衡（请求均匀分配）、集群容错（调用失败时切换机器重试）、服务降级（负载过高时屏蔽部分服务保障核心）、路由策略（选择最优服务提供者）、监控管理（监控报警）</p>
</li>
<li><p>dubbo中的设计模式：ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();是工厂模式，Adaptive运行时动态决定调用哪个实现，代理模式。使用调用链Filter责任链模式。ClassLoaderFilter在主功能上添加功能装饰器模式。注册中心向消费者发送notify消息表示服务更新，观察者模式。</p>
</li>
<li><p>dubbo总结：Dubbo考虑了框架可扩展性，url总线设计，层次划分。一个调用链路中存在很多Filter拦截，相对HSF性能差，但是可以将自己逻辑整合到调用链中。</p>
</li>
<li><p>dubbo限流：服务治理的一种，确保服务提供者不会因为过高请求负载而崩溃。基于令牌桶算法，以恒定速率向桶中添加令牌，每个请求需要从桶中消耗令牌，Guava中RateLimiter实现令牌桶。基于信号量Semaphore，控制同时执行服务的线程数。</p>
</li>
<li><p>dubbo序列化有哪些：Hessian2序列化，紧凑且效率高，二进制序列化协议，跨语言，dubbo中默认的。java内置序列化。Fastjson序列化，将对象序列化为json字符串，适合web通信场景。Protobuf序列化，使用.proto文件定义数据结构，生成二进制格式存储数据，跨语言。</p>
</li>
<li><p>dubbo比spring cloud优势：1.轻量级和高性能：基于RPC和Netty框架。强调性能。2.灵活的服务治理：路由规则、负载均衡、故障转移、集群支持。3.独立的注册中心：zookeeper等可选，提供分离的服务发现设计。4.支持跨语言的服务调用，gRpc、Hessian集成。5.简单易用，二方包的形式</p>
</li>
<li><p>Spring Cloud：基于Spring Boot，一整套微服务解决方案，提供一系列用于构建微服务应用的工具和框架。相对更重。基于REST原则，基于HTTP&#x2F;REST的服务通信。</p>
</li>
</ul>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ul>
<li>分布式：多台计算机位于不同地理位置，分布式存储处理数据和应用程序。组件之间通过网络连接。</li>
<li>分布式优点：可扩展性、容错性、地理分散降低延时。</li>
<li>分布式难点：数据一致性、系统管理（部署、管理、容灾、处理节点故障）、跨节点事务</li>
<li>分布式事务：事务的操作分布在不同节点，跨库事务，需要确保事务ACID（原子性、一致性、隔离性、持久性）</li>
<li>分布式事务方法：两阶段提交2PC（准备阶段询问所有参与者是否可提交，根据答复指示所有参与者提交&#x2F;回滚，所有ok才提交）、三阶段提交3PC（增加预提交，参与者将事务操作记录写入日志，即使协调者失去响应，参与者也有足够的信息来完成或回滚事务。减少因协调者故障导致的阻塞，提高容错）、分布式事务框架（XA事务协议）、事务补偿、BASE理论（宽松，基本可用，软状态，最终一致性）</li>
<li>分布式锁：分布式系统中同步访问共享资源的机制，避免多节点同时修改同一数据的冲突。1⃣️基于数据库锁，select for update对特定行上行级锁。2⃣️基于redis，SETNX命令，expire过期时间。3⃣️基于zookeeper，分布式协调服务，创建一个独特的节点表示获锁。保障原子性和唯一性。</li>
</ul>
<h2 id="metaq"><a href="#metaq" class="headerlink" title="metaq"></a>metaq</h2><ul>
<li>metaq：分布式的，基于队列模型的消息队列中间件，基于发布订阅模式，有push&#x2F;pull两种消费模式。支持严格的消息顺序，亿级别堆积能力，支持消息回溯。延时消息。</li>
<li>消息队列三大场景：异步、解耦、削峰。</li>
<li>metaq架构：NameServer（路由注册中心，实例彼此独立，用于服务发现和Topic的注册中心，每个节点维护topic和broker的映射关系）、Broker（实际消息存储的服务器，分master和slave，每个Broker与所有的NameServer建立长连接，定时注册Topic信息到NameServer。主节点读写，从节点提供冗余和故障转移。）、Producer（消息生产者，与NameServer其中一个建立长连接，读取Topic路由信息。与提供Topic服务的Master Broker建立长连接，并定时向其发送心跳）、Consumer（消息消费者，与NameServer其中一个建立长连接，读取Topic路由信息。从Master Broker&#x2F;Slave Broker订阅消息，与Broker建立心跳。可pull可push，可集群可广播）。</li>
<li>metaq的存储模型：1⃣️CommitLog是物理存储文件，存储所有Topic的消息元数据，是全局的顺序写入的日志文件。2⃣️ConsumerQueue逻辑队列是每个Message Queue的索引文件及存储上的体现，记录CommitLog中的消息地址（偏移量、大小、消息tag的hashcode），每个条目20字节，提供快速访问。类似B+树，CommitLog是叶子结点存储实际数据，ConsumerQueue是中间节点负责索引数据。3⃣️Message Queue是逻辑上的消息队列，是Topic的分区，分散在不同Broker。用于并行发送和接收消息。4⃣️IndexFile用于快速检索消息，维护消息键（消息ID、Key）到物理位置的映射。</li>
<li>metaq如何保证消息高可用：1⃣️Producer：支持同步异步发送方式，同步消息发送确认、消息重试。使用负载均衡选择Broker进行消息投递。快速失败：调度线程定时检查第一个节点排队时间，超过就立即返回失败，以尽快重试。故障规避机制避开上次失败的Broker。2⃣️Consumer：消息拉取确认、消费失败重试队列、消费进度存储（定期存储消费进度offset，重启或故障后从进度继续消费）、业务层实现幂等消费（重复消费也不影响）。3⃣️Broker：持久化存储机制（存储到CommitLog，顺序写入磁盘）、主从部署（主从同步、主从切换，Master和Slave故障转移）、死信队列（无法成功消费的消息进入死信队列）、使用内存映射文件MappedFile（将磁盘文件映射到内存中，以操作内存方式操作磁盘，减少CPU拷贝）</li>
<li>同步刷盘和异步刷盘：将内存中数据持久化到磁盘中，同步刷盘是将消息成功写入commitLog中之后再返回给生产者成功，更可靠。异步刷盘是写到内存后直接返回，然后通过另一个后台线程来刷盘，吞吐量更高。</li>
<li>Broker主从同步：从节点定时向主节点发送同步请求，主节点根据从节点CommitLog最大偏移量返回消息。</li>
<li>NameServer作用：Broker的动态注册与发现（心跳检测是否存活）、路由信息管理（保存整个Broker集群的路由信息，topic和Broker的映射关系）。每个NameServer有一份完整数据。</li>
<li>Raft协议和Paxos：分布式系统中用于解决一致性问题的共识算法。例如Zookeeper中的Leader选举。</li>
<li>RocketMq集群模式：1⃣️单master模式：不能故障转移和高可用。2⃣️多master模式：不能故障转移。3⃣️多maste多slave异步模式：异步复制，实时性高，Master宕机磁盘损坏情况下会丢失少量消息。4⃣️多master多slave同步模式：同步双写，写成功才返回给应用，无单点故障。</li>
<li>RocketMq顺序消息如何保证：CommitLog的写入是顺序的，消息队列FIFO，对于单个Message Queue而言，是按存储顺序顺序消费的。多个Message Queue是不保证全局顺序的。需要确保消息只分配给一个Message Queue。</li>
<li>RocketMq负载均衡：Producer负载均衡，轮询方式发送到Message Queue。Consumer负载均衡，集群模式下queue均匀分配给实例，每个queue只分给一个Consumer实例。广播模式下所有consumer分到所有queue。</li>
<li>死信队列：消息重复消费失败，达到最大重试次数，进入死信队列。一个死信队列对应一个GroupId，不分Topic。</li>
<li>消息幂等：消费者接收到消息后，根据业务唯一Key（如Message key）做幂等，即使重复消费也没事。</li>
<li>推拉消息模式：Pull：拉取型，消费者主动定期轮询Broker，请求新消息。Push：消费者注册消息监听器来接收Broker的消息推送，被动消费。但实现上，都是消费端主动拉取的方式，RocketMq的服务端不会主动推送，push模式下还是消费端拉取消息，拉取后调用回调接口，模拟推送。</li>
<li>任何一台Broker宕机怎么办：Broker采用主从架构，多副本策略。Broker宕机后主从切换，高可用。4.5开始支持Dlegder模式，基于raft分布式一致算法。</li>
<li>消息被消费后会立即删除吗：不会，消费后只是消息队列的消费进度（offset）更新，消息的删除是通过定期清理过期文件来实现的。</li>
<li>延时消息实现：是在投递到Topic这一阶段延时的。1⃣️消息投递：提供若干个延时等级。有一个专门的延时Topic，存入对应延时等级的队列中。2⃣️消息调度：Broker启动时，创建ScheduledThreadPoolExecutor线程池，每个延迟队列一个线程扫描，定期检查延时队列中的消息是否到期。3⃣️转移消息：取出消息重新进行CommitLog写入，写入对应Consumer Queue。然后正常消费。</li>
<li>metaq总结：高性能（吞吐量高并发量高，队列模型、并行消费、基于Netty）、高可靠性（消息丢失可能小，重试机制、故障规避机制、重试、死信队列）、高实时性（低延迟，快速失败、异步刷盘、零拷贝）</li>
</ul>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul>
<li>消息队列：消息队列是一个用于接收消息、存储消息并且转发消息的中间件，异步、削峰、解耦。</li>
<li>metaq中的nameserver：类似kafka中zookeeper的角色，不直接采用ZooKeeper是因为ZooKeeper有自动选举Master的功能，MetaQ的架构设计上决定了它不需要进行Master选举，而只需要使用一个轻量级的元数据服务器就可以了。</li>
<li>kafka：一个多分区、多副本且基于 ZooKeeper协调的分布式消息系统。定位为一个分布式流式处理平台，高吞吐、可持久化、可水平扩展、支持流数据处理。</li>
<li>kafka的架构：zookeeper保存broker集群元数据，对控制器进行选举操作。Producer生产消息并发送到Broker。Consumer从Broker订阅并消费消息。Broker接收生产者的消息，存储消息，为消息设置偏移量。Topic消息的主题。一个Topic细分为多个分区，在存储上看作一个可追加的Log文件。offset是消息在分区中的唯一标识，保证消息在分区的顺序性，不跨分区，也就是kafka只保证分区有序性。Replication副本，保证高可用，同一Partion在多个Broker上存多个副本，主提供读写，主失效的话，zookeeper选举controller，controller选择主。</li>
<li>kafka高可用：多分区，一个Topic主题分区数据跨越多个broker分布式存储，每个分区有多个副本，主出现故障，可以故障转移。</li>
<li>kafka一定不会丢失消息吗：只有一个副本情况下会丢失，生产者确认策略是异步的还是同步的，异步的可能在消息到达服务器之前丢失。短暂网络故障、磁盘损坏。</li>
<li>netty的优点：1⃣️Reactor模型处理并发网络事件：主Reactor线程负责接收新的客户端连接，将连接分配给从Reactor，负责监控和处理IO事件。2⃣️内存管理：池化的内存分配方式，减少内存分配和回收成本。字节缓冲区ByteBuf提供内存读写，较JDK自带的ByteBuffer具有更高的性能，引用计数。3⃣️连接管理：基于事件循环(EventLoop)的模型来管理网络连接。每个EventLoop都维护了它自己的选择器(Selector)和任务队列，能够处理成百上千的连接而不会创建与之对等的线程，降低资源消耗。链式的处理器ChannelHandler来处理网络事件。</li>
<li>tcp和udp：tcp面向连接，udp无连接。tcp提供可靠传输，流量控制，拥塞控制，udp尽力而为，不保证数据包顺序、完整性、正确性，不会自动重传。tcp点到点的，面向字节流，传输慢，首部开销大20-60字节，适合文件传输、网页。udp一对一多对一多对多一对多，面向报文，传输效率快，不可靠，首部开销小8字节，适合视频通话。</li>
</ul>
<h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><ul>
<li>Netty是什么：提供异步的基于事件驱动的网络应用程序框架。用来快速开发高性能、高可靠性的网络IO程序，最流行的NIO框架。Elasticsearch、Dubbo、gRpc、Zookeeper、Rocketmq都用Netty。NIO、Seletor选择器、事件驱动、回调异步。</li>
<li>Netty的事件驱动：事件如连接打开、数据到达、连接关闭均以异步方式处理。提供EventLoop处理IO事件，其中ChannelHandlers响应事件。发起IO后，立即返回ChannelFuture对象，开发者在上面增加监听器ChannelFutureListener，在IO完成时收到通知。回调机制和Future的异步编程模型。</li>
<li>Reactor模型：事件驱动架构的一种实现方式。一个单线程监听就绪IO事件，并将IO事件分发给回调函数。Acceptor处理新连接，Reactor分派事件分派给Handler，Handler事件处理。NIO就是。</li>
<li>Netty优点：高并发基于NIO、传输快零拷贝、封装好、内存池设计使用直接内存、高性能序列化协议Protobuf</li>
<li>Netty应用场景：RPC框架的网络通信工具、实现HTTP服务器、实现即时通讯系统、消息推送系统</li>
<li>Netty相比原生NIO优势：易用性（封装API）、稳定性（修复了select空转导致CPU100%问题）、高性能（对象池复用和零拷贝技术）、Netty异步基于事件驱动</li>
<li>Netty和Tomcat区别：Tomcat是用作Servlet容器的Web服务器，Netty是异步事件驱动的网络应用框架。通信协议上，Tomcat基于http，Netty不仅支持http，可以通过编程自定义各种协议。Tomcat需要遵循Servlet规范请求与响应模型，Netty不需要。</li>
<li>Netty体系结构：1⃣️Channel：Socket的连接依据，创建、注册到EventLoop、连接到远程节点。2⃣️EventLoop：Executor在Netty的线程模型抽象，由EventLoopGroup分配管理。一个EventLoop可以被分配给多个Channel，一个Channel的IO操作由一个线程执行。作用是负载监听网络事件并调用事件处理器进行IO操作。3⃣️EventLoopGroup：线程池，通常两个，一个用于接受新连接，另一个用于处理已接受连接的数据传输IO操作。4⃣️ChannelHandler：处理具体的业务逻辑，用户自定义事件处理逻辑，如连接打开关闭、数据读取写入。5⃣️ChannelPipeline：ChannelHandler实例链，编排Handler事件处理器链式执行。6⃣️Bootstrap：启动类，用于配置整个Netty程序，进程绑定到端口、设置线程模型、事件处理流。分为服务端ServerBootstrap和客户端Bootstrap</li>
<li>Netty运行总结：Netty的服务端通过Channel处理每次的连接请求，Channel都会注册到EventLoop线程模型中等待排队或立即执行。EventLoop由EventLoopGroup管理和分配。Channel有四种生命状态，ChannaelHandler处理具体的业务逻辑，ChannelPipeline编排所有的Handler顺序执行。Bootstrap用于将这些逻辑成为一个可运行的程序，提供一个运行入口。</li>
<li>网关：客户端和服务之间的中介，简化网络结构，对外提供统一的访问接口。功能：路由转发、负载均衡、鉴权、限流、监控。Netty可实现网关，实现WebSocketHandler，两个EventLoopGroup，通过ServerBootstrap引导，异步调用的Channel方式，执行ChannelPipeline中的ChannelHandler。</li>
<li>Netty线程模型：使用事件循环EventLoop处理IO操作，每个EventLoop绑定到一个线程，服务多个Channel，负责调度和执行ChannelPipeline中的ChannelHandler。EventLoopGroup一个接收新连接的boss和负责已连接的worker。实现Reactor模式，每个EventLoop包含一个Selector选择器来监听注册在其上的channel事件。</li>
<li>Netty服务端启动过程：1.创建主从EventLoopGroup实例 2.初始化服务端启动引导ServerBootstrap实例，配置启动参数  3.设置ChannelPipeline，添加自定义ChannelHandler来处理事件和数据交互 4.ServerBootstrap的bind方法绑定服务器监听的端口，启动服务器来接收客户端连接 5.sync方法阻塞等待直到服务器绑定操作完成，随后进入服务模式</li>
<li>Netty的无锁化体现在哪：串行无锁化设计，在IO线程内部进行多个Handler串行操作，期间不进行线程切换，避免多线程导致的锁竞争。</li>
<li>Netty如何解决epoll空轮询的：使用NIO的epoll选择器时遇到无效的文件描述符而无限循环。Netty维护一个计数器监控epoll_wait返回次数，如果没有任何IO事件情况下连续多次返回，认为空轮询，Netty会重建Selector，将原来的Channel重新注册到新的Selector上。</li>
<li>拆包和粘包：TCP面向流，没有界限的一串数据，会根据TCP缓冲区的实际情况进行包的划分。通过上层应用协议设计来解决：1.消息长度固定 2.特殊分隔符作为结束标志 3.消息头定义消息长度</li>
<li>Netty解决拆包和粘包：依靠提供的一系列解码器（Decoder），能够根据应用层协议将接收到的字节流重新组合成有意义的数据单元（消息或帧）。</li>
<li>Netty零拷贝：使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。Netty的Zero-copy完全是在用户态（Java应用层）的，偏向于优化数据操作。OS层面的Zero-copy通常是避免在用户态和内核态之间的拷贝数据。</li>
<li>TCP长连接和短连接：TCP的长连接和短连接由应用层面决定。短连接是建立连接读写完成后关闭连接，每次建立连接消耗资源。长连接是读写后不关闭连接，后续继续使用。</li>
<li>Netty长连接和心跳机制：TCP长连接中可能出现断网异常，因此引入心跳机制，在client和server之间没有数据交互时给对方发送特殊数据包，对方收到后回应一个（PING-PONG交互），表示仍然在线。</li>
<li>Netty对象池技术：对象池缓存创建好的对象，避免需要时才创建。Netty中buffer是对数据的抽象，数据拷贝时用到，代表可读写的内存区域，通过ByteBuf类实现，Netty会对其进行池化，减少内存分配和垃圾回收开销。</li>
<li>Netty序列化协议：不强制使用特定的序列化协议。它提供了灵活的编解码器机制，允许开发者根据需要使用不同的序列化协议：json&#x2F;pb。</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li>设计模式：23种，为复杂解耦，将一大坨代码拆分成职责单一的模块，满足高内聚低耦合、开闭原则（不改变现有代码的基础上扩展功能）。创建型：创建和使用解耦。结构型：不同的功能代码解耦。行为型：不同的行为代码解耦。</li>
<li>面向对象的四大特征：封装（封装成对象，隐藏实现细节，private public控制访问权限）、抽象（忽略不同，抽象相同点，继承抽象类is a和实现接口has a）、继承（继承父类的属性和方法，允许重用和扩展）、多态（重载是静态，重写Override是动态）</li>
<li>创建型模式：封装复杂的创建过程，解耦对象创建和使用。单例模式：创建全局唯一对象。工厂模式：创建不同但相关类型的对象（同一父类&#x2F;接口），给定参数决定对象类型。建造者模式：创建复杂对象，设置不同可选参数定制化对象Builder。原型模式：创建成本大，复制已有对象进行创建。</li>
<li>单例模式：一个类创建全局唯一实例，提供全局访问点。spring容器一级缓存即单例池，ApplicationContext.getBean获取bean。唯一访问性能高，不适合有状态的。</li>
<li>单例模式实现：1⃣️饿汉式：类加载时就创建，线程安全，但无法延迟加载。2⃣️懒汉式：第一次使用时才创建，延迟加载，但多线程下需要加锁保证线程安全避免创建多实例。3⃣️静态内部类：在外部类加载时不会被加载，只有第一次使用才加载并创建实例，JVM保证线程安全。4⃣️枚举类：天生单例。5⃣️双重检查锁定：既延迟加载又线程安全，同步外检查一次，同步块内检查一次，volatile+synchronized。</li>
<li>线程唯一单例怎么实现：ConcurrentHashMap、或ThreadLocal线程局部变量。</li>
<li>工厂模式：提供工厂类来代替new操作。Executors方法时静态工厂模式。1⃣️简单工厂模式：工厂类方法根据传入参数不同决定生成不同对象。2⃣️工厂方法模式：工厂接口，不同产品创建实现类，开闭原则。3⃣️抽象工厂模式：接口代表一个产品族。不同方法创建不同产品。</li>
<li>建造者模式：创建复杂对象，@Builder传入参数定制化。</li>
<li>原型模式：创建对象成本大，直接复制已有对象方式创建。浅拷贝：只对基本数据类型复制，引用数据类型进行引用传递。深拷贝：引用数据类型创建新对象并复制内容。实现：实现Cloneable接口，重写Object的clone方法。或序列化实现。</li>
<li>代理模式：结构型模式，给某对象提供代理，由代理对象控制对真实对象的访问，直接调用变间接调用，不改变原代码前提下增加功能：鉴权、统计、监控、限流。1⃣️静态代理：在运行前就创建代理类，实现相同接口&#x2F;继承实现类。2⃣️动态代理：运行期间通过反射动态创建代理类，运行前不存在代理类字节码文件。不需要为每个代理类创建代理对象。</li>
<li>适配器模式：允许不兼容的接口之间交互，创建一个中间层，将一个接口转换为适配的接口。类适配器：继承实现。对象适配器：组合实现。例如Spring MVC中提供不同的HandlerAdapter适配不同的处理器，供DispatchServlet处理HTTP请求。Spring AOP中提供不同的适配器AdvisorAdapter来封装不同类型的通知。</li>
<li>观察者模式：行为型模式，基于发布订阅，对象发生变化时进行通知。同步阻塞：阻塞消息发布者。异步非阻塞：使用消息队列，非阻塞地通知观察者。</li>
<li>模版模式：通过定义一个算法的骨架，并将一些步骤的实现延迟到子类。算法结构不变，子类重新定义算法。例如JdbcTemplate。</li>
<li>策略模式：行为型模式，定义一个算法接口，不同算法实现该接口，上下文类表示使用策略的类，维护一个指向策略接口的引用。可以轻松增加、替换算法。</li>
<li>责任链模式：多个不同的处理类对象Handler组成一条链，请求在链上传递，链上每个对象处理，返回&#x2F;传递给下一个对象。</li>
<li>Spring中的设计模式：1⃣️单例模式：Spring容器单例池，bean都是单例的。2⃣️工厂模式：BeanFactory和ApplicationContext创建Bean。3⃣️代理模式：Aop功能使用JDK动态代理和Cglib动态代理。4⃣️模版模式：JdbcTemplate提供一套模板方法来处理数据库的连接、执行 SQL 语句、处理结果集。5⃣️观察者模式：Spring事件驱动模型，ApplicationEvent事件、发布者、监听器。6⃣️适配器模式：Spring MVC中适配不同的处理器Controller。AOP中适配不同的通知Advice。</li>
<li>工作中用到的设计模式：1⃣️单例模式：数据库连接池、XStream用来进行xml序列化反序列化，反复创建回造成ygc，使用单例模式。2⃣️工厂模式：根据不同业务类型返回对应的业务处理类。实现InitializingBean接口，重写afterPropertiesSet方法，用Map维护不同业务类的引用。3⃣️观察者模式：报警系统，定义事件类继承ApplicationEvent，业务类中使用applicationContext.publishEvent(ApplicationEvent)来发送事件，定义监听器EventListener，监听消息发送报警。4⃣️责任链模式：轨迹处理流程：解析、切分、抽稀、匹配、入库，定义责任链HandlerChain，按照流程处理。</li>
</ul>
<h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><ul>
<li>zookeeper：分布式协调服务，用来管理hadoop生态圈的。为分布式应用提供一致性服务的软件，功能：配置管理、服务发现、领导者选举、集群管理。</li>
<li>zookeeper为什么使用集群：1.高可用性，单节点失败仍可运行。2.数据一致性，ZAB协议实现所有节点数据一致性。3.负载均衡，分散负载。4.可伸缩性。</li>
<li>zooleeper架构：1.Client连接到一台Server，向server获取信息，周期性发送心跳给server，server回复ack，没回复则重定向一台server。2.Server包括一台Leader和多台Follower。3.ensemble表示一组服务器，至少3台。4.Leader，服务启动时进行Leader选举，负责处理写操作，在集群中同步数据。5.Follower跟随者，处理读操作，数据冗余，转发写请求，参与投票。</li>
<li>zookeeper中数据结构：和Unix文件系统类似，看作一棵树，节点称为Znode，存储1MB数据，通过其路径唯一标识。不能存大数据。create命令创建数据，get命令获取目录的值，用多版本并发控制来解决并发，set修改。</li>
<li>zookeeper三种目录节点znode类型：1.持久目录：创建之后一直存在，直到显式删除，存储长期有效的配置信息和系统状态信息。2.临时目录：在client活动期间有效，断开自动删除，不能有子目录。常用于锁和服务发现机制，例如标记某个资源正在被使用，或一个实例的注册信息。3.顺序目录：在指定路径后增加一个单调递增的计数器作为后缀，生成唯一的标识符，用于分布式锁中的实现队列顺序。</li>
<li>zookeeper分布式锁：顺序临时节点+watch监听器。创建一个锁节点&#x2F;locks，请求获锁，需要在该目录下创建一个顺序临时节点，然后判断自己是不是最小节点，是则获取到锁，不是则创建一个监听器监听比自己小一的上一个节点，上一个节点删除（手动删或断开连接自动删除）则该节点获取到锁。</li>
<li>zookeeper的观察者模式：zookeeper&#x3D;文件系统+通知机制。zookeeper允许客户端设置对znode的监视（watch），典型的发布-订阅模式，节点发生变化时，客户端会被通知。特点：一次性（监视被触发后会被移除），可以对分布式环境中的状态变化快速做出反应。</li>
<li>zookeeper的leader选举：最小号选举法：每个节点投票给自己，节点之间互相发送自己的投票，节点收到投票后评估选择最小id的节点成为领导者。当一个节点收到超过半数节点支持同一id的投票时，节点认为领导者已选好。考虑节点id和最大的事务id（zxid），确保领导者是数据最新的节点。</li>
<li>zookeeper的ZAB协议：原子广播协议，保证数据一致性。负责服务之间的数据复制（顺序一致性的）和领导者选举过程中的状态同步。1⃣️消息广播：类似两阶段提交，Leader接收写请求，请求封装成事务，事务zxid保证顺序，发送给所有Follower，超过半数成功响应则执行commit。未响应的随后同步。2⃣️崩溃恢复：选举数据最新的节点作为Leader，与集群中其他节点同步状态。</li>
<li>zookeeper集群搭建：准备至少三台服务器，安装zookeeper，zoo.cfg配置文件中设置数据目录，设置连接端口，配置服务器列表。启动zookeeper服务。</li>
<li>zookeeper如何保证hadoop高可用的：1⃣️故障切换和Leader选举：Zookeeper故障转移控制器ZKFC监控和处理NameNode的故障切换，协助备用NameNode成为主节点保障HDFS高可用。ResourceManager也是。2⃣️集群元信息同步：zookeeper提供一致性的分布式数据管理，Hadoop的组件可以利用zookeeper维护和同步系统信息如配置信息、集群状态。3⃣️服务发现：zooKeeper 可以作为一个服务注册表，帮助客户端发现当前可用的服务地址。</li>
<li>zookeeper的应用：Kafka中zookeeper用于集群管理和协调，包括 Broker 的注册、领导者选举、集群配置管理等。还是Kafka 集群元数据的存储中心。HBase中zookeeper用于领导者选举、存储集群元数据。</li>
</ul>
<h2 id="hadoop"><a href="#hadoop" class="headerlink" title="hadoop"></a>hadoop</h2><ul>
<li>hadoop：分布式计算框架，用于在分布式服务器集群上存储和处理大数据集的框架，包括底层存储框架HDFS、分布式计算框架MapReduce、资源调度系统YARN。可以分布式运行PB级别数据。Zookeeper提供协调服务，例如HBase中集群协调领导者选举。</li>
<li>HDFS：分布式文件系统，将文件数据存储在多台机器组成的集群上，每份数据具有多个备份，更可靠。</li>
<li>HDFS架构：主从结构，一个主节点namenode，多个从节点datanode。1⃣️namenode负责接收用户请求，维护文件目录结构、管理文件和block(文件被分为块)的关系以及block和datanode的关系。2⃣️datanode负责存储文件，文件被分成block存储（128M&#x2F;256M），在不同datanode上有多个副本。文件索引与实际数据分离。对硬件要求不高，可存储超大文件，目标是高数据吞吐量。</li>
<li>mapreduce：分布式运算程序的编程框架，用于大数据集的并行运算，海量计算任务分而治之。计算任务分摊到各个计算节点并行计算，汇总得到最终结果。分布式的，抽象了并行处理的复杂度，开发者只需要实现Mapper和Reducer。</li>
<li>mapreduce核心步骤：map拆解（处理输入的键值对，执行定义的Map函数，生成中间键值对）、reduce组合（汇总每个键的值，生成最终结果）。具体可分为：Split、Map、Combiner、Shuffle、Reduce。</li>
<li>split：将输入文件切割为若干块，每一块由不同节点处理。将文章分为不同句。</li>
<li>map：将每个节点的原始数据处理为中间数据，输入输出都是kv。</li>
<li>shuffle：洗牌，因为split是随机的，导致相同key数据处理在不同节点。shuffle将map后的结果重新分组，相同key给到同一reduce节点。</li>
<li>combiner：减少shuffle需要的网络IO操作，对Map后的结果提前做一次归约，相同key组成一条。</li>
<li>mapreduce的架构：计算向数据靠拢，使用主从架构，一个JobTracker接收客户端提交的计算任务，把计算任务分给TaskTracker执行，进行调度、监控。多个TaskTracker执行分配的计算任务。</li>
<li>JobTracker：跟踪任务的执行进度、资源使用量等信息，将这些信息告诉任务调度器TaskScheduler。</li>
<li>TaskTracker：使用slot划分节点资源（CPU、内存），将slot分配给MapTask和ReduceTask。2.0用YARN来进行资源调度。</li>
<li>YARN：负责资源管理、任务调度的框架。基于主从模式的分布式架构。一个ResourceManager，多个NodeManager其中包含ApplicationMaster和Container。1⃣️ResourceManager是中控模块，负责整个集群资源的管理和分配。2⃣️NodeManager是每个节点上的资源和任务管理器，启动管理container。3⃣️ApplicationMaster每个应用的调度和协调，向RM申请资源，告诉container做什么。4⃣️Container资源容器，程序执行环境，封装任务所需的资源：cpu、内存。</li>
<li>自己使用mapreduce：在odps处理大规模数据时，map任务组织数据键值对，定义key和value，key位分组依据adcode，value为数据。reduce中数据已经按照adcode进行了分组，在分组中做数据处理计算。</li>
<li>MaxCompute：odps，大规模数据计算服务，负责存储和处理大量数据。</li>
<li>DataWorks：数据开发与管理平台，负责流程设计、调度、管理，提交到 MaxCompute中执行计算任务。</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul>
<li>10G文件1G内存怎么排序：外部排序，分隔为小的文件块，对每个小文件放入内存进行排序，排序结果写回磁盘。对多个排序结果进行归并排序，使用优先队列（最小堆），归并过程中，每次从堆中取出的最小元素被挨个写入最终的输出文件中。</li>
<li>直接选择排序：第一次从arr[0到]arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]到arr[n-1]中选取最小值，与arr[1]交换。总共n-1次。</li>
<li>插入排序：逐渐构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</li>
<li>堆排序：通过构建二叉堆，不断移除堆顶元素并重建堆，最终得到一个有序序列。</li>
<li>归并排序：归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表</li>
<li>希尔排序：希尔排序又叫缩小增量排序，把所有的数据按照下标间隔进行分组，在每个组内进行插入排序。排完之后缩小分组数，再插入排序。不断缩小组的间距。直到只分一为组。</li>
<li>排序复杂度：快排时间Onlogn空间Ologn不稳定。冒泡时间On空间O1稳定。</li>
</ul>
<h2 id="计算机原理"><a href="#计算机原理" class="headerlink" title="计算机原理"></a>计算机原理</h2><ul>
<li><p>网络分层：物理层（比特流的透明传输，中继器、集线器）、数据链路层（传送帧MAC、网卡、网桥、交换机）、网络层（选择合适的路由，IP、ICMP、路由器、防火墙）、传输层（TCP、UDP）、应用层（DNS、HTTP、SMTP、FTP）</p>
</li>
<li><p>TCP的安全性：三次握手（客户端SYN，服务端ACKSYN，客户端ACK）、四次挥手（客户端FIN、服务端ACK、服务端传输完FIN、客户端ACK）</p>
</li>
<li><p>tcp流量控制：避免发送方发送得太快接收方来不及处理，滑动窗口的方式，接收端告诉客户端确认序列号和还能接受多少数据。发送端调整滑动窗口（已发送未确认、为发送可接受）。更新窗口信息可能丢失，设置0窗口探测报文。</p>
</li>
<li><p>tcp拥塞控制：防止过多数据注入网络。慢开始（加倍达到慢开始门限）。拥塞避免（拥塞窗口+1），如果拥塞，门限减半，窗口变1，执行慢开始。快重传：接收方收到失序报文发出重复ACK，发送方收到三个重复确认，就重传。快恢复：失序报文后，慢开始门限减半，拥塞窗口设为减半后的门限，执行拥塞避免。</p>
</li>
<li><p>tcp不提供加密功能，需要应用层的TSL&#x2F;SSL。两台服务器间可以建立多个tcp连接（socket&#x3D;ip+端口号不同即可）</p>
</li>
<li><p>输入url发生什么：1.DNS解析获取ip，浏览器缓存-路由器缓存-DNS缓存。2.根据ip建立TCP连接。3.浏览器向服务器发送http请求。4.服务器响应http请求。5.浏览器进行渲染。</p>
</li>
<li><p>tcp&#x2F;ip理解：IP协议是网络层的协议，使用分组交换技术来传输数据，通过路由器进行转发，最终到达目的地。无连接性、无状态性、不保证可靠传输。TCP是传输层协议，主要负责在IP协议提供的基础上实现可靠的、有序的、有连接的和无差错的数据传输。</p>
</li>
<li><p>cookie、session、token：1⃣️cookie用来保存一些信息在客户端比如记住密码和推荐显示。2⃣️session用来标识一次会话，记录用户状态，在一次会话期间共享数据。用户首次访问服务器时创建一个session，session id设置为cookie保存在浏览器。3⃣️token用来做密钥快捷登录的。</p>
</li>
<li><p>cookie、session、token：生成位置都在服务器，cookie和token保存在客户端，session保存在服务器。鉴权过程：请求携带cookie与服务器记录cookie对比确认用户状态。session用请求中session id提取，恢复用户状态。请求携带token与服务器通过请求信息生成token对比。</p>
</li>
<li><p>http状态码：301永久重定向。302临时重定向。400服务端无法理解客户端请求。401未授权，需要用户身份认证。403禁止访问，服务端拒绝。404未找到请求的资源。500服务端内部错误。</p>
</li>
<li><p>DNS基于什么协议：DNS域名解析系统，应用层，用于将人类可读的主机名转换为机器可读的IP地址。主要基于UDP进行工作，但当响应数据大小超过报文限制，或者需要更可靠传输时，用TCP。</p>
</li>
<li><p>DNS过程：解析域名时，首先检查本地DNS缓存，如果未找到，请求将发送至配置的递归DNS服务器，递归DNS服务器会进行一系列迭代查询，从根服务器开始，逐级向下询问直到找到该域名的权威DNS服务器，获取对应IP地址。沿着查询链路返回给用户的设备。</p>
</li>
</ul>
<h2 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h2><ul>
<li>边缘计算：一种分布式计算框架，在靠近数据生成的位置（边缘）处理数据的方法。将计算能力下放到网络的边缘，边缘网络基本上由终端设备、边缘设备、边缘服务器等构成。特点：低延迟、节省带宽、提高隐私和安全性、实时数据处理。应用场景：物联网（IoT）、智慧城市、无人超市。</li>
<li>边缘计算和云计算：边缘计算采用分布式计算架构，将运算分散在靠近数据源的近端设备处理，分担云平台的工作量，不需要把数据回传云端处理，实时性更好、效率更高、延迟最短，没有网络也不妨碍。</li>
<li>k8s：Kubernetes是一个开源的容器编排系统，用于自动化部署、扩展和管理容器化应用程序。由google设计。</li>
<li>docker：容器化技术允许将应用程序及其依赖项打包到一个轻量级、可移植的容器中，使得应用程序能够在任何环境中一致地运行。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bredismysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/24/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bredismysql/" class="post-title-link" itemprop="url">那些年背过的面试题之redis&mysql</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-07-24 22:22:24 / Modified: 23:12:13" itemprop="dateCreated datePublished" datetime="2025-07-24T22:22:24+08:00">2025-07-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><ul>
<li><p>redis分布式锁原理：1⃣️setnx键不存在时设置，expire过期时间避免死锁。2⃣️看门狗机制，如果客户端仍在运行，自动续租锁。3⃣️自旋，尝试自旋固定时间。固定次数。4⃣️lua脚本用于执行复杂操作，并保证原子性。5⃣️redis分布式锁不完全可靠，主从复制，主节点同步到从节点之前崩溃，从节点升级，又获取到锁。</p>
</li>
<li><p>redis集群：1⃣️自动分片：数据划分为多个哈希槽，每个节点负责多个哈希槽。2⃣️无中心架构：节点对等，无中心节点。3⃣️主从复制：一个节点可以有多个从节点，实现故障恢复、数据冗余、读写分离。</p>
</li>
<li><p>redis两种同步策略：全量RDB文件、增量同步AOF</p>
</li>
<li><p>redis持久化：redis数据存在内存中，持久化机制将数据存储到磁盘文件。RDB快照是某个时间点数据的二进制全量备份。AOF日志是修改内存数据的指令记录。</p>
</li>
<li><p>redis的RDB：redis是单线程的，为了不阻塞请求响应，fork子线程进行快照持久化，持久化期间，两线程共享一份实体资源，只有在写操作发生时，共享的内存页会被复制，副本供写操作使用（写时复制），最小化对主进程影响。</p>
</li>
<li><p>redis的AOF：使用fsync命令将指令记录存入AOF文件，每1s执行一次</p>
</li>
<li><p>redis重启使用哪种持久化：都开启的话使用AOF持久化，因为包含更完整的操作历史记录。</p>
</li>
<li><p>redis哨兵机制：保证高可用，实现集群监控故障转移。多个sentinel节点。1⃣️监控：sential节点与其他master&#x2F;slave&#x2F;sentinel节点发送PING做心跳检测，交换信息监控主从拓扑。2⃣️主观客观下线：主观一台认为，客观大多数认为。3⃣️哨兵选举：sentinel选出一个leader做故障转移，raft算法，1.节点认为主管下线就申请成为leader，2.其他节点没有答应别人就答应他，3.票数达标就成为leader。4⃣️故障转移：根据从节点优先级选择新的master节点，sentinel leader向其他节点发送命令，并关注原master。</p>
</li>
<li><p>redis双写一致性：更新操作同时写入数据库和缓存，因为分布式系统中网络延迟、系统故障等原因，导致两者数据不一致，解决：1.先写数据库再删缓存：高并发可能会多次缓存穿透，增加数据库压力。2.先写数据库再更新缓存：不会缓存穿透，但是更新缓存操作需要并发控制防止竞争。更高级：消息队列保障顺序、分布式锁。</p>
</li>
<li><p>redis延时双删：在删除数据时，防止删除不能完全同步，首先删除数据库记录，再第一次删除缓存记录，延时短暂时间后，再删一次缓存。避免缓存网络抖动未删除。如果之间又写入，缓存穿透一次读到数据库。</p>
</li>
<li><p>redis缓存击穿：单个key访问并发过高，过期时请求直接打在DB上，数据库压力大。解决：加锁，缓存没有就对key加锁查库后更新缓存、将过期时间也写在value中，异步刷新过期时间、接口限流降级熔断。</p>
</li>
<li><p>redis缓存穿透：查询在缓存和DB不存在的数据时，都打到DB，就像缓存不存在。解决：在请求缓存前加布隆过滤器，筛掉一定不存在的数据。</p>
</li>
<li><p>redis缓存雪崩：大批量数据同时过期，大量请求直接打到DB。解决：缓存数据过期时间设置随机，热点数据均匀分布在不同缓存数据库。</p>
</li>
<li><p>布隆过滤器：快读判断一个元素是否在集合中，可能误判不会漏判。实现：长度m的位数组、k个哈希函数得到k个位置，将对应位置为1。查找时看是不是所有哈希函数得到的位都是1.</p>
</li>
<li><p>RDBMS和NoSQL：关系型数据库（组织化结构，行列格式）、Not only sql（数据存储没有固定格式，可横向扩展）。RDBMS：固定查询语言、事务一致性ACID。NoSQL：无固定查询语言、键值redis、列存储HBase、文档MongoDB、图形存储Neo4j、最终一致性BASE。</p>
</li>
<li><p>redis：远程字典服务，键值对，数据缓存在内存，周期性持久化到磁盘、主从同步、哨兵机制高可用。应用：高速缓存、计数器。</p>
</li>
<li><p>redis数据结构：1⃣️String：最大512M，实现：未使用C语言字符串，自己实现简单动态字符串SDS，带长度信息，embstr编码和raw编码，字符串修改时检查字符串长度避免缓冲区溢出，减少内存重新分配次数。2⃣️列表List：双向链表型数据结构，可两端插入弹出，可指定下标&#x2F;范围获取。实现消息队列、分页。实现：quikList，外层是双向链表linkedList，每个节点是zipList压缩列表，将多个元素序列化存储在一块连续内存中。3⃣️Set集合：不允许重复，没有顺序，支持多集合间并集交集差集操作。实现：如果元素都整数且数量较少，使用intset整数集合压缩数据结构。否则使用hashTable。4⃣️zset有序集合：给每个元素多设置一个分数，作为排序的依据。实现：hashTable存储元素到分数的映射，快速查询和更新分数。跳跃表skiplist维护元素的有序性，并提供高效范围查询。5⃣️hash：存储key-value记录。实现：当字段和值数量不多时，使用压缩列表zipList。否则使用哈希表hashtable，每项都包含指向键的指针和指向值的指针。</p>
</li>
<li><p>redis为什么快：1.完全基于内存 2.单线程无上下文切换成本 3.基于C语言，优化过的数据结构 4.基于非阻塞的IO多路复用和事件驱动模型，使用Seletor监视所有注册的通道，IO事件发生时进行通知。单线程高效处理大量并发连接。</p>
</li>
<li><p>redis6.0改用多线程：依然使用单线程处理客户端请求，只是多线程处理数据读写和协议解析。redis性能瓶颈在网络IO而非CPU。</p>
</li>
<li><p>redis热key问题：某个key大量并发打到一台服务器，达到网卡上线，宕机。缓存雪崩。解决：热key打散在不同服务器。提前加载热key到内存，内存做二级缓存。</p>
</li>
<li><p>redis设置过期时间：expire key seconds；set key value EX seconds；底层采用过期字典存储键的过期时间。</p>
</li>
<li><p>redis过期策略：1⃣️惰性删除：查询key时才对过期时间检测，已过期删除。2⃣️定期删除：定期执行过期键的扫描和删除，避免消耗过多计算资源，使用采样的过程随机抽取，如果过期的多就再抽样。3⃣️都没删除的：等redis内存淘汰机制。</p>
</li>
<li><p>redis内存淘汰：LRU最近最久未使用，淘汰最长时间没有访问的。链表&#x2F;哈希表+双向链表。redis中使用近似的LRU，随机抽取一些键，检查最后访问时间戳，淘汰最久未访问的。</p>
</li>
<li><p>redis高可用：主从架构、哨兵、持久化</p>
</li>
<li><p>redis事务：1⃣️事务是一组命令的集合，数据库事务通过ACID保证，undo log撤销日志。2⃣️redis中事务机制：通过MULTI、EXEC、WATCH 和 DISCARD 四个命令提供。MULTI开启事务，输入多个命令，不会立即执行而是放入一个队列，调用EXEC命令才会将队列中命令原子执行。3⃣️事务监控：WATCH命令设置监控的键，在事务操作之前就监控，如果EXEC之前键被其他客户端修改，则不执行DISCARD。是一种CAS乐观锁的机制。</p>
</li>
<li><p>redis操作一个命令最耗时的地方：网络IO延迟：尽可能使用长连接或连接池。数据持久化延迟：合理配置RDB快照和AOF Rewrite时机（每秒？每条指令？），避免频繁的fork带来的延迟。数据淘汰引发的延迟：避免同一时间大量key过期。</p>
</li>
</ul>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><ul>
<li><p>RDBMS和NoSQL：RDBMS关系型数据库（组织化结构，表格行列格式，Mysql、Oracle、PostgreSQL）、Not only sql非关系型数据库（数据存储没有固定格式，可横向扩展）。1⃣️数据结构：结构化与非结构化，键值redis、列存储HBase、文档MongoDB、图形存储Neo4j。2⃣️数据关联：sql中多张表可关联，nosql数据之间无关联。3⃣️查询语言：sql固定查询语言，nosql不固定查询语言。4⃣️事务一致性：sql提供强一致性和完整事务支持，nosql提供BASE基本可用、软状态、最终一致性。5⃣️存储方式：sql存在磁盘，nosql存在内存。6⃣️扩展性：sql垂直扩展，升级单个服务器的内存cpu存储空间。nosql可水平扩展，分布式存储。</p>
</li>
<li><p>数据库事务：一条&#x2F;多条语句组成，要么全部执行要么全部不执行的执行单元。1⃣️原子性：最小执行单元，操作失败时undo log来回滚。2⃣️一致性：事务执行前后数据保持一致。3⃣️隔离性：并发执行的事务之间不会互相干扰，MVCC、锁机制实现不同隔离级别。4⃣️持久性：事务一旦提交对数据库的修改是永久的，系统崩溃时使用redo日志来恢复。</p>
</li>
<li><p>redo日志和undo日志：1⃣️redo log：重做日志，保障持久性，系统崩溃时恢复数据。物理日志，记录数据页的物理修改操作。更新先写入redo log，再空闲时更新到磁盘，预写式技术减少IO频率。2⃣️undo log：撤销日志，保障原子性，回滚时恢复数据。逻辑日志，记录数据操作的逆向操作。还提供一致性读，即使数据被修改也能从undo log访问到修改前的数据。</p>
</li>
<li><p>事务的隔离级别：事务隔离级别定义了一个事务可能受其他事务影响的程度。1⃣️读未提交：可能脏读（读到其他事务未提交的修改）。2⃣️读已提交：不可重复度（事务内两次读到数据不一致）。3⃣️可重复度：默认的，幻读（可能读到第一次读没有的新纪录，行数不一致）。4⃣️串行化：事务串行执行，强制锁定事务访问的数据，锁竞争。（表级锁）</p>
</li>
<li><p>解决不可重复度：MVCC多版本并发控制，同一时刻不同事务读取到不同版本的数据。实现：隐藏列、undo log、版本链。每行数据多个隐藏列（版本号、删除时间、指向undo log的指针），undo log通过回滚指针把一个数据行所有快照连接起来形成一个版本链，使用事务版本号比较来控制数据版本。优点：避免加锁，允许读写操作并发执行。</p>
</li>
<li><p>mysql的锁：表锁、行锁（Innodb有，通过给索引项加锁实现，如果没有索引相当于表锁）。共享锁、排他锁。insert、update、delete操作innodb会自动给涉及到的数据加排他锁。select for update加排他锁。select lock in share mode加共享锁。</p>
</li>
<li><p>间隙锁：Innodb中的，用于锁定一个范围，不是固定的行数据。Innodb中可重复读及更高级别使用的锁机制。可以避免幻读，避免其他事务在该范围内插入。</p>
</li>
<li><p>意向锁：Innodb中的锁机制，用来事务获行锁之前表明锁定意图，分为意向共享锁和意向排他锁。意向锁是表级锁，获行锁之前先获取对应意向锁，不需要检查每行的锁状态，通过意向锁了解表的锁使用情况。意向共享锁不阻塞其他意向共享锁，意向排他锁不阻塞其他意向排他锁。意向共享锁（IS）或意向排他锁（IX）会阻塞整个表的排他锁。</p>
</li>
<li><p>快照读和当前读：快照读：执行普通的select查询，Innodb使用MVCC进行快照读，不加行锁，不会阻塞其他事务的读写操作，提供一致性的非阻塞读取。当前读：显式加锁select、update、delete，会对对应数据行加排他锁，获取数据的最新版本。</p>
</li>
<li><p>Innodp和Myisam：InnoDB支持事务处理、行级锁定和外键约束，适合于高并发和需要强数据完整性的应用。MyISAM拥有较高的读取速度和全文索引支持，但不支持事务处理，只有表级锁定。</p>
</li>
<li><p>Mysql索引：数据库表中一个特殊的数据结构，帮助提高数据检索速率。使用B树和B+树作为索引的数据结构。Innodb中主键索引使用聚簇索引，B+树叶子结点存储表的实际行数据。非主键索引使用B+树，叶子结点存储对应行主键而不是行数据本身。Myisam中都是非聚簇索引，B+树叶子结点存储行数据的指针。</p>
</li>
<li><p>Mysql索引缺点：空间成本、维护成本（数据插入删除更新时索引也需要更新，导致更新操作变慢）。索引通常以索引文件的形式存储在磁盘。</p>
</li>
<li><p>Mysql中有哪些索引：主键索引、唯一索引、普通索引、全文索引、空间索引、组合索引、外键索引</p>
</li>
<li><p>B树和B+树区别：都是多路搜索树，自平衡。B+树所有的值存储在叶子结点，并且形成有序链表，适合范围查询，内部节点存储键和指向叶子结点的指针。更胖更低，IO效率高。B树每个节点都存储键和值，对于点查询更为高效。</p>
</li>
<li><p>哈希索引：Memory存储引擎使用，基于内存。散列算法使用哈希表很快O(1)，适合等值比较查询，不适合范围查询。如果重复的键会哈希冲突。Innodb中自适应哈希索引。</p>
</li>
<li><p>红黑树：自平衡的二叉搜索树，节点要么红色要么黑色，根节点黑色，红节点的子节点都是黑色，叶子结点都是黑色空节点。通过旋转、重新着色来维持平衡。</p>
</li>
<li><p>聚簇索引和非聚簇索引：聚簇索引：数据存储和索引放在一块，索引结构的叶子结点保存了行数据（主键索引）、非聚簇索引：数据和索引分开，索引结构的叶子结点存储行数据的指针（辅助索引）。聚簇索引中，表中数据的物理顺序和索引顺序一致，所以一个表只能有一个聚簇索引。</p>
</li>
<li><p>最左前缀匹配：联合索引中，查询时使用的where子句中的条件必须包含联合索引中最左边的列索引才能生效，如果跳过或使用范围查询，则后面列不能有效使用索引。因为B+树是有序的。</p>
</li>
<li><p>sql语句执行过程：1.建立连接 2.mysql8.0查看是否开启缓存 3.解析器进行语法解析，生成解析树，检查语法正确 4.优化器生成执行计划，查看是否可优化。5.执行引擎执行sql。</p>
</li>
<li><p>数据库三范式：1.列不可分割 2.所有非主键字段都依赖于主键 3.所有非主键字段直接依赖于主键。</p>
</li>
<li><p>回表查询和覆盖索引：回表查询是普通索引，先定位主键，再定位行记录，扫描两遍索引树。覆盖索引是索引中包含了查询所需的所有字段，直接从索引中获取数据，不需要回表查询，减少磁盘IO。</p>
</li>
<li><p>explain：展示如何执行select语句：如何使用索引、表连接顺序、估计扫描行数。</p>
</li>
<li><p>数据库优化：1.建索引，where order by group by涉及的列建立索引。2.索引优化，最左匹配原则，不使用like “%abc”。3.建立分区，如时间字段4.利用缓存redis，缓存热数据5.查询限定数据范围，如查询一个月内的6.读写分离7.分库分表，垂直拆分水平拆分8.数据异构到es9.冷热数据分离10.升级OceanBase</p>
</li>
<li><p>无法使用索引：!&#x3D;、is null、or、&gt;&lt;、in、not in</p>
</li>
<li><p>mysql中char和varchar的区别：char是固定长度的字符串，即使存储数据短于设计长度，会用空格填充，所以可以快速查询。varchar可变长度的字符串，只占用必要空间加一个额外的长度字节，节省空间但影响查询性能。</p>
</li>
<li><p>delete和truncate：delete删除表时会增加大量undo日志和redo日志，truncate会立即删除表中所有数据，不能回滚，快速释放占用的空间。</p>
</li>
<li><p>mysql主从复制：主服务器将变更记录到二进制日志（binary log）文件，从服务器连接到主服务器后，请求从上次停止的位置开始传送日志，存到中继日志relay log，开线程重放。数据冗余、读写分离、高可用性。</p>
</li>
<li><p>主从复制的数据一致性问题：主从复制有延时，可能造成读到不一致的数据。根据数据复制到从服务器对主服务器事务提交的影响，分为：1.异步复制（写入二进制日志之后确认事务提交，从服务器落后于主服务器，不一致风险高）2.半同步复制（等待至少一个从服务器收到二进制日志，主服务器故障时可以找到这个从服务器成为主）3.同步复制（等待所有从服务器，较高的数据一致性）</p>
</li>
<li><p>mysql集群架构：1⃣️一主多从架构：写操作都主库，从库负责读。2⃣️多级复制架构：一主和多从之间增加一个master2主库，表都是空表，仅负责转发binlog。减轻主库负担。3⃣️双主架构：master1和master2互为主从。</p>
</li>
<li><p>mysql分库分表：将数据分散在多个数据库和表中。垂直拆分：按照表的列来进行拆分，将一个表分割成多个表。水平拆分：按照表的行进行拆分，用某个id做哈希取余进行分散。挑战：数据一致性、跨库或跨表的事务处理、数据迁移和重新分片等问题。解决：两阶段提交会锁定资源。XA协议。事务补偿。</p>
</li>
<li><p>跨库事务：tddl不支持跨库事务提交，强一致性需要使用切面事务实现。最终一致性可以用状态机+定时任务实现。</p>
</li>
<li><p>自增id：1.redis提供incr命令，单线程。2.雪花id：41位时间戳（毫秒，能用70年），10位机器标识，12位序列号。</p>
</li>
<li><p>分库分表之主键id：需要一个全局唯一的分布式id：1⃣️数据库自增长id，根据表的数量设置步长，但是不能扩表了。2⃣️redis incr&#x2F;incrby命令生成自增长id。数据存在内存，实例宕机可能丢数据。3⃣️uuid：本地生产不占用网络资源，缺点是太长，不具备有序性。适合用于编号。4⃣️雪花算法：有序增长，全局唯一。每秒可生成四百多万id。分三段：时间毫秒级、集群+机器id、序列号。可灵活分配比特位。缺点：强依赖机器时钟，可能导致发号重复。美团Leaf分布式id中，引入zookeeper，服务向zookeeper获取机器id，zookeeper检测时间是否正确。</p>
</li>
<li><p>mysql和Oracle的区别：1⃣️oracle数据库是一个重量级对象关系数据库管理系统（ORDBMS），收费的。mysql是一个轻量级开源的关系数据库管理系统（RDBMS），开源的免费的。2⃣️安全性上：oracle验证用户的参数有很多，有着较强的安全性，mysql验证用户的参数只有三个（用户名、密码、位置），安全性较弱。3⃣️对事务的支持：MySQL在innodb存储引擎的行级锁的情况下才可支持事务，而Oracle则完全支持事务。4⃣️mysql的诊断调优方法较少，主要有慢查询日志。Oracle有各种成熟的性能诊断调优工具。5⃣️并发性：mysql虽然InnoDB引擎的表可用行级锁，但行级锁机制依赖于表的索引，如果表没有索引，或者sql语句没有使用索引，将使用表级锁。Oracle使用行级锁，对资源锁定粒度更小，不依赖于索引。6⃣️应用：Oracle应用于大型复杂的企业级应用，性能、可伸缩性、可靠性更强大。mysql应用于中小型应用。</p>
</li>
<li><p>mysql当前读和快照读：1⃣️快照读是指读取数据不需要等待其他事务对数据锁的释放，通过MVCC允许读取数据的历史版本，提供一致性视图，实现了非阻塞的读。普通的select操作就是快照读，RR可重复读和RC读已提交下的select是快照读。2⃣️当前读：读取数据的最新版本，并对读取的数据加锁（行锁或间隙锁）。常用于需要修改数据的场景，例如update、delete、select for update。在串行化隔离级别下，即使普通select也是当前读。</p>
</li>
<li><p>索引优化：建立合适的联合索引，达到覆盖索引，尽量保持区分度高的在最左</p>
</li>
<li><p>mysql的delete文件大小不变：Innodb采用延迟空间回收，删除数据仅做标记，不立即回收磁盘空间，避免频繁磁盘操作。数据文件以数据页为单位组织。而且delete会记录redo和undo日志，消耗IO资源和存储空间。使用：Truncate table删除表的所有数据并初始化。drop重建表，删除后重建。</p>
</li>
<li><p>drop、delete、truncate：delete可回滚，会触发表上的触发器。truncate删除表中所有数据，不能回滚，更快，占用空间小。drop删除表，触发器不会触发。</p>
</li>
<li><p>适合&#x2F;不适合建立索引：适合：频繁使用的、用来缩小查询范围的、需要排列的。不适合：查询中很少涉及的、重复值比较多的、特殊的数据类型如text的。</p>
</li>
<li><p>mybatis是否支持延迟加载：延迟加载是用到数据时才进行加载，避免一次性加载大量关联数据，提高查询效率。配置文件中可以设置延迟加载，按需取材。底层使用CGLIB动态代理实现，创建目标对象的代理对象，目标对象是开启延迟加载的mapper所映射的实体类。通过字节码技术运行时生成代理类，调用目标方法时，进入拦截器的invoke方法，执行sql查询以获取关联数据，注入到对象属性中。</p>
</li>
</ul>
<h2 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h2><ul>
<li>Mybatis保证跨库数据一致性？：Mybatis是一个持久层框架，不直接提供跨库调用数据一致性的解决方案。需要借助外部分布式事务解决方案：分布式事务框架、两阶段提交、最终一致性、分布式事务中间件XA协议。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/23/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bjava2024/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/23/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bjava2024/" class="post-title-link" itemprop="url">那些年背过的面试题之java2024</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-23 00:44:10" itemprop="dateCreated datePublished" datetime="2025-07-23T00:44:10+08:00">2025-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-27 19:12:47" itemprop="dateModified" datetime="2025-07-27T19:12:47+08:00">2025-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><ul>
<li>jvm内存模型：线程共有：堆（对象实例和数组）、方法区（被虚拟机加载的类信息、方法信息、字段信息、常量、静态变量、即时编译器编译后的代码缓存）、直接内存（非运行时数据，IO操作）。线程私有：虚拟机栈（一个方法一个栈帧：局部变量表、操作数栈、动态链接、返回地址）、本地方法栈（native方法）、PC程序计数器（下一条指令位置的指针）</li>
<li>jmm内存模型：多线程环境下对共享变量的同步，保证多线程环境下的可见性、有序性。主内存和工作内存，可见性volatile线程更改了工作内存中的共享变量其他线程能够立马看到，有序性volatile禁止指令重排synchronized锁，原子性synchronized和CAS无锁的原子操作</li>
</ul>
<h2 id="锁、并发编程"><a href="#锁、并发编程" class="headerlink" title="锁、并发编程"></a>锁、并发编程</h2><ul>
<li><p>java有哪些锁：内置锁synchronized、重入锁ReentrantLock、读写锁ReadWriteLock、条件锁Condition</p>
</li>
<li><p>synchronized：内置锁，控制对共享资源访问的同步机制，修饰实例方法、静态方法、代码块，原理：对象头MarkWord，记录hashCode、锁标志、GC年龄。修饰代码块monitorenter和monitorexist字节码指令。修饰方法flags指令，锁的计数器。锁升级：无锁、偏向锁（记录线程指针）、轻量级锁（CAS自旋）、重量级锁（阻塞线程）</p>
</li>
<li><p>volatile：轻量级的synchronized，保证共享变量的可见性，读写操作直接对主内存进行，不会引起线程上下文的切换和调度。禁止指令重排。lock前缀指令，相当于内存屏障。保证原子操作线程安全。非原子操作不保证，用AtomicInteger、CAS。</p>
</li>
<li><p>CAS：无锁的原子操作，用来在并发编程中实现无锁同步。非阻塞的，减少锁开销。ABA问题，导致自旋，消耗CPU，只能一个变量的原子操作。</p>
</li>
<li><p>ReentrantLock：可重入的互斥锁，可重入、API层面锁、可响应中断、可公平不公平、Condition分离对象的等待集合。原理：队列同步器AQS，中volatile变量state记录锁的状态和重入次数，CAS操作更新状态变量和加入等待队列和更新队列头节点，FIFO队列管理等待锁的线程。</p>
</li>
<li><p>Condition：条件锁，与ReentrantLock结合使用，更精细控制等待唤醒，有选择地唤醒等待中的线程。</p>
</li>
<li><p>公平锁和非公平锁：公平锁所有线程都会被阻塞，非公平锁获锁之前不管等待队列，减少唤醒线程上下文切换开销。</p>
</li>
<li><p>RentrantLock如何实现公平非公平：子类 <code>FairSync</code> 和 <code>NonfairSync</code>。默认非公平锁，线程尝试直接获取锁，不考虑等待队列中的顺序。新到来的线程如果此时锁恰好可用，则可以直接获取锁，减少了上下文切换，提高了吞吐量。公平锁中，获取锁时会检查同步队列（AQS 队列）中是否有比当前线程等待时间更长的线程。如果有，则当前线程必须等待；如果没有其他线程或自己是队列中最前面的，则可以尝试获取锁。这样保证了最先进入等待状态的线程优先获得锁，遵循先来先服务的原则。</p>
</li>
<li><p>信号量Semaphore：控制对有限资源访问的计数器，实现资源池，控制并发数。permit为1时互斥锁。</p>
</li>
<li><p>闭锁CountDownLatch：用于等待一组线程都完成之后才继续操作，不可重用。</p>
</li>
<li><p>栅栏CyclicBarrier：一组线程互相等待都达到某个屏障点再继续执行，可重用。</p>
</li>
<li><p>读写锁ReadWriteLock：可同时读，写操作互斥，原理AQS，状态变量按位切割记录多个线程状态。锁降级：在释放写锁之前先获取读锁，避免在释放写锁和获取读锁之间其他线程修改变量，保证可见性。因为同一线程，所以允许获取读锁。</p>
</li>
<li><p>AQS：AbstractQueuedSynchronizer队列同步器，基于FIFO等待队列的同步框架，volatile和CAS实现同步状态管理，内置FIFO队列实现线程排队等待机制。构建各种阻塞性质的同步器。</p>
</li>
<li><p>锁优化：1.减小锁粒度：大锁变为不同的小锁来减少锁竞争提高并发，例如ConcurrentHashMap的分段锁。2.锁分离：读写分离ReadWriteLock读锁共享写锁独占。3.锁消除：不必要的不加锁，减少锁持有时间。4.锁粗化：短时间重复获取同一锁，将锁范围扩大，减少锁开销。5.使用无锁数据结构：CopyOnWriteArrayList，atomic下的原子类，volatile+cas，实现无锁的线程安全操作。</p>
</li>
<li><p>CopyOnWriteArrayList：线程安全的ArrayList。写时复制。读取的时候在当前数组进行，修改的时候，复制当前列表，在新列表上修改，然后将原列表引用指向新的列表。这个更新操作是原子性的，使用volatile 变量来存储底层数组的引用，写操作在读操作之前完成。</p>
</li>
<li><p>悲观锁和乐观锁：悲观锁认为冲突普遍存在，阻止并发访问保证一致性。乐观锁通过数据版本号来检测冲突，冲突之后撤销或重试。</p>
</li>
<li><p>死锁：多线程互相持有和等待对方的资源，形成循环等待。互斥条件、请求与保持条件、不可剥夺条件、循环等待条件。CAS破坏互斥条件，银行家算法分配资源之前先检查是否会死锁，破坏循环等待。</p>
</li>
<li><p>线程池：管理一系列线程的资源池，避免线程频繁创建销毁开销，提高响应速度。1.ThreadPoolExecutor构造函数创建（核心线程数、最大线程数、阻塞队列、最大线程存活时间、threadFactory、饱和策略）2.Executors工具类创建（不推荐，使用无界阻塞队列OOM，CachedThreadPool使用同步队列创建线程数无限制OOM）</p>
</li>
<li><p>线程池饱和策略：AbortPolicy抛出异常来拒绝、CallerRunsPolicy调用线程中运行、DiscardPolicy直接丢弃、DiscardOldestPolicy丢弃最早未处理的。</p>
</li>
<li><p>线程池阻塞队列：ArrayBlockingQueue基于数组结构的有界阻塞队列FIFO、LinkedBlockingQueue基于链表的无界阻塞队列、SynchronousQueue同步队列无容量、DelayQueue延迟无界阻塞队列，延迟期满时从队列取出、PriorityBlockingQueue支持优先级排序的无界阻塞队列。</p>
</li>
<li><p>线程池处理顺序：核心线程、任务队列、最大线程、饱和策略</p>
</li>
<li><p>ThreadPoolExecutor的execute和submit：1.execute是Executor方法，submit是ExecutorService方法。2.execute只接收Runnable，出现异常原地抛出。submit接收Runnable和Callable，返回Future，捕获异常在future.get方法中抛出。</p>
</li>
<li><p>happens-before：向程序员提供跨线程的内存可见性保证。volatile规则：对一个volatile的写happens - before后续对这个volatile的读。监视器规则：对一个锁的解锁happens - before随后对这个锁的加锁。线程生命周期规则：start、join。</p>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li>Thread的run方法和start方法：1.new一个Thread，调用start方法，表示启动一个线程，进入就绪状态，等待分配到时间片后运行。是多线程工作。2.直接执行run方法不会以多线程方式执行。</li>
<li>创建线程方式：1⃣️继承Thread类，重写run方法，创建对象调用start方法。2⃣️实现Runnable接口，重写run方法，创建对象作为参数传递给Thread的构造方法，调用start。或者传递给线程池的submit&#x2F;execute方法。3⃣️实现Callable接口，重写call方法，有返回，创建FutureTask对象，callable对象作为参数传递给FutureTask构造函数。将FutureTask对象作为参数传递给Thread构造函数，调用start。执行futureTask.get()方法获取线程执行的结果。</li>
<li>Runnable和Thread：1⃣️java单继承，Thread类有局限性。Thread类实现了Runnable接口。2⃣️Runnable更容易可以实现多个线程间的资源共享，提交给Thread同一个Runnable对象，共享其中的private对象。（只是共享，线程安全要加同步）。多个thread对象共享static变量。</li>
<li>Runnable和Callable：1.方法签名不同，Runnable是run方法，Callable是call方法。2.返回值类型不同，Runnable无返回，Callable的call方法返回指定类型结果，通过Future接口获取执行结果。3.异常处理不同：Runnable异常原地抛出，Callable的call方法通过Future.get方法来捕获异常信息。</li>
<li>线程状态：创建、就绪、运行、阻塞、等待、定时等待、终止。1⃣️start方法后等待JVM调度，就绪。调度到之后是运行。2⃣️运行到就绪：Thread.yield方法使线程从运行状态变为就绪状态，让出CPU资源给其他线程执行。3⃣️阻塞状态：线程运行过程中，发出I&#x2F;O请求时，该线程进入阻塞状态。当线程运行过程中尝试获取同步锁时，却被另一个线程获取，此时JVM把当前线程存到对象的锁池中，该线程进入阻塞状态。4⃣️阻塞到运行：获取到锁。5⃣️运行到等待：调用o.wait()方法和thread.join()方法（表示等待调用join方法的线程结束，当前线程才继续执行），进入等待状态。6⃣️定时等待：Thread.sleep方法进入等待状态，不释放锁。o.wait方法进入等待状态，释放同步锁，wait方法需要在同步方法&#x2F;代码块中。7⃣️notify方法唤醒在此对象监视器上等待的单个线程，进入就绪状态。</li>
<li>进程和线程：进程是操作系统资源分配的基本单元。线程是处理器任务调度和执行的基本单元。多个线程共享进程的堆和方法区，不共享栈和程序计数器。</li>
<li>ThreadLocal：是线程局部变量，线程私有，实现线程之间的数据隔离，避免使用共享变量的线程安全问题。注意在线程池中，线程被复用，需要及时清理，避免内存泄漏。</li>
<li>ThreadLocal和ThreadLocalMap的关系：ThreadLocalMap是ThreadLocal的内部数据结构，每个Thread对象有一个ThreadLocalMap对象，用于存储线程局部变量的键值对，键是ThreadLoca对象，值是ThreadLocal对象存的局部变量。每个线程可以有多个ThreadLocal对象。</li>
<li>ThreadLocal为什么内存泄露：每个线程的ThreadLocalMap，key是ThreadLocal对象（弱引用），value是存入的值（强引用）。ThreadLocal对象作为key是弱引用，外部强引用消失后，GC直接回收，但value还被强引用锁死。线程池中的线程反复利用，ThreadLocalMap跟着长寿。Map里的废弃物品（null key + value）越积越多，直到OOM。不调用set&#x2F;get&#x2F;remove，ThreadLocalMap不会自动清理null key的Entry。</li>
<li>ThreadLocal为什么不用强引用：用强引用→ThreadLocal对象永不回收，泄漏更严重！弱引用至少能回收key，给程序员一个补救机会。所以，用完必须要remove。线程结束会自动清理，但是线程池中的线程永不结束。</li>
<li>ThreadLocalMap如何清理：当一个线程终止时，该线程的 <code>ThreadLocalMap</code> 会随着线程对象一起被垃圾回收器自动清理。在 <code>set(T value)</code> 和 <code>get()</code> 操作中，如果发现某个 <code>Entry</code> 的 <code>key</code> 已经为 <code>null</code>（即 <code>ThreadLocal</code> 被垃圾回收了），那么这个 <code>Entry</code> 会被从 <code>ThreadLocalMap</code> 中移除。对于长时间运行的线程或线程池中的线程，如果不主动清除不再需要的 <code>ThreadLocal</code> 变量，可能会导致内存泄漏，因为 <code>ThreadLocalMap</code> 中的值是强引用类型的，即使对应的 <code>ThreadLocal</code> 实例已经被垃圾回收了（<code>ThreadLocalMap</code> 的键为弱引用），只要线程还在运行，这些值就不会被释放。线程池中，在finally中使用<code>threadLocal.remove();</code>手动清理。</li>
</ul>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><ul>
<li>SPI：service provider interface，服务加载机制，META-INF中配置接口和实现，ServiceLoader运行时发现和加载实现，可动态替换服务实现。提供可扩展的方式，使得第三方服务可以提供新的实现或自定义功能，解耦接口和服务实现。应用：JDBC驱动加载，日志框架选择。</li>
</ul>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><ul>
<li>IO：涉及到数据的存储、交换，都用IO，文件IO、网络IO</li>
<li>BIO：同步阻塞IO，每来一个新连接就需要创建一个线程，数据的读取写入都需要阻塞在线程中。浪费线程资源，不适合单机过多连接。</li>
<li>NIO：同步非阻塞IO，线程发起IO操作，如果数据还没准备好，可立即返回执行其他任务。数据写入读取不再阻塞，但是需要等待IO操作完成，可同时处理多个Socket请求。适用连接多且比较短的。</li>
<li>NIO多路复用：背景：应用程序询问数据是否就绪需要系统调用。因此为了解决频繁系统调用，一次向内核传递多个需要询问的Socket是否就绪（Seletor）。select、poll实现多路复用的机制，监控多个网络连接的IO事件，poll没有最大连接数限制。epoll提供了更高效的事件通知机制，在内核态开辟了两个集合，空间换时间，不需要每次传入整个Socket集合，减少拷贝，不需要主动地对所有文件描述符进行轮询。（单线程监控多个网络通道，轮询通道是否准备好，epoll通道准备好时得到通知）</li>
<li>epoll：1⃣️epoll_create:在内核申请一块内存区域用于存储需要监控的fd，红黑树存储。2⃣️epoll_ctl:将需要监控的fd添加到创建的集合中。3⃣️epoll_wait:调用epoll_wait以等待事件发生，这个调用会阻塞直到有事件发生，或者超时。返回就绪的fd集合，链表存储。开发者只需要遍历这个列表并处理每个事件。</li>
<li>IO多路复用的多线程版本：一个线程监听新连接的接入。若干个线程负责多个Socket的读写。</li>
<li>AIO：异步非阻塞IO，jdk1.7升级，发起IO请求后立即继续执行后续代码，不需要等待IO操作完成。完成通过回调事件通知来告知调用者。windows中操作系统实现，Linux中使用自建线程池实现。</li>
<li>Socket；网络通信基本概念，两程序连接进行数据交换</li>
<li>Channel：能进行读写操作的IO通道。</li>
<li>Selector：可以监视多个Channel的IO事件。Channel注册在Selector上，允许单线程管理多个网络连接。</li>
<li>FD：Linux中一切皆文件。无论文件、Socket、设备文件。File Descriptor文件描述符，看作文件的id。进程级别的资源句柄，提供访问文件的抽象层。</li>
<li>Linux系统分三层：User、Kernel、Hardware</li>
<li>用户态和内核态：内核态是控制计算机硬件资源，例如协调CPU分配内存空间。用户态是提供应用程序运行的空间。内核提供的一组通用的访问内核管理资源的接口是系统调用。系统调用需要内核态和用户态的切换，涉及到CPU中断、堆栈切换、寄存器保存。</li>
</ul>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><ul>
<li><p>死亡对象判断方法：1.引用计数法：给对象加一个引用计数器，被引用+1，引用失效-1，无法解决循环引用问题。2.可达性分析法：GC Root作为起始点，从它们向下搜索，走过的路径叫做引用链，一个对象与所有GC Root都不相连，需要被回收。</p>
</li>
<li><p>可达性分析中的两次标记：可达性分析中不可达的对象，并不是非死不可，而是缓刑，需要两次标记。一次标记筛选是否需要执行finalize方法，需要进入下一次标记。第二次标记查看对象finalize方法中对象是否被其他存活的对象引用，如果是那么该对象将变成可达的。finalize用来做外部资源清理，被try finally取代。</p>
</li>
<li><p>垃圾收集算法：1⃣️标记清除：标记要回收的对象，然后统一回收。会产生不连续的内存碎片。2⃣️标记复制：young使用，内存分为两块儿，一块儿使用完后，将存活的复制到另一块儿，然后清除。内存压缩一半，复制效率低。3⃣️标记整理：old使用，把存活对象向一端移动，然后清除边界外的内存。解决不连续内存碎片，但是移动存活对象并更新引用负担大。停顿时间长。4⃣️分代：新生代：每次存活对象较少，复制操作少，用标记复制，新生代分为较大的eden和两个较小的survivor，每次使用eden和一块儿survivor，回收时将存活对象复制到另一块儿survivor。回收时不用中断应用程序执行，避免碎片化问题。老年代存活率较高，没有额外空间分配担保，选用标记清除&#x2F;标记整理。</p>
</li>
<li><p>eden、survivor、old分配顺序：对象优先在eden区分配，大对象和长期存活的对象进入老年代。一次minor gc之后存活在survivor中的对象1岁，此后每在survivor中熬过一次minor gc就+1岁，达到阈值或一半超过同一年龄就晋升老年代。</p>
</li>
<li><p>空间分配担保：在minor gc之前，虚拟机检查老年代的最大可用连续空间是否大于新生代所有对象总空间，如果成立，minor gc安全。如果不成立，看虚拟机是否允许担保失败，允许的话检查之前历次晋升老年代对象的平均大小，如果大于则尝试minor gc。如果小于或不允许担保失败直接full gc。</p>
</li>
<li><p>几个gc：1⃣️minor gc：也叫young gc，在新生代空间不足时触发。2⃣️major gc：老年代空间不足时触发，通常涉及整个堆的回收。CMS中不会停止所有线程。3⃣️full gc：停止应用程序执行，整个堆和方法区的垃圾收集。老年代不足、元空间不足、显示调用System.gc、担保失败。</p>
</li>
<li><p>垃圾收集器CMS：Concurrent Mark Sweep，jdk8的，关注最短垃圾回收停顿时间，老年代使用多线程的标记清除算法。第一次实现垃圾收集与用户线程同时工作，第一款真正意义上的并发收集器。新生代使用标记复制ParNew 垃圾收集器，Serial收集器的多线程版本。1⃣️初始标记：暂停所有其他线程，标记所有直接与GC Roots相连的对象，速度很快。2⃣️并发标记：从根对象开始，遍历对象图，标记所有存活的对象。3⃣️重新标记：修正并发标记期间发生变动的对象引用，停顿。4⃣️并发清除：对未标记的对象进行清除。优点：并发、低停顿。缺点：对CPU资源敏感、无法处理浮动垃圾、产生内存碎片。</p>
</li>
<li><p>垃圾收集器G1：Garbage-First，jdk9的，精准控制停顿时间，G1整体来看是标记整理，局部来看是标记复制。保留分代的概念，把堆分为若干固定大小的region，每个region扮演eden、survivor、old，维护优先级列表，每次根据允许的收集时间，优先选择垃圾最多的区域回收。不再固定收集某个区域，而是灵活组成回收集。1⃣️初始标记：暂停工作线程，标记从GC Roots直接可达的对象。2⃣️并发标记：遍历对象图，标记所有存活的对象。3⃣️最终标记：修正在并发标记阶段由于应用程序继续运行导致标记信息变化的部分。4⃣️筛选回收：制定回收计划，构成回收集，把存活对象复制到空的region中，再清理旧的region。涉及到存活对象移动，需要暂停工作线程。这里多条收集器线程并行完成。</p>
</li>
<li><p>CMS和G1：1.专注不同：CMS专注于并发清除低延迟，只需处理老年代到新生代的引用，会内存碎片。G1指定最大停顿时间，分Region的内存布局，按收益动态确定回收集，不会产生内存碎片。2.小内存CMS占优，大内存G1占优，分界线6-8G。3.CMS分配大对象空间不足时full gc，G1期望停顿时间设置很小，垃圾回收赶不上分配时full gc。</p>
</li>
<li><p>垃圾收集器ZGC：jdk11的，低延迟垃圾收集。基于Region内存布局，不设分代，使用读屏障、染色指针，实现并发标记整理。着色笔：在对象头中增加额外内存，加快标记过程。读屏障：解决垃圾回收和应用程序同时进行时，应用程序读取到被回收的对象。在对象头部增加标识位表示对象是否正在被垃圾收集器访问。</p>
</li>
<li><p>java对象引用：1.强引用：传统的引用，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。2.软引用：用于维护一些可有可无的对象。只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。3.弱引用：拥有更短的生命周期，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。4.虚引用：一种形同虚设的引用，它主要用来跟踪对象被垃圾回收的活动。</p>
</li>
<li><p>jvm调优从哪里入手：1⃣️堆内存设置，-Xms设置初始堆大小，-Xmx设置最大堆大小，过小导致频繁的垃圾回收和OOM，过大导致长时间的垃圾回收停顿。2⃣️垃圾收集器选择，串行、并行、CMS、G1回收器，衡量指标：内存占用、吞吐量、延迟。监控GC活动：使用监控工具：jstat、VisualVM、YourKit和GC日志。3⃣️线程堆栈大小：-Xss调整，影响栈深度。4⃣️调优代码、调整元空间的大小，排查内存泄漏风险、系统级优化（CPU、内存、磁盘IO）。</p>
</li>
</ul>
<h2 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h2><ul>
<li>jvm排查线程cpu问题：1.ps -ef|grep java 或者 jps 查找出进程id。2.top -Hp 进程id 查找出最耗cpu的线程id。 top -c看进程的。3.printf “%x\n” 线程id ，转换为16进制的id。4.使用jstack 进程id | grep 16进制线程id 查找出堆栈信息，分析。另外，arthas也可以打印出前多少个线程及占有cpu情况thread -n 5。</li>
<li>jvm性能监控工具：1⃣️jps：输出jvm中运行的进程状态信息。2⃣️jstack：生成 Java 进程的线程堆栈信息，用于分析线程状态和死锁等问题。jstack 进程id | grep 16进制线程id。3⃣️jstat：JVM统计监测工具，排查gc，jstat -gc 进程id 250 4。4⃣️jmap和jhat：生成 Java 内存快照，分析内存使用和内存泄漏。用jmap把进程内存使用情况dump到文件中，再用jhat分析查看。</li>
<li>机器慢了怎么排查：CPU、内存、磁盘、磁盘IO、网络IO。</li>
<li>排查工具：1.df -h查看磁盘使用情况。2.free -h &#x2F; vmstat显示系统内存使用情况。3.mpstat命令查看cpu使用情况，输出各种cpu时间百分比。4.netstat -s查看网络状态，显示各种网络协议的统计信息，接收发送数据包数等。5.iostat -x查看IO统计信息。6.top命令实时显示Linux系统中进程的动态运行信息，包括CPU和内存的使用情况。top -Hp $pid用于显示特定进程的线程信息。</li>
<li>OOM排查：除了程序计数器，其他内存存储都可能OOM。原因：1.内存泄漏：程序未能释放不再使用的内存。2.Java堆分配空间不足导致内存溢出。排查：使用jmap -dump命令dump文件，在内存分析工具如VisualVM、MAT中观察对象引用关系、对象数量大小。可能未正确释放资源、关闭文件流、断开网络连接、销毁对象引用。定位到代码排查。</li>
<li>jvm调优：分配jvm内存需要考虑应用需求，是否处理大量数据。考虑垃圾收集器。16g机器将JVM最大堆内存设置为12G（Xms12G -Xmx12G），使用G1垃圾收集器。元空间存储类的元数据，设置初始值256M，最大值512M。线程堆栈大小，几百KB到1MB，取决于有没有深层递归（-Xss256k）。</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li><p>ArrayList和LinkedList：ArrayList基于动态数组，连续内存，适合遍历和查找元素，不适合增删，增删创建新数组。LinkedList基于双向链表，适合增删，不适合随机查找。</p>
</li>
<li><p>HashSet和TreeSet：HashSet底层基于HashMap。TreeSet基于红黑树，元素处于排序状态，支持有序集合操作。</p>
</li>
<li><p>队列：Queue接口是FIFO队列，Deque扩展Queue是双端队列接口。ArrayDeque是Deque的实现，双端队列。LinkedList也是Deque的实现，可以做双端队列。Stack栈，继承自Vector。Vector是同步集合，使用synchronized。</p>
</li>
<li><p>HashMap：数组+链表+红黑树。链表长度&gt;8数组长度&gt;64时变红黑树。链表解决哈希冲突，bucket。键和值都允许为空。</p>
</li>
<li><p>HashMap为什么使用红黑树：哈希函数质量不高&#x2F;存储大量数据，链表变长，影响搜索效率。所以jdk8之后，链表长度超过8时，链表变红黑树，自平衡的二叉查找树，搜索元素时间复杂度O(logn)，提高搜索效率。</p>
</li>
<li><p>HashMap扩容底层数组为什么扩为两倍保持2的幂次：1.方便利用位运算替代取模运算来计算元素索引位置。2.减少冲突：二进制位增加一位，只看最高位要么移动要么不变，确保分布均匀。 </p>
</li>
<li><p>ConcurrentHashMap：线程安全的HashMap，jdk7使用分段锁，分16段，一段一把锁。jdk8使用synchronized和CAS保证线程安全。</p>
</li>
<li><p>如何提高链表查询效率：1.使用双向链表。2.使用跳表，在链表上增加多级索引。3.元素存到哈希表进行映射。</p>
</li>
<li><p>B+树：索引数据记录在叶子结点，形成有序链表，方便范围查询。极端退化形成链表。具有更低的树高，降低磁盘寻址次数，减少IO次数。</p>
</li>
<li><p>跳表：skip list，分层结构多级链表，随机化的数据结构，用于存储有序元素。提供对数时间复杂度。每一层都是下一层的快照，只包含部分元素，每层元素通过指针相连。查找先从顶层查找，从而快速跨越多个不必要元素。应用：redis中zset使用hash+跳表。</p>
</li>
<li><p>大顶堆小顶堆：基于完全二叉树（除最底层外每一层都是满的，最底层从左向右填充），层序遍历用数组表示，用来实现优先队列。大顶堆中父节点大于子节点，根节点最大，同层没有顺序。</p>
</li>
<li><p>LRU：最近最久未使用。实现：1.链表，头部是要淘汰的，每次页面访问将页面移动到链表尾部。2.哈希表+双向链表，哈希表用来快速查找页面对应的链表节点。3.时间戳：每个页面分配时间戳，被访问时更新时间戳。</p>
</li>
<li><p>操作系统的页面淘汰算法：1.FIFO先进先出，使用队列。2.LFU最不常用，使用计数器跟踪每个页面访问次数，每次淘汰访问次数最少的，不考虑时间局部性。3.LRU最近最久未使用。4.时钟算法clock，LRU近似实现，维护循环列表。</p>
</li>
<li><p>八种基本数据类型及封装类：byte有符号整数（8bit，-128-127）、short有符号16bit整数、int有符号32bit整数、long有符号64bit整数、float32bit单精度浮点数、double64bit双精度浮点数、char16bit的unicode字符、boolean</p>
</li>
<li><p>装箱和拆箱：装箱：基本数据类型自动转换为对应封装类对象（编译器转换为Integer.valueOf）。拆箱：封装类对象自动转换为基本数据类型（编译器转换为o.intValue()）。</p>
</li>
<li><p>String、StringBuilder、StringBuffer：1⃣️String是不可变的，每次修改都是创建一个新的对象，性能较低。2⃣️StringBuilder可变，内部维护一个自动扩容的字符串数组，不是线程安全的。3⃣️StringBuffer可变，线程安全的，synchronized。</p>
</li>
<li><p>String不可变的设计原理：1⃣️内部使用私有的final字符数组存储字符串数据，创建之后引用不会指向另一个数组。2⃣️虽然数组本身可变，但是String没有提供方法修改数组内容。3⃣️虚拟机维护字符串池，相同内容的字符串可共享同一内存地址。创建时首先检查字符串池是否有相同内容字符串对象，有则返回引用。</p>
</li>
<li><p>String不可变的好处：1⃣️安全性：防止被恶意修改导致的安全漏洞。2⃣️线程安全：String对象本身线程安全。指向String对象的引用变量不是。3⃣️实现字符串常量池成为可能，重用字符串，节省内存开销。4⃣️创建字符串的哈希码缓存：字符串不可变，哈希码也不会变，适合作为键使用在哈希表中HashMap。</p>
</li>
<li><p>HashMap和TreeMap：HashMap基于哈希表，使用哈希函数提供O1的快速访问，不保证元素顺序。数组+链表&#x2F;红黑树。TreeMap基于红黑树，键值对按照键的自然顺序或指定比较器顺序Ologn复杂度排序。两者都是非线程安全的。</p>
</li>
<li><p>反射怎么创建对象：1⃣️Class的newInstance方法为无参构造器的类创建：Class&lt;?&gt; clazz &#x3D; Class.forName(“com.Demo”); Object o &#x3D; clazz.newInstance(); 2⃣️先获取Constructor，再newInstance。可以获取指定构造参数的构造器。3⃣️私有方法，可以constructor.setAccessible(true); 来设置可访问。</p>
</li>
<li><p>ArrayList 和 LinkedList怎么线程安全：1⃣️使用Collections.synchronizedList(list)将任何List转换为线程安全的List。（所有操作都使用相同的对象锁进行同步）。2⃣️使用显式的同步块，每次访问操作时加相同的锁。3⃣️使用concurrent包中的并发集合，CopyOnWriteArrayList，写时复制，适用于遍历操作远多于修改操作。ConcurrentHashMap、ConcurrentLinkedQueue。</p>
</li>
<li><p>java.util.concurrent包下有哪些：1⃣️Executor：线程调度框架：任务Runnable，Callable、任务执行ExecutorService，ThreadPoolExecutor ScheduledThreadPoolExecutor、异步计算结果Future，FutureTask。2⃣️同步器：CountDownLatch，CyclicBarrier，Semaphore。3⃣️并发集合：ConcurrentHashMap，ConcurrentLinkedQueue，CopyOnWriteArrayList，CopyOnWriteArraySet，以及支持阻塞的线程安全队列ArrayBlockingQueue等。4⃣️原子变量AtomicInteger等。5⃣️锁Lock：ReentrantLock，ReadWriteLock。</p>
</li>
<li><p>重写 <code>equals()</code> 时必须重写 <code>hashCode()</code>：是为了保证 <strong>相等的对象必须有相同的哈希码</strong>，这是 Java 的约定。否则在使用 <code>HashMap</code>、<code>HashSet</code> 等哈希结构时，会导致对象无法正确存取或比较，引发逻辑错误。</p>
</li>
</ul>
<h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><ul>
<li>java异常体系：一个以Throwable类为根的类层次结构，两个分支：1⃣️Error和Exception。Error错误代表了JVM无法预期或难以恢复的严重问题，比如OOM、StackOverflowError、线程死锁等，一般无需捕捉。Exception异常包括：2⃣️Checked Exceptions受检异常，又叫编译时异常，在编写可能会抛出它们的方法时需要显式地进行处理（通过try-catch块）或声明（通过throws关键字），这些异常通常是外部错误，如文件未找到（FileNotFoundException）、网络问题（IOException）、SQL异常等。3⃣️Unchecked Exceptions非受检异常，又叫运行时异常，包括RuntimeException及其子类，不需要显示处理或声明，通常是程序错误，例如数组越界、空指针。</li>
</ul>
<h2 id="变量修饰"><a href="#变量修饰" class="headerlink" title="变量修饰"></a>变量修饰</h2><ul>
<li><p>static：静态</p>
<ul>
<li>应用于变量：静态变量或类变量，变量属于类而不是对象，所有该类的对象共享同一个静态变量。</li>
<li>应用于方法：静态方法，表示该方法属于类，可以不依赖于对象实例被调用。只能访问static变量和方法。</li>
<li>定义静态代码块：在类被加载到JVM时仅执行一次，常用于初始化静态变量。</li>
<li>应用于类：只能用来修饰内部类，可以不依赖于外部类的实例被创建和使用，可以访问外部类的所有静态成员和静态方法。</li>
</ul>
</li>
<li><p>final：常量，用于创建不可变对象、防止方法或类被更改</p>
<ul>
<li>修饰变量：表示该变量一旦被初始化后就不能被修改，对于基本数据类型，变量的值不能改变，对于引用类型，变量不能再指向另一个对象，但所指向的对象内容本身可以变化。</li>
<li>当final应用于方法时，该方法不能被子类覆盖（重写）。</li>
<li>当final应用于类时，它表明该类不能被继承。</li>
</ul>
</li>
<li><p>类加载机制：运行时动态加载，类加载器（ClassLoader）负责将类的字节码Class文件从不同的来源（例如文件系统、网络等）加载到Java虚拟机中。1⃣️加载阶段：类加载器读取二进制数据（.class文件）并生成对应的java.lang.Class对象。2⃣️验证：确保加载的类的字节码是合法的，检查字节码的格式、语法、数据流、符号引用等。3⃣️准备：为类变量分配内存并初始化为默认值，方法区中分配。4⃣️解析：将常量池内的符号引用转换为直接引用的过程。5⃣️初始化：执行静态变量的赋值操作和静态代码块内的代码。</p>
</li>
<li><p>符号引用和直接引用：符号引用就是一组符号来描述所引用的目标，直接引用就是直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。</p>
</li>
<li><p>java编译阶段和运行阶段：编译阶段是源代码（.java文件）被编译器转换成字节码（.class文件）的过程，由Java编译器（ javac）负责。运行阶段是将.class 文件加载到JVM并执行的过程。类加载在运行阶段，支持运行时绑定（或晚期绑定），是Java动态链接和多态的基础。</p>
</li>
<li><p>常量池：运行时常量池位于方法区。它是类文件中每个类或接口的常量池表的运行时表示，用于存储编译器生成的字面量和符号引用。字符串常量池最初位于方法区，在Java 7以后被移到堆内存。它是一种特殊的常量池，用于存储字符串字面量和引用，目的是避免重复创建相同内容的字符串对象，以节省内存和提升性能。</p>
</li>
<li><p>双亲委派模型：JVM中的双亲委派是一种类加载机制，通过一层一层的父子关系将类的加载工作委派给上层的ClassLoader。这种机制的目的是为了避免类的重复加载，保证类的加载安全和类的共享。</p>
</li>
<li><p>想加载两个全路径相同的类：1.使用不具有父子关系的类加载器。2.打破双亲委派模型，自定义类加载器，并重写 loadClass() 方法，改变类加载的委派逻辑。</p>
</li>
<li><p>java接口中可以有非抽象方法吗：非抽象方法即具体实现的方法，java8之前只能包含抽象方法。java8引入了默认方法和静态方法。默认方法：default修饰。静态方法：static修饰，可以通过接口名直接调用。java9还提供了private私有方法。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/23/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bjava2025/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/23/myblog/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bjava2025/" class="post-title-link" itemprop="url">那些年背过的面试题之java2025</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-23 00:44:10" itemprop="dateCreated datePublished" datetime="2025-07-23T00:44:10+08:00">2025-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-27 19:09:21" itemprop="dateModified" datetime="2025-07-27T19:09:21+08:00">2025-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">那些年背过的面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Reactor响应式编程和Reactor线程模型"><a href="#Reactor响应式编程和Reactor线程模型" class="headerlink" title="Reactor响应式编程和Reactor线程模型"></a>Reactor响应式编程和Reactor线程模型</h2><p>Reactor 是一个响应式编程库，提供了非阻塞、高效的异步数据流处理能力。Project Reactor应用于Spring生态系统（Spring WebFlux），用于处理 HTTP 请求和响应的异步流式数据。</p>
<p><strong>特点</strong>：<br>非阻塞：通过事件驱动的方式处理数据流，避免线程阻塞。<br>背压支持：允许消费者控制生产者的速率，防止资源过载。<br>高效性：适合高并发场景，能够更好地利用系统资源。<br>函数式风格：提供丰富的操作符，可以通过链式调用对数据流进行转换和处理。</p>
<p><strong>适用场景</strong>：响应式系统（如 Spring WebFlux）、数据流处理（如实时日志分析、事件流处理）。</p>
<p>Reactor 提供了<strong>两个核心类</strong>：<br>Flux：表示可以发射 0到N个元素 的异步数据流。<br>Mono：表示可以发射 0或1个元素 的异步数据流。<br>Flux 是 Reactor 中的一个核心类，用于表示可以发射多个元素的异步数据流。发射 0到N个元素，并最终以完成或错误信号结束。Flux 提供了丰富的操作符，可以轻松地对数据流进行转换、过滤、合并和错误处理。<br>——————————————————————<br>Reactor线程模型：一种经典的IO多路复用设计模式，用于高效处理大量并发连接。核心思想是通过一个或多个线程监听 I&#x2F;O 事件（如读写就绪），并将这些事件分发给相应的处理器进行处理。</p>
<p><strong>特点</strong>：<br>事件驱动：通过监听 I&#x2F;O 事件（如 select、poll 或 epoll）来避免阻塞等待。<br>单线程或多线程模型：单线程 Reactor 模型：所有事件由一个线程处理。多线程 Reactor 模型：使用多个线程来处理事件，适合高并发场景。<br>非阻塞 I&#x2F;O：避免因等待 I&#x2F;O 操作完成而阻塞线程，从而提高吞吐量。</p>
<p><strong>典型实现</strong>：Java NIO、Netty 等框架基于 Reactor 模型构建。</p>
<p><strong>核心组件</strong>：<br>Acceptor：负责接收新的连接请求，并将其注册到事件监听器中。<br>Dispatcher：负责监听 I&#x2F;O 事件并分发给对应的处理器。<br>Handler：处理具体的业务逻辑。</p>
<p><strong>适用场景</strong>：高并发网络服务（如 Web 服务器、消息队列等）、需要高效处理大量短连接或长连接的场景。<br>——————————————————————<br>Project Reactor和Reactor线程模型的联系：<br>**Project Reactor 提供了更高层次的抽象，专注于业务逻辑的响应式处理，而 Reactor线程模型则更关注底层 I&#x2F;O 事件的分发，处理网络层IO。**都是非阻塞的，都是事件驱动的。</p>
<h2 id="record关键字"><a href="#record关键字" class="headerlink" title="record关键字"></a>record关键字</h2><p>record：一种用于<strong>定义不可变数据载体类</strong>的特殊类形式，是 Java 14 引入的一个关键字，正式在 Java 16 标准化。</p>
<p>record 是<strong>一种简化数据类的语法，目的是存储数据而不对这些数据进行复杂的操作或修改的场景。自动生成了包括构造函数，getter、toString、equals、hashCode 等方法。</strong></p>
<p>它是一种不可变（Immutable）的类，所有字段都是 final，创建后状态不能更改。</p>
<p><strong>用法</strong>：<br>1、作为独立的类文件<br><code>public record Film(String name, String desc) &#123;&#125;</code></p>
<p>2、嵌套在其他类中，类似静态内部类<br><code>public static record Film</code></p>
<p>3、方法内部<br>从 Java 16 开始，record 可以被定义为局部类（即在方法内部定义）。这种用法适合<strong>仅在某个方法中使用的临时数据结构</strong>。直接record Film</p>
<p>PS：静态内部类和非静态内部类：静态内部类不依赖于外部类的实例，可以直接通过外部类名访问。只能访问外部类的静态成员。非静态内部类依赖于外部类的实例，必须通过外部类的实例来创建。可以访问外部类的所有成员，因为内部类持有一个对外部类实例的隐式引用。</p>
<h2 id="线上redis机器爆了，如何优化"><a href="#线上redis机器爆了，如何优化" class="headerlink" title="线上redis机器爆了，如何优化"></a>线上redis机器爆了，如何优化</h2><p>如果在生产环境中发现 Redis 出现异常，比如内存爆了或者响应变慢，首先通过 Redis 的 INFO 命令（<strong>redis-cli info</strong>）和监控平台查看当前的资源使用情况，确认是<strong>内存、CPU、连接数还是某个慢查询</strong>引起的。</p>
<p>如果是** Big Key **（存储的数据体积很大，如一个Hash包含上万个字段）或者热 Key 造成的，我会进行数据结构优化、拆分 Key、引入本地缓存；如果是连接数过高，我会检查连接池配置，适当增加连接池大小或引入连接复用。</p>
<p>如果是 QPS 过高导致 Redis 成为瓶颈，我会考虑引入<strong>Redis 集群、读写分离、或者对热点数据进行缓存</strong>。</p>
<p>此外，我也会加强缓存的<strong>失效策略</strong>、防止缓存穿透和击穿，并结合布隆过滤器等手段保护后端数据库。</p>
<h2 id="spring声明式事务-Transactional"><a href="#spring声明式事务-Transactional" class="headerlink" title="spring声明式事务@Transactional"></a>spring声明式事务@Transactional</h2><p>在Spring中事务管理的方式有两种，编程式事务和声明式事务。编程式事务将业务代码和事务代码耦合到一块，当发生异常的时候还得需要手动回滚事务，不优雅。</p>
<p>声明式事务：<strong>基于AOP，设置好切点，当我们调用事务方法时，会调用到生成的代理对象，代理对象中加入了事务提交和回滚的逻辑。当方法执行成功时提交事务，当方法发生异常时回滚事务。</strong></p>
<p>@Transactional可以用在类，方法，接口上：</p>
<ol>
<li>用在类上，该类的所有public方法都具有事务</li>
<li>用在方法上，方法具有事务。当类和方法同时配置事务的时候，方法的属性会覆盖类的属性</li>
<li>用在接口上，一般不建议这样使用，因为只有基于接口的代理会生效，如果Spring AOP使用cglib来实现动态代理，会导致事务失效（因为注解不能被继承）</li>
</ol>
<p><strong>@Transactional失效的场景</strong></p>
<ol>
<li>@Transactional注解应用到非public方法（除非特殊配置，例如使用AspectJ 静态织入实现 AOP）</li>
<li>自调用，因为@Transactional是基于动态代理实现的，自调用时，方法执行不会经过代理对象</li>
<li>异常在代码中被你自己try catch了，不抛异常进入不了回滚的逻辑</li>
<li>异常类型不正确，默认只支持RuntimeException和Error，不支持检查异常，如果抛出任何异常都回滚，可以配置rollbackFor为Exception</li>
<li>事务传播配置不符合业务逻辑</li>
</ol>
<p><strong>为什么只有public方法上的@Transactional注解才会生效？</strong></p>
<p>首先JDK动态代理肯定只能是public，因为接口的权限修饰符只能是public。cglib代理的方式是可以代理protected方法的（private不行，子类访问不了父类的private方法）如果支持protected，可能会造成当切换代理的实现方式时表现不同，增大出现bug的可能性，所以统一一下。</p>
<p>Transactional的事务传播行为默认为Propagation.REQUIRED。<strong>「如果当前存在事务，则加入该事务。如果当前没有事务，则创建一个新的事务」</strong></p>
<p>Propagation.REQUIRES_NEW**「创建一个新事务，如果当前存在事务，则把当前事务挂起」**</p>
<h2 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h2><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2132083">https://cloud.tencent.com/developer/article/2132083</a></p>
<h2 id="什么是零拷贝"><a href="#什么是零拷贝" class="headerlink" title="什么是零拷贝"></a>什么是零拷贝</h2><h2 id="Redis字典的实现方式和冲突处理"><a href="#Redis字典的实现方式和冲突处理" class="headerlink" title="Redis字典的实现方式和冲突处理"></a>Redis字典的实现方式和冲突处理</h2><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2329632">https://cloud.tencent.com/developer/article/2329632</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/12/myblog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%A5%BF%E7%93%9C%E4%B9%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/12/myblog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%A5%BF%E7%93%9C%E4%B9%A6/" class="post-title-link" itemprop="url">西瓜书</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-02-12 21:55:33 / Modified: 22:01:29" itemprop="dateCreated datePublished" datetime="2025-02-12T21:55:33+08:00">2025-02-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><ul>
<li>什么是机器学习：在计算机上从数据中产生模型的算法，即学习算法。计算机科学是研究关于算法的学问，机器学习是研究关于学习算法的学问。</li>
<li>基本术语：样本的集合-数据集，属性张成的空间-属性空间&#x2F;样本空间，一个样本在坐标轴上表示-特征向量，一个样本的特征数-维数。聚类：将样本分簇，学习过程中使用的训练样本无标记信息。训练数据无标记信息-无监督学习：聚类为代表。监督学习：回归分类为代表。模型适用于新样本的能力，适用于整个样本空间-泛化能力。</li>
<li>归纳：从特殊到一般的泛化过程。演绎：从一般到特殊的特化过程。</li>
<li>广义的归纳学习相当于从样本中学习，狭义的归纳学习要求从训练数据中学得概念，概念学习。学得泛化性能好又语义明确的概念太困难，常用的技术是产生黑箱模型。从样例中学习就是广义的归纳学习。</li>
<li>假设空间：指模型可能学习到的所有函数或解的集合。学习过程可以看作在所有假设组成的空间中进行搜索的过程，学习得到的模型对应了假设空间中的一个假设。存在与训练集一致的假设集合，称为版本空间，其中可能多个假设空间。</li>
<li>机器学习算法在学习过程中对某种类型假设的偏好，称为归纳偏好。任何有效的机器学习算法都有归纳偏好，否则无法产生确定的学习结果。奥卡姆剃刀：选择最简单的。实际上，选择与问题相匹配的归纳偏好，才会起决定性作用。</li>
<li>人工智能发展历程：推理期（逻辑推理能力） - 知识期（专家系统，人把知识总结再教给计算机）- 机器学习（研究最多的是从样例中学习，广义的归纳学习）。机器学习：符号主义学习（决策树和基于逻辑的学习，决策树学习以信息论为基础，以信息熵最小化为目标，模拟了人类对概念进行判定的树形流程，简单易用。但是逻辑学习表示能力太强，假设空间太大，复杂度高问题规模大）- 基于神经网络的连接主义学习（与符号主义产生明确概念不同，连接主义产生的是黑箱模型，最大的局限性是试错性，参数调节对结果影响很大）- 统计学习（支持向量机SVM和核方法） - 连接主义带着深度学习卷土重来（很多层的神经网络，模型复杂度高，但是下功夫调参，性能就能好）</li>
<li>数据挖掘是从海量数据中发掘知识，数据库领域为数据挖掘提供数据管理技术，机器学习和统计学的研究为数据挖掘提供数据分许技术。</li>
<li>萨缪尔，跳棋程序。提出机器学习，是不显式编程地赋予计算机能力的研究。</li>
</ul>
<h1 id="第二章-模型评估与选择"><a href="#第二章-模型评估与选择" class="headerlink" title="第二章 模型评估与选择"></a>第二章 模型评估与选择</h1><ul>
<li>误差：训练误差或经验误差：学习器在训练集上的误差；泛化误差：学习器在新样本上的误差。</li>
<li>过拟合与欠拟合：过拟合是由于学习能力过于强大,以至于把训练样本所包含的不太一般的特性都学到了（无法完全避免）；欠拟合是由于学习能力低下而造成的（神经网络中增加训练轮次）。</li>
<li>评估方法：泛化误差无法直接获得，测试集上的测试误差作为泛化误差的近似。1、留出法： 直接将数据划分为两个互斥集合，<strong>一个集合作为训练集，另一个作为互斥集</strong>，若干次随机划分。2、交叉验证法：先将数据集划分为<strong>k</strong>个大小相似的互斥子集，每次用<strong>k-1</strong>个子集的并集作为训练集，余下那个子集作为测试集。k折交叉验证，p次随机划分，p次k折交叉验证。3、自助法：每次从数据集D中挑选一个样本，再将该样本放回初始数据集D中，重复m次，得到包含m个样本的数据集D’。初始数据集D中约有36.8%的样本未出现在D’中。小数据集中有用，但是自助法产生的数据集改变了初始数据集的分布。</li>
<li>性能度量：查准率：所预测的正例有多少是正确的概率；查全率：在真实正例条件下，有多少正例被预测出来。</li>
<li>P-R曲线：以查全率为横坐标，查准率为纵坐标。</li>
<li>出现交点时，引入平衡点(Break-Event Point, BEP)来度量学习器的优劣。是查准率&#x3D;查全率时的取值。P是查准率，R是查全率。调整阈值实现变化的。</li>
<li>F1度量：调和平均，F1 &#x3D; 2<em>P</em>R&#x2F;(P+R)。为表达对P和R的偏好，引入贝塔，F1度量的一般形式。</li>
<li>ROC曲线和AUC面积：ROC曲线的纵轴是“真正例率”(True Positive Rate, TPR)，横轴是“假正例率”(False Positive Rate, FPR)。AUC为曲线下的面积。</li>
<li>代价敏感错误率和代价曲线：分类任务中，不同错误造成的损失不同，也就是非均等代价，所以引入代价矩阵，最小化总体代价。</li>
<li>t分布：统计学中的概率分布，是一种对称的、钟形的概率分布，其形状与正态分布类似，但尾部更厚。</li>
<li>偏差与方差：偏差、方差、噪声，是影响模型性能的三个核心概念，它们共同决定了模型的泛化能力。1、偏差是模型预测值的期望（多个训练集训练的多个模型）与真实值之间的差异，反映了模型对数据的拟合能力，高偏差意味着欠拟合，需要使用更复杂的模型和增加特征数量。2、方差是模型预测值的变化程度，反映了模型对训练数据的敏感性。不同训练集训练模型的预测值与真实值的方差。高方差意味着模型过于复杂，过度拟合训练数据中的噪声。低方差意味着模型对训练数据的变化不敏感，泛化能力较强。降低方差需要使用正则化，增加训练数据量。3、噪声是数据中无法被模型捕捉的随机误差，不可避免的，与模型无关。例如图像可能包含模糊或遮挡。</li>
<li>偏差度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力;方差度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响;噪声则表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。</li>
<li>偏差-方差分解说明，泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的。给定学习任务，为了取得好的泛化性能，则需使偏差较小，即能够充分拟合数据，并且使方差较小，即使得数据扰动产生的影响小。</li>
<li>训练不足时，学习器拟合能力不足，偏差主导了泛化误差。训练程度加深，训练数据的扰动能够被学习器学习到，方差主导了泛化误差。</li>
</ul>
<h1 id="第三章-线性模型"><a href="#第三章-线性模型" class="headerlink" title="第三章 线性模型"></a>第三章 线性模型</h1><ul>
<li>线性回归：用于建模因变量与自变量之间的线性关系。非线性模型可在线性模型的基础上引入层次结构和高维映射得到。简单线性回归只有一个因变量属性，多元线性回归有多个。目标：使得模型的预测值与真实值之间的误差最小。 均方误差：差平方的平均，对应欧几里得距离。参数估计方法：最小二乘法【解析法】（基于均方误差最小化来求导进行模型求解，对异常值非常敏感）、梯度下降【迭代法】（通过迭代优化逐步调整回归系数，使损失函数最小化）线性回归优点：简单可解释性强；缺点：无法捕捉非线性关系，对异常值敏感。</li>
<li>对数线性回归：通过对因变量取对数，将其转换为线性模型的形式，从而利用线性回归的方法进行建模因变量与自变量之间的对数线性关系。通常用于处理因变量是计数数据或频率数据的情况。</li>
<li>对数几率回归：分类算法，通过将线性回归的输出映射到概率空间，并使用对数几率来建模分类问题。简单高效、可解释性强，应用于二分类问题，但只能建模线性决策边界。实际上是用线性回归模型的预测结果去逼近真实标记的对数几率，对数几率是：log(p&#x2F;1-p)</li>
<li>sigmoid函数：因其形状类似于字母“S”而得名，核心作用是将任意实数映射到 [0, 1] 区间，常用于表示概率或作为激活函数。σ(z)&#x3D;1&#x2F;1+e−z。输出范围是0-1，具有单调性、非线性、平滑性。应用：对数几率回归中用于将线性回归的输出映射到 [0, 1] 区间，表示概率。在神经网络中，Sigmoid 函数常用于隐藏层或输出层的激活函数，引入非线性能力。缺点：存在梯度消失和计算复杂度较高。</li>
<li>线性判别分析LDA：核心思想是通过将数据投影到低维空间，使得同类样本尽可能接近，不同类样本尽可能远离，从而实现分类或降维。目标是找到一个投影方向（或超平面），使得在该方向上，类内距离最小化，类间距离最大化。</li>
<li>拉格朗日乘子法：一种用于求解约束优化问题的数学方法。核心思想是通过引入拉格朗日乘子，将约束条件融入目标函数，从而将约束优化问题转化为无约束优化问题。通过求解拉格朗日函数的极值，可以得到原约束优化问题的解。对因变量和拉格朗日乘子求偏导之后解方程。</li>
<li>多分类问题：1、直接多分类方法：Softmax 回归，使用 Softmax 函数将线性模型的输出转换为概率分布。神经网络中在输出层使用 Softmax 激活函数，将输出转换为概率分布。2、间接多分类方法：将多分类任务拆为若干个二分类任务求解，一对一（需训练N(N - 1)&#x2F;2个分类器）、一对其余（需训练N 个分类器）。</li>
<li>类别不平衡问题：指在分类任务中，不同类别的样本数量分布不均衡，其中一个或少数类别的样本数量远远少于其他类别。影响：模型偏向多数类、准确率评价指标失效。解决：数据层面，过采样随机复制少数类样本增加少数类样本的数量，欠采样减少多数类样本的数量，混合采样。算法层面，为不同类别分配不同的误分类代价，使模型更关注少数类。</li>
</ul>
<h1 id="第四章-决策树"><a href="#第四章-决策树" class="headerlink" title="第四章 决策树"></a>第四章 决策树</h1><ul>
<li>决策树：通过一系列规则对数据进行划分，使得每个子集尽可能纯净（即属于同一类别或具有相似的值），构建一棵树形结构。构建过程可以看作是一个递归的“分而治之”过程。</li>
<li>决策树的构建过程：1、根据某种准则（如信息增益、基尼指数等），选择最优特征进行划分。2、根据最优特征的取值，将数据集划分为多个子集。3、对每个子集递归地重复上述过程，直到满足停止条件（如子集纯净、达到最大深度等）。4、当满足停止条件时，生成叶节点，叶节点的值为该子集中多数类别（分类任务）或平均值（回归任务）。</li>
<li>决策树用于选择最有划分特征的准则：分类任务：信息增益（表示划分前后信息熵的减少量，信息熵&#x3D;plogp，信息增益越大，就认为用属性a来进行划分所获得的纯度提升最大）、增益率（通过引入固有值对信息增益进行归一化处理，克服了信息增益对取值数目较多的特征的偏好问题）、基尼指数（表示从数据集中随机抽取两个样本，其类别标签不一致的概率。基尼指数越小，数据集的纯度越高）。回归任务：均方误差MSE（选择使均方误差最小的特征进行划分）。</li>
<li>决策树的剪枝：决策树容易过拟合，因此需要通过剪枝（Pruning）来提高泛化能力。预剪枝：节点划分前先进行估计，计算划分前和划分后的验证集精度，只有划分后精度变大了，才会划分，其他的就直接一刀切不再划分。后剪枝：先生成一颗完整的决策树，从叶节点向上剪枝，通过验证集评估剪枝前后的性能，决定是否保留。</li>
<li>决策树的连续与缺失值处理：决策树通常用于处理离散特征，如果要处理连续属性：二分法和多分法。需要注意，与连续属性不同，若当前结点划分属性为连续属性，则该属性还可作为其后代节点的划分属性。对于缺失值（样本的某些属性值缺失），通过忽略、填补或单独分支处理缺失值。</li>
<li>决策树的分类边界：决策树的分类边界有一个明显的特点：轴平行，即它的分类边界由若干个与坐标轴平行的分段组成。每一段划分都直接对应了某个属性取值。</li>
<li>多变量决策树：非叶节点不再仅对某个属性，而是对属性的线性组合进行划分，实现斜划分，与传统的单变量决策树不同，多变量决策树不是为每个非叶结点寻找一个最优划分属性，而是试图建立一个合适的线性分类器。</li>
</ul>
<h1 id="第五章-神经网络"><a href="#第五章-神经网络" class="headerlink" title="第五章 神经网络"></a>第五章 神经网络</h1><ul>
<li>神经网络：一种模仿生物神经系统结构和功能的计算模型，通过多层神经元的相互连接和权重调整，能够学习复杂的非线性关系。</li>
<li>神经元：通过加权求和和激活函数处理后输出</li>
<li>激活函数：引入非线性，使神经网络能够学习复杂模式，Sigmoid、ReLU、SoftMax。</li>
<li>神经网络的学习过程，就是根据训练数据来调整神经元之间的”连接权”以及每个功能神经元的阈值。输入层神经元仅仅是接受输入，而隐层与输出层则都包含功能神经元（有激活函数）。</li>
<li>感知器：由两层神经元组成，输入层接受外界输入信号后传递给输出层，输出层是神经元，也叫做“阈值逻辑单元”。局限性：能实现与或非逻辑运算，只能解决线性可分问题（存在一个线性超平面能将它们分开），无法处理非线性分类任务（如异或问题）。</li>
<li>多层网络：通过堆叠多个感知器层，能够学习复杂的非线性关系。包括：输入层（接收输入数据，每个节点对应一个特征）、隐藏层（通过非线性变换提取特征，可以有多层）、输出层（输出预测结果，节点数取决于任务类型，如分类任务中节点数等于类别数）。神经网络的前一层的每一个神经元都与后一层的所有神经元相连–全连接神经网络。</li>
<li>多层前馈神经网络：先将输入提供给输入层神经元，然后逐层将信号前传（前向传播），直到产生输出层的结果。然后计算输出层的误差（损失函数，如均方误差、交叉熵），再将误差逆向传播至隐层神经元（误差逆传播算法，使用链式法则逐层传播误差），最后根据隐层神经元的误差来对权值和阈值进行调整（基于梯度下降策略，以目标的负梯度方向对参数进行调整）。该迭代过程循环进行，直到达到某些停止条件为止，例如训练误差己达到一个很小的值。</li>
<li>累积误差逆向传播：基于累积误差最小化进行更新</li>
<li>只需包含足够多神经元的隐层，多层前馈网络就能以任意精度逼近任意复杂度的连续函数，通过试错法调整隐层神经元的个数。</li>
<li>解决过拟合：早停：将数据分成训练集和验证集，训练集用来计算梯度、更新连接权和阈值，验证集用来估计误差，若连续多轮训练集误差降低但验证集误差升高，则停止训练，同时返回具有最小验证集误差的连接权和阈值。正则化：在损失函数中加入额外的惩罚项，限制模型参数的大小或复杂度。</li>
<li>神经网络类型：前馈神经网络FNN：最简单的神经网络，信息单向传播。卷积神经网络CNN：用于图像处理，通过卷积核提取局部特征。循环神经网络RNN：用于序列数据（如文本、时间序列），具有记忆能力。生成对抗网络GAN：由生成器和判别器组成，用于生成数据。</li>
<li>如何避免陷入局部最小：从多个不同的初始点开始搜索、动量法通过引入历史梯度信息，加速梯度下降并帮助跳出局部最小值、使用自适应学习率方法动态调整学习率、使用模拟退火，通过引入逐渐降低的“温度”参数，控制搜索过程中的随机性，从而在早期探索更多解空间，后期逐渐收敛到全局最优解、使用SGD随机梯度，通过引入噪声帮助跳出局部最小值。（都是启发式的）</li>
<li>模拟退火：每一步以一定概率接受比当前解更差的结果，接受次优解的概率随着时间的推移逐渐降低，从而保证算法稳定。</li>
<li>RBF网络：一种单隐层前馈神经网络，使用径向基函数作为隐层神经元激活函数，输出层则是对隐层神经元输出的线性组合。常用于函数逼近、分类和回归任务，具有结构简单、训练速度快的特点。RBF 径向基函数的核心思想是通过距离度量（通常是欧氏距离）来计算输入数据点与某个中心点之间的相似性。常见的RDF函数有高斯函数，具有径向对称性、平滑性的特点。</li>
<li>竞争型学习：神经网络中一种常用的无监督学习策略，在使用该策略时，网络的输出神经元相互竞争，每一时刻仅有一个竞争获胜的神经元被激活，其他神经元的状态被抑制。这种机制亦称”胜者通吃” (winner-take-all) 原则。</li>
<li>ART（自适应共振理论网络）网络：竞争型学习的代表，该网络由比较层、识别层、识别阈值和重置模块构成。在接收到比较层的输入信号后识别层神经元之间相互竞争以产生获胜神经元。竞争的最简单方式是计算输入向量与每个识别层神经元所对应的模式类的代表向量之间的距离，距离最小者胜。获胜神经元将向其他识别层神经元发送信号，抑制其激活。若输入向量与获胜神经元所对应的代表向量之间的相似度大于识别阈值，则当前输入样本将被归为该代表向量所属类别，同时，网络连接权将会更新，使得以后在接收到相似输入样本时该模式类会计算出更大的相似度，从而使该获胜神经元有更大可能获胜。若相似度不大于识别阈值，则重置模块将在识别层增设一个新的神经元，其代表向量就设置为当前输入向量。</li>
<li>ART网络是一种基于自适应共振理论的无监督学习神经网络，能够动态地学习和分类输入数据，同时保持对之前学习模式的稳定性。可以进行增量学习。它适用于模式识别、数据聚类和异常检测等任务，尽管参数敏感和计算复杂度较高，但在动态学习任务中表现出色。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/20/myblog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E4%BA%8Etensorflow%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/20/myblog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E4%BA%8Etensorflow%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">基于tensorflow的深度学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-20 15:57:17" itemprop="dateCreated datePublished" datetime="2023-08-20T15:57:17+08:00">2023-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-02-12 21:56:16" itemprop="dateModified" datetime="2025-02-12T21:56:16+08:00">2025-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一章-Numpy常用操作"><a href="#第一章-Numpy常用操作" class="headerlink" title="第一章 Numpy常用操作"></a>第一章 Numpy常用操作</h2><p>tensorflow：深度学习框架<br>python本身含有列表list和数组array。<br>list列表的元素可以是任何对象，因此列表中保存的是对象的指针，浪费内存和CPU计算时间。<br>array不支持多维，没有各种运算函数。</p>
<p>numpy提供ndarray（存储单一数据类型的多维数组）和ufunc（对数组进行处理的函数）</p>
<p>1.将列表转换为ndarray。<br>2.np函数，截取ndarray<br>3.numpy中的random函数<br>4.numpy中的矩阵操作<br>5.ndarray的合并和展平<br>6.使用numpy和math的比较，使用向量化矩阵运算可以避免循环语句<br>7.numpy的广播机制：方便不同shape的数组进行数学运算。原则是对齐维度，对数组进行扩充到可以进行运算，利用自动复制等方法把低维数据补齐。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">print(np.arange(10))</span><br><span class="line">print(np.arange(0, 10))</span><br><span class="line">print(np.arange(1, 4, 0.5))</span><br><span class="line">print(np.arange(9, -1, -1))</span><br><span class="line"></span><br><span class="line">nd1 = np.arange(10)</span><br><span class="line">print(nd1)</span><br><span class="line">print(nd1[3:6])</span><br><span class="line">print(nd1[1:6:2])</span><br><span class="line">print(nd1[::-2])</span><br><span class="line"></span><br><span class="line">np2 = np.arange(25).reshape([5,5])</span><br><span class="line">print(np2)</span><br><span class="line">print(np2[[1,2]]) #1、2行</span><br><span class="line">print(np2[1:3, :])</span><br><span class="line">print(np2[:, 1:3])</span><br><span class="line">import numpy as np</span><br><span class="line">from numpy import random</span><br><span class="line"></span><br><span class="line">a = np.arange(1, 25, dtype=float)</span><br><span class="line">print(a)</span><br><span class="line">c1 = random.choice(a, size=(3,4))</span><br><span class="line">print(c1)</span><br><span class="line">print(np.sum(a))</span><br><span class="line">print(a / np.sum(a))</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">nd3 = np.arange(9).reshape([3,3])</span><br><span class="line">print(np.transpose(nd3))</span><br><span class="line">print(nd3.trace)</span><br><span class="line">print(np.linalg.det(nd3))</span><br><span class="line">print(np.linalg.solve(nd3, np.eye(3)))</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">print(time.process_time())</span><br></pre></td></tr></table></figure>

<h2 id="第二章-Theano基础"><a href="#第二章-Theano基础" class="headerlink" title="第二章 Theano基础"></a>第二章 Theano基础</h2><p>Theano是python的一个库，对于解决大量数据的问题，使用Theano可以获取与手工用C实现差不多的性能。符号计算图。<br>conda install theano<br>符号变量&#x3D;张量Tensor。<br>张量是标量、向量、矩阵的统称。<br>Theano是一个通用的符号计算框架，将复杂的符号表达式编译成函数模型。<br>1.定义符号变量<br>import theano<br>from theano import tensor<br>2.符号计算图模型来描述变量间的运算关系，把符号表达式转换为一个计算图来处理。<br>3.函数：提供一个接口，把函数计算图编译为可调用的函数对象。Theano进行了编译优化，执行的是优化后保存在图结构中的模型，提升速度，不好调试。<br>自动求导：对于每个op都定义了根据输入计算出偏导数，使用链式法则，就可以计算出梯度了。<br>更新共享变量参数：深度学习中通常需要迭代多次，每次迭代都需要更新参数。theano.function中的updates参数就是包含两个元素的列表或tuple。<br>条件：ifelse、switch<br>循环：scan用来构建循环Graph的方法<br>4.共享变量：是实现机器学习算法参数更新的重要机制。shared函数会返回共享变量，这种变量的值可以在多个函数中直接使用。用function中的updates参数进行更新。</p>
<h2 id="第三章-线性代数"><a href="#第三章-线性代数" class="headerlink" title="第三章 线性代数"></a>第三章 线性代数</h2><p>1.标量、向量、矩阵、张量<br>2.可逆矩阵、对角矩阵、对称矩阵、单位向量、正交向量、正交矩阵<br>0范数(L0范数)-向量中非0元素的个数。<br>1范数(L1范数)-向量中各个元素绝对值之和。<br>2范数(L2范数)-向量的模长。<br>无穷范数(最大范数)-向量中各个元素绝对值的最大值。</p>
<p>3.向量组、线性组合、向量空间。向量组线性相关。最大线性无关组、向量组的秩。矩阵的行秩和列秩相等。<br>4.向量的大小用范数来表示。<br>5.特征值分解，特征值，特征向量。<br>6.奇异值分解：分解成三个矩阵的乘积。可以拓展矩阵求逆到非方矩阵上。SVD<br>7.迹运算：矩阵对角元素的和 Tr<br>8.主成分分析：PCA：通过正交变换将一组可能存在相关性的变量转换为一组线性不相关的变量，转换后的这组变量叫做主成分。属于特征降维。<br>在减少需要分析的指标或维度的同时，尽量减少原指标所含信息的损失，以达到对所收集数据进行全面分析的目的。<br>for i in range(10):<br>    print(i)</p>
<h2 id="第四章-概率与信息论"><a href="#第四章-概率与信息论" class="headerlink" title="第四章 概率与信息论"></a>第四章 概率与信息论</h2><p>机器学习、深度学习的三大基石：线性代数、概率与信息论、数值分析。<br>机器学习大部分时候处理的都是不确定量或随机量。</p>
<p>1.信息论主要研究对一个信号包含信息的多少进行量化。<br>样本空间：一个实验或随机试验所有可能结果的集合，每个可能结果为一个样本点。<br>随机变量：随机事件的结果：离散随机变量、连续随机变量。n维随机变量&#x2F;随机向量。</p>
<p>2.概率分布<br>通常关心随机变量落在某一区间的概率：分布函数F<br>离散型随机变量：两点分布、二项分布、poisson分布<br>连续型随机变量：用概率密度函数来描述变量的概率分布fx。正态分布&#x3D;高斯分布，钟形曲线，平均值和标准差，标准差大的更分散。正态分布是一种理想分布。<br>scipy库进行统计</p>
<p>3.边缘概率：定义在多维随机变量的子集上的概率分布称为边缘概率分布。对于连续型随机变量，可以通过联合密度函数来得到边缘密度函数。<br>4.条件概率，条件概率的链式法则<br>5.独立性与条件独立性<br>6.期望、方差、协方差。<br>期望描述数据的大小，但无法描述数据的离散程度。<br>方差可以用来衡量随机变量取值的离散程度。<br>协方差可以衡量随机变量间的相关性强度。如果X和Y独立，那么它们的协方差为0.反之不一定成立，独立性比协方差为0的条件更强。如果X和Y都是正态分布，此时独立和协方差为0是一个概念。<br>相关系数将每个变量的贡献进行归一化，在协方差的基础上进行正则化，把相关系数限制在-1到1之间。如果等于1，表示线性正相关。<br>协方差推广到n个随机或n维随机变量的情况，对于n维，就是n*n的协方差矩阵。协方差矩阵是对称矩阵，协方差矩阵的对角元素为方差。<br>用numpy的相关函数、数据分析库pandas、画图库matplotlib、sns。<br>7.贝叶斯定理<br>与条件概率和边缘概率有关，通过已知的三个概率函数推出第四个。<br>分类器：近邻分类器、线性分类器、支撑向量机分类器、神经网络分类器、随机森林分类器<br>损失函数：多类支撑向量机损失、交叉熵损失、L1损失、L2损失<br>线性分类器，层级结构形成神经网络，高纬映射形成支撑向量机 - 非线性模型<br>线性分类器的权值：可以看作是一种模版，分界面（决策边界）<br>分类器的损失函数：搭建了模型性能与模型参数之间的桥梁。<br>多类支撑向量机损失：正确类别的得分比不正确类别的得分高出1分，就无损失，否则产生损失。</p>
<h2 id="第五章-概率图模型"><a href="#第五章-概率图模型" class="headerlink" title="第五章 概率图模型"></a>第五章 概率图模型</h2><p>1.概率图模型是一种用图的形式表示随机变量之间条件依赖关系的概率模型，是概率论与图论的结合。<br>有向概率图模型：贝叶斯网络：表达随机变量间的依赖关系和相互关系<br>无向概率图模型：马尔可夫网络：表达随机变量间的相互关系</p>
<p>2.贝叶斯网络分为静态贝叶斯网络和动态贝叶斯网络<br>动态贝叶斯网络可用于处理随时间变化的动态系统中的推断和预测等问题。其中隐马尔可夫模型HMM，被广泛用于语音识别、自动分词与词性标注和统计机器翻译等领域。</p>
<p>3.隐马尔可夫模型<br>初始状态项链、状态转移概率矩阵、观测概率矩阵<br>状态序列（标记序列）和观测序列。<br>隐马尔可夫模型可解决三个基本问题：评估问题、解码问题、学习问题<br>实例：掷骰子，多种骰子<br>解码问题：知道骰子有几种（隐含状态数量），每种骰子是什么（转换概率），根据掷骰子的结果（可见状态链），想知道每次掷出来的都是哪种骰子（隐含状态链）。</p>
<p>4.马尔可夫网络<br>无向概率图模型，关于一组有马尔可夫性质随机变量X的全联合概率分布模型。<br>重点是其中的一种：马尔可夫随机场MRF。<br>马尔可夫随机场有一组势函数，也称因子，是定义在变量子集上的非负函数。<br>条件随机场。</p>
<h2 id="第六章-机器学习基础"><a href="#第六章-机器学习基础" class="headerlink" title="第六章 机器学习基础"></a>第六章 机器学习基础</h2><p>机器学习分为监督学习、无监督学习、半监督学习（强化学习）。</p>
<h3 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/22/myblog/spring/springboot%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Sweetwater">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sweetwater's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/22/myblog/spring/springboot%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">springboot学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-22 18:37:23" itemprop="dateCreated datePublished" datetime="2022-12-22T18:37:23+08:00">2022-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-20 15:40:41" itemprop="dateModified" datetime="2023-08-20T15:40:41+08:00">2023-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="springboot创建工程"><a href="#springboot创建工程" class="headerlink" title="springboot创建工程"></a>springboot创建工程</h2><p>微服务体系下不可或缺。<br>ssm(spring+springMvc+mybatis) -&gt; springboot -&gt; springcloud</p>
<p>springboot：约定优于配置，不用专注于配置。2014年发布。</p>
<p>springboot的位置：是spring的顶级项目，和springFramework(ioc、aop)是同等级的。</p>
<p>springboot使用最小配置快速构建spring项目。springboot不是spring功能上的增强，而是提供一种快速开发spring项目的方式。</p>
<p>spring缺点：<br>&lt;1&gt; 写配置文件，繁琐<br>&lt;2&gt; 依赖繁琐，maven坐标版本问题</p>
<p>springboot提供的优点：<br>&lt;1&gt; 自动配置，应用程序启动时的过程<br>&lt;2&gt; 起步依赖，坐标pom打包到一起，对其他库的依赖传递<br>&lt;3&gt; 其他：嵌入式服务器，安全，健康检测</p>
<hr>
<p>✅ 用springboot搭建一个web项目：<br>&lt;1&gt; 创建maven项目<br>&lt;2&gt; 引入起步依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--springboot工程需要继承的父工程   --&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.1&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--  web开发的起步依赖  --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>&lt;3&gt; 写一个controller</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.liuxuan.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-12-22 23:28</span><br><span class="line"> **/</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/h&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;hello!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;4&gt; 写引导类，springboot项目入口，然后运行main方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.liuxuan;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-12-22 23:38</span><br><span class="line"> **/</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class StartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(StartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>✅ 快速构建</p>
<p>用idea，选Spring Initializr，选maven project，选jar打包方式，勾选依赖。</p>
<h2 id="springboot起步依赖"><a href="#springboot起步依赖" class="headerlink" title="springboot起步依赖"></a>springboot起步依赖</h2><p>spring-boot-starter-parent，往里看源码，最终是spring-boot-dependency包，其中pom文件中<code>&lt;dependencyManagement&gt;</code> 是版本锁定，父工程中定义的版本信息，自己工程中就可以不写版本号。</p>
<p>spring-boot-starter-web，往里看，发现引入了spring-web、spring-webmvc。</p>
<p>总结：<br>1.在spring-boot-starter-parent中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。<br>2.在各种starter中，定义了完成该功能的坐标合集，其中大部分版本信息来自于父工程。<br>3.我们工程继承自parent，引入starter，通过依赖传递，就可以简单方便获取需要的jar包，并且不会存在版本冲突问题。</p>
<h2 id="springboot配置"><a href="#springboot配置" class="headerlink" title="springboot配置"></a>springboot配置</h2><p>配置文件分类：properties文件、yaml&#x2F;yml文件。<br>profile文件，三种环境动态切换。</p>
<p>springboot基于约定，配置有默认值，替换的话，用application.properties&#x2F;application.yml文件来配置。resource根目录下，application.properties&#x2F;yml&#x2F;yaml 文件里面放程序自动识别的内容，也可以写自己定义的内容。</p>
<p>同一级目录下，配置文件的加载顺序：properties &gt; yml &gt; yaml</p>
<p>yaml：不是一个标记语言，是直观的能被电脑识别的数据序列化格式，以数据为核心，比xml更加简洁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xml:</span><br><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;port&gt;8080&lt;/port&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line"></span><br><span class="line">yml:</span><br><span class="line">server:</span><br><span class="line">    port: 8080</span><br><span class="line"></span><br><span class="line">properties:</span><br><span class="line">server.port=8080</span><br></pre></td></tr></table></figure>

<p>yaml语法：大小写敏感、数据值前必须有空格（至少一个）、缩进表示层级关系，缩进空格个数不重要，但要左对齐、#注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line"></span><br><span class="line">person:</span><br><span class="line">  name: liu</span><br><span class="line">  address: [beijing, shanghai]</span><br><span class="line"></span><br><span class="line">msg1: &quot;hello \n world&quot;  #双引号识别转义字符</span><br><span class="line">msg2: &#x27;hello \n world&#x27;  #单引号原样输出</span><br><span class="line"></span><br><span class="line">参数引用：$&#123;name&#125;</span><br></pre></td></tr></table></figure>


<p>读取配置文件内容：</p>
<p>1.@Value方法，单个属性注入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;person.name&#125;&quot;)</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">@Value(&quot;$&#123;person.address[0]&#125;&quot;)</span><br><span class="line">private String address;</span><br></pre></td></tr></table></figure>

<p>2.Environment</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private Environment env;    </span><br><span class="line"></span><br><span class="line">env.getProperty(&quot;person.name&quot;)</span><br></pre></td></tr></table></figure>

<p>3.@ConfigurationProperties，对象和配置的绑定</p>
<p>在实体类Person上加注解 <code>@ConfigurationProperties(prefix=&quot;person&quot;)</code></p>
<hr>
<p>profile：一套程序通常需要部署在不同的环境下，开发测试生产，如果每次打包都要修改配置文件，麻烦，profile提供进行动态配置切换的方式。</p>
<p>配置方式：<br>1.多profile文件方式：提供多个配置文件，每个代表一个环境<br>application-dev.properties&#x2F;yml<br>application-test.properties&#x2F;yml<br>application-pro.properties&#x2F;yml</p>
<p>2.yml单文件方式<br>用—分割不同环境配置</p>
<p>激活方式：<br>1.配置方式：<br><code>spring.profiles.active=dev</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    profiles:</span><br><span class="line">        active: dev</span><br></pre></td></tr></table></figure>

<p>2.虚拟机参数<br>在VM option中输入：<code>-Dspring.profiles.active=test</code></p>
<p>3.命令行参数<br>先package打包<br><code>java -jar ...jar --spring.profiles.active=test</code></p>
<hr>
<p>打包过程中，遇到：jar中没有主清单属性</p>
<p>原因：打包后的jar文件中的MANIFEST.MF缺少项目启动项，即没有Main-Class</p>
<p>解决方案：<br>1、指定MANIFEST.MF路径<br>项目打包前：<br>第一步 file–&gt;project structure 弹框后选中Atifacts—&gt; + —-&gt;jar—-&gt;from module with dependenceis<br>第二步 选择一个Main Class，选的StartApplication文件</p>
<p>2、项目pom.xml文件中添加插件spring-boot-maven-plugin</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>内部配置加载顺序：</p>
<p>1.项目根目录下的config文件夹下<br>2.项目根目录（idea点project files的根目录）下<br>3.classPath（resource目录下）的config文件夹下<br>4.classPath（resource目录下）下</p>
<p>前两个不会打进jar包里</p>
<hr>
<p>外部配置加载顺序：</p>
<p>1.命令行指定端口号：<code>java -jar spring-boot-study-api-1.0-SNAPSHOT.jar --server.port=8086</code><br>指定默认前缀路径：<code>--server.servlet.context-path=/default</code><br>2.指定外部配置文件路径：<code>--spring.config.location=路径</code><br>3.在jar包同目录下（target文件夹下），加一个配置文件<code>application.properties</code>，同样生效，外部配置优先生效</p>
<h2 id="springboot整合其他框架"><a href="#springboot整合其他框架" class="headerlink" title="springboot整合其他框架"></a>springboot整合其他框架</h2><h3 id="springboot整合Junit"><a href="#springboot整合Junit" class="headerlink" title="springboot整合Junit"></a>springboot整合Junit</h3><p>1.引入spring-boot-starter-test 起步依赖<br>2.在测试类上加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class) //springboot2不用加</span><br><span class="line">@SpringBootTest(classes = StartApplication.class) //如果与StartApplication在一个包下，可以不加括号里的</span><br></pre></td></tr></table></figure>


<h3 id="springboot整合redis"><a href="#springboot整合redis" class="headerlink" title="springboot整合redis"></a>springboot整合redis</h3><p>1.引入spring-boot-starter-data-redis依赖<br>2.连接本地的redis，不需要任何配置<br>3.直接用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">redisTemplate.boundValueOps(&quot;name&quot;).set(&quot;liu&quot;);</span><br><span class="line">Object o = redisTemplate.boundValueOps(&quot;name&quot;).get();</span><br></pre></td></tr></table></figure>
<p>4.其他ip的，需要配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    port: 6379</span><br></pre></td></tr></table></figure>


<h3 id="spring整合mybatis"><a href="#spring整合mybatis" class="headerlink" title="spring整合mybatis"></a>spring整合mybatis</h3><p>1.引入mybatis起步依赖 <code>mybatis-spring-boot-starter</code> （不同于其他，这个是mybatis提供的，用3.0.1的有点问题，改用2.1.0），添加mysql驱动 <code>mysql-connector-java</code><br>2.配置datasource和mybatis</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql:///test?serverTimezone=UTC</span><br><span class="line">    #db.url=jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    username: liuxuan</span><br><span class="line">    password: jade</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>
<p>3.创建表，并编写实体类<br>4.纯注解开发</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">@Repository</span><br><span class="line">public interface StudentMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from student&quot;)</span><br><span class="line">    public List&lt;Student&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5 .xml映射文件形式开发<br>Mapper接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">@Repository</span><br><span class="line">public interface StudentXmlMapper &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;Student&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xml配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.liuxuan.repository.mapper.StudentXmlMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.liuxuan.repository.domain.Student&quot;</span>&gt;</span></span><br><span class="line">        select * from student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>增加mybatis配置(不在spring下)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  # Mapper映射文件路径</span><br><span class="line">  mapper-locations: classpath:mapper/*Mapper.xml</span><br><span class="line">  # 包扫描</span><br><span class="line">  type-aliases-package: com.liuxuan.repository.domain</span><br></pre></td></tr></table></figure>


<h2 id="springboot原理分析"><a href="#springboot原理分析" class="headerlink" title="springboot原理分析"></a>springboot原理分析</h2><h3 id="springboot自动配置"><a href="#springboot自动配置" class="headerlink" title="springboot自动配置"></a>springboot自动配置</h3><p>Condition是spring4.0增加的条件判断功能，可以实现选择性地创建Bean操作。</p>
<h4 id="✅需求1-创建bean增加条件"><a href="#✅需求1-创建bean增加条件" class="headerlink" title="✅需求1:创建bean增加条件"></a>✅需求1:创建bean增加条件</h4><p>1.自定义条件类，继承Condition接口，实现matches方法，方法中进行逻辑判断，参数context可以获取上下文容器等，metadata可以获取注解属性。<br>2.判断条件，初始化bean时使用@Conditional(条件类.class)注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">需要加注解@Conditional：</span><br><span class="line">@Configuration</span><br><span class="line">public class UserConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @Conditional(ClassCondition.class)</span><br><span class="line">    public User user() &#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">自己定义一个实现了Condition接口的类，里面实现条件判断matches方法：</span><br><span class="line">public class ClassCondition implements Condition &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        // 写创建bean的条件：导入jedis坐标后创建bean</span><br><span class="line">        try &#123;</span><br><span class="line">            Class cls = Class.forName(&quot;redis.clients.jedis.Jedis&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">获取bean：</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class StartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 启动springboot应用，获取spring的ioc容器</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br><span class="line"></span><br><span class="line">        // 获取bean</span><br><span class="line">        Object user = context.getBean(&quot;user&quot;);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="✅需求2-用自定义注解实现动态Condition"><a href="#✅需求2-用自定义注解实现动态Condition" class="headerlink" title="✅需求2:用自定义注解实现动态Condition"></a>✅需求2:用自定义注解实现动态Condition</h4><p>定义自定义注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Conditional(ClassCondition.class)</span><br><span class="line">public @interface ConditionOnClass &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Config中加注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class UserConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">//    @Conditional(ClassCondition.class)</span><br><span class="line">    @ConditionOnClass(&quot;redis.clients.jedis.Jedis&quot;)</span><br><span class="line">    public User user() &#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承Condition接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ClassCondition implements Condition &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param context  上下文对象。用于获取环境、Ioc容器、classLoader对象</span><br><span class="line">     * @param metadata 注解元对象，可以用于获取注解定义的属性值</span><br><span class="line">     * @return boolean</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        // 需求1：写创建bean的条件：导入jedis坐标后创建bean</span><br><span class="line">//        try &#123;</span><br><span class="line">//            Class cls = Class.forName(&quot;redis.clients.jedis.Jedis&quot;);</span><br><span class="line">//        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">//            return false;</span><br><span class="line">//        &#125;</span><br><span class="line">//        return true;</span><br><span class="line"></span><br><span class="line">        // 需求2：通过注解属性值value指定坐标后创建bean</span><br><span class="line">        Map&lt;String, Object&gt; map = metadata.getAnnotationAttributes(ConditionOnClass.class.getName());</span><br><span class="line">        String[] value = (String[])map.get(&quot;value&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            for (String className : value) &#123;</span><br><span class="line">                Class&lt;?&gt; cls = Class.forName(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看包spring-boot-anto-configuration中，springboot已经定义好了很多condition注解，例如：@ConditionalOnClass。</p>
<hr>
<h4 id="✅切换内置服务器"><a href="#✅切换内置服务器" class="headerlink" title="✅切换内置服务器"></a>✅切换内置服务器</h4><p>spring-boot-starter-web</p>
<p>spring-boot-autoconfiguration 包的web的embedded中内置了四种服务器，包括jetty、netty、tomcat、undertom。</p>
<p>里面还有个类负责选择web服务器，原理也是用了@ConditionalOnClass注解，看导入了什么坐标来选择服务器。</p>
<p>用<exclusions> 把spring-boot-starter-web 中的 spring-boot-starter-tomcat 排除掉。再引入jetty的依赖，就会切换为jetty服务器。</p>
<hr>
<h4 id="✅-Enable-注解"><a href="#✅-Enable-注解" class="headerlink" title="✅ @Enable*注解"></a>✅ @Enable*注解</h4><p>SpringBoot提供了很多@Enable开头的注解，用于动态启动某些功能(获取一些bean)，其底层原理是使用@Import注解导入一些配置类，实现Bean的动态加载。</p>
<p>看注解 @SpringBootApplication</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration --内部@Configuration可配置bean</span><br><span class="line">@EnableAutoConfiguration --重点</span><br><span class="line">@ComponentScan(   --包扫描</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public @interface SpringBootApplication</span><br><span class="line"></span><br><span class="line">其中Enable注解下：</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">重要的是Import注解</span><br></pre></td></tr></table></figure>

<p>⚠️启动子模块的启动类，无法启动父工程的controller。</p>
<p>springboot工程不可以直接获取其他jar包中定义的bean，比如redisTemplate。</p>
<p>原因：@ComponentScan 包扫描的范围是：当前引导类所在包及其子包，其他项目配置Bean的包不在该范围内。</p>
<p>尝试：另外创建一个子模块，子模块引入另一个子模块的pom，然后尝试获取另一个子模块的bean。<br>报错：NoSuchBeanDefinitionException。</p>
<p>如何获取Bean：<br>1.在启动类上加@ComponentScan注解，扫描要引入Bean的包。<br>缺点：要写包太累赘<br>2.使用@Import注解加载要导入bean的配置类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Import &#123;</span><br><span class="line">    Class&lt;?&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>value中的这些类会被spring创建并放入IOC容器中。<br>缺点：要记类的名字<br>3.对Import注解进行封装<br>自定义一个Enable注解，把Import注解封装进去，要想用这个bean的时候，直接用Enable注解就可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Import(UserConfig.class)</span><br><span class="line">public @interface EnableUser &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) //排除此类的AutoConfig</span><br><span class="line">//@ComponentScan(&quot;com.liuxuan.condition&quot;)</span><br><span class="line">//@Import(UserConfig.class)</span><br><span class="line">@EnableUser</span><br><span class="line">public class StartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 启动springboot应用，获取spring的ioc容器</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br><span class="line"></span><br><span class="line">        // 获取bean</span><br><span class="line">        Object user = context.getBean(&quot;user&quot;);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>😊<code>@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class&#125;)</code></p>
<p>exclude，排除此类的AutoConfig，即禁止 SpringBoot 自动注入数据源配置。</p>
<p>DataSourceAutoConfiguration.class 会自动查找 application.yml 或者 properties 文件里的 spring.datasource.* 相关属性并自动配置单数据源「注意这里提到的单数据源」。</p>
<p>那么问题来了，排除了自动配置，Spring还怎么识别到数据库配置呢？</p>
<p>答：显然接下来就需要手动配置，如果你发现项目中存在这个排除的操作，可以在项目中搜一下Java关键字@ConfigurationProperties(“spring.datasource)，你可能会发现手动配置数据源的类。</p>
<p>再来回答为何要手动配置数据源，因为要配置多数据源，上边有提到DataSourceAutoConfiguration.class默认会帮我们自动配置单数据源，所以，如果想在项目中使用多数据源就需要排除它，手动指定多数据源。</p>
<p>@SpringBootApplication注解中exclude参数使用及原理:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/csdn_20150804/article/details/116104742">https://blog.csdn.net/csdn_20150804/article/details/116104742</a></p>
<h4 id="✅-Import注解"><a href="#✅-Import注解" class="headerlink" title="✅ @Import注解"></a>✅ @Import注解</h4><p>@Enable*底层依赖@Import注解导入一些类，使用@Import导入的类会被Spring加载到IOC容器中，@Import提供四种用法：</p>
<p>1.导入Bean</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StartApplication上：</span><br><span class="line">@Import(User.class)</span><br><span class="line"></span><br><span class="line">StartApplication中：</span><br><span class="line">// 根据类型获取bean</span><br><span class="line">Object user = context.getBean(User.class);</span><br><span class="line">System.out.println(user);</span><br><span class="line">// 获取bean名称</span><br><span class="line">Map&lt;String, User&gt; map = context.getBeansOfType(User.class);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>

<p>2.导入配置类<br>这种方式，配置类上的@Configuration注解可以不加</p>
<p>3.导入ImportSelect实现类。一般用于加载配置文件中的类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Import(MyImportSelector.class)</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">public class MyImportSelector implements ImportSelector &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        return new String[]&#123;&quot;com.liuxuan.condition.User&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.导入ImportBeanDefinitionRegistrar实现类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Import(MyImportBeanDefinitionRegistrar.class)</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(User.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(&quot;beanName&quot;, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="✅-EnableAutoConfiguration注解"><a href="#✅-EnableAutoConfiguration注解" class="headerlink" title="✅@EnableAutoConfiguration注解"></a>✅@EnableAutoConfiguration注解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@EnableAutoConfiguration</span><br><span class="line"></span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line"></span><br><span class="line">AutoConfigurationImportSelector中：</span><br><span class="line">public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    if (!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        return NO_IMPORTS;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">        return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">核心代码：getAutoConfigurationEntry</span><br><span class="line">List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line"></span><br><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">    return configurations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">意思是：从spring-boot-autoconfiguration的jar包下面的META-INF/spring.factories文件中加载。</span><br><span class="line">看到这个文件中可以看到：</span><br><span class="line"> # Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">有很多配置文件类</span><br></pre></td></tr></table></figure>

<p>总结：<br>@EnableAutoConfiguration 如何实现自动配置<br>1.@EnableAutoConfiguration注解内部使用@Import({AutoConfigurationImportSelector.class}) 来加载配置类<br>2.配置文件位置：META-INF&#x2F;spring.factories，该配置文件中定义了大量的配置类，当springboot应用启动时，会自动加载这些配置类，初始化bean<br>3.并不是所有的bean都会被初始化，在配置类中使用Condition来加载满足条件的bean</p>
<h4 id="✅自定义starter实现"><a href="#✅自定义starter实现" class="headerlink" title="✅自定义starter实现"></a>✅自定义starter实现</h4><p>看mybatis-spring-boot-starter如何实现：<br>1.看到mybatis-spring-boot-starter包下没什么，只有一个pom文件，里面引入mybatis-spring-boot-autoconfigure包<br>2.mybatis-spring-boot-autoconfigure包的META-INF&#x2F;spring.factories文件中定义了MybatisAutoConfiguration<br>3.@EnableAutoConfiguration会自动识别到META-INF&#x2F;spring.factories文件，从而识别到MybatisAutoConfiguration，模块中初始化的bean就创建出来</p>
<p>需求：自定义redis-starter，当导入redis-starter坐标时，springboot自动创建jedis的bean。</p>
<p>1.创建一个redis-autoconfiguration模块，在里面提供jedis的bean，并实现自动配置。</p>
<p>⚠️亲测，一个模块的配置了8082端口，另一个模块没配置端口，但是运行该模块的StartApplication，要用的是8082端口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RedisAutoConfiguration.class:</span><br><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(RedisProperties.class) //RedisProperties被spring识别，创建bean</span><br><span class="line">@ConditionalOnClass(Jedis.class)  //疑问：没有Jedis坐标则不配置，创建之前不是没这个Bean吗？导入坐标和有bean的关系？</span><br><span class="line">public class RedisAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(name = &quot;jedis&quot;)  //已经定义了就不定义</span><br><span class="line">    public Jedis getJedisBean(RedisProperties redisProperties) &#123;</span><br><span class="line">        System.out.println(&quot;RedisAutoConfiguration...&quot;);</span><br><span class="line">        return new Jedis(redisProperties.getIp(), redisProperties.getPort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RedisProperties.class:</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ConfigurationProperties(prefix = &quot;redis&quot;) //与配置文件中对应</span><br><span class="line">public class RedisProperties &#123;</span><br><span class="line">    private String ip = &quot;localhost&quot;; //没提供时给默认值</span><br><span class="line">    private Integer port = 6379;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建META-INF&#x2F;spring.factories文件，其中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">    com.liuxuan.redis.configuration.RedisAutoConfiguration</span><br></pre></td></tr></table></figure>

<p>3.创建redis-starter模块，pom文件中引入redis-configuration依赖。</p>
<p>4.在另一个模块中，pom文件中引入redis-starter依赖。在StartApplication中尝试获取bean。这个模块中导入了Jedis依赖，但是并没有Jedis的bean的配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br><span class="line">Jedis jedis = context.getBean(Jedis.class);</span><br><span class="line">System.out.println(jedis);</span><br><span class="line"></span><br><span class="line">jedis.set(&quot;hello&quot;, &quot;hi&quot;);</span><br><span class="line">System.out.println(jedis.get(&quot;hello&quot;));</span><br></pre></td></tr></table></figure>

<p>5.可以在使用的模块中进行配置redis的ip和host</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis.port=6379</span><br><span class="line">redis.ip=localhost</span><br></pre></td></tr></table></figure>

<p>总结：StartApplication上的@SpringBootApplication注解中的@EnableAutoConfiguration中的@Import({AutoConfigurationImportSelector.class})中会自动去找jar包中的META-INF&#x2F;spring.factories文件，识别到需要加载的配置类，再获取配置类创建的bean，从而实现自动配置bean。</p>
<p>看spring-boot-autoconfiguration包下的data下的redis下的文件中，就定义了RedisAutoConfiguration，和上面实现类似。</p>
<h3 id="springboot监听机制"><a href="#springboot监听机制" class="headerlink" title="springboot监听机制"></a>springboot监听机制</h3><p>springboot的监听机制，其实是对java提供的事件监听机制的封装。</p>
<p>java中的事件监听机制定义了以下几个角色：<br>1.事件：Event，继承java.util.EventObject类的对象<br>2.事件源：Source，任意对象Object<br>3.监听器：Listener，实现java.util.EventListener接口的对象</p>
<p>springboot不需要这么麻烦，springboot在项目启动时，会对几个监听器进行回调，我们可以实现这些监听器接口，在项目启动时完成一些操作。</p>
<p>ApplicationContextInitializer、SpringApplicationRunListener、CommandLineRunner、ApplicationRunner</p>
<p>1 .继承这些接口，重写方法，并打印对应操作，@Component注册bean。</p>
<p>2 .启动发现只有后两个有打印。<br>CommandLineRunner、ApplicationRunner在项目启动后执行run方法，可以帮助做一些事情，比如：缓存预热(提前把数据库的数据加到缓存)<br>打印这两个方法的args，发现是空数组，在配置中的environment中的program arguments中添加hello world，就会返回[hello, world]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyCommandLineRunner implements CommandLineRunner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;MyCommandLineRunner run...&quot;);</span><br><span class="line">        System.out.println(&quot;MyCommandLineRunner args:&quot; + Arrays.asList(args));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyApplicationRunner implements ApplicationRunner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(ApplicationArguments args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;MyApplicationRunner run...&quot;);</span><br><span class="line">        System.out.println(&quot;MyApplicationRunner args:&quot; + Arrays.asList(args.getSourceArgs()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3 .其他两个监听器怎么用：在META-INF&#x2F;spring.factories（固定的写法，工程启动时会被自动扫描到）中配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">  com.liuxuan.listener.MyApplicationContextInitializer</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">  com.liuxuan.listener.MySpringApplicationRunListener</span><br></pre></td></tr></table></figure>

<p>MyApplicationContextInitializer的initialize方法：项目还没有准备ioc容器之前，可以检测一些资源是否存在。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyApplicationContextInitializer implements ApplicationContextInitializer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void initialize(ConfigurableApplicationContext applicationContext) &#123;</span><br><span class="line">        System.out.println(&quot;MyApplicationContextInitializer project start..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>MySpringApplicationRunListener 报错：<code>java.lang.NoSuchMethodException: com.liuxuan.listener.MySpringApplicationRunListener.&lt;init&gt;(org.springframework.boot.SpringApplication, [Ljava.lang.String;)</code><br>表示需要一个构造方法。<br>看一下代码中提供的一个实现类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//入参SpringApplication表示项目启动时的事件源</span><br><span class="line">public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered &#123;</span><br><span class="line">    private final SpringApplication application;</span><br><span class="line">    private final String[] args;</span><br><span class="line">    private final SimpleApplicationEventMulticaster initialMulticaster;</span><br><span class="line"></span><br><span class="line">    public EventPublishingRunListener(SpringApplication application, String[] args) &#123;</span><br><span class="line">        this.application = application;</span><br><span class="line">        this.args = args;</span><br><span class="line">        this.initialMulticaster = new SimpleApplicationEventMulticaster();</span><br><span class="line">        Iterator var3 = application.getListeners().iterator();</span><br><span class="line"></span><br><span class="line">        while(var3.hasNext()) &#123;</span><br><span class="line">            ApplicationListener&lt;?&gt; listener = (ApplicationListener)var3.next();</span><br><span class="line">            this.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，加一个构造方法，并把@Component去掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class MySpringApplicationRunListener implements SpringApplicationRunListener &#123;</span><br><span class="line"></span><br><span class="line">    public MySpringApplicationRunListener(SpringApplication application, String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void starting(ConfigurableBootstrapContext bootstrapContext) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 项目启动中...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 环境对象开始准备中(还不能获取配置信息)...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextPrepared(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 上下文对象开始准备(还没加载ioc容器)...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextLoaded(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 上下文对象开始加载(创建springboot启动的bean)...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void started(ConfigurableApplicationContext context, Duration timeTaken) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 加载完成...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void started(ConfigurableApplicationContext context) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void ready(ConfigurableApplicationContext context, Duration timeTaken) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void running(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 项目启动完成开始运行...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void failed(ConfigurableApplicationContext context, Throwable exception) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 项目启动失败...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看spring-boot包下的context下的event包下的一些定义好的事件Event，往里看都是继承自java的util包下的EventObject的。所以说springboot的事件监听是对java事件监听的封装。</p>
<h3 id="springboot启动流程"><a href="#springboot启动流程" class="headerlink" title="springboot启动流程"></a>springboot启动流程</h3><p>观察者模式：观察者和被观察者，被观察者：事件和事件源，观察者：监听器。</p>
<h4 id="✅初始化"><a href="#✅初始化" class="headerlink" title="✅初始化"></a>✅初始化</h4><p>debug一下启动类StartApplication中的<code>SpringApplication.run</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123;</span><br><span class="line">    return (new SpringApplication(primarySources)).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个SpringApplication对象（事件源对象）。</p>
<p>SpringApplication构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">    this.sources = new LinkedHashSet();</span><br><span class="line">    this.bannerMode = Mode.CONSOLE;</span><br><span class="line">    this.logStartupInfo = true;</span><br><span class="line">    this.addCommandLineProperties = true;</span><br><span class="line">    this.addConversionService = true;</span><br><span class="line">    this.headless = true;</span><br><span class="line">    this.registerShutdownHook = true;</span><br><span class="line">    this.additionalProfiles = Collections.emptySet();</span><br><span class="line">    this.isCustomEnvironment = false;</span><br><span class="line">    this.lazyInitialization = false;</span><br><span class="line">    this.applicationContextFactory = ApplicationContextFactory.DEFAULT;</span><br><span class="line">    this.applicationStartup = ApplicationStartup.DEFAULT;</span><br><span class="line">    this.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);</span><br><span class="line">    this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));  //有没有主类</span><br><span class="line">    this.webApplicationType = WebApplicationType.deduceFromClasspath();   //是否是web环境</span><br><span class="line">    this.bootstrapRegistryInitializers = new ArrayList(this.getSpringFactoriesInstances(BootstrapRegistryInitializer.class));</span><br><span class="line">    this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));  //从springfactory文件中加载initializers</span><br><span class="line">    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));  //从springfactory配置文件中加载listener（放到set集合中）</span><br><span class="line">    this.mainApplicationClass = this.deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/springboot%E5%90%AF%E5%8A%A8.png"></p>
<h4 id="✅run方法"><a href="#✅run方法" class="headerlink" title="✅run方法"></a>✅run方法</h4><p>StartApplication的run方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">    long startTime = System.nanoTime();  //监控耗时，也可以用StopWatch</span><br><span class="line">    DefaultBootstrapContext bootstrapContext = this.createBootstrapContext();</span><br><span class="line">    ConfigurableApplicationContext context = null;  //定一个容器</span><br><span class="line">    this.configureHeadlessProperty();  //加载东西</span><br><span class="line">    SpringApplicationRunListeners listeners = this.getRunListeners(args);  //获取RunListener</span><br><span class="line">    listeners.starting(bootstrapContext, this.mainApplicationClass);  //调用runListener的starting方法</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">        ConfigurableEnvironment environment = this.prepareEnvironment(listeners, bootstrapContext, applicationArguments);  //准备环境，回调runListener的prepareEnvironment方法，环境对象Environment就有信息了</span><br><span class="line">        this.configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = this.printBanner(environment);  //打印spring图标，可以替换banner.txt</span><br><span class="line">        context = this.createApplicationContext();  //创建ioc容器</span><br><span class="line">        context.setApplicationStartup(this.applicationStartup);</span><br><span class="line">        this.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);  //加载ioc容器</span><br><span class="line">        // 可以看context里的beanFactory里的beanDefinitionMap，里面是真正的bean，这时还没加载bean</span><br><span class="line">        this.refreshContext(context);  //这里从配置文件里找，创建bean（耗时操作）</span><br><span class="line">        this.afterRefresh(context, applicationArguments);</span><br><span class="line">        Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">        if (this.logStartupInfo) &#123;</span><br><span class="line">            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), timeTakenToStartup);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        listeners.started(context, timeTakenToStartup);  //项目启动成功，加载成功</span><br><span class="line">        this.callRunners(context, applicationArguments);  //commandLineRunner和applicationRunner 回调执行</span><br><span class="line">    &#125; catch (Throwable var12) &#123;</span><br><span class="line">        this.handleRunFailure(context, var12, listeners);</span><br><span class="line">        throw new IllegalStateException(var12);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">        listeners.ready(context, timeTakenToReady);</span><br><span class="line">        return context;</span><br><span class="line">    &#125; catch (Throwable var11) &#123;</span><br><span class="line">        this.handleRunFailure(context, var11, (SpringApplicationRunListeners)null);</span><br><span class="line">        throw new IllegalStateException(var11);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>以上，通过debug源码的方式，探索了springboot启动流程，看了监听器方法在哪里执行回调。</p>
<h2 id="springboot监控"><a href="#springboot监控" class="headerlink" title="springboot监控"></a>springboot监控</h2><h3 id="url方式"><a href="#url方式" class="headerlink" title="url方式"></a>url方式</h3><p>SpringBoot自带监控功能Actuator，可以帮助实现对程序内部运行情况监控，比如监控状况、Bean加载情况、配置属性 、日志信息等。</p>
<p>使用步骤</p>
<p>① 导入依赖坐标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>② 访问<a target="_blank" rel="noopener" href="http://localhost:8080/actuator">http://localhost:8080/actuator</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_links&quot;:&#123;</span><br><span class="line">        &quot;self&quot;:&#123;</span><br><span class="line">            &quot;href&quot;:&quot;http://localhost:8082/actuator&quot;,</span><br><span class="line">            &quot;templated&quot;:false</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;health-path&quot;:&#123;</span><br><span class="line">            &quot;href&quot;:&quot;http://localhost:8082/actuator/health/&#123;*path&#125;&quot;,</span><br><span class="line">            &quot;templated&quot;:true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;health&quot;:&#123;</span><br><span class="line">            &quot;href&quot;:&quot;http://localhost:8082/actuator/health&quot;,</span><br><span class="line">            &quot;templated&quot;:false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">路径	描述</span><br><span class="line">/beans	描述应用程序上下文里全部的Bean，以及它们的关系</span><br><span class="line">/env	获取全部环境属性</span><br><span class="line">/env/&#123;name&#125;	根据名称获取特定的环境属性值</span><br><span class="line">/health	报告应用程序的健康指标，这些值由HealthIndicator的实现类提供</span><br><span class="line">/info	获取应用程序的定制信息，这些信息由info打头的属性提供</span><br><span class="line">/mappings	描述全部的URI路径，以及它们和控制器(包含Actuator端点)的映射关系</span><br><span class="line">/metrics	报告各种应用程序度量信息，比如内存用量和HTTP请求计数</span><br><span class="line">/metrics/&#123;name&#125;	报告指定名称的应用程序度量值</span><br><span class="line">/trace	提供基本的HTTP请求跟踪信息(时间戳、HTTP头等)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">info:</span><br><span class="line">  name: hello</span><br><span class="line">  age: 23</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  #开启健康检查的完整信息</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: always</span><br><span class="line">  #将所有的监控endPoints暴漏出来</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: *</span><br></pre></td></tr></table></figure>

<h3 id="Spring-Boot-Admin"><a href="#Spring-Boot-Admin" class="headerlink" title="Spring Boot Admin"></a>Spring Boot Admin</h3><p>监控的可视化界面，只不过需要自己再起个监控服务。</p>
<p>Spring Boot Admin是一个开源社区项目，用于管理和监控SpringBoot应用程序。</p>
<p>Spring Boot Admin 有两个角色，客户端(Client)和服务端(Server)。</p>
<p>应用程序作为Spring Boot Admin Client向为Spring Boot Admin Server注册</p>
<p>Spring Boot Admin Server 的UI界面将Spring Boot Admin Client的Actuator Endpoint上的一些监控信息.</p>
<p>使用步骤：</p>
<p>admin-server（监控服务）</p>
<p>① 创建 admin-server 模块</p>
<p>② 导入依赖坐标 admin-starter-server</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>③ 在引导类上启用监控功能@EnableAdminServer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableAdminServer</span><br><span class="line">public class SpringbootAdminServerApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootAdminServerApplication.class, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>admin-client（被监控服务）</p>
<p>① 创建 admin-client 模块</p>
<p>② 导入依赖坐标 admin-starter-client</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>③ 配置相关信息：server地址等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指定admin.server地址，server在9000端口号，相当于向server注册</span><br><span class="line">spring.boot.admin.client.url=http://localhost:9000</span><br><span class="line">展示健康检查详细详细展示出来</span><br><span class="line">management.endpoint.health.show-details=always</span><br><span class="line">开启所有配置</span><br><span class="line">management.endpoints.web.exposure.include=*</span><br></pre></td></tr></table></figure>

<p>④ 启动server和client服务，访问server<br><a target="_blank" rel="noopener" href="http://localhost:9000/applications">http://localhost:9000/applications</a></p>
<hr>
<p>出现问题：<br>Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured.</p>
<p>原因：当前项目没有配置DataSource相关配置。springboot自动配置时，检测到添加了mysql的依赖包，但是配置文件中却没添加数据库的相关配置。<br>该案例中：mysql依赖在父pom中引入，该子工程不用mysql。</p>
<p>解决办法：@SpringBootApplication(exclude &#x3D; DataSourceAutoConfiguration.class) 排除自动注入数据库配置</p>
<hr>
<p>不知道是不是包的版本不对，有的版本报错，有的版本运行了却没显示。<br>idea中点EndPoins就可以图形化界面的方式来监控，不用那么麻烦，</p>
<h2 id="springboot项目部署"><a href="#springboot项目部署" class="headerlink" title="springboot项目部署"></a>springboot项目部署</h2><p>SpringBoot 项目开发完毕后，支持两种方式部署到服务器：</p>
<p>① jar包(官方推荐) 用内置的tomcat启动</p>
<p>② war包</p>
<h3 id="jar打包方式"><a href="#jar打包方式" class="headerlink" title="jar打包方式"></a>jar打包方式</h3><p>将当前模块打包：idea右边maven中选择要打包的模块，点lifecycle，点package。</p>
<p>打好的jar包在项目的target目录下。直接<code>java -jar .\jar包名称</code>，启动成功。</p>
<h3 id="war打包方式"><a href="#war打包方式" class="headerlink" title="war打包方式"></a>war打包方式</h3><p>pom.xml里更改打包方式：<code>&lt;packaging&gt;war&lt;/packaging&gt;</code><br>如果想改war包的名字：<code>&lt;finalName&gt;</code>标签</p>
<p>在引导类继承SpringBootServletInitializer类，并重写configure方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootDeployApplication extends SpringBootServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootDeployApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123;</span><br><span class="line">        return builder.sources(SpringBootDeployApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行，打好的war包可以被外部tomcat识别，将其放在tomcat目录下的webapps目录下，启动tomcat即可（startup.bat），浏览器访问需要加项目的包名称，因为WEB-INF文件在其之下。并且，内置项目的端口号配置就不生效了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sweetwater"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">Sweetwater</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sweetwater</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
